//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace QtGui
{
    /// <summary>
    /// <para>The QColor class provides colors based on RGB, HSV or CMYK
    /// values.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A color is normally specified in terms of RGB (red, green, and
    /// blue) components, but it is also possible to specify it in terms of HSV
    /// (hue, saturation, and value) and CMYK (cyan, magenta, yellow and black)
    /// components. In addition a color can be specified using a color name. The
    /// color name can be any of the SVG 1.0 color names.</para>
    /// <para></para>
    /// <para> RGBHSVCMYK</para>
    /// <para>	</para>
    /// <para></para>
    /// <para>The QColor constructor creates the color based on RGB values. To
    /// create a QColor based on either HSV or CMYK values, use the toHsv() and
    /// toCmyk() functions respectively. These functions return a copy of the color
    /// using the desired format. In addition the static fromRgb(), fromHsv() and
    /// fromCmyk() functions create colors from the specified values.
    /// Alternatively, a color can be converted to any of the three formats using
    /// the convertTo() function (returning a copy of the color in the desired
    /// format), or any of the setRgb(), setHsv() and setCmyk() functions altering
    /// this color's format. The spec() function tells how the color was
    /// specified.</para>
    /// <para>A color can be set by passing an RGB string (such as
    /// &quot;#112233&quot;), or an ARGB string (such as &quot;#ff112233&quot;) or
    /// a color name (such as &quot;blue&quot;), to the setNamedColor() function.
    /// The color names are taken from the SVG 1.0 color names. The name() function
    /// returns the name of the color in the format &quot;#RRGGBB&quot;. Colors can
    /// also be set using setRgb(), setHsv() and setCmyk(). To get a lighter or
    /// darker color use the lighter() and darker() functions respectively.</para>
    /// <para>The isValid() function indicates whether a QColor is legal at
    /// all. For example, a RGB color with RGB values out of range is illegal. For
    /// performance reasons, QColor mostly disregards illegal colors, and for that
    /// reason, the result of using an invalid color is undefined.</para>
    /// <para>The color components can be retrieved individually, e.g with
    /// red(), hue() and cyan(). The values of the color components can also be
    /// retrieved in one go using the getRgb(), getHsv() and getCmyk() functions.
    /// Using the RGB color model, the color components can in addition be accessed
    /// with rgb().</para>
    /// <para>There are several related non-members: QRgb is a typdef for an
    /// unsigned int representing the RGB value triplet (r, g, b). Note that it
    /// also can hold a value for the alpha-channel (for more information, see the
    /// Alpha-Blended Drawing section). The qRed(), qBlue() and qGreen() functions
    /// return the respective component of the given QRgb value, while the qRgb()
    /// and qRgba() functions create and return the QRgb triplet based on the given
    /// component values. Finally, the qAlpha() function returns the alpha
    /// component of the provided QRgb, and the qGray() function calculates and
    /// return a gray value based on the given value.</para>
    /// <para>QColor is platform and device independent. The QColormap class
    /// maps the color to the hardware.</para>
    /// <para>For more information about painting in general, see the Paint
    /// System documentation.</para>
    /// <para></para>
    /// <para>Integer vs. Floating Point Precision</para>
    /// <para>QColor supports floating point precision and provides floating
    /// point versions of all the color components functions, e.g. getRgbF(),
    /// hueF() and fromCmykF(). Note that since the components are stored using
    /// 16-bit integers, there might be minor deviations between the values set
    /// using, for example, setRgbF() and the values returned by the getRgbF()
    /// function due to rounding.</para>
    /// <para>While the integer based functions take values in the range 0-255
    /// (except hue() which must have values within the range 0-359), the floating
    /// point functions accept values in the range 0.0 - 1.0.</para>
    /// <para></para>
    /// <para>Alpha-Blended Drawing</para>
    /// <para>QColor also support alpha-blended outlining and filling. The
    /// alpha channel of a color specifies the transparency effect, 0 represents a
    /// fully transparent color, while 255 represents a fully opaque color. For
    /// example:</para>
    /// <para>// Specify semi-transparent red</para>
    /// <para>painter.setBrush(QColor(255, 0, 0, 127));</para>
    /// <para>painter.drawRect(0, 0, width()/2, height());</para>
    /// <para></para>
    /// <para>// Specify semi-transparent blue</para>
    /// <para>painter.setBrush(QColor(0, 0, 255, 127));</para>
    /// <para>painter.drawRect(0, 0, width(), height()/2);</para>
    /// <para>The code above produces the following output:</para>
    /// <para>The alpha channel of a color can be retrieved and set using the
    /// alpha() and setAlpha() functions if its value is an integer, and alphaF()
    /// and setAlphaF() if its value is qreal (double). By default, the
    /// alpha-channel is set to 255 (opaque). To retrieve and set all the RGB color
    /// components (including the alpha-channel) in one go, use the rgba() and
    /// setRgba() functions.</para>
    /// <para></para>
    /// <para>Predefined Colors</para>
    /// <para>There are 20 predefined QColors described by the Qt::GlobalColor
    /// enum, including black, white, primary and secondary colors, darker versions
    /// of these colors and three shades of gray. QColor also recognizes a variety
    /// of color names; the static colorNames() function returns a QStringList
    /// color names that QColor knows about.</para>
    /// <para>Additionally, the Qt::color0, Qt::color1 and Qt::transparent
    /// colors are used for special purposes.</para>
    /// <para>Qt::color0 (zero pixel value) and Qt::color1 (non-zero pixel
    /// value) are special colors for drawing in QBitmaps. Painting with Qt::color0
    /// sets the bitmap bits to 0 (transparent; i.e., background), and painting
    /// with Qt::color1 sets the bits to 1 (opaque; i.e., foreground).</para>
    /// <para>Qt::transparent is used to indicate a transparent pixel. When
    /// painting with this value, a pixel value will be used that is appropriate
    /// for the underlying pixel format in use.</para>
    /// <para></para>
    /// <para>The HSV Color Model</para>
    /// <para>The RGB model is hardware-oriented. Its representation is close
    /// to what most monitors show. In contrast, HSV represents color in a way more
    /// suited to the human perception of color. For example, the relationships
    /// &quot;stronger than&quot;, &quot;darker than&quot;, and &quot;the opposite
    /// of&quot; are easily expressed in HSV but are much harder to express in
    /// RGB.</para>
    /// <para>HSV, like RGB, has three components:</para>
    /// <para></para>
    /// <para>H, for hue, is in the range 0 to 359 if the color is chromatic
    /// (not gray), or meaningless if it is gray. It represents degrees on the
    /// color wheel familiar to most people. Red is 0 (degrees), green is 120, and
    /// blue is 240.</para>
    /// <para></para>
    /// <para>S, for saturation, is in the range 0 to 255, and the bigger it
    /// is, the stronger the color is. Grayish colors have saturation near 0; very
    /// strong colors have saturation near 255.</para>
    /// <para></para>
    /// <para>V, for value, is in the range 0 to 255 and represents lightness
    /// or brightness of the color. 0 is black; 255 is as far from black as
    /// possible.</para>
    /// </remarks>
    public unsafe partial class QColor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public QColor.Spec cspec;

            [FieldOffset(4)]
            internal QColor._.Internal ct;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColorC2Ej")]
            internal static extern void ctor_3(global::System.IntPtr instance, uint rgb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColorC2ERKS_")]
            internal static extern void cctor_6(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColorC2ENS_4SpecE")]
            internal static extern void ctor_7(global::System.IntPtr instance, QColor.Spec spec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor4nameEv")]
            internal static extern void Name_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor4nameENS_10NameFormatE")]
            internal static extern void Name_1(global::System.IntPtr @return, global::System.IntPtr instance, QColor.NameFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor13setNamedColorERK7QString")]
            internal static extern void SetNamedColor_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6getRgbEPiS0_S0_S0_")]
            internal static extern void GetRgb_0(global::System.IntPtr instance, int* r, int* g, int* b, int* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor6setRgbEiiii")]
            internal static extern void SetRgb_0(global::System.IntPtr instance, int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6getHsvEPiS0_S0_S0_")]
            internal static extern void GetHsv_0(global::System.IntPtr instance, int* h, int* s, int* v, int* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor6setHsvEiiii")]
            internal static extern void SetHsv_0(global::System.IntPtr instance, int h, int s, int v, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor7getCmykEPiS0_S0_S0_S0_")]
            internal static extern void GetCmyk_0(global::System.IntPtr instance, int* c, int* m, int* y, int* k, int* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor7setCmykEiiiii")]
            internal static extern void SetCmyk_0(global::System.IntPtr instance, int c, int m, int y, int k, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6getHslEPiS0_S0_S0_")]
            internal static extern void GetHsl_0(global::System.IntPtr instance, int* h, int* s, int* l, int* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor6setHslEiiii")]
            internal static extern void SetHsl_0(global::System.IntPtr instance, int h, int s, int l, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5toRgbEv")]
            internal static extern void ToRgb_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5toHsvEv")]
            internal static extern void ToHsv_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6toCmykEv")]
            internal static extern void ToCmyk_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5toHslEv")]
            internal static extern void ToHsl_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor9convertToENS_4SpecE")]
            internal static extern void ConvertTo_0(global::System.IntPtr @return, global::System.IntPtr instance, QColor.Spec colorSpec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor7fromRgbEj")]
            internal static extern void FromRgb_0(global::System.IntPtr @return, uint rgb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor8fromRgbaEj")]
            internal static extern void FromRgba_0(global::System.IntPtr @return, uint rgba);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor7fromRgbEiiii")]
            internal static extern void FromRgb_1(global::System.IntPtr @return, int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor7fromHsvEiiii")]
            internal static extern void FromHsv_0(global::System.IntPtr @return, int h, int s, int v, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor8fromCmykEiiiii")]
            internal static extern void FromCmyk_0(global::System.IntPtr @return, int c, int m, int y, int k, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor7fromHslEiiii")]
            internal static extern void FromHsl_0(global::System.IntPtr @return, int h, int s, int l, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5lightEi")]
            internal static extern void Light_0(global::System.IntPtr @return, global::System.IntPtr instance, int f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor4darkEi")]
            internal static extern void Dark_0(global::System.IntPtr @return, global::System.IntPtr instance, int f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColoreqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColorneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QColor12isValidColorERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValidColor_0(global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5alphaEv")]
            internal static extern int Alpha_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor8setAlphaEi")]
            internal static extern void SetAlpha_0(global::System.IntPtr instance, int alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor3redEv")]
            internal static extern int Red_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor6setRedEi")]
            internal static extern void SetRed_0(global::System.IntPtr instance, int red);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5greenEv")]
            internal static extern int Green_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor8setGreenEi")]
            internal static extern void SetGreen_0(global::System.IntPtr instance, int green);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor4blueEv")]
            internal static extern int Blue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor7setBlueEi")]
            internal static extern void SetBlue_0(global::System.IntPtr instance, int blue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor4rgbaEv")]
            internal static extern uint Rgba_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor7setRgbaEj")]
            internal static extern void SetRgba_0(global::System.IntPtr instance, uint rgba);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor3rgbEv")]
            internal static extern uint Rgb_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QColor6setRgbEj")]
            internal static extern void SetRgb_1(global::System.IntPtr instance, uint rgb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor3hueEv")]
            internal static extern int Hue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor10saturationEv")]
            internal static extern int Saturation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6hsvHueEv")]
            internal static extern int HsvHue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor13hsvSaturationEv")]
            internal static extern int HsvSaturation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5valueEv")]
            internal static extern int Value_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor4cyanEv")]
            internal static extern int Cyan_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor7magentaEv")]
            internal static extern int Magenta_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6yellowEv")]
            internal static extern int Yellow_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor5blackEv")]
            internal static extern int Black_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor6hslHueEv")]
            internal static extern int HslHue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor13hslSaturationEv")]
            internal static extern int HslSaturation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QColor9lightnessEv")]
            internal static extern int Lightness_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>The type of color specified, either RGB, HSV, CMYK or HSL.</para>
        /// <para>See also spec() and convertTo().</para>
        /// </summary>
        public enum Spec : uint
        {
            Invalid = 0,
            Rgb = 1,
            Hsv = 2,
            Cmyk = 3,
            Hsl = 4
        }

        /// <summary>
        /// <para>How to format the output of the name() function</para>
        /// <para>See also name().</para>
        /// </summary>
        public enum NameFormat : uint
        {
            /// <summary>#RRGGBB A "#" character followed by three two-digit hexadecimal numbers (i.e. #RRGGBB).</summary>
            HexRgb = 0,
            /// <summary>#AARRGGBB A "#" character followed by four two-digit hexadecimal numbers (i.e. #AARRGGBB).</summary>
            HexArgb = 1
        }

        internal unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 10)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal QColor._.__.Internal argb;

                [FieldOffset(0)]
                internal QColor._.__.Internal ahsv;

                [FieldOffset(0)]
                internal QColor._.__.Internal acmyk;

                [FieldOffset(0)]
                internal QColor._.__.Internal ahsl;

                [FieldOffset(0)]
                public fixed ushort array[5];
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 10)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ushort alpha;

                    [FieldOffset(2)]
                    public ushort red;

                    [FieldOffset(4)]
                    public ushort green;

                    [FieldOffset(6)]
                    public ushort blue;

                    [FieldOffset(8)]
                    public ushort pad;
                }
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 10)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ushort alpha;

                    [FieldOffset(2)]
                    public ushort hue;

                    [FieldOffset(4)]
                    public ushort saturation;

                    [FieldOffset(6)]
                    public ushort value;

                    [FieldOffset(8)]
                    public ushort pad;
                }
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 10)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ushort alpha;

                    [FieldOffset(2)]
                    public ushort cyan;

                    [FieldOffset(4)]
                    public ushort magenta;

                    [FieldOffset(6)]
                    public ushort yellow;

                    [FieldOffset(8)]
                    public ushort black;
                }
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 10)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ushort alpha;

                    [FieldOffset(2)]
                    public ushort hue;

                    [FieldOffset(4)]
                    public ushort saturation;

                    [FieldOffset(6)]
                    public ushort lightness;

                    [FieldOffset(8)]
                    public ushort pad;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QColor __CreateInstance(global::System.IntPtr native)
        {
            return new QColor((QColor.Internal*) native);
        }

        public static QColor __CreateInstance(QColor.Internal native)
        {
            return new QColor(native);
        }

        private static QColor.Internal* __CopyValue(QColor.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QColor.Internal.cctor_6(ret, new global::System.IntPtr(&native));
            return (QColor.Internal*) ret;
        }

        private QColor(QColor.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QColor(QColor.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a color with the value color. The alpha component is
        /// ignored and set to solid.</para>
        /// <para>See also fromRgb() and isValid().</para>
        /// </summary>
        public QColor(uint rgb)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = rgb;
            Internal.ctor_3(__Instance, arg0);
        }

        public QColor(QColor.Spec spec)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = spec;
            Internal.ctor_7(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the name of the color in the format &quot;#RRGGBB&quot;;
        /// i.e. a &quot;#&quot; character followed by three two-digit hexadecimal
        /// numbers.</para>
        /// <para>See also setNamedColor().</para>
        /// </summary>
        public string Name()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.Name_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the name of the color in the specified format.</para>
        /// <para>This function was introduced in  Qt 5.2.</para>
        /// <para>See also setNamedColor() and NameFormat.</para>
        /// </summary>
        public string Name(QColor.NameFormat format)
        {
            var arg0 = format;
            var __ret = new QtCore.QString.Internal();
            Internal.Name_1(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Sets the RGB value of this QColor to name, which may be in one of
        /// these formats:</para>
        /// <para></para>
        /// <para>#RGB (each of R, G, and B is a single hex digit)</para>
        /// <para>#RRGGBB</para>
        /// <para>#AARRGGBB (Since 5.2)</para>
        /// <para>#RRRGGGBBB</para>
        /// <para>#RRRRGGGGBBBB</para>
        /// <para>A name from the list of colors defined in the list of SVG color
        /// keyword names provided by the World Wide Web Consortium; for example,
        /// &quot;steelblue&quot; or &quot;gainsboro&quot;. These color names work on
        /// all platforms. Note that these color names are not the same as defined by
        /// the Qt::GlobalColor enums, e.g. &quot;green&quot; and Qt::green does not
        /// refer to the same color.</para>
        /// <para>transparent - representing the absence of a color.</para>
        /// <para></para>
        /// <para>The color is invalid if name cannot be parsed.</para>
        /// <para>See also QColor(), name(), and isValid().</para>
        /// </summary>
        public void SetNamedColor(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.SetNamedColor_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Sets the contents pointed to by r, g, b, and a, to the red,
        /// green, blue, and alpha-channel (transparency) components of the color's RGB
        /// value.</para>
        /// <para>These components can be retrieved individually using the red(),
        /// green(), blue() and alpha() functions.</para>
        /// <para>See also rgb() and setRgb().</para>
        /// </summary>
        public void GetRgb(int* r, int* g, int* b, int* a = null)
        {
            var arg0 = r;
            var arg1 = g;
            var arg2 = b;
            var arg3 = a;
            Internal.GetRgb_0(__Instance, arg0, arg1, arg2, arg3);
        }

        /// <summary>
        /// <para>Sets the RGB value to r, g, b and the alpha value to a.</para>
        /// <para>All the values must be in the range 0-255.</para>
        /// <para>See also rgb(), getRgb(), and setRgbF().</para>
        /// </summary>
        public void SetRgb(int r, int g, int b, int a = 255)
        {
            Internal.SetRgb_0(__Instance, r, g, b, a);
        }

        /// <summary>
        /// <para>Sets the contents pointed to by h, s, v, and a, to the hue,
        /// saturation, value, and alpha-channel (transparency) components of the
        /// color's HSV value.</para>
        /// <para>These components can be retrieved individually using the hue(),
        /// saturation(), value() and alpha() functions.</para>
        /// <para>See also setHsv() and The HSV Color Model.</para>
        /// </summary>
        public void GetHsv(int* h, int* s, int* v, int* a = null)
        {
            var arg0 = h;
            var arg1 = s;
            var arg2 = v;
            var arg3 = a;
            Internal.GetHsv_0(__Instance, arg0, arg1, arg2, arg3);
        }

        /// <summary>
        /// <para>Sets a HSV color value; h is the hue, s is the saturation, v is
        /// the value and a is the alpha component of the HSV color.</para>
        /// <para>The saturation, value and alpha-channel values must be in the
        /// range 0-255, and the hue value must be greater than -1.</para>
        /// <para>See also getHsv(), setHsvF(), and The HSV Color Model.</para>
        /// </summary>
        public void SetHsv(int h, int s, int v, int a = 255)
        {
            Internal.SetHsv_0(__Instance, h, s, v, a);
        }

        /// <summary>
        /// <para>Sets the contents pointed to by c, m, y, k, and a, to the cyan,
        /// magenta, yellow, black, and alpha-channel (transparency) components of the
        /// color's CMYK value.</para>
        /// <para>These components can be retrieved individually using the cyan(),
        /// magenta(), yellow(), black() and alpha() functions.</para>
        /// <para>See also setCmyk() and The CMYK Color Model.</para>
        /// </summary>
        public void GetCmyk(int* c, int* m, int* y, int* k, int* a = null)
        {
            var arg0 = c;
            var arg1 = m;
            var arg2 = y;
            var arg3 = k;
            var arg4 = a;
            Internal.GetCmyk_0(__Instance, arg0, arg1, arg2, arg3, arg4);
        }

        /// <summary>
        /// <para>Sets the color to CMYK values, c (cyan), m (magenta), y (yellow),
        /// k (black), and a (alpha-channel, i.e. transparency).</para>
        /// <para>All the values must be in the range 0-255.</para>
        /// <para>See also getCmyk(), setCmykF(), and The CMYK Color Model.</para>
        /// </summary>
        public void SetCmyk(int c, int m, int y, int k, int a = 255)
        {
            Internal.SetCmyk_0(__Instance, c, m, y, k, a);
        }

        /// <summary>
        /// <para>Sets the contents pointed to by h, s, l, and a, to the hue,
        /// saturation, lightness, and alpha-channel (transparency) components of the
        /// color's HSL value.</para>
        /// <para>These components can be retrieved individually using the
        /// hueHsl(), saturationHsl(), lightness() and alpha() functions.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also setHsl().</para>
        /// </summary>
        public void GetHsl(int* h, int* s, int* l, int* a = null)
        {
            var arg0 = h;
            var arg1 = s;
            var arg2 = l;
            var arg3 = a;
            Internal.GetHsl_0(__Instance, arg0, arg1, arg2, arg3);
        }

        /// <summary>
        /// <para>Sets a HSL color value; h is the hue, s is the saturation, l is
        /// the lightness and a is the alpha component of the HSL color.</para>
        /// <para>The saturation, value and alpha-channel values must be in the
        /// range 0-255, and the hue value must be greater than -1.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also getHsl() and setHslF().</para>
        /// </summary>
        public void SetHsl(int h, int s, int l, int a = 255)
        {
            Internal.SetHsl_0(__Instance, h, s, l, a);
        }

        /// <summary>
        /// <para>Create and returns an RGB QColor based on this color.</para>
        /// <para>See also fromRgb(), convertTo(), and isValid().</para>
        /// </summary>
        public QColor ToRgb()
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.ToRgb_0(new IntPtr(&__ret), __Instance);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates and returns an HSV QColor based on this color.</para>
        /// <para>See also fromHsv(), convertTo(), isValid(), and The HSV Color
        /// Model.</para>
        /// </summary>
        public QColor ToHsv()
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.ToHsv_0(new IntPtr(&__ret), __Instance);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates and returns a CMYK QColor based on this color.</para>
        /// <para>See also fromCmyk(), convertTo(), isValid(), and The CMYK Color
        /// Model.</para>
        /// </summary>
        public QColor ToCmyk()
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.ToCmyk_0(new IntPtr(&__ret), __Instance);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates and returns an HSL QColor based on this color.</para>
        /// <para>See also fromHsl(), convertTo(), and isValid().</para>
        /// </summary>
        public QColor ToHsl()
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.ToHsl_0(new IntPtr(&__ret), __Instance);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates a copy of this color in the format specified by
        /// colorSpec.</para>
        /// <para>See also spec(), toCmyk(), toHsv(), toRgb(), and
        /// isValid().</para>
        /// </summary>
        public QColor ConvertTo(QColor.Spec colorSpec)
        {
            var arg0 = colorSpec;
            var __ret = new QtGui.QColor.Internal();
            Internal.ConvertTo_0(new IntPtr(&__ret), __Instance, arg0);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Use lighter(factor) instead.</para>
        /// </summary>
        [System.ObsoleteAttribute("Use lighter(factor) instead.")]
        public QColor Light(int f = 150)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.Light_0(new IntPtr(&__ret), __Instance, f);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Use darker(factor) instead.</para>
        /// </summary>
        [System.ObsoleteAttribute("Use darker(factor) instead.")]
        public QColor Dark(int f = 200)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.Dark_0(new IntPtr(&__ret), __Instance, f);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if this color has the same RGB and alpha values as
        /// color; otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QColor __op, QColor c)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool cNull = ReferenceEquals(c, null);
            if (__opNull || cNull)
                return __opNull && cNull;
            var arg0 = __op.__Instance;
            var arg1 = c.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QColor;
        }

        /// <summary>
        /// <para>Returns true if this color has a different RGB and alpha values
        /// from color; otherwise returns false.</para>
        /// </summary>
        public static bool operator !=(QColor __op, QColor c)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(c, null) ? global::System.IntPtr.Zero : c.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Static convenience function that returns a QColor constructed
        /// from the given QRgb value rgb.</para>
        /// <para>The alpha component of rgb is ignored (i.e. it is automatically
        /// set to 255), use the fromRgba() function to include the alpha-channel
        /// specified by the given QRgb value.</para>
        /// <para>See also fromRgba(), fromRgbF(), toRgb(), and isValid().</para>
        /// </summary>
        public static QColor FromRgb(uint rgb)
        {
            var arg0 = rgb;
            var __ret = new QtGui.QColor.Internal();
            Internal.FromRgb_0(new IntPtr(&__ret), arg0);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Static convenience function that returns a QColor constructed
        /// from the given QRgb value rgba.</para>
        /// <para>Unlike the fromRgb() function, the alpha-channel specified by the
        /// given QRgb value is included.</para>
        /// <para>See also fromRgb() and isValid().</para>
        /// </summary>
        public static QColor FromRgba(uint rgba)
        {
            var arg0 = rgba;
            var __ret = new QtGui.QColor.Internal();
            Internal.FromRgba_0(new IntPtr(&__ret), arg0);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Static convenience function that returns a QColor constructed
        /// from the RGB color values, r (red), g (green), b (blue), and a
        /// (alpha-channel, i.e. transparency).</para>
        /// <para>All the values must be in the range 0-255.</para>
        /// <para>See also toRgb(), fromRgbF(), and isValid().</para>
        /// </summary>
        public static QColor FromRgb(int r, int g, int b, int a = 255)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.FromRgb_1(new IntPtr(&__ret), r, g, b, a);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Static convenience function that returns a QColor constructed
        /// from the HSV color values, h (hue), s (saturation), v (value), and a
        /// (alpha-channel, i.e. transparency).</para>
        /// <para>The value of s, v, and a must all be in the range 0-255; the
        /// value of h must be in the range 0-359.</para>
        /// <para>See also toHsv(), fromHsvF(), isValid(), and The HSV Color
        /// Model.</para>
        /// </summary>
        public static QColor FromHsv(int h, int s, int v, int a = 255)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.FromHsv_0(new IntPtr(&__ret), h, s, v, a);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Static convenience function that returns a QColor constructed
        /// from the given CMYK color values: c (cyan), m (magenta), y (yellow), k
        /// (black), and a (alpha-channel, i.e. transparency).</para>
        /// <para>All the values must be in the range 0-255.</para>
        /// <para>See also toCmyk(), fromCmykF(), isValid(), and The CMYK Color
        /// Model.</para>
        /// </summary>
        public static QColor FromCmyk(int c, int m, int y, int k, int a = 255)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.FromCmyk_0(new IntPtr(&__ret), c, m, y, k, a);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Static convenience function that returns a QColor constructed
        /// from the HSV color values, h (hue), s (saturation), l (lightness), and a
        /// (alpha-channel, i.e. transparency).</para>
        /// <para>The value of s, l, and a must all be in the range 0-255; the
        /// value of h must be in the range 0-359.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also toHsl(), fromHslF(), and isValid().</para>
        /// </summary>
        public static QColor FromHsl(int h, int s, int l, int a = 255)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.FromHsl_0(new IntPtr(&__ret), h, s, l, a);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if the name is a valid color name and can be used to
        /// construct a valid QColor object, otherwise returns false.</para>
        /// <para>It uses the same algorithm used in setNamedColor().</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also setNamedColor().</para>
        /// </summary>
        public static bool IsValidColor(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.IsValidColor_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the alpha color component of this color.</para>
        /// <para>See also setAlpha(), alphaF(), and Alpha-Blended Drawing.</para>
        /// <para></para>
        /// <para>Sets the alpha of this color to alpha. Integer alpha is specified
        /// in the range 0-255.</para>
        /// <para>See also alpha(), alphaF(), and Alpha-Blended Drawing.</para>
        /// </summary>
        public int Alpha
        {
            get
            {
                var __ret = Internal.Alpha_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetAlpha_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the red color component of this color.</para>
        /// <para>See also setRed(), redF(), and getRgb().</para>
        /// <para></para>
        /// <para>Sets the red color component of this color to red. Integer
        /// components are specified in the range 0-255.</para>
        /// <para>See also red(), redF(), and setRgb().</para>
        /// </summary>
        public int Red
        {
            get
            {
                var __ret = Internal.Red_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRed_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the green color component of this color.</para>
        /// <para>See also setGreen(), greenF(), and getRgb().</para>
        /// <para></para>
        /// <para>Sets the green color component of this color to green. Integer
        /// components are specified in the range 0-255.</para>
        /// <para>See also green(), greenF(), and setRgb().</para>
        /// </summary>
        public int Green
        {
            get
            {
                var __ret = Internal.Green_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetGreen_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the blue color component of this color.</para>
        /// <para>See also setBlue(), blueF(), and getRgb().</para>
        /// <para></para>
        /// <para>Sets the blue color component of this color to blue. Integer
        /// components are specified in the range 0-255.</para>
        /// <para>See also blue(), blueF(), and setRgb().</para>
        /// </summary>
        public int Blue
        {
            get
            {
                var __ret = Internal.Blue_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetBlue_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the RGB value of the color, including its alpha.</para>
        /// <para>For an invalid color, the alpha value of the returned color is
        /// unspecified.</para>
        /// <para>See also setRgba() and rgb().</para>
        /// <para></para>
        /// <para>Sets the RGB value to rgba, including its alpha.</para>
        /// <para>See also rgba() and rgb().</para>
        /// </summary>
        public uint Rgba
        {
            get
            {
                var __ret = Internal.Rgba_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetRgba_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the RGB value of the color. The alpha value is
        /// opaque.</para>
        /// <para>See also setRgb(), getRgb(), and rgba().</para>
        /// <para></para>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the RGB value to rgb. The alpha value is set to
        /// opaque.</para>
        /// </summary>
        public uint Rgb
        {
            get
            {
                var __ret = Internal.Rgb_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetRgb_1(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the hue color component of this color.</para>
        /// <para>The color is implicitly converted to HSV.</para>
        /// <para>See also hsvHue(), hueF(), getHsv(), and The HSV Color
        /// Model.</para>
        /// </summary>
        public int Hue
        {
            get
            {
                var __ret = Internal.Hue_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the saturation color component of this color.</para>
        /// <para>The color is implicitly converted to HSV.</para>
        /// <para>See also hsvSaturation(), saturationF(), getHsv(), and The HSV
        /// Color Model.</para>
        /// </summary>
        public int Saturation
        {
            get
            {
                var __ret = Internal.Saturation_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the hue color component of this color.</para>
        /// <para>See also hueF(), getHsv(), and The HSV Color Model.</para>
        /// </summary>
        public int HsvHue
        {
            get
            {
                var __ret = Internal.HsvHue_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the saturation color component of this color.</para>
        /// <para>See also saturationF(), getHsv(), and The HSV Color Model.</para>
        /// </summary>
        public int HsvSaturation
        {
            get
            {
                var __ret = Internal.HsvSaturation_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the value color component of this color.</para>
        /// <para>See also valueF(), getHsv(), and The HSV Color Model.</para>
        /// </summary>
        public int Value
        {
            get
            {
                var __ret = Internal.Value_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the cyan color component of this color.</para>
        /// <para>See also cyanF(), getCmyk(), and The CMYK Color Model.</para>
        /// </summary>
        public int Cyan
        {
            get
            {
                var __ret = Internal.Cyan_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the magenta color component of this color.</para>
        /// <para>See also magentaF(), getCmyk(), and The CMYK Color Model.</para>
        /// </summary>
        public int Magenta
        {
            get
            {
                var __ret = Internal.Magenta_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the yellow color component of this color.</para>
        /// <para>See also yellowF(), getCmyk(), and The CMYK Color Model.</para>
        /// </summary>
        public int Yellow
        {
            get
            {
                var __ret = Internal.Yellow_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the black color component of this color.</para>
        /// <para>See also blackF(), getCmyk(), and The CMYK Color Model.</para>
        /// </summary>
        public int Black
        {
            get
            {
                var __ret = Internal.Black_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the hue color component of this color.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also getHslF() and getHsl().</para>
        /// </summary>
        public int HslHue
        {
            get
            {
                var __ret = Internal.HslHue_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the saturation color component of this color.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also saturationF(), getHsv(), and The HSV Color Model.</para>
        /// </summary>
        public int HslSaturation
        {
            get
            {
                var __ret = Internal.HslSaturation_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the lightness color component of this color.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also lightnessF() and getHsl().</para>
        /// </summary>
        public int Lightness
        {
            get
            {
                var __ret = Internal.Lightness_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QRegion class specifies a clip region for a painter.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QRegion is used with QPainter::setClipRegion() to limit the paint
    /// area to what needs to be painted. There is also a QWidget::repaint()
    /// function that takes a QRegion parameter. QRegion is the best tool for
    /// minimizing the amount of screen area to be updated by a repaint.</para>
    /// <para>This class is not suitable for constructing shapes for rendering,
    /// especially as outlines. Use QPainterPath to create paths and shapes for use
    /// with QPainter.</para>
    /// <para>QRegion is an implicitly shared class.</para>
    /// <para></para>
    /// <para>Creating and Using Regions</para>
    /// <para>A region can be created from a rectangle, an ellipse, a polygon
    /// or a bitmap. Complex regions may be created by combining simple regions
    /// using united(), intersected(), subtracted(), or xored() (exclusive or). You
    /// can move a region using translate().</para>
    /// <para>You can test whether a region isEmpty() or if it contains() a
    /// QPoint or QRect. The bounding rectangle can be found with
    /// boundingRect().</para>
    /// <para>The function rects() gives a decomposition of the region into
    /// rectangles.</para>
    /// <para>Example of using complex regions:</para>
    /// <para>void MyWidget::paintEvent(QPaintEvent *)</para>
    /// <para>{</para>
    /// <para>    QRegion r1(QRect(100, 100, 200, 80),    // r1: elliptic
    /// region</para>
    /// <para>               QRegion::Ellipse);</para>
    /// <para>    QRegion r2(QRect(100, 120, 90, 30));    // r2: rectangular
    /// region</para>
    /// <para>    QRegion r3 = r1.intersected(r2);        // r3:
    /// intersection</para>
    /// <para></para>
    /// <para>    QPainter painter(this);</para>
    /// <para>    painter.setClipRegion(r3);</para>
    /// <para>    ...                                     // paint clipped
    /// graphics</para>
    /// <para>}</para>
    /// <para></para>
    /// <para>Additional License Information</para>
    /// <para>On Embedded Linux, Windows CE and X11 platforms, parts of this
    /// class rely on code obtained under the following licenses:</para>
    /// <para>Copyright (c) 1987 X Consortium</para>
    /// <para>Permission is hereby granted, free of charge, to any person
    /// obtaining a copy of this software and associated documentation files (the
    /// &quot;Software&quot;), to deal in the Software without restriction,
    /// including without limitation the rights to use, copy, modify, merge,
    /// publish, distribute, sublicense, and/or sell copies of the Software, and to
    /// permit persons to whom the Software is furnished to do so, subject to the
    /// following conditions:</para>
    /// <para>The above copyright notice and this permission notice shall be
    /// included in all copies or substantial portions of the Software.</para>
    /// <para>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
    /// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    /// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    /// IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
    /// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    /// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    /// DEALINGS IN THE SOFTWARE.</para>
    /// <para>Except as contained in this notice, the name of the X Consortium
    /// shall not be used in advertising or otherwise to promote the sale, use or
    /// other dealings in this Software without prior written authorization from
    /// the X Consortium.</para>
    /// </remarks>
    public unsafe partial class QRegion : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QRegionC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QRegionC2EiiiiNS_10RegionTypeE")]
            internal static extern void ctor_1(global::System.IntPtr instance, int x, int y, int w, int h, QRegion.RegionType t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QRegionC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr region);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QRegionC2ERK7QBitmap")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QRegionD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QRegion9translateEii")]
            internal static extern void Translate_0(global::System.IntPtr instance, int dx, int dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion10translatedEii")]
            internal static extern void Translated_0(global::System.IntPtr @return, global::System.IntPtr instance, int dx, int dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion6unitedERKS_")]
            internal static extern void United_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion11intersectedERKS_")]
            internal static extern void Intersected_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion10subtractedERKS_")]
            internal static extern void Subtracted_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion5xoredERKS_")]
            internal static extern void Xored_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion10intersectsERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Intersects_0(global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegionorERKS_")]
            internal static extern void OperatorPipe_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegionplERKS_")]
            internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegionanERKS_")]
            internal static extern void OperatorAmp_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegionmiERKS_")]
            internal static extern void OperatorMinus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegioneoERKS_")]
            internal static extern void OperatorCaret_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegioneqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion7isEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion6isNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QRegion9rectCountEv")]
            internal static extern int RectCount_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Specifies the shape of the region to be created.</para>
        /// </summary>
        public enum RegionType : uint
        {
            /// <summary>the region covers the entire rectangle.</summary>
            Rectangle = 0,
            /// <summary>the region is an ellipse inside the rectangle.</summary>
            Ellipse = 1
        }

        internal unsafe partial class QRegionData
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal QtCore.QtPrivate.RefCount.Internal @ref;

                [FieldOffset(4)]
                public global::System.IntPtr qt_rgn;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QRegion __CreateInstance(global::System.IntPtr native)
        {
            return new QRegion((QRegion.Internal*) native);
        }

        public static QRegion __CreateInstance(QRegion.Internal native)
        {
            return new QRegion(native);
        }

        private static QRegion.Internal* __CopyValue(QRegion.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QRegion.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QRegion.Internal*) ret;
        }

        private QRegion(QRegion.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QRegion(QRegion.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty region.</para>
        /// <para>See also isEmpty().</para>
        /// </summary>
        public QRegion()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a rectangular or elliptic region.</para>
        /// <para>If t is Rectangle, the region is the filled rectangle (x, y, w,
        /// h). If t is Ellipse, the region is the filled ellipse with center at (x + w
        /// / 2, y + h / 2) and size (w ,h).</para>
        /// </summary>
        public QRegion(int x, int y, int w, int h, QRegion.RegionType t = QRegion.RegionType.Rectangle)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg4 = t;
            Internal.ctor_1(__Instance, x, y, w, h, arg4);
        }

        /// <summary>
        /// <para>Constructs a new region which is equal to region r.</para>
        /// </summary>
        public QRegion(QRegion region)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(region, null) ? global::System.IntPtr.Zero : region.__Instance;
            Internal.cctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a region from the bitmap bm.</para>
        /// <para>The resulting region consists of the pixels in bitmap bm that are
        /// Qt::color1, as if each pixel was a 1 by 1 rectangle.</para>
        /// <para>This constructor may create complex regions that will slow down
        /// painting when used. Note that drawing masked pixmaps can be done much
        /// faster using QPixmap::setMask().</para>
        /// </summary>
        public QRegion(QBitmap bitmap)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            Internal.ctor_5(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Translates (moves) the region dx along the X axis and dy along
        /// the Y axis.</para>
        /// </summary>
        public void Translate(int dx, int dy)
        {
            Internal.Translate_0(__Instance, dx, dy);
        }

        /// <summary>
        /// <para>Returns a copy of the region that is translated dx along the x
        /// axis and dy along the y axis, relative to the current position. Positive
        /// values move the region to the right and down.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also translate().</para>
        /// </summary>
        public QRegion Translated(int dx, int dy)
        {
            var __ret = new QtGui.QRegion.Internal();
            Internal.Translated_0(new IntPtr(&__ret), __Instance, dx, dy);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a region which is the union of this region and r.</para>
        /// <para>The figure shows the union of two elliptical regions.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also intersected(), subtracted(), and xored().</para>
        /// </summary>
        public QRegion United(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.United_0(new IntPtr(&__ret), __Instance, arg0);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a region which is the intersection of this region and
        /// r.</para>
        /// <para>The figure shows the intersection of two elliptical
        /// regions.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also subtracted(), united(), and xored().</para>
        /// </summary>
        public QRegion Intersected(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.Intersected_0(new IntPtr(&__ret), __Instance, arg0);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a region which is r subtracted from this region.</para>
        /// <para>The figure shows the result when the ellipse on the right is
        /// subtracted from the ellipse on the left (left - right).</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also intersected(), united(), and xored().</para>
        /// </summary>
        public QRegion Subtracted(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.Subtracted_0(new IntPtr(&__ret), __Instance, arg0);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a region which is the exclusive or (XOR) of this region
        /// and r.</para>
        /// <para>The figure shows the exclusive or of two elliptical
        /// regions.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also intersected(), united(), and subtracted().</para>
        /// </summary>
        public QRegion Xored(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.Xored_0(new IntPtr(&__ret), __Instance, arg0);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if this region intersects with region, otherwise
        /// returns false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public bool Intersects(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = Internal.Intersects_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Applies the united() function to this region and r. r1|r2 is
        /// equivalent to r1.united(r2).</para>
        /// <para>See also united() and operator+().</para>
        /// </summary>
        public static QRegion operator |(QRegion __op, QRegion r)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.OperatorPipe_0(new IntPtr(&__ret), arg0, arg1);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Applies the united() function to this region and r. r1+r2 is
        /// equivalent to r1.united(r2).</para>
        /// <para>See also united() and operator|().</para>
        /// </summary>
        public static QRegion operator +(QRegion __op, QRegion r)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.OperatorPlus_0(new IntPtr(&__ret), arg0, arg1);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Applies the intersected() function to this region and r.
        /// r1&amp;r2 is equivalent to r1.intersected(r2).</para>
        /// <para>See also intersected().</para>
        /// </summary>
        public static QRegion operator &(QRegion __op, QRegion r)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.OperatorAmp_0(new IntPtr(&__ret), arg0, arg1);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Applies the subtracted() function to this region and r. r1-r2 is
        /// equivalent to r1.subtracted(r2).</para>
        /// <para>See also subtracted().</para>
        /// </summary>
        public static QRegion operator -(QRegion __op, QRegion r)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.OperatorMinus_0(new IntPtr(&__ret), arg0, arg1);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Applies the xored() function to this region and r. r1^r2 is
        /// equivalent to r1.xored(r2).</para>
        /// <para>See also xored().</para>
        /// </summary>
        public static QRegion operator ^(QRegion __op, QRegion r)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.OperatorCaret_0(new IntPtr(&__ret), arg0, arg1);
            return QRegion.__CreateInstance(__ret);
        }

        public static bool operator !=(QRegion __op, QRegion r)
        {
            return !(__op == r);
        }

        /// <summary>
        /// <para>Returns true if the region is equal to r; otherwise returns
        /// false.</para>
        /// </summary>
        public static bool operator ==(QRegion __op, QRegion r)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool rNull = ReferenceEquals(r, null);
            if (__opNull || rNull)
                return __opNull && rNull;
            var arg0 = __op.__Instance;
            var arg1 = r.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QRegion;
        }

        /// <summary>
        /// <para>Returns true if the region is empty; otherwise returns false. An
        /// empty region is a region that contains no points.</para>
        /// <para>Example:</para>
        /// <para>QRegion r1(10, 10, 20, 20);</para>
        /// <para>r1.isEmpty();               // false</para>
        /// <para></para>
        /// <para>QRegion r3;</para>
        /// <para>r3.isEmpty();               // true</para>
        /// <para></para>
        /// <para>QRegion r2(40, 40, 20, 20);</para>
        /// <para>r3 = r1.intersected(r2);    // r3: intersection of r1 and
        /// r2</para>
        /// <para>r3.isEmpty();               // true</para>
        /// <para></para>
        /// <para>r3 = r1.united(r2);         // r3: union of r1 and r2</para>
        /// <para>r3.isEmpty();               // false</para>
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                var __ret = Internal.IsEmpty_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the region is empty; otherwise returns false. An
        /// empty region is a region that contains no points. This function is the same
        /// as isEmpty</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also isEmpty().</para>
        /// </summary>
        public bool IsNull
        {
            get
            {
                var __ret = Internal.IsNull_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of rectangles that will be returned in
        /// rects().</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// </summary>
        public int RectCount
        {
            get
            {
                var __ret = Internal.RectCount_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QKeySequence class encapsulates a key sequence as used by
    /// shortcuts.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>In its most common form, a key sequence describes a combination
    /// of keys that must be used together to perform some action. Key sequences
    /// are used with QAction objects to specify which keyboard shortcuts can be
    /// used to trigger actions.</para>
    /// <para>Key sequences can be constructed for use as keyboard shortcuts in
    /// three different ways:</para>
    /// <para></para>
    /// <para>For standard shortcuts, a standard key can be used to request the
    /// platform-specific key sequence associated with each shortcut.</para>
    /// <para>For custom shortcuts, human-readable strings such as
    /// &quot;Ctrl+X&quot; can be used, and these can be translated into the
    /// appropriate shortcuts for users of different languages. Translations are
    /// made in the &quot;QShortcut&quot; context.</para>
    /// <para>For hard-coded shortcuts, integer key codes can be specified with
    /// a combination of values defined by the Qt::Key and Qt::Modifier enum
    /// values. Each key code consists of a single Qt::Key value and zero or more
    /// modifiers, such as Qt::SHIFT, Qt::CTRL, Qt::ALT and Qt::META.</para>
    /// <para></para>
    /// <para>For example, Ctrl P might be a sequence used as a shortcut for
    /// printing a document, and can be specified in any of the following
    /// ways:</para>
    /// <para>QKeySequence(QKeySequence::Print);</para>
    /// <para>QKeySequence(tr(&quot;Ctrl+P&quot;));</para>
    /// <para>QKeySequence(tr(&quot;Ctrl+p&quot;));</para>
    /// <para>QKeySequence(Qt::CTRL + Qt::Key_P);</para>
    /// <para>Note that, for letters, the case used in the specification string
    /// does not matter. In the above examples, the user does not need to hold down
    /// the Shift key to activate a shortcut specified with &quot;Ctrl+P&quot;.
    /// However, for other keys, the use of Shift as an unspecified extra modifier
    /// key can lead to confusion for users of an application whose keyboards have
    /// different layouts to those used by the developers. See the Keyboard Layout
    /// Issues section below for more details.</para>
    /// <para>It is preferable to use standard shortcuts where possible. When
    /// creating key sequences for non-standard shortcuts, you should use
    /// human-readable strings in preference to hard-coded integer values.</para>
    /// <para>QKeySequence objects can be cast to a QString to obtain a
    /// human-readable translated version of the sequence. Similarly, the
    /// toString() function produces human-readable strings for use in menus. On
    /// Mac OS X, the appropriate symbols are used to describe keyboard shortcuts
    /// using special keys on the Macintosh keyboard.</para>
    /// <para>An alternative way to specify hard-coded key codes is to use the
    /// Unicode code point of the character; for example, 'A' gives the same key
    /// sequence as Qt::Key_A.</para>
    /// <para>Note: On Mac OS X, references to &quot;Ctrl&quot;, Qt::CTRL,
    /// Qt::Control and Qt::ControlModifier correspond to the Command keys on the
    /// Macintosh keyboard, and references to &quot;Meta&quot;, Qt::META, Qt::Meta
    /// and Qt::MetaModifier correspond to the Control keys. Developers on Mac OS X
    /// can use the same shortcut descriptions across all platforms, and their
    /// applications will automatically work as expected on Mac OS X.</para>
    /// <para></para>
    /// <para>Standard Shortcuts</para>
    /// <para>QKeySequence defines many standard keyboard shortcuts to reduce
    /// the amount of effort required when setting up actions in a typical
    /// application. The table below shows some common key sequences that are often
    /// used for these standard shortcuts by applications on four widely-used
    /// platforms. Note that on Mac OS X, the Ctrl value corresponds to the Command
    /// keys on the Macintosh keyboard, and the Meta value corresponds to the
    /// Control keys.</para>
    /// <para></para>
    /// <para> StandardKeyWindowsMac OS XKDEGNOME</para>
    /// <para>HelpContents	F1	Ctrl+?	F1	F1</para>
    /// <para>WhatsThis	Shift+F1	Shift+F1	Shift+F1	Shift+F1</para>
    /// <para>Open	Ctrl+O	Ctrl+O	Ctrl+O	Ctrl+O</para>
    /// <para>Close	Ctrl+F4, Ctrl+W	Ctrl+W, Ctrl+F4	Ctrl+W	Ctrl+W</para>
    /// <para>Save	Ctrl+S	Ctrl+S	Ctrl+S	Ctrl+S</para>
    /// <para>Quit	Ctrl+Q	Qtrl+Q	Qtrl+Q</para>
    /// <para>SaveAs	Ctrl+Shift+S	Ctrl+Shift+S</para>
    /// <para>New	Ctrl+N	Ctrl+N	Ctrl+N	Ctrl+N</para>
    /// <para>Delete	Del	Del, Meta+D	Del, Ctrl+D	Del, Ctrl+D</para>
    /// <para>Cut	Ctrl+X, Shift+Del	Ctrl+X, Meta+K	Ctrl+X, F20, Shift+Del
    /// Ctrl+X, F20, Shift+Del</para>
    /// <para>Copy	Ctrl+C, Ctrl+Ins	Ctrl+C	Ctrl+C, F16, Ctrl+Ins	Ctrl+C, F16,
    /// Ctrl+Ins</para>
    /// <para>Paste	Ctrl+V, Shift+Ins	Ctrl+V, Meta+Y	Ctrl+V, F18, Shift+Ins
    /// Ctrl+V, F18, Shift+Ins</para>
    /// <para>Preferences	Ctrl+,	</para>
    /// <para>Undo	Ctrl+Z, Alt+Backspace	Ctrl+Z	Ctrl+Z, F14	Ctrl+Z, F14</para>
    /// <para>Redo	Ctrl+Y, Shift+Ctrl+Z, Alt+Shift+Backspace	Ctrl+Shift+Z
    /// Ctrl+Shift+Z	Ctrl+Shift+Z</para>
    /// <para>Back	Alt+Left, Backspace	Ctrl+[	Alt+Left	Alt+Left</para>
    /// <para>Forward	Alt+Right, Shift+Backspace	Ctrl+]	Alt+Right
    /// Alt+Right</para>
    /// <para>Refresh	F5	F5	F5	Ctrl+R, F5</para>
    /// <para>ZoomIn	Ctrl+Plus	Ctrl+Plus	Ctrl+Plus	Ctrl+Plus</para>
    /// <para>ZoomOut	Ctrl+Minus	Ctrl+Minus	Ctrl+Minus	Ctrl+Minus</para>
    /// <para>FullScreen	F11, Alt+Enter	Ctrl+Meta+F	F11, Ctrl+Shift+F
    /// Ctrl+F11</para>
    /// <para>Print	Ctrl+P	Ctrl+P	Ctrl+P	Ctrl+P</para>
    /// <para>AddTab	Ctrl+T	Ctrl+T	Ctrl+Shift+N, Ctrl+T	Ctrl+T</para>
    /// <para>NextChild	Ctrl+Tab, Forward, Ctrl+F6	Ctrl+}, Forward, Ctrl+Tab
    /// Ctrl+Tab, Forward, Ctrl+Comma	Ctrl+Tab, Forward</para>
    /// <para>PreviousChild	Ctrl+Shift+Tab, Back, Ctrl+Shift+F6	Ctrl+{, Back,
    /// Ctrl+Shift+Tab	Ctrl+Shift+Tab, Back, Ctrl+Period	Ctrl+Shift+Tab,
    /// Back</para>
    /// <para>Find	Ctrl+F	Ctrl+F	Ctrl+F	Ctrl+F</para>
    /// <para>FindNext	F3, Ctrl+G	Ctrl+G	F3	Ctrl+G, F3</para>
    /// <para>FindPrevious	Shift+F3, Ctrl+Shift+G	Ctrl+Shift+G	Shift+F3
    /// Ctrl+Shift+G, Shift+F3</para>
    /// <para>Replace	Ctrl+H	(none)	Ctrl+R	Ctrl+H</para>
    /// <para>SelectAll	Ctrl+A	Ctrl+A	Ctrl+A	Ctrl+A</para>
    /// <para>Deselect	Ctrl+Shift+A	Ctrl+Shift+A</para>
    /// <para>Bold	Ctrl+B	Ctrl+B	Ctrl+B	Ctrl+B</para>
    /// <para>Italic	Ctrl+I	Ctrl+I	Ctrl+I	Ctrl+I</para>
    /// <para>Underline	Ctrl+U	Ctrl+U	Ctrl+U	Ctrl+U</para>
    /// <para>MoveToNextChar	Right	Right, Meta+F	Right	Right</para>
    /// <para>MoveToPreviousChar	Left	Left, Meta+B	Left	Left</para>
    /// <para>MoveToNextWord	Ctrl+Right	Alt+Right	Ctrl+Right	Ctrl+Right</para>
    /// <para>MoveToPreviousWord	Ctrl+Left	Alt+Left	Ctrl+Left	Ctrl+Left</para>
    /// <para>MoveToNextLine	Down	Down, Meta+N	Down	Down</para>
    /// <para>MoveToPreviousLine	Up	Up, Meta+P	Up	Up</para>
    /// <para>MoveToNextPage	PgDown	PgDown, Alt+PgDown, Meta+Down, Meta+PgDown,
    /// Meta+V	PgDown	PgDown</para>
    /// <para>MoveToPreviousPage	PgUp	PgUp, Alt+PgUp, Meta+Up, Meta+PgUp	PgUp
    /// PgUp</para>
    /// <para>MoveToStartOfLine	Home	Ctrl+Left, Meta+Left	Home	Home</para>
    /// <para>MoveToEndOfLine	End	Ctrl+Right, Meta+Right	End, Ctrl+E	End,
    /// Ctrl+E</para>
    /// <para>MoveToStartOfBlock	(none)	Alt+Up, Meta+A	(none)	(none)</para>
    /// <para>MoveToEndOfBlock	(none)	Alt+Down, Meta+E	(none)	(none)</para>
    /// <para>MoveToStartOfDocument	Ctrl+Home	Ctrl+Up, Home	Ctrl+Home
    /// Ctrl+Home</para>
    /// <para>MoveToEndOfDocument	Ctrl+End	Ctrl+Down, End	Ctrl+End
    /// Ctrl+End</para>
    /// <para>SelectNextChar	Shift+Right	Shift+Right	Shift+Right
    /// Shift+Right</para>
    /// <para>SelectPreviousChar	Shift+Left	Shift+Left	Shift+Left
    /// Shift+Left</para>
    /// <para>SelectNextWord	Ctrl+Shift+Right	Alt+Shift+Right	Ctrl+Shift+Right
    /// Ctrl+Shift+Right</para>
    /// <para>SelectPreviousWord	Ctrl+Shift+Left	Alt+Shift+Left	Ctrl+Shift+Left
    /// Ctrl+Shift+Left</para>
    /// <para>SelectNextLine	Shift+Down	Shift+Down	Shift+Down	Shift+Down</para>
    /// <para>SelectPreviousLine	Shift+Up	Shift+Up	Shift+Up	Shift+Up</para>
    /// <para>SelectNextPage	Shift+PgDown	Shift+PgDown	Shift+PgDown
    /// Shift+PgDown</para>
    /// <para>SelectPreviousPage	Shift+PgUp	Shift+PgUp	Shift+PgUp
    /// Shift+PgUp</para>
    /// <para>SelectStartOfLine	Shift+Home	Ctrl+Shift+Left	Shift+Home
    /// Shift+Home</para>
    /// <para>SelectEndOfLine	Shift+End	Ctrl+Shift+Right	Shift+End
    /// Shift+End</para>
    /// <para>SelectStartOfBlock	(none)	Alt+Shift+Up, Meta+Shift+A	(none)
    /// (none)</para>
    /// <para>SelectEndOfBlock	(none)	Alt+Shift+Down, Meta+Shift+E	(none)
    /// (none)</para>
    /// <para>SelectStartOfDocument	Ctrl+Shift+Home	Ctrl+Shift+Up, Shift+Home
    /// Ctrl+Shift+Home	Ctrl+Shift+Home</para>
    /// <para>SelectEndOfDocument	Ctrl+Shift+End	Ctrl+Shift+Down, Shift+End
    /// Ctrl+Shift+End	Ctrl+Shift+End</para>
    /// <para>DeleteStartOfWord	Ctrl+Backspace	Alt+Backspace	Ctrl+Backspace
    /// Ctrl+Backspace</para>
    /// <para>DeleteEndOfWord	Ctrl+Del	(none)	Ctrl+Del	Ctrl+Del</para>
    /// <para>DeleteEndOfLine	(none)	(none)	Ctrl+K	Ctrl+K</para>
    /// <para>DeleteCompleteLine	(none)	(none)	Ctrl+U	Ctrl+U</para>
    /// <para>InsertParagraphSeparator	Enter	Enter	Enter	Enter</para>
    /// <para>InsertLineSeparator	Shift+Enter	Meta+Enter, Meta+O	Shift+Enter
    /// Shift+Enter</para>
    /// <para></para>
    /// <para>Note that, since the key sequences used for the standard
    /// shortcuts differ between platforms, you still need to test your shortcuts
    /// on each platform to ensure that you do not unintentionally assign the same
    /// key sequence to many actions.</para>
    /// <para></para>
    /// <para>Keyboard Layout Issues</para>
    /// <para>Many key sequence specifications are chosen by developers based
    /// on the layout of certain types of keyboard, rather than choosing keys that
    /// represent the first letter of an action's name, such as Ctrl S
    /// (&quot;Ctrl+S&quot;) or Ctrl C (&quot;Ctrl+C&quot;). Additionally, because
    /// certain symbols can only be entered with the help of modifier keys on
    /// certain keyboard layouts, key sequences intended for use with one keyboard
    /// layout may map to a different key, map to no keys at all, or require an
    /// additional modifier key to be used on different keyboard layouts.</para>
    /// <para>For example, the shortcuts, Ctrl plus and Ctrl minus, are often
    /// used as shortcuts for zoom operations in graphics applications, and these
    /// may be specified as &quot;Ctrl++&quot; and &quot;Ctrl+-&quot; respectively.
    /// However, the way these shortcuts are specified and interpreted depends on
    /// the keyboard layout. Users of Norwegian keyboards will note that the + and
    /// - keys are not adjacent on the keyboard, but will still be able to activate
    /// both shortcuts without needing to press the Shift key. However, users with
    /// British keyboards will need to hold down the Shift key to enter the +
    /// symbol, making the shortcut effectively the same as
    /// &quot;Ctrl+Shift+=&quot;.</para>
    /// <para>Although some developers might resort to fully specifying all the
    /// modifiers they use on their keyboards to activate a shortcut, this will
    /// also result in unexpected behavior for users of different keyboard
    /// layouts.</para>
    /// <para>For example, a developer using a British keyboard may decide to
    /// specify &quot;Ctrl+Shift+=&quot; as the key sequence in order to create a
    /// shortcut that coincidentally behaves in the same way as Ctrl plus. However,
    /// the = key needs to be accessed using the Shift key on Norwegian keyboard,
    /// making the required shortcut effectively Ctrl Shift Shift = (an impossible
    /// key combination).</para>
    /// <para>As a result, both human-readable strings and hard-coded key codes
    /// can both be problematic to use when specifying a key sequence that can be
    /// used on a variety of different keyboard layouts. Only the use of standard
    /// shortcuts guarantees that the user will be able to use the shortcuts that
    /// the developer intended.</para>
    /// <para>Despite this, we can address this issue by ensuring that
    /// human-readable strings are used, making it possible for translations of key
    /// sequences to be made for users of different languages. This approach will
    /// be successful for users whose keyboards have the most typical layout for
    /// the language they are using.</para>
    /// <para></para>
    /// <para>GNU Emacs Style Key Sequences</para>
    /// <para>Key sequences similar to those used in GNU Emacs, allowing up to
    /// four key codes, can be created by using the multiple argument constructor,
    /// or by passing a human-readable string of comma-separated key
    /// sequences.</para>
    /// <para>For example, the key sequence, Ctrl X followed by Ctrl C, can be
    /// specified using either of the following ways:</para>
    /// <para>QKeySequence(tr(&quot;Ctrl+X, Ctrl+C&quot;));</para>
    /// <para>QKeySequence(Qt::CTRL + Qt::Key_X, Qt::CTRL + Qt::Key_C);</para>
    /// <para>Warning: A QApplication instance must have been constructed
    /// before a QKeySequence is created; otherwise, your application may
    /// crash.</para>
    /// <para></para>
    /// <para>See also QShortcut.</para>
    /// </remarks>
    public unsafe partial class QKeySequence : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QKeySequenceC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QKeySequenceC2ERK7QStringNS_14SequenceFormatE")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr key, QKeySequence.SequenceFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QKeySequenceC2Eiiii")]
            internal static extern void ctor_2(global::System.IntPtr instance, int k1, int k2, int k3, int k4);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QKeySequenceC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr ks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QKeySequenceC2ENS_11StandardKeyE")]
            internal static extern void ctor_4(global::System.IntPtr instance, QKeySequence.StandardKey key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QKeySequenceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequence8toStringENS_14SequenceFormatE")]
            internal static extern void ToString_0(global::System.IntPtr @return, global::System.IntPtr instance, QKeySequence.SequenceFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QKeySequence10fromStringERK7QStringNS_14SequenceFormatE")]
            internal static extern void FromString_0(global::System.IntPtr @return, global::System.IntPtr str, QKeySequence.SequenceFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QKeySequence14listFromStringERK7QStringNS_14SequenceFormatE")]
            internal static extern QList.Internal ListFromString_0(global::System.IntPtr str, QKeySequence.SequenceFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QKeySequence12listToStringERK5QListIS_ENS_14SequenceFormatE")]
            internal static extern void ListToString_0(global::System.IntPtr @return, global::System.IntPtr list, QKeySequence.SequenceFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequence7matchesERKS_")]
            internal static extern QKeySequence.SequenceMatch Matches_0(global::System.IntPtr instance, global::System.IntPtr seq);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QKeySequence8mnemonicERK7QString")]
            internal static extern void Mnemonic_0(global::System.IntPtr @return, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QKeySequence11keyBindingsENS_11StandardKeyE")]
            internal static extern QList.Internal KeyBindings_0(QKeySequence.StandardKey key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequenceeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequenceltERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr ks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequence5countEv")]
            internal static extern int Count_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequence7isEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QKeySequence10isDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum represent standard key bindings. They can be used to
        /// assign platform dependent keyboard shortcuts to a QAction.</para>
        /// <para>Note that the key bindings are platform dependent. The currently
        /// bound shortcuts can be queried using keyBindings().</para>
        /// <para>This enum was introduced or modified in  Qt 4.2.</para>
        /// </summary>
        public enum StandardKey : uint
        {
            /// <summary>Unbound key.</summary>
            UnknownKey = 0,
            /// <summary>Open help contents.</summary>
            HelpContents = 1,
            /// <summary>Activate "what's this".</summary>
            WhatsThis = 2,
            /// <summary>Open document.</summary>
            Open = 3,
            /// <summary>Close document/tab.</summary>
            Close = 4,
            /// <summary>Save document.</summary>
            Save = 5,
            /// <summary>Create new document.</summary>
            New = 6,
            /// <summary>Delete.</summary>
            Delete = 7,
            /// <summary>Cut.</summary>
            Cut = 8,
            /// <summary>Copy.</summary>
            Copy = 9,
            /// <summary>Paste.</summary>
            Paste = 10,
            /// <summary>Undo.</summary>
            Undo = 11,
            /// <summary>Redo.</summary>
            Redo = 12,
            /// <summary>Navigate back.</summary>
            Back = 13,
            /// <summary>Navigate forward.</summary>
            Forward = 14,
            /// <summary>Refresh or reload current document.</summary>
            Refresh = 15,
            /// <summary>Zoom in.</summary>
            ZoomIn = 16,
            /// <summary>Zoom out.</summary>
            ZoomOut = 17,
            /// <summary>Print document.</summary>
            Print = 18,
            /// <summary>Add new tab.</summary>
            AddTab = 19,
            /// <summary>Navigate to next tab or child window.</summary>
            NextChild = 20,
            /// <summary>Navigate to previous tab or child window.</summary>
            PreviousChild = 21,
            /// <summary>Find in document.</summary>
            Find = 22,
            /// <summary>Find next result.</summary>
            FindNext = 23,
            /// <summary>Find previous result.</summary>
            FindPrevious = 24,
            /// <summary>Find and replace.</summary>
            Replace = 25,
            /// <summary>Select all text.</summary>
            SelectAll = 26,
            /// <summary>Bold text.</summary>
            Bold = 27,
            /// <summary>Italic text.</summary>
            Italic = 28,
            /// <summary>Underline text.</summary>
            Underline = 29,
            /// <summary>Move cursor to next character.</summary>
            MoveToNextChar = 30,
            /// <summary>Move cursor to previous character.</summary>
            MoveToPreviousChar = 31,
            /// <summary>Move cursor to next word.</summary>
            MoveToNextWord = 32,
            /// <summary>Move cursor to previous word.</summary>
            MoveToPreviousWord = 33,
            /// <summary>Move cursor to next line.</summary>
            MoveToNextLine = 34,
            /// <summary>Move cursor to previous line.</summary>
            MoveToPreviousLine = 35,
            /// <summary>Move cursor to next page.</summary>
            MoveToNextPage = 36,
            /// <summary>Move cursor to previous page.</summary>
            MoveToPreviousPage = 37,
            /// <summary>Move cursor to start of line.</summary>
            MoveToStartOfLine = 38,
            /// <summary>Move cursor to end of line.</summary>
            MoveToEndOfLine = 39,
            /// <summary>Move cursor to start of a block. This shortcut is only used on OS X.</summary>
            MoveToStartOfBlock = 40,
            /// <summary>Move cursor to end of block. This shortcut is only used on the OS X.</summary>
            MoveToEndOfBlock = 41,
            /// <summary>Move cursor to start of document.</summary>
            MoveToStartOfDocument = 42,
            /// <summary>Move cursor to end of document.</summary>
            MoveToEndOfDocument = 43,
            /// <summary>Extend selection to next character.</summary>
            SelectNextChar = 44,
            /// <summary>Extend selection to previous character.</summary>
            SelectPreviousChar = 45,
            /// <summary>Extend selection to next word.</summary>
            SelectNextWord = 46,
            /// <summary>Extend selection to previous word.</summary>
            SelectPreviousWord = 47,
            /// <summary>Extend selection to next line.</summary>
            SelectNextLine = 48,
            /// <summary>Extend selection to previous line.</summary>
            SelectPreviousLine = 49,
            /// <summary>Extend selection to next page.</summary>
            SelectNextPage = 50,
            /// <summary>Extend selection to previous page.</summary>
            SelectPreviousPage = 51,
            /// <summary>Extend selection to start of line.</summary>
            SelectStartOfLine = 52,
            /// <summary>Extend selection to end of line.</summary>
            SelectEndOfLine = 53,
            /// <summary>Extend selection to the start of a text block. This shortcut is only used on OS X.</summary>
            SelectStartOfBlock = 54,
            /// <summary>Extend selection to the end of a text block. This shortcut is only used on OS X.</summary>
            SelectEndOfBlock = 55,
            /// <summary>Extend selection to start of document.</summary>
            SelectStartOfDocument = 56,
            /// <summary>Extend selection to end of document.</summary>
            SelectEndOfDocument = 57,
            /// <summary>Delete the beginning of a word up to the cursor.</summary>
            DeleteStartOfWord = 58,
            /// <summary>Delete word from the end of the cursor.</summary>
            DeleteEndOfWord = 59,
            /// <summary>Delete end of line.</summary>
            DeleteEndOfLine = 60,
            /// <summary>Insert a new paragraph.</summary>
            InsertParagraphSeparator = 61,
            /// <summary>Insert a new line.</summary>
            InsertLineSeparator = 62,
            /// <summary>Save document after prompting the user for a file name.</summary>
            SaveAs = 63,
            /// <summary>Open the preferences dialog.</summary>
            Preferences = 64,
            /// <summary>Quit the application.</summary>
            Quit = 65,
            /// <summary>Toggle the window state to/from full screen.</summary>
            FullScreen = 66,
            /// <summary>Deselect text. Since 5.1</summary>
            Deselect = 67,
            /// <summary>Delete the entire line.</summary>
            DeleteCompleteLine = 68
        }

        public enum SequenceFormat : uint
        {
            /// <summary>The key sequence as a platform specific string. This means that it will be shown translated and on the Mac it will resemble a key sequence from the menu bar. This enum is best used when you want to display the string to the user.</summary>
            NativeText = 0,
            /// <summary>The key sequence is given in a "portable" format, suitable for reading and writing to a file. In many cases, it will look similar to the native text on Windows and X11.</summary>
            PortableText = 1
        }

        public enum SequenceMatch : uint
        {
            /// <summary>The key sequences are different; not even partially matching.</summary>
            NoMatch = 0,
            /// <summary>The key sequences match partially, but are not the same.</summary>
            PartialMatch = 1,
            /// <summary>The key sequences are the same.</summary>
            ExactMatch = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QKeySequence __CreateInstance(global::System.IntPtr native)
        {
            return new QKeySequence((QKeySequence.Internal*) native);
        }

        public static QKeySequence __CreateInstance(QKeySequence.Internal native)
        {
            return new QKeySequence(native);
        }

        private static QKeySequence.Internal* __CopyValue(QKeySequence.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QKeySequence.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QKeySequence.Internal*) ret;
        }

        private QKeySequence(QKeySequence.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QKeySequence(QKeySequence.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty key sequence.</para>
        /// </summary>
        public QKeySequence()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a key sequence from the key string, based on
        /// format.</para>
        /// <para>For example &quot;Ctrl+O&quot; gives CTRL+'O'. The strings
        /// &quot;Ctrl&quot;, &quot;Shift&quot;, &quot;Alt&quot; and &quot;Meta&quot;
        /// are recognized, as well as their translated equivalents in the
        /// &quot;QShortcut&quot; context (using QObject::tr()).</para>
        /// <para>Up to four key codes may be entered by separating them with
        /// commas, e.g. &quot;Alt+X,Ctrl+S,Q&quot;.</para>
        /// <para>This constructor is typically used with tr(), so that shortcut
        /// keys can be replaced in translations:</para>
        /// <para>QMenu *file = new QMenu(this);</para>
        /// <para>file-&gt;addAction(tr(&quot;&amp;Open...&quot;), this,
        /// SLOT(open()),</para>
        /// <para>                  QKeySequence(tr(&quot;Ctrl+O&quot;,
        /// &quot;File|Open&quot;)));</para>
        /// <para>Note the &quot;File|Open&quot; translator comment. It is by no
        /// means necessary, but it provides some context for the human
        /// translator.</para>
        /// </summary>
        public QKeySequence(string key, QKeySequence.SequenceFormat format = QKeySequence.SequenceFormat.NativeText)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = format;
            Internal.ctor_1(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a key sequence with up to 4 keys k1, k2, k3 and
        /// k4.</para>
        /// <para>The key codes are listed in Qt::Key and can be combined with
        /// modifiers (see Qt::Modifier) such as Qt::SHIFT, Qt::CTRL, Qt::ALT, or
        /// Qt::META.</para>
        /// </summary>
        public QKeySequence(int k1, int k2 = 0, int k3 = 0, int k4 = 0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_2(__Instance, k1, k2, k3, k4);
        }

        /// <summary>
        /// <para>Copy constructor. Makes a copy of keysequence.</para>
        /// </summary>
        public QKeySequence(QKeySequence ks)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(ks, null) ? global::System.IntPtr.Zero : ks.__Instance;
            Internal.cctor_3(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a QKeySequence object for the given key. The result
        /// will depend on the currently running platform.</para>
        /// <para>The resulting object will be based on the first element in the
        /// list of key bindings for the key.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public QKeySequence(QKeySequence.StandardKey key)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = key;
            Internal.ctor_4(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Return a string representation of the key sequence, based on
        /// format.</para>
        /// <para>For example, the value Qt::CTRL+Qt::Key_O results in
        /// &quot;Ctrl+O&quot;. If the key sequence has multiple key codes, each is
        /// separated by commas in the string returned, such as &quot;Alt+X, Ctrl+Y,
        /// Z&quot;. The strings, &quot;Ctrl&quot;, &quot;Shift&quot;, etc. are
        /// translated using QObject::tr() in the &quot;QShortcut&quot; context.</para>
        /// <para>If the key sequence has no keys, an empty string is
        /// returned.</para>
        /// <para>On Mac OS X, the string returned resembles the sequence that is
        /// shown in the menu bar.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also fromString().</para>
        /// </summary>
        public string ToString(QKeySequence.SequenceFormat format = QKeySequence.SequenceFormat.PortableText)
        {
            var arg0 = format;
            var __ret = new QtCore.QString.Internal();
            Internal.ToString_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Matches the sequence with seq. Returns ExactMatch if successful,
        /// PartialMatch if seq matches incompletely, and NoMatch if the sequences have
        /// nothing in common. Returns NoMatch if seq is shorter.</para>
        /// </summary>
        public QKeySequence.SequenceMatch Matches(QKeySequence seq)
        {
            var arg0 = ReferenceEquals(seq, null) ? global::System.IntPtr.Zero : seq.__Instance;
            var __ret = Internal.Matches_0(__Instance, arg0);
            return __ret;
        }

        public static bool operator !=(QKeySequence __op, QKeySequence other)
        {
            return !(__op == other);
        }

        /// <summary>
        /// <para>Returns true if this key sequence is equal to the other key
        /// sequence; otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QKeySequence __op, QKeySequence other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QKeySequence;
        }

        public static bool operator >(QKeySequence __op, QKeySequence ks)
        {
            return !(__op < ks);
        }

        /// <summary>
        /// <para>Provides an arbitrary comparison of this key sequence and other
        /// key sequence. All that is guaranteed is that the operator returns false if
        /// both key sequences are equal and that (ks1 &lt; ks2) == !( ks2 &lt; ks1) if
        /// the key sequences are not equal.</para>
        /// <para>This function is useful in some circumstances, for example if you
        /// want to use QKeySequence objects as keys in a QMap.</para>
        /// <para>See also operator==(), operator!=(), operator&gt;(),
        /// operator&lt;=(), and operator&gt;=().</para>
        /// </summary>
        public static bool operator <(QKeySequence __op, QKeySequence ks)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(ks, null) ? global::System.IntPtr.Zero : ks.__Instance;
            var __ret = Internal.OperatorLess_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Return a QKeySequence from the string str based on format.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also toString().</para>
        /// </summary>
        public static QKeySequence FromString(string str, QKeySequence.SequenceFormat format = QKeySequence.SequenceFormat.PortableText)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(str).ToPointer(), str.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = format;
            var __ret = new QtGui.QKeySequence.Internal();
            Internal.FromString_0(new IntPtr(&__ret), arg0, arg1);
            return QKeySequence.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Return a list of QKeySequence from the string str based on
        /// format.</para>
        /// <para>This function was introduced in  Qt 5.1.</para>
        /// <para>See also fromString() and listToString().</para>
        /// </summary>
        public static System.Collections.Generic.IList<QKeySequence> ListFromString(string str, QKeySequence.SequenceFormat format = QKeySequence.SequenceFormat.PortableText)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(str).ToPointer(), str.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = format;
            var __ret = Internal.ListFromString_0(arg0, arg1);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QKeySequence>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QKeySequence.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Return a string representation of list based on format.</para>
        /// <para>This function was introduced in  Qt 5.1.</para>
        /// <para>See also toString() and listFromString().</para>
        /// </summary>
        public static string ListToString(System.Collections.Generic.IList<QKeySequence> list, QKeySequence.SequenceFormat format = QKeySequence.SequenceFormat.PortableText)
        {
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = list.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = list.Count;
            fixed (void** __v = new void*[list.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < list.Count; i++)
            {
                __qlistDataData->array[i] = (void*) list[i].__Instance;
            }
            var arg0 = new global::System.IntPtr(&__qList);
            var arg1 = format;
            var __ret = new QtCore.QString.Internal();
            Internal.ListToString_0(new IntPtr(&__ret), arg0, arg1);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the shortcut key sequence for the mnemonic in text, or an
        /// empty key sequence if no mnemonics are found.</para>
        /// <para>For example, mnemonic(&quot;E&amp;xit&quot;) returns
        /// Qt::ALT+Qt::Key_X, mnemonic(&quot;&amp;Quit&quot;) returns ALT+Key_Q, and
        /// mnemonic(&quot;Quit&quot;) returns an empty QKeySequence.</para>
        /// <para>We provide a list of common mnemonics in English. At the time of
        /// writing, Microsoft and Open Group do not appear to have issued equivalent
        /// recommendations for other languages.</para>
        /// </summary>
        public static QKeySequence Mnemonic(string text)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtGui.QKeySequence.Internal();
            Internal.Mnemonic_0(new IntPtr(&__ret), arg0);
            return QKeySequence.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a list of key bindings for the given key. The result of
        /// calling this function will vary based on the target platform. The first
        /// element of the list indicates the primary shortcut for the given platform.
        /// If the result contains more than one result, these can be considered
        /// alternative shortcuts on the same platform for the given key.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public static System.Collections.Generic.IList<QKeySequence> KeyBindings(QKeySequence.StandardKey key)
        {
            var arg0 = key;
            var __ret = Internal.KeyBindings_0(arg0);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QKeySequence>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QKeySequence.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns the number of keys in the key sequence. The maximum is
        /// 4.</para>
        /// </summary>
        public int Count
        {
            get
            {
                var __ret = Internal.Count_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the key sequence is empty; otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                var __ret = Internal.IsEmpty_0(__Instance);
                return __ret;
            }
        }

        public bool IsDetached
        {
            get
            {
                var __ret = Internal.IsDetached_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QVector2D class represents a vector or vertex in 2D
    /// space.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QVector2D class can also be used to represent vertices in 2D
    /// space. We therefore do not need to provide a separate vertex class.</para>
    /// <para></para>
    /// <para>See also QVector3D, QVector4D, and QQuaternion.</para>
    /// </remarks>
    public unsafe partial class QVector2D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public float xp;

            [FieldOffset(4)]
            public float yp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector2DC2ERK9QVector3D")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector2DC2ERK9QVector4D")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector2DC2ERKS_")]
            internal static extern void cctor_6(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector2D9normalizeEv")]
            internal static extern void Normalize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D15distanceToPointERKS_")]
            internal static extern float DistanceToPoint_0(global::System.IntPtr instance, global::System.IntPtr point);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D14distanceToLineERKS_S1_")]
            internal static extern float DistanceToLine_0(global::System.IntPtr instance, global::System.IntPtr point, global::System.IntPtr direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QVector2D10dotProductERKS_S1_")]
            internal static extern float DotProduct_0(global::System.IntPtr v1, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D10toVector3DEv")]
            internal static extern void ToVector3D_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D10toVector4DEv")]
            internal static extern void ToVector4D_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D6lengthEv")]
            internal static extern float Length_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D13lengthSquaredEv")]
            internal static extern float LengthSquared_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector2D10normalizedEv")]
            internal static extern QVector2D.Internal Normalized_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QVector2D __CreateInstance(global::System.IntPtr native)
        {
            return new QVector2D((QVector2D.Internal*) native);
        }

        public static QVector2D __CreateInstance(QVector2D.Internal native)
        {
            return new QVector2D(native);
        }

        private static QVector2D.Internal* __CopyValue(QVector2D.Internal native)
        {
            var ret = (QVector2D.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QVector2D(QVector2D.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QVector2D(QVector2D.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a vector with x and y coordinates from a 3D vector.
        /// The z coordinate of vector is dropped.</para>
        /// <para>See also toVector3D().</para>
        /// </summary>
        public QVector2D(QVector3D vector)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a vector with x and y coordinates from a 3D vector.
        /// The z and w coordinates of vector are dropped.</para>
        /// <para>See also toVector4D().</para>
        /// </summary>
        public QVector2D(QVector4D vector)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_5(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Normalizes the currect vector in place. Nothing happens if this
        /// vector is a null vector or the length of the vector is very close to
        /// 1.</para>
        /// <para>See also length() and normalized().</para>
        /// </summary>
        public void Normalize()
        {
            Internal.Normalize_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the distance from this vertex to a point defined by the
        /// vertex point.</para>
        /// <para>This function was introduced in  Qt 5.1.</para>
        /// <para>See also distanceToLine().</para>
        /// </summary>
        public float DistanceToPoint(QVector2D point)
        {
            var arg0 = ReferenceEquals(point, null) ? global::System.IntPtr.Zero : point.__Instance;
            var __ret = Internal.DistanceToPoint_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the distance that this vertex is from a line defined by
        /// point and the unit vector direction.</para>
        /// <para>If direction is a null vector, then it does not define a line. In
        /// that case, the distance from point to this vertex is returned.</para>
        /// <para>This function was introduced in  Qt 5.1.</para>
        /// <para>See also distanceToPoint().</para>
        /// </summary>
        public float DistanceToLine(QVector2D point, QVector2D direction)
        {
            var arg0 = ReferenceEquals(point, null) ? global::System.IntPtr.Zero : point.__Instance;
            var arg1 = ReferenceEquals(direction, null) ? global::System.IntPtr.Zero : direction.__Instance;
            var __ret = Internal.DistanceToLine_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the 3D form of this 2D vector, with the z coordinate set
        /// to zero.</para>
        /// <para>See also toVector4D() and toPoint().</para>
        /// </summary>
        public QVector3D ToVector3D()
        {
            var __ret = new QtGui.QVector3D.Internal();
            Internal.ToVector3D_0(new IntPtr(&__ret), __Instance);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the 4D form of this 2D vector, with the z and w
        /// coordinates set to zero.</para>
        /// <para>See also toVector3D() and toPoint().</para>
        /// </summary>
        public QVector4D ToVector4D()
        {
            var __ret = new QtGui.QVector4D.Internal();
            Internal.ToVector4D_0(new IntPtr(&__ret), __Instance);
            return QVector4D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the dot product of v1 and v2.</para>
        /// </summary>
        public static float DotProduct(QVector2D v1, QVector2D v2)
        {
            var arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            var __ret = Internal.DotProduct_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the length of the vector from the origin.</para>
        /// <para>See also lengthSquared() and normalized().</para>
        /// </summary>
        public float Length
        {
            get
            {
                var __ret = Internal.Length_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the squared length of the vector from the origin. This is
        /// equivalent to the dot product of the vector with itself.</para>
        /// <para>See also length() and dotProduct().</para>
        /// </summary>
        public float LengthSquared
        {
            get
            {
                var __ret = Internal.LengthSquared_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the normalized unit vector form of this vector.</para>
        /// <para>If this vector is null, then a null vector is returned. If the
        /// length of the vector is very close to 1, then the vector will be returned
        /// as-is. Otherwise the normalized form of the vector of length 1 will be
        /// returned.</para>
        /// <para>See also length() and normalize().</para>
        /// </summary>
        public QVector2D Normalized
        {
            get
            {
                var __ret = Internal.Normalized_0(__Instance);
                return QVector2D.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QTouchDevice class describes the device from which touch
    /// events originate.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Each QTouchEvent contains a QTouchDevice pointer to allow
    /// accessing device-specific properties like type and capabilities. It is the
    /// responsibility of the platform or generic plug-ins to register the
    /// available touch devices via QWindowSystemInterface before generating any
    /// touch events. Applications do not need to instantiate this class, they
    /// should just access the global instances pointed to by
    /// QTouchEvent::device().</para>
    /// </remarks>
    public unsafe partial class QTouchDevice : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDeviceC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDeviceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDeviceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QTouchDevice4nameEv")]
            internal static extern void Name_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDevice7setNameERK7QString")]
            internal static extern void SetName_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QTouchDevice4typeEv")]
            internal static extern QTouchDevice.DeviceType Type_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDevice7setTypeENS_10DeviceTypeE")]
            internal static extern void SetType_0(global::System.IntPtr instance, QTouchDevice.DeviceType devType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QTouchDevice12capabilitiesEv")]
            internal static extern QTouchDevice.CapabilityFlag Capabilities_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDevice15setCapabilitiesE6QFlagsINS_14CapabilityFlagEE")]
            internal static extern void SetCapabilities_0(global::System.IntPtr instance, QTouchDevice.CapabilityFlag caps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QTouchDevice18maximumTouchPointsEv")]
            internal static extern int MaximumTouchPoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTouchDevice21setMaximumTouchPointsEi")]
            internal static extern void SetMaximumTouchPoints_0(global::System.IntPtr instance, int max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QTouchDevice7devicesEv")]
            internal static extern QList.Internal Devices_0();
        }

        /// <summary>
        /// <para>This enum represents the type of device that generated a
        /// QTouchEvent.</para>
        /// </summary>
        public enum DeviceType : uint
        {
            /// <summary>In this type of device, the touch surface and display are integrated. This means the surface and display typically have the same size, such that there is a direct relationship between the touch points' physical positions and the coordinate reported by QTouchEvent::TouchPoint. As a result, Qt allows the user to interact directly with multiple QWidgets and QGraphicsItems at the same time.</summary>
            TouchScreen = 0,
            /// <summary>In this type of device, the touch surface is separate from the display. There is not a direct relationship between the physical touch location and the on-screen coordinates. Instead, they are calculated relative to the current mouse position, and the user must use the touch-pad to move this reference point. Unlike touch-screens, Qt allows users to only interact with a single QWidget or QGraphicsItem at a time.</summary>
            TouchPad = 1
        }

        /// <summary>
        /// <para>This enum is used with QTouchDevice::capabilities() to indicate
        /// what kind of information the touch device or its driver can provide.</para>
        /// </summary>
        [Flags]
        public enum CapabilityFlag : uint
        {
            /// <summary>Indicates that position information is available, meaning that the pos() family of functions in the touch points return valid points.</summary>
            Position = 0x1,
            /// <summary>Indicates that touch area information is available, meaning that the rect() family of functions in the touch points return valid rectangles.</summary>
            Area = 0x2,
            /// <summary>Indicates that pressure information is available, meaning that pressure() returns a valid value.</summary>
            Pressure = 0x4,
            /// <summary>Indicates that velocity information is available, meaning that velocity() returns a valid vector.</summary>
            Velocity = 0x8,
            /// <summary>Indicates that the list returned by QTouchEvent::TouchPoint::rawScreenPositions() may contain one or more positions for each touch point. This is relevant when the touch input gets filtered or corrected on driver level.</summary>
            RawPositions = 0x10,
            /// <summary>Indicates that the normalized position is available, meaning that normalizedPos() returns a valid value.</summary>
            NormalizedPosition = 0x20
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTouchDevice __CreateInstance(global::System.IntPtr native)
        {
            return new QTouchDevice((QTouchDevice.Internal*) native);
        }

        public static QTouchDevice __CreateInstance(QTouchDevice.Internal native)
        {
            return new QTouchDevice(native);
        }

        private static QTouchDevice.Internal* __CopyValue(QTouchDevice.Internal native)
        {
            var ret = (QTouchDevice.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QTouchDevice(QTouchDevice.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTouchDevice(QTouchDevice.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a new touch device instance. By default the name is
        /// empty, the only capability is Position and type is TouchScreen.</para>
        /// </summary>
        public QTouchDevice()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the touch device name.</para>
        /// <para>This string may often be empty. It is however useful for systems
        /// that have more than one touch input device because there it can be used to
        /// differentiate between the devices (i.e. to tell from which device a
        /// QTouchEvent originates from).</para>
        /// <para>See also setName().</para>
        /// <para></para>
        /// <para>Sets the name (a unique identifier) for the device. In most
        /// systems it is enough to leave this unset and keep the default empty name.
        /// This identifier becomes important when having multiple touch devices and a
        /// need to differentiate between them.</para>
        /// <para>See also name().</para>
        /// </summary>
        public string Name
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Name_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the touch device type.</para>
        /// <para>See also setType().</para>
        /// <para></para>
        /// <para>Sets the device type devType.</para>
        /// <para>See also type().</para>
        /// </summary>
        public QTouchDevice.DeviceType Type
        {
            get
            {
                var __ret = Internal.Type_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetType_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the touch device capabilities.</para>
        /// <para>See also setCapabilities().</para>
        /// <para></para>
        /// <para>Sets the capabilities caps supported by the device and its
        /// driver.</para>
        /// <para>See also capabilities().</para>
        /// </summary>
        public QTouchDevice.CapabilityFlag Capabilities
        {
            get
            {
                var __ret = Internal.Capabilities_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetCapabilities_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the maximum number of simultaneous touch points (fingers)
        /// that can be detected.</para>
        /// <para>This function was introduced in  Qt 5.2.</para>
        /// <para>See also setMaximumTouchPoints().</para>
        /// <para></para>
        /// <para>Sets the maximum number of simultaneous touchpoints max supported
        /// by the device and its driver.</para>
        /// <para>See also maximumTouchPoints().</para>
        /// </summary>
        public int MaximumTouchPoints
        {
            get
            {
                var __ret = Internal.MaximumTouchPoints_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMaximumTouchPoints_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns a list of all registered devices.</para>
        /// <para>Note: The returned list cannot be used to add new devices. Use
        /// QWindowSystemInterface::registerTouchDevice() instead.</para>
        /// <para></para>
        /// <para>int QTouchDevice::maximumTouchPoints() const</para>
        /// <para>Returns the maximum number of simultaneous touch points (fingers)
        /// that can be detected.</para>
        /// <para>This function was introduced in  Qt 5.2.</para>
        /// <para>See also setMaximumTouchPoints().</para>
        /// </summary>
        public static System.Collections.Generic.IList<QTouchDevice> Devices
        {
            get
            {
                var __ret = Internal.Devices_0();
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTouchDevice>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTouchDevice.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }
    }

    /// <summary>
    /// <para>The QInputEvent class is the base class for events that describe
    /// user input.</para>
    /// </summary>
    public unsafe partial class QInputEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QInputEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QInputEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QInputEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QInputEvent((QInputEvent.Internal*) native);
        }

        public static QInputEvent __CreateInstance(QInputEvent.Internal native)
        {
            return new QInputEvent(native);
        }

        private static QInputEvent.Internal* __CopyValue(QInputEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QInputEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QInputEvent.Internal*) ret;
        }

        private QInputEvent(QInputEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QInputEvent(QInputEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QInputEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QInputEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QEnterEvent class contains parameters that describe an enter
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Enter events occur when the mouse cursor enters a window or a
    /// widget.</para>
    /// </remarks>
    public unsafe partial class QEnterEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct Internal
        {
            [FieldOffset(16)]
            internal QtCore.QPointF.Internal l;

            [FieldOffset(32)]
            internal QtCore.QPointF.Internal w;

            [FieldOffset(48)]
            internal QtCore.QPointF.Internal s;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QEnterEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QEnterEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QEnterEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QEnterEvent((QEnterEvent.Internal*) native);
        }

        public static QEnterEvent __CreateInstance(QEnterEvent.Internal native)
        {
            return new QEnterEvent(native);
        }

        private static QEnterEvent.Internal* __CopyValue(QEnterEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(64);
            QtGui.QEnterEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QEnterEvent.Internal*) ret;
        }

        private QEnterEvent(QEnterEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QEnterEvent(QEnterEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QEnterEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QEnterEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QMouseEvent class contains parameters that describe a mouse
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Mouse events occur when a mouse button is pressed or released
    /// inside a widget, or when the mouse cursor is moved.</para>
    /// <para>Mouse move events will occur only when a mouse button is pressed
    /// down, unless mouse tracking has been enabled with
    /// QWidget::setMouseTracking().</para>
    /// <para>Qt automatically grabs the mouse when a mouse button is pressed
    /// inside a widget; the widget will continue to receive mouse events until the
    /// last mouse button is released.</para>
    /// <para>A mouse event contains a special accept flag that indicates
    /// whether the receiver wants the event. You should call ignore() if the mouse
    /// event is not handled by your widget. A mouse event is propagated up the
    /// parent widget chain until a widget accepts it with accept(), or an event
    /// filter consumes it.</para>
    /// <para>Note: If a mouse event is propagated to a widget for which
    /// Qt::WA_NoMousePropagation has been set, that mouse event will not be
    /// propagated further up the parent widget chain.The state of the keyboard
    /// modifier keys can be found by calling the modifiers() function, inherited
    /// from QInputEvent.</para>
    /// <para>The functions pos(), x(), and y() give the cursor position
    /// relative to the widget that receives the mouse event. If you move the
    /// widget as a result of the mouse event, use the global position returned by
    /// globalPos() to avoid a shaking motion.</para>
    /// <para>The QWidget::setEnabled() function can be used to enable or
    /// disable mouse and keyboard events for a widget.</para>
    /// <para>Reimplement the QWidget event handlers,
    /// QWidget::mousePressEvent(), QWidget::mouseReleaseEvent(),
    /// QWidget::mouseDoubleClickEvent(), and QWidget::mouseMoveEvent() to receive
    /// mouse events in your own widgets.</para>
    /// <para></para>
    /// <para>See also QWidget::setMouseTracking(), QWidget::grabMouse(), and
    /// QCursor::pos().</para>
    /// </remarks>
    public unsafe partial class QMouseEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(24)]
            internal QtCore.QPointF.Internal l;

            [FieldOffset(40)]
            internal QtCore.QPointF.Internal w;

            [FieldOffset(56)]
            internal QtCore.QPointF.Internal s;

            [FieldOffset(72)]
            public QtCore.Qt.MouseButton b;

            [FieldOffset(76)]
            internal QtCore.Qt.MouseButton mouseState;

            [FieldOffset(80)]
            public int caps;

            [FieldOffset(84)]
            public QVector2D.Internal velocity;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QMouseEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QMouseEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QMouseEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QMouseEvent((QMouseEvent.Internal*) native);
        }

        public static QMouseEvent __CreateInstance(QMouseEvent.Internal native)
        {
            return new QMouseEvent(native);
        }

        private static QMouseEvent.Internal* __CopyValue(QMouseEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(96);
            QtGui.QMouseEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QMouseEvent.Internal*) ret;
        }

        private QMouseEvent(QMouseEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QMouseEvent(QMouseEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int Caps
        {
            get
            {
                return ((Internal*) __Instance)->caps;
            }

            set
            {
                ((Internal*) __Instance)->caps = value;
            }
        }

        protected QVector2D Velocity
        {
            get
            {
                return QVector2D.__CreateInstance(((Internal*) __Instance)->velocity);
            }

            set
            {
                ((Internal*) __Instance)->velocity = ReferenceEquals(value, null) ? new QVector2D.Internal() : *(QVector2D.Internal*) (value.__Instance);
            }
        }

        #region Virtual table interop

        // ~QMouseEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QMouseEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QHoverEvent class contains parameters that describe a mouse
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Mouse events occur when a mouse cursor is moved into, out of, or
    /// within a widget, and if the widget has the Qt::WA_Hover attribute.</para>
    /// <para>The function pos() gives the current cursor position, while
    /// oldPos() gives the old mouse position.</para>
    /// <para>There are a few similarities between the events
    /// QEvent::HoverEnter and QEvent::HoverLeave, and the events QEvent::Enter and
    /// QEvent::Leave. However, they are slightly different because we do an
    /// update() in the event handler of HoverEnter and HoverLeave.</para>
    /// <para>QEvent::HoverMove is also slightly different from
    /// QEvent::MouseMove. Let us consider a top-level window A containing a child
    /// B which in turn contains a child C (all with mouse tracking
    /// enabled):</para>
    /// <para>Now, if you move the cursor from the top to the bottom in the
    /// middle of A, you will get the following QEvent::MouseMove events:</para>
    /// <para></para>
    /// <para>A::MouseMove</para>
    /// <para>B::MouseMove</para>
    /// <para>C::MouseMove</para>
    /// <para></para>
    /// <para>You will get the same events for QEvent::HoverMove, except that
    /// the event always propagates to the top-level regardless whether the event
    /// is accepted or not. It will only stop propagating with the
    /// Qt::WA_NoMousePropagation attribute.</para>
    /// <para>In this case the events will occur in the following way:</para>
    /// <para></para>
    /// <para>A::HoverMove</para>
    /// <para>A::HoverMove, B::HoverMove</para>
    /// <para>A::HoverMove, B::HoverMove, C::HoverMove</para>
    /// </remarks>
    public unsafe partial class QHoverEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(24)]
            internal QtCore.QPointF.Internal p;

            [FieldOffset(40)]
            internal QtCore.QPointF.Internal op;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QHoverEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QHoverEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QHoverEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QHoverEvent((QHoverEvent.Internal*) native);
        }

        public static QHoverEvent __CreateInstance(QHoverEvent.Internal native)
        {
            return new QHoverEvent(native);
        }

        private static QHoverEvent.Internal* __CopyValue(QHoverEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(56);
            QtGui.QHoverEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QHoverEvent.Internal*) ret;
        }

        private QHoverEvent(QHoverEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QHoverEvent(QHoverEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        #region Virtual table interop

        // ~QHoverEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QHoverEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QWheelEvent class contains parameters that describe a wheel
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Wheel events are sent to the widget under the mouse cursor, but
    /// if that widget does not handle the event they are sent to the focus widget.
    /// Wheel events are generated for both mouse wheels and trackpad scroll
    /// gestures. There are two ways to read the wheel event delta: angleDelta()
    /// returns the delta in wheel degrees. This value is always provided.
    /// pixelDelta() returns the delta in screen pixels and is available on
    /// platforms that have high-resolution trackpads, such as Mac OS X.</para>
    /// <para>The functions pos() and globalPos() return the mouse cursor's
    /// location at the time of the event.</para>
    /// <para>A wheel event contains a special accept flag that indicates
    /// whether the receiver wants the event. You should call ignore() if you do
    /// not handle the wheel event; this ensures that it will be sent to the parent
    /// widget.</para>
    /// <para>The QWidget::setEnabled() function can be used to enable or
    /// disable mouse and keyboard events for a widget.</para>
    /// <para>The event handler QWidget::wheelEvent() receives wheel
    /// events.</para>
    /// <para></para>
    /// <para>See also QMouseEvent and QWidget::grabMouse().</para>
    /// </remarks>
    public unsafe partial class QWheelEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(24)]
            internal QtCore.QPointF.Internal p;

            [FieldOffset(40)]
            internal QtCore.QPointF.Internal g;

            [FieldOffset(56)]
            internal QtCore.QPoint.Internal pixelD;

            [FieldOffset(64)]
            internal QtCore.QPoint.Internal angleD;

            [FieldOffset(72)]
            public int qt4D;

            [FieldOffset(76)]
            public QtCore.Qt.Orientation qt4O;

            [FieldOffset(80)]
            internal QtCore.Qt.MouseButton mouseState;

            [FieldOffset(84)]
            public uint ph;

            [FieldOffset(84)]
            public int reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QWheelEventC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QWheelEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QWheelEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QWheelEvent((QWheelEvent.Internal*) native);
        }

        public static QWheelEvent __CreateInstance(QWheelEvent.Internal native)
        {
            return new QWheelEvent(native);
        }

        private static QWheelEvent.Internal* __CopyValue(QWheelEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(88);
            QtGui.QWheelEvent.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QWheelEvent.Internal*) ret;
        }

        private QWheelEvent(QWheelEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QWheelEvent(QWheelEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int Qt4D
        {
            get
            {
                return ((Internal*) __Instance)->qt4D;
            }

            set
            {
                ((Internal*) __Instance)->qt4D = value;
            }
        }

        protected int Reserved
        {
            get
            {
                return ((Internal*) __Instance)->reserved;
            }

            set
            {
                ((Internal*) __Instance)->reserved = value;
            }
        }

        #region Virtual table interop

        // ~QWheelEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWheelEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTabletEvent class contains parameters that describe a Tablet
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Tablet events are generated from tablet peripherals such as Wacom
    /// tablets and various other brands, and electromagnetic stylus devices
    /// included with some types of tablet computers. (It is not the same as
    /// QTouchEvent which a touchscreen generates, even when a passive stylus is
    /// used on a touchscreen.)</para>
    /// <para>Tablet events are similar to mouse events; for example, the x(),
    /// y(), pos(), globalX(), globalY(), and globalPos() accessors provide the
    /// cursor position, and you can see which buttons() are pressed (pressing the
    /// stylus tip against the tablet surface is equivalent to a left mouse
    /// button). But tablet events also pass through some extra information that
    /// the tablet device driver provides; for example, you might want to do
    /// subpixel rendering with higher resolution coordinates (hiResGlobalX() and
    /// hiResGlobalY()), adjust color brightness based on the pressure() of the
    /// tool against the tablet surface, use different brushes depending on the
    /// type of tool in use (device()), modulate the brush shape in some way
    /// according to the X-axis and Y-axis tilt of the tool with respect to the
    /// tablet surface (xTilt() and yTilt()), and use a virtual eraser instead of a
    /// brush if the user switches to the other end of a double-ended stylus
    /// (pointerType()).</para>
    /// <para>Every event contains an accept flag that indicates whether the
    /// receiver wants the event. You should call QTabletEvent::accept() if you
    /// handle the tablet event; otherwise it will be sent to the parent widget.
    /// The exception are TabletEnterProximity and TabletLeaveProximity events:
    /// these are only sent to QApplication and do not check whether or not they
    /// are accepted.</para>
    /// <para>The QWidget::setEnabled() function can be used to enable or
    /// disable mouse, tablet and keyboard events for a widget.</para>
    /// <para>The event handler QWidget::tabletEvent() receives TabletPress,
    /// TabletRelease and TabletMove events. Qt will first send a tablet event,
    /// then if it is not accepted by any widget, it will send a mouse event. This
    /// allows users of applications that are not designed for tablets to use a
    /// tablet like a mouse. However high-resolution drawing applications should
    /// handle the tablet events, because they can occur at a higher frequency,
    /// which is a benefit for smooth and accurate drawing. If the tablet events
    /// are rejected, the synthetic mouse events may be compressed for
    /// efficiency.</para>
    /// <para>New in Qt 5.4: QTabletEvent includes all information available
    /// from the device, including QTabletEvent::buttons(). Previously it was not
    /// possible to accept all tablet events and also know which stylus buttons
    /// were pressed.</para>
    /// <para>Note that pressing the stylus button while the stylus hovers over
    /// the tablet will generate a button press on some types of tablets, while on
    /// other types it will be necessary to press the stylus against the tablet
    /// surface in order to register the simultaneous stylus button press.</para>
    /// <para></para>
    /// <para>Notes for X11 Users</para>
    /// <para>If the tablet is configured in xorg.conf to use the Wacom driver,
    /// there will be separate XInput &quot;devices&quot; for the stylus, eraser,
    /// and (optionally) cursor and touchpad. Qt recognizes these by their names.
    /// Otherwise, if the tablet is configured to use the evdev driver, there will
    /// be only one device and applications may not be able to distinguish the
    /// stylus from the eraser.</para>
    /// </remarks>
    public unsafe partial class QTabletEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(24)]
            internal QtCore.QPointF.Internal mPos;

            [FieldOffset(40)]
            internal QtCore.QPointF.Internal mGPos;

            [FieldOffset(56)]
            public int mDev;

            [FieldOffset(60)]
            public int mPointerType;

            [FieldOffset(64)]
            public int mXT;

            [FieldOffset(68)]
            public int mYT;

            [FieldOffset(72)]
            public int mZ;

            [FieldOffset(80)]
            public double mPress;

            [FieldOffset(88)]
            public double mTangential;

            [FieldOffset(96)]
            public double mRot;

            [FieldOffset(104)]
            public long mUnique;

            [FieldOffset(112)]
            public global::System.IntPtr mExtra;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTabletEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QTabletEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum defines what type of device is generating the
        /// event.</para>
        /// <para>This enum was introduced or modified in  Qt 4.1.</para>
        /// </summary>
        public enum TabletDevice : uint
        {
            /// <summary>No device, or an unknown device.</summary>
            NoDevice = 0,
            /// <summary>A Puck (a device that is similar to a flat mouse with a transparent circle with cross-hairs).</summary>
            Puck = 1,
            /// <summary>A Stylus.</summary>
            Stylus = 2,
            /// <summary>An airbrush</summary>
            Airbrush = 3,
            /// <summary>A 4D Mouse.</summary>
            FourDMouse = 4,
            XFreeEraser = 5,
            /// <summary>A special stylus that also knows about rotation (a 6D stylus).</summary>
            RotationStylus = 6
        }

        /// <summary>
        /// <para>This enum defines what type of point is generating the
        /// event.</para>
        /// <para>See also pointerType().</para>
        /// </summary>
        public enum PointerType : uint
        {
            /// <summary>An unknown device.</summary>
            UnknownPointer = 0,
            /// <summary>Tip end of a stylus-like device (the narrow end of the pen).</summary>
            Pen = 1,
            /// <summary>Any puck-like device.</summary>
            Cursor = 2,
            /// <summary>Eraser end of a stylus-like device (the broad end of the pen).</summary>
            Eraser = 3
        }

        private readonly bool __ownsNativeInstance;

        public static new QTabletEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QTabletEvent((QTabletEvent.Internal*) native);
        }

        public static QTabletEvent __CreateInstance(QTabletEvent.Internal native)
        {
            return new QTabletEvent(native);
        }

        private static QTabletEvent.Internal* __CopyValue(QTabletEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(120);
            QtGui.QTabletEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTabletEvent.Internal*) ret;
        }

        private QTabletEvent(QTabletEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTabletEvent(QTabletEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int MDev
        {
            get
            {
                return ((Internal*) __Instance)->mDev;
            }

            set
            {
                ((Internal*) __Instance)->mDev = value;
            }
        }

        protected int MPointerType
        {
            get
            {
                return ((Internal*) __Instance)->mPointerType;
            }

            set
            {
                ((Internal*) __Instance)->mPointerType = value;
            }
        }

        protected int MXT
        {
            get
            {
                return ((Internal*) __Instance)->mXT;
            }

            set
            {
                ((Internal*) __Instance)->mXT = value;
            }
        }

        protected int MYT
        {
            get
            {
                return ((Internal*) __Instance)->mYT;
            }

            set
            {
                ((Internal*) __Instance)->mYT = value;
            }
        }

        protected int MZ
        {
            get
            {
                return ((Internal*) __Instance)->mZ;
            }

            set
            {
                ((Internal*) __Instance)->mZ = value;
            }
        }

        protected global::System.IntPtr MExtra
        {
            get
            {
                return ((Internal*) __Instance)->mExtra;
            }

            set
            {
                ((Internal*) __Instance)->mExtra = value;
            }
        }

        #region Virtual table interop

        // ~QTabletEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTabletEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QNativeGestureEvent class contains parameters that describe a
    /// gesture event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Native gesture events are generated by the operating system,
    /// typically by interpreting touch events. Gesture events are high-level
    /// events such as zoom or rotate.</para>
    /// <para></para>
    /// <para> Event TypeDescriptionTouch equence</para>
    /// <para>Qt::ZoomNativeGesture	Magnification delta in percent.	OS X:
    /// Two-finger pinch.</para>
    /// <para>Qt::SmartZoomNativeGesture	Boolean magnification state.	OS X:
    /// Two-finger douple tap (trackpad) / One-finger douple tap (magic
    /// mouse).</para>
    /// <para>Qt::RotateNativeGesture	Rotation delta in degrees.	OS X:
    /// Two-finger rotate.</para>
    /// <para></para>
    /// <para>In addition, BeginNativeGesture and EndNativeGesture are sent
    /// before and after gesture event streams:</para>
    /// <para>BeginNativeGesture ZoomNativeGesture ZoomNativeGesture
    /// ZoomNativeGesture EndNativeGesture</para>
    /// <para></para>
    /// <para>See also Qt::NativeGestureType and QGestureEvent.</para>
    /// </remarks>
    public unsafe partial class QNativeGestureEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(20)]
            public QtCore.Qt.NativeGestureType mGestureType;

            [FieldOffset(24)]
            internal QtCore.QPointF.Internal mLocalPos;

            [FieldOffset(40)]
            internal QtCore.QPointF.Internal mWindowPos;

            [FieldOffset(56)]
            internal QtCore.QPointF.Internal mScreenPos;

            [FieldOffset(72)]
            public double mRealValue;

            [FieldOffset(80)]
            public uint mSequenceId;

            [FieldOffset(88)]
            public ulong mIntValue;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QNativeGestureEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QNativeGestureEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QNativeGestureEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QNativeGestureEvent((QNativeGestureEvent.Internal*) native);
        }

        public static QNativeGestureEvent __CreateInstance(QNativeGestureEvent.Internal native)
        {
            return new QNativeGestureEvent(native);
        }

        private static QNativeGestureEvent.Internal* __CopyValue(QNativeGestureEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(96);
            QtGui.QNativeGestureEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QNativeGestureEvent.Internal*) ret;
        }

        private QNativeGestureEvent(QNativeGestureEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QNativeGestureEvent(QNativeGestureEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QKeyEvent class describes a key event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Key events are sent to the widget with keyboard input focus when
    /// keys are pressed or released.</para>
    /// <para>A key event contains a special accept flag that indicates whether
    /// the receiver will handle the key event. This flag is set by default, so
    /// there is no need to call accept() when acting on a key event. Calling
    /// ignore() on a key event will propagate it to the parent widget. The event
    /// is propagated up the parent widget chain until a widget accepts it or an
    /// event filter consumes it.</para>
    /// <para>The QWidget::setEnable() function can be used to enable or
    /// disable mouse and keyboard events for a widget.</para>
    /// <para>The event handlers QWidget::keyPressEvent(),
    /// QWidget::keyReleaseEvent(), QGraphicsItem::keyPressEvent() and
    /// QGraphicsItem::keyReleaseEvent() receive key events.</para>
    /// <para></para>
    /// <para>See also QFocusEvent and QWidget::grabKeyboard().</para>
    /// </remarks>
    public unsafe partial class QKeyEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(20)]
            internal QString.Internal txt;

            [FieldOffset(24)]
            public int k;

            [FieldOffset(28)]
            public uint nScanCode;

            [FieldOffset(32)]
            public uint nVirtualKey;

            [FieldOffset(36)]
            public uint nModifiers;

            [FieldOffset(40)]
            public ushort c;

            [FieldOffset(42)]
            public ushort autor;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QKeyEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QKeyEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QKeyEvent7matchesEN12QKeySequence11StandardKeyE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Matches_0(global::System.IntPtr instance, QKeySequence.StandardKey key);
        }

        private readonly bool __ownsNativeInstance;

        public static new QKeyEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QKeyEvent((QKeyEvent.Internal*) native);
        }

        public static QKeyEvent __CreateInstance(QKeyEvent.Internal native)
        {
            return new QKeyEvent(native);
        }

        private static QKeyEvent.Internal* __CopyValue(QKeyEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(44);
            QtGui.QKeyEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QKeyEvent.Internal*) ret;
        }

        private QKeyEvent(QKeyEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QKeyEvent(QKeyEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Returns true if the key event matches the given standard key;
        /// otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public bool Matches(QKeySequence.StandardKey key)
        {
            var arg0 = key;
            var __ret = Internal.Matches_0(__Instance, arg0);
            return __ret;
        }

        protected int K
        {
            get
            {
                return ((Internal*) __Instance)->k;
            }

            set
            {
                ((Internal*) __Instance)->k = value;
            }
        }

        #region Virtual table interop

        // ~QKeyEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QKeyEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QFocusEvent class contains event parameters for widget focus
    /// events.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Focus events are sent to widgets when the keyboard input focus
    /// changes. Focus events occur due to mouse actions, key presses (such as Tab
    /// or Backtab), the window system, popup menus, keyboard shortcuts, or other
    /// application-specific reasons. The reason for a particular focus event is
    /// returned by reason() in the appropriate event handler.</para>
    /// <para>The event handlers QWidget::focusInEvent(),
    /// QWidget::focusOutEvent(), QGraphicsItem::focusInEvent and
    /// QGraphicsItem::focusOutEvent() receive focus events.</para>
    /// <para></para>
    /// <para>See also QWidget::setFocus(), QWidget::setFocusPolicy(), and
    /// Keyboard Focus in Widgets.</para>
    /// </remarks>
    public unsafe partial class QFocusEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public QtCore.Qt.FocusReason m_reason;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QFocusEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QFocusEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFocusEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QFocusEvent((QFocusEvent.Internal*) native);
        }

        public static QFocusEvent __CreateInstance(QFocusEvent.Internal native)
        {
            return new QFocusEvent(native);
        }

        private static QFocusEvent.Internal* __CopyValue(QFocusEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QFocusEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QFocusEvent.Internal*) ret;
        }

        private QFocusEvent(QFocusEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFocusEvent(QFocusEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QFocusEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QFocusEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QPaintEvent class contains event parameters for paint
    /// events.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Paint events are sent to widgets that need to update themselves,
    /// for instance when part of a widget is exposed because a covering widget was
    /// moved.</para>
    /// <para>The event contains a region() that needs to be updated, and a
    /// rect() that is the bounding rectangle of that region. Both are provided
    /// because many widgets cannot make much use of region(), and rect() can be
    /// much faster than region().boundingRect().</para>
    /// <para></para>
    /// <para>Automatic Clipping</para>
    /// <para>Painting is clipped to region() during the processing of a paint
    /// event. This clipping is performed by Qt's paint system and is independent
    /// of any clipping that may be applied to a QPainter used to draw on the paint
    /// device.</para>
    /// <para>As a result, the value returned by QPainter::clipRegion() on a
    /// newly-constructed QPainter will not reflect the clip region that is used by
    /// the paint system.</para>
    /// <para></para>
    /// <para>See also QPainter, QWidget::update(), QWidget::repaint(), and
    /// QWidget::paintEvent().</para>
    /// </remarks>
    public unsafe partial class QPaintEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.QRect.Internal m_rect;

            [FieldOffset(28)]
            public QRegion.Internal m_region;

            [FieldOffset(32)]
            public bool m_erased;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPaintEventC2ERK7QRegion")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr paintRegion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPaintEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPaintEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPaintEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QPaintEvent((QPaintEvent.Internal*) native);
        }

        public static QPaintEvent __CreateInstance(QPaintEvent.Internal native)
        {
            return new QPaintEvent(native);
        }

        private static QPaintEvent.Internal* __CopyValue(QPaintEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(36);
            QtGui.QPaintEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QPaintEvent.Internal*) ret;
        }

        private QPaintEvent(QPaintEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPaintEvent(QPaintEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a paint event object with the region that needs to be
        /// updated. The region is specified by paintRegion.</para>
        /// </summary>
        public QPaintEvent(QRegion paintRegion)
        {
            __Instance = Marshal.AllocHGlobal(36);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(paintRegion, null) ? global::System.IntPtr.Zero : paintRegion.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected QRegion M_region
        {
            get
            {
                return QRegion.__CreateInstance(((Internal*) __Instance)->m_region);
            }

            set
            {
                ((Internal*) __Instance)->m_region = ReferenceEquals(value, null) ? new QRegion.Internal() : *(QRegion.Internal*) (value.__Instance);
            }
        }

        protected bool M_erased
        {
            get
            {
                return ((Internal*) __Instance)->m_erased;
            }

            set
            {
                ((Internal*) __Instance)->m_erased = value;
            }
        }

        #region Virtual table interop

        // ~QPaintEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QMoveEvent class contains event parameters for move
    /// events.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Move events are sent to widgets that have been moved to a new
    /// position relative to their parent.</para>
    /// <para>The event handler QWidget::moveEvent() receives move
    /// events.</para>
    /// <para></para>
    /// <para>See also QWidget::move() and QWidget::setGeometry().</para>
    /// </remarks>
    public unsafe partial class QMoveEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.QPoint.Internal p;

            [FieldOffset(20)]
            internal QtCore.QPoint.Internal oldp;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMoveEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMoveEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QMoveEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QMoveEvent((QMoveEvent.Internal*) native);
        }

        public static QMoveEvent __CreateInstance(QMoveEvent.Internal native)
        {
            return new QMoveEvent(native);
        }

        private static QMoveEvent.Internal* __CopyValue(QMoveEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            QtGui.QMoveEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QMoveEvent.Internal*) ret;
        }

        private QMoveEvent(QMoveEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QMoveEvent(QMoveEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QMoveEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QMoveEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QExposeEvent class contains event parameters for expose
    /// events.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Expose events are sent to windows when an area of the window is
    /// invalidated or window visibility in the windowing system changes.</para>
    /// <para>The event handler QWindow::exposeEvent() receives expose
    /// events.</para>
    /// </remarks>
    public unsafe partial class QExposeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public QRegion.Internal rgn;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QExposeEventC2ERK7QRegion")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr rgn);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QExposeEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QExposeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QExposeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QExposeEvent((QExposeEvent.Internal*) native);
        }

        public static QExposeEvent __CreateInstance(QExposeEvent.Internal native)
        {
            return new QExposeEvent(native);
        }

        private static QExposeEvent.Internal* __CopyValue(QExposeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QExposeEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QExposeEvent.Internal*) ret;
        }

        private QExposeEvent(QExposeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QExposeEvent(QExposeEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an expose event for the given exposeRegion which must
        /// be in local coordinates.</para>
        /// </summary>
        public QExposeEvent(QRegion rgn)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(rgn, null) ? global::System.IntPtr.Zero : rgn.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected QRegion Rgn
        {
            get
            {
                return QRegion.__CreateInstance(((Internal*) __Instance)->rgn);
            }

            set
            {
                ((Internal*) __Instance)->rgn = ReferenceEquals(value, null) ? new QRegion.Internal() : *(QRegion.Internal*) (value.__Instance);
            }
        }

        #region Virtual table interop

        // ~QExposeEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QExposeEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QResizeEvent class contains event parameters for resize
    /// events.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Resize events are sent to widgets that have been resized.</para>
    /// <para>The event handler QWidget::resizeEvent() receives resize
    /// events.</para>
    /// <para></para>
    /// <para>See also QWidget::resize() and QWidget::setGeometry().</para>
    /// </remarks>
    public unsafe partial class QResizeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.QSize.Internal s;

            [FieldOffset(20)]
            internal QtCore.QSize.Internal olds;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QResizeEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QResizeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QResizeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QResizeEvent((QResizeEvent.Internal*) native);
        }

        public static QResizeEvent __CreateInstance(QResizeEvent.Internal native)
        {
            return new QResizeEvent(native);
        }

        private static QResizeEvent.Internal* __CopyValue(QResizeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            QtGui.QResizeEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QResizeEvent.Internal*) ret;
        }

        private QResizeEvent(QResizeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QResizeEvent(QResizeEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QResizeEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QResizeEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QCloseEvent class contains parameters that describe a close
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Close events are sent to widgets that the user wants to close,
    /// usually by choosing &quot;Close&quot; from the window menu, or by clicking
    /// the X title bar button. They are also sent when you call QWidget::close()
    /// to close a widget programmatically.</para>
    /// <para>Close events contain a flag that indicates whether the receiver
    /// wants the widget to be closed or not. When a widget accepts the close
    /// event, it is hidden (and destroyed if it was created with the
    /// Qt::WA_DeleteOnClose flag). If it refuses to accept the close event nothing
    /// happens. (Under X11 it is possible that the window manager will forcibly
    /// close the window; but at the time of writing we are not aware of any window
    /// manager that does this.)</para>
    /// <para>The event handler QWidget::closeEvent() receives close events.
    /// The default implementation of this event handler accepts the close event.
    /// If you do not want your widget to be hidden, or want some special handing,
    /// you should reimplement the event handler and ignore() the event.</para>
    /// <para>The closeEvent() in the Application example shows a close event
    /// handler that asks whether to save a document before closing.</para>
    /// <para>If you want the widget to be deleted when it is closed, create it
    /// with the Qt::WA_DeleteOnClose flag. This is very useful for independent
    /// top-level windows in a multi-window application.</para>
    /// <para>QObjects emits the destroyed() signal when they are
    /// deleted.</para>
    /// <para>If the last top-level window is closed, the
    /// QGuiApplication::lastWindowClosed() signal is emitted.</para>
    /// <para>The isAccepted() function returns true if the event's receiver
    /// has agreed to close the widget; call accept() to agree to close the widget
    /// and call ignore() if the receiver of this event does not want the widget to
    /// be closed.</para>
    /// <para></para>
    /// <para>See also QWidget::close(), QWidget::hide(), QObject::destroyed(),
    /// QCoreApplication::exec(), QCoreApplication::quit(), and
    /// QGuiApplication::lastWindowClosed().</para>
    /// </remarks>
    public unsafe partial class QCloseEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QCloseEventC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QCloseEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QCloseEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QCloseEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QCloseEvent((QCloseEvent.Internal*) native);
        }

        public static QCloseEvent __CreateInstance(QCloseEvent.Internal native)
        {
            return new QCloseEvent(native);
        }

        private static QCloseEvent.Internal* __CopyValue(QCloseEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QCloseEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QCloseEvent.Internal*) ret;
        }

        private QCloseEvent(QCloseEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QCloseEvent(QCloseEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a close event object.</para>
        /// <para>See also accept().</para>
        /// </summary>
        public QCloseEvent()
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QCloseEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QCloseEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QIconDragEvent class indicates that a main icon drag has
    /// begun.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Icon drag events are sent to widgets when the main icon of a
    /// window has been dragged away. On Mac OS X, this happens when the proxy icon
    /// of a window is dragged off the title bar.</para>
    /// <para>It is normal to begin using drag and drop in response to this
    /// event.</para>
    /// <para></para>
    /// <para>See also Drag and Drop, QMimeData, and QDrag.</para>
    /// </remarks>
    public unsafe partial class QIconDragEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QIconDragEventC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QIconDragEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QIconDragEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QIconDragEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QIconDragEvent((QIconDragEvent.Internal*) native);
        }

        public static QIconDragEvent __CreateInstance(QIconDragEvent.Internal native)
        {
            return new QIconDragEvent(native);
        }

        private static QIconDragEvent.Internal* __CopyValue(QIconDragEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QIconDragEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QIconDragEvent.Internal*) ret;
        }

        private QIconDragEvent(QIconDragEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QIconDragEvent(QIconDragEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an icon drag event object with the accept flag set to
        /// false.</para>
        /// <para>See also accept().</para>
        /// </summary>
        public QIconDragEvent()
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QIconDragEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconDragEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QShowEvent class provides an event that is sent when a widget
    /// is shown.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>There are two kinds of show events: show events caused by the
    /// window system (spontaneous), and internal show events. Spontaneous
    /// (QEvent::spontaneous()) show events are sent just after the window system
    /// shows the window; they are also sent when a top-level window is redisplayed
    /// after being iconified. Internal show events are delivered just before the
    /// widget becomes visible.</para>
    /// <para></para>
    /// <para>See also QHideEvent.</para>
    /// </remarks>
    public unsafe partial class QShowEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QShowEventC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QShowEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QShowEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QShowEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QShowEvent((QShowEvent.Internal*) native);
        }

        public static QShowEvent __CreateInstance(QShowEvent.Internal native)
        {
            return new QShowEvent(native);
        }

        private static QShowEvent.Internal* __CopyValue(QShowEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QShowEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QShowEvent.Internal*) ret;
        }

        private QShowEvent(QShowEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QShowEvent(QShowEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QShowEvent.</para>
        /// </summary>
        public QShowEvent()
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QShowEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QShowEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QHideEvent class provides an event which is sent after a
    /// widget is hidden.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This event is sent just before QWidget::hide() returns, and also
    /// when a top-level window has been hidden (iconified) by the user.</para>
    /// <para>If spontaneous() is true, the event originated outside the
    /// application. In this case, the user hid the window using the window manager
    /// controls, either by iconifying the window or by switching to another
    /// virtual desktop where the window is not visible. The window will become
    /// hidden but not withdrawn. If the window was iconified,
    /// QWidget::isMinimized() returns true.</para>
    /// <para></para>
    /// <para>See also QShowEvent.</para>
    /// </remarks>
    public unsafe partial class QHideEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QHideEventC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QHideEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QHideEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QHideEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QHideEvent((QHideEvent.Internal*) native);
        }

        public static QHideEvent __CreateInstance(QHideEvent.Internal native)
        {
            return new QHideEvent(native);
        }

        private static QHideEvent.Internal* __CopyValue(QHideEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QHideEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QHideEvent.Internal*) ret;
        }

        private QHideEvent(QHideEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QHideEvent(QHideEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QHideEvent.</para>
        /// </summary>
        public QHideEvent()
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QHideEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QHideEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QContextMenuEvent class contains parameters that describe a
    /// context menu event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Context menu events are sent to widgets when a user performs an
    /// action associated with opening a context menu. The actions required to open
    /// context menus vary between platforms; for example, on Windows, pressing the
    /// menu button or clicking the right mouse button will cause this event to be
    /// sent.</para>
    /// <para>When this event occurs it is customary to show a QMenu with a
    /// context menu, if this is relevant to the context.</para>
    /// <para>Context menu events contain a special accept flag that indicates
    /// whether the receiver accepted the event. If the event handler does not
    /// accept the event then, if possible, whatever triggered the event will be
    /// handled as a regular input event.</para>
    /// </remarks>
    public unsafe partial class QContextMenuEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(20)]
            internal QtCore.QPoint.Internal p;

            [FieldOffset(28)]
            internal QtCore.QPoint.Internal gp;

            [FieldOffset(36)]
            public uint reas;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QContextMenuEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QContextMenuEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the reason why the event was sent.</para>
        /// </summary>
        public enum Reason : uint
        {
            /// <summary>The mouse caused the event to be sent. Normally this means the right mouse button was clicked, but this is platform dependent.</summary>
            Mouse = 0,
            /// <summary>The keyboard caused this event to be sent. On Windows, this means the menu button was pressed.</summary>
            Keyboard = 1,
            /// <summary>The event was sent by some other means (i.e. not by the mouse or keyboard).</summary>
            Other = 2
        }

        private readonly bool __ownsNativeInstance;

        public static new QContextMenuEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QContextMenuEvent((QContextMenuEvent.Internal*) native);
        }

        public static QContextMenuEvent __CreateInstance(QContextMenuEvent.Internal native)
        {
            return new QContextMenuEvent(native);
        }

        private static QContextMenuEvent.Internal* __CopyValue(QContextMenuEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(40);
            QtGui.QContextMenuEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QContextMenuEvent.Internal*) ret;
        }

        private QContextMenuEvent(QContextMenuEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QContextMenuEvent(QContextMenuEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        #region Virtual table interop

        // ~QContextMenuEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QContextMenuEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QInputMethodEvent class provides parameters for input method
    /// events.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Input method events are sent to widgets when an input method is
    /// used to enter text into a widget. Input methods are widely used to enter
    /// text for languages with non-Latin alphabets.</para>
    /// <para>Note that when creating custom text editing widgets, the
    /// Qt::WA_InputMethodEnabled window attribute must be set explicitly (using
    /// the QWidget::setAttribute() function) in order to receive input method
    /// events.</para>
    /// <para>The events are of interest to authors of keyboard entry widgets
    /// who want to be able to correctly handle languages with complex character
    /// input. Text input in such languages is usually a three step process:</para>
    /// <para></para>
    /// <para>Starting to ComposeWhen the user presses the first key on a
    /// keyboard, an input context is created. This input context will contain a
    /// string of the typed characters.</para>
    /// <para></para>
    /// <para>ComposingWith every new key pressed, the input method will try to
    /// create a matching string for the text typed so far called preedit string.
    /// While the input context is active, the user can only move the cursor inside
    /// the string belonging to this input context.</para>
    /// <para></para>
    /// <para>CompletingAt some point, the user will activate a user interface
    /// component (perhaps using a particular key) where they can choose from a
    /// number of strings matching the text they have typed so far. The user can
    /// either confirm their choice cancel the input; in either case the input
    /// context will be closed.</para>
    /// </remarks>
    public unsafe partial class QInputMethodEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QString.Internal preedit;

            [FieldOffset(16)]
            internal QList.Internal attrs;

            [FieldOffset(20)]
            internal QString.Internal commit;

            [FieldOffset(24)]
            public int replace_from;

            [FieldOffset(28)]
            public int replace_length;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QInputMethodEventC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QInputMethodEventC2ERK7QStringRK5QListINS_9AttributeEE")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr preeditText, global::System.IntPtr attributes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QInputMethodEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QInputMethodEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QInputMethodEvent15setCommitStringERK7QStringii")]
            internal static extern void SetCommitString_0(global::System.IntPtr instance, global::System.IntPtr commitString, int replaceFrom, int replaceLength);
        }

        /// <summary>
        /// <para>See also Attribute.</para>
        /// </summary>
        public enum AttributeType : uint
        {
            /// <summary>A QTextCharFormat for the part of the preedit string specified by start and length. value contains a QVariant of type QTextFormat specifying rendering of this part of the preedit string. There should be at most one format for every part of the preedit string. If several are specified for any character in the string the behaviour is undefined. A conforming implementation has to at least honor the backgroundColor, textColor and fontUnderline properties of the format.</summary>
            TextFormat = 0,
            /// <summary>If set, a cursor should be shown inside the preedit string at position start. The length variable determines whether the cursor is visible or not. If the length is 0 the cursor is invisible. If value is a QVariant of type QColor this color will be used for rendering the cursor, otherwise the color of the surrounding text will be used. There should be at most one Cursor attribute per event. If several are specified the behaviour is undefined.</summary>
            Cursor = 1,
            /// <summary>The variant contains a QLocale object specifying the language of a certain part of the preedit string. There should be at most one language set for every part of the preedit string. If several are specified for any character in the string the behavior is undefined.</summary>
            Language = 2,
            /// <summary>The ruby text for a part of the preedit string. There should be at most one ruby text set for every part of the preedit string. If several are specified for any character in the string the behaviour is undefined.</summary>
            Ruby = 3,
            /// <summary>If set, the edit cursor should be moved to the specified position in the editor text contents. In contrast with Cursor, this attribute does not work on the preedit text, but on the surrounding text. The cursor will be moved after the commit string has been committed, and the preedit string will be located at the new edit position. The start position specifies the new position and the length variable can be used to set a selection starting from that point. The value is unused.</summary>
            Selection = 4
        }

        public unsafe partial class Attribute : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public QInputMethodEvent.AttributeType type;

                [FieldOffset(4)]
                public int start;

                [FieldOffset(8)]
                public int length;

                [FieldOffset(16)]
                internal QtCore.QVariant.Internal value;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN17QInputMethodEvent9AttributeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN17QInputMethodEvent9AttributeD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Attribute __CreateInstance(global::System.IntPtr native)
            {
                return new Attribute((Attribute.Internal*) native);
            }

            public static Attribute __CreateInstance(Attribute.Internal native)
            {
                return new Attribute(native);
            }

            private static Attribute.Internal* __CopyValue(Attribute.Internal native)
            {
                var ret = Marshal.AllocHGlobal(32);
                QtGui.QInputMethodEvent.Attribute.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                return (Attribute.Internal*) ret;
            }

            private Attribute(Attribute.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Attribute(Attribute.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public QInputMethodEvent.AttributeType Type
            {
                get
                {
                    return ((Internal*) __Instance)->type;
                }

                set
                {
                    ((Internal*) __Instance)->type = value;
                }
            }

            public int Start
            {
                get
                {
                    return ((Internal*) __Instance)->start;
                }

                set
                {
                    ((Internal*) __Instance)->start = value;
                }
            }

            public int Length
            {
                get
                {
                    return ((Internal*) __Instance)->length;
                }

                set
                {
                    ((Internal*) __Instance)->length = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QInputMethodEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QInputMethodEvent((QInputMethodEvent.Internal*) native);
        }

        public static QInputMethodEvent __CreateInstance(QInputMethodEvent.Internal native)
        {
            return new QInputMethodEvent(native);
        }

        private static QInputMethodEvent.Internal* __CopyValue(QInputMethodEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QInputMethodEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QInputMethodEvent.Internal*) ret;
        }

        private QInputMethodEvent(QInputMethodEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QInputMethodEvent(QInputMethodEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an event of type QEvent::InputMethod. The
        /// attributes(), preeditString(), commitString(), replacementStart(), and
        /// replacementLength() are initialized to default values.</para>
        /// <para>See also setCommitString().</para>
        /// </summary>
        public QInputMethodEvent()
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs an event of type QEvent::InputMethod. The preedit text
        /// is set to preeditText, the attributes to attributes.</para>
        /// <para>The commitString(), replacementStart(), and replacementLength()
        /// values can be set using setCommitString().</para>
        /// <para>See also preeditString() and attributes().</para>
        /// </summary>
        public QInputMethodEvent(string preeditText, System.Collections.Generic.IList<QInputMethodEvent.Attribute> attributes)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(preeditText).ToPointer(), preeditText.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qList1 = new QtCore.QList.Internal();
            var __qlistDataData1 = (QListData.Data.Internal*) __qList1._0.d;
            __qlistDataData1->alloc = attributes.Count;
            __qlistDataData1->begin = 0;
            __qlistDataData1->end = attributes.Count;
            fixed (void** __v = new void*[attributes.Count])
            {
                __qlistDataData1->array = __v;
            }

            for (int i = 0; i < attributes.Count; i++)
            {
                __qlistDataData1->array[i] = (void*) attributes[i].__Instance;
            }
            var arg1 = new global::System.IntPtr(&__qList1);
            Internal.ctor_1(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a copy of other.</para>
        /// </summary>
        public QInputMethodEvent(QInputMethodEvent other)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the commit string to commitString.</para>
        /// <para>The commit string is the text that should get added to (or
        /// replace parts of) the text of the editor widget. It usually is a result of
        /// the input operations and has to be inserted to the widgets text directly
        /// before the preedit string.</para>
        /// <para>If the commit string should replace parts of the of the text in
        /// the editor, replaceLength specifies the number of characters to be
        /// replaced. replaceFrom specifies the position at which characters are to be
        /// replaced relative from the start of the preedit string.</para>
        /// <para>See also commitString(), replacementStart(), and
        /// replacementLength().</para>
        /// </summary>
        public void SetCommitString(string commitString, int replaceFrom = 0, int replaceLength = 0)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(commitString).ToPointer(), commitString.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.SetCommitString_0(__Instance, arg0, replaceFrom, replaceLength);
        }
    }

    /// <summary>
    /// <para>The QInputMethodQueryEvent class provides an event sent by the
    /// input context to input objects.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>It is used by the input method to query a set of properties of
    /// the object to be able to support complex input method operations as support
    /// for surrounding text and reconversions.</para>
    /// <para>queries() specifies which properties are queried.</para>
    /// <para>The object should call setValue() on the event to fill in the
    /// requested data before calling accept().</para>
    /// </remarks>
    public unsafe partial class QInputMethodQueryEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.InputMethodQuery m_queries;

            [FieldOffset(16)]
            internal QVector.Internal m_values;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QInputMethodQueryEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QInputMethodQueryEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QueryPair
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public QtCore.Qt.InputMethodQuery query;

                [FieldOffset(8)]
                internal QtCore.QVariant.Internal value;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QInputMethodQueryEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QInputMethodQueryEvent((QInputMethodQueryEvent.Internal*) native);
        }

        public static QInputMethodQueryEvent __CreateInstance(QInputMethodQueryEvent.Internal native)
        {
            return new QInputMethodQueryEvent(native);
        }

        private static QInputMethodQueryEvent.Internal* __CopyValue(QInputMethodQueryEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QInputMethodQueryEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QInputMethodQueryEvent.Internal*) ret;
        }

        private QInputMethodQueryEvent(QInputMethodQueryEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QInputMethodQueryEvent(QInputMethodQueryEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QInputMethodQueryEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QInputMethodQueryEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QDropEvent class provides an event which is sent when a drag
    /// and drop action is completed.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>When a widget accepts drop events, it will receive this event if
    /// it has accepted the most recent QDragEnterEvent or QDragMoveEvent sent to
    /// it.</para>
    /// <para>The drop event contains a proposed action, available from
    /// proposedAction(), for the widget to either accept or ignore. If the action
    /// can be handled by the widget, you should call the acceptProposedAction()
    /// function. Since the proposed action can be a combination of Qt::DropAction
    /// values, it may be useful to either select one of these values as a default
    /// action or ask the user to select their preferred action.</para>
    /// <para>If the proposed drop action is not suitable, perhaps because your
    /// custom widget does not support that action, you can replace it with any of
    /// the possible drop actions by calling setDropAction() with your preferred
    /// action. If you set a value that is not present in the bitwise OR
    /// combination of values returned by possibleActions(), the default copy
    /// action will be used. Once a replacement drop action has been set, call
    /// accept() instead of acceptProposedAction() to complete the drop
    /// operation.</para>
    /// <para>The mimeData() function provides the data dropped on the widget
    /// in a QMimeData object. This contains information about the MIME type of the
    /// data in addition to the data itself.</para>
    /// <para></para>
    /// <para>See also QMimeData, QDrag, and Drag and Drop.</para>
    /// </remarks>
    public unsafe partial class QDropEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct Internal
        {
            [FieldOffset(16)]
            internal QtCore.QPointF.Internal p;

            [FieldOffset(32)]
            internal QtCore.Qt.MouseButton mouseState;

            [FieldOffset(36)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(40)]
            internal QtCore.Qt.DropAction act;

            [FieldOffset(44)]
            public QtCore.Qt.DropAction drop_action;

            [FieldOffset(48)]
            public QtCore.Qt.DropAction default_action;

            [FieldOffset(52)]
            public global::System.IntPtr mdata;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QDropEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QDropEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QDropEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QDropEvent((QDropEvent.Internal*) native);
        }

        public static QDropEvent __CreateInstance(QDropEvent.Internal native)
        {
            return new QDropEvent(native);
        }

        private static QDropEvent.Internal* __CopyValue(QDropEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(56);
            QtGui.QDropEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QDropEvent.Internal*) ret;
        }

        private QDropEvent(QDropEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDropEvent(QDropEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QDropEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDropEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QDragMoveEvent class provides an event which is sent while a
    /// drag and drop action is in progress.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A widget will receive drag move events repeatedly while the drag
    /// is within its boundaries, if it accepts drop events and enter events. The
    /// widget should examine the event to see what kind of data it provides, and
    /// call the accept() function to accept the drop if appropriate.</para>
    /// <para>The rectangle supplied by the answerRect() function can be used
    /// to restrict drops to certain parts of the widget. For example, we can check
    /// whether the rectangle intersects with the geometry of a certain child
    /// widget and only call acceptProposedAction() if that is the case.</para>
    /// <para>Note that this class inherits most of its functionality from
    /// QDropEvent.</para>
    /// <para></para>
    /// <para>See also QDragEnterEvent, QDragLeaveEvent, and QDropEvent.</para>
    /// </remarks>
    public unsafe partial class QDragMoveEvent : QtGui.QDropEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct Internal
        {
            [FieldOffset(16)]
            internal QtCore.QPointF.Internal p;

            [FieldOffset(32)]
            internal QtCore.Qt.MouseButton mouseState;

            [FieldOffset(36)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(40)]
            internal QtCore.Qt.DropAction act;

            [FieldOffset(44)]
            public QtCore.Qt.DropAction drop_action;

            [FieldOffset(48)]
            public QtCore.Qt.DropAction default_action;

            [FieldOffset(52)]
            public global::System.IntPtr mdata;

            [FieldOffset(56)]
            internal QtCore.QRect.Internal rect;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QDragMoveEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QDragMoveEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QDragMoveEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QDragMoveEvent((QDragMoveEvent.Internal*) native);
        }

        public static QDragMoveEvent __CreateInstance(QDragMoveEvent.Internal native)
        {
            return new QDragMoveEvent(native);
        }

        private static QDragMoveEvent.Internal* __CopyValue(QDragMoveEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(72);
            QtGui.QDragMoveEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QDragMoveEvent.Internal*) ret;
        }

        private QDragMoveEvent(QDragMoveEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDragMoveEvent(QDragMoveEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QDropEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        #region Virtual table interop

        // ~QDragMoveEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDragMoveEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QDragEnterEvent class provides an event which is sent to a
    /// widget when a drag and drop action enters it.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A widget must accept this event in order to receive the drag move
    /// events that are sent while the drag and drop action is in progress. The
    /// drag enter event is always immediately followed by a drag move
    /// event.</para>
    /// <para>QDragEnterEvent inherits most of its functionality from
    /// QDragMoveEvent, which in turn inherits most of its functionality from
    /// QDropEvent.</para>
    /// <para></para>
    /// <para>See also QDragLeaveEvent, QDragMoveEvent, and QDropEvent.</para>
    /// </remarks>
    public unsafe partial class QDragEnterEvent : QtGui.QDragMoveEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct Internal
        {
            [FieldOffset(16)]
            internal QtCore.QPointF.Internal p;

            [FieldOffset(32)]
            internal QtCore.Qt.MouseButton mouseState;

            [FieldOffset(36)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(40)]
            internal QtCore.Qt.DropAction act;

            [FieldOffset(44)]
            public QtCore.Qt.DropAction drop_action;

            [FieldOffset(48)]
            public QtCore.Qt.DropAction default_action;

            [FieldOffset(52)]
            public global::System.IntPtr mdata;

            [FieldOffset(56)]
            internal QtCore.QRect.Internal rect;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QDragEnterEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QDragEnterEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QDragEnterEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QDragEnterEvent((QDragEnterEvent.Internal*) native);
        }

        public static QDragEnterEvent __CreateInstance(QDragEnterEvent.Internal native)
        {
            return new QDragEnterEvent(native);
        }

        private static QDragEnterEvent.Internal* __CopyValue(QDragEnterEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(72);
            QtGui.QDragEnterEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QDragEnterEvent.Internal*) ret;
        }

        private QDragEnterEvent(QDragEnterEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDragEnterEvent(QDragEnterEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QDragMoveEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        #region Virtual table interop

        // ~QDragEnterEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDragEnterEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QDragLeaveEvent class provides an event that is sent to a
    /// widget when a drag and drop action leaves it.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This event is always preceded by a QDragEnterEvent and a series
    /// of QDragMoveEvents. It is not sent if a QDropEvent is sent instead.</para>
    /// <para></para>
    /// <para>See also QDragEnterEvent, QDragMoveEvent, and QDropEvent.</para>
    /// </remarks>
    public unsafe partial class QDragLeaveEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QDragLeaveEventC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QDragLeaveEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QDragLeaveEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QDragLeaveEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QDragLeaveEvent((QDragLeaveEvent.Internal*) native);
        }

        public static QDragLeaveEvent __CreateInstance(QDragLeaveEvent.Internal native)
        {
            return new QDragLeaveEvent(native);
        }

        private static QDragLeaveEvent.Internal* __CopyValue(QDragLeaveEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QDragLeaveEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QDragLeaveEvent.Internal*) ret;
        }

        private QDragLeaveEvent(QDragLeaveEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDragLeaveEvent(QDragLeaveEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QDragLeaveEvent.</para>
        /// <para>Warning: Do not create a QDragLeaveEvent yourself since these
        /// objects rely on Qt's internal state.</para>
        /// </summary>
        public QDragLeaveEvent()
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QDragLeaveEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDragLeaveEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QHelpEvent class provides an event that is used to request
    /// helpful information about a particular point in a widget.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This event can be intercepted in applications to provide tooltips
    /// or &quot;What's This?&quot; help for custom widgets. The type() can be
    /// either QEvent::ToolTip or QEvent::WhatsThis.</para>
    /// <para></para>
    /// <para>See also QToolTip, QWhatsThis, QStatusTipEvent, and
    /// QWhatsThisClickedEvent.</para>
    /// </remarks>
    public unsafe partial class QHelpEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.QPoint.Internal p;

            [FieldOffset(20)]
            internal QtCore.QPoint.Internal gp;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QHelpEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QHelpEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QHelpEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QHelpEvent((QHelpEvent.Internal*) native);
        }

        public static QHelpEvent __CreateInstance(QHelpEvent.Internal native)
        {
            return new QHelpEvent(native);
        }

        private static QHelpEvent.Internal* __CopyValue(QHelpEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            QtGui.QHelpEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QHelpEvent.Internal*) ret;
        }

        private QHelpEvent(QHelpEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QHelpEvent(QHelpEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QHelpEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QHelpEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QStatusTipEvent class provides an event that is used to show
    /// messages in a status bar.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Status tips can be set on a widget using the
    /// QWidget::setStatusTip() function. They are shown in the status bar when the
    /// mouse cursor enters the widget. For example:</para>
    /// <para></para>
    /// <para> MainWindow::MainWindow(QWidget *parent)</para>
    /// <para>    : QMainWindow(parent)</para>
    /// <para>{</para>
    /// <para>    QWidget *myWidget = new QWidget;</para>
    /// <para>    myWidget-&gt;setStatusTip(tr(&quot;This is my
    /// widget.&quot;));</para>
    /// <para></para>
    /// <para>    setCentralWidget(myWidget);</para>
    /// <para>    ...</para>
    /// <para>}</para>
    /// <para>	</para>
    /// <para></para>
    /// <para>Status tips can also be set on actions using the
    /// QAction::setStatusTip() function:</para>
    /// <para></para>
    /// <para> MainWindow::MainWindow(QWidget *parent)</para>
    /// <para>    : QMainWindow(parent)</para>
    /// <para>{</para>
    /// <para>    QMenu *fileMenu =
    /// menuBar()-&gt;addMenu(tr(&quot;File&quot;));</para>
    /// <para></para>
    /// <para>    QAction *newAct = new QAction(tr(&quot;&amp;New&quot;),
    /// this);</para>
    /// <para>    newAct-&gt;setStatusTip(tr(&quot;Create a new
    /// file.&quot;));</para>
    /// <para>    fileMenu-&gt;addAction(newAct);</para>
    /// <para>    ...</para>
    /// <para>}</para>
    /// <para>	</para>
    /// <para></para>
    /// <para>Finally, status tips are supported for the item view classes
    /// through the Qt::StatusTipRole enum value.</para>
    /// <para></para>
    /// <para>See also QStatusBar, QHelpEvent, and
    /// QWhatsThisClickedEvent.</para>
    /// </remarks>
    public unsafe partial class QStatusTipEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QString.Internal s;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QStatusTipEventC2ERK7QString")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr tip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QStatusTipEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QStatusTipEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QStatusTipEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QStatusTipEvent((QStatusTipEvent.Internal*) native);
        }

        public static QStatusTipEvent __CreateInstance(QStatusTipEvent.Internal native)
        {
            return new QStatusTipEvent(native);
        }

        private static QStatusTipEvent.Internal* __CopyValue(QStatusTipEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QStatusTipEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QStatusTipEvent.Internal*) ret;
        }

        private QStatusTipEvent(QStatusTipEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QStatusTipEvent(QStatusTipEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a status tip event with the text specified by
        /// tip.</para>
        /// <para>See also tip().</para>
        /// </summary>
        public QStatusTipEvent(string tip)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(tip).ToPointer(), tip.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QStatusTipEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QStatusTipEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QWhatsThisClickedEvent class provides an event that can be
    /// used to handle hyperlinks in a &quot;What's This?&quot; text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para></para>
    /// <para>See also QWhatsThis, QHelpEvent, and QStatusTipEvent.</para>
    /// </remarks>
    public unsafe partial class QWhatsThisClickedEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QString.Internal s;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QWhatsThisClickedEventC2ERK7QString")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr href);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QWhatsThisClickedEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QWhatsThisClickedEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QWhatsThisClickedEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QWhatsThisClickedEvent((QWhatsThisClickedEvent.Internal*) native);
        }

        public static QWhatsThisClickedEvent __CreateInstance(QWhatsThisClickedEvent.Internal native)
        {
            return new QWhatsThisClickedEvent(native);
        }

        private static QWhatsThisClickedEvent.Internal* __CopyValue(QWhatsThisClickedEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QWhatsThisClickedEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QWhatsThisClickedEvent.Internal*) ret;
        }

        private QWhatsThisClickedEvent(QWhatsThisClickedEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QWhatsThisClickedEvent(QWhatsThisClickedEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an event containing a URL specified by href when a
        /// link is clicked in a &quot;What's This?&quot; message.</para>
        /// <para>See also href().</para>
        /// </summary>
        public QWhatsThisClickedEvent(string href)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(href).ToPointer(), href.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QWhatsThisClickedEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWhatsThisClickedEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QActionEvent class provides an event that is generated when a
    /// QAction is added, removed, or changed.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Actions can be added to widgets using QWidget::addAction(). This
    /// generates an ActionAdded event, which you can handle to provide custom
    /// behavior. For example, QToolBar reimplements QWidget::actionEvent() to
    /// create QToolButtons for the actions.</para>
    /// <para></para>
    /// <para>See also QAction, QWidget::addAction(), QWidget::removeAction(),
    /// and QWidget::actions().</para>
    /// </remarks>
    public unsafe partial class QActionEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public global::System.IntPtr act;

            [FieldOffset(16)]
            public global::System.IntPtr bef;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QActionEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QActionEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QActionEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QActionEvent((QActionEvent.Internal*) native);
        }

        public static QActionEvent __CreateInstance(QActionEvent.Internal native)
        {
            return new QActionEvent(native);
        }

        private static QActionEvent.Internal* __CopyValue(QActionEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QActionEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QActionEvent.Internal*) ret;
        }

        private QActionEvent(QActionEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QActionEvent(QActionEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QActionEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QActionEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QFileOpenEvent class provides an event that will be sent when
    /// there is a request to open a file or a URL.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>File open events will be sent to the QApplication::instance()
    /// when the operating system requests that a file or URL should be opened.
    /// This is a high-level event that can be caused by different user actions
    /// depending on the user's desktop environment; for example, double clicking
    /// on an file icon in the Finder on Mac OS X.</para>
    /// <para>This event is only used to notify the application of a request.
    /// It may be safely ignored.</para>
    /// <para>Note: This class is currently supported for Mac OS X only.</para>
    /// </remarks>
    public unsafe partial class QFileOpenEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QString.Internal f;

            [FieldOffset(16)]
            internal QtCore.QUrl.Internal m_url;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QFileOpenEventC2ERK7QString")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QFileOpenEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QFileOpenEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFileOpenEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QFileOpenEvent((QFileOpenEvent.Internal*) native);
        }

        public static QFileOpenEvent __CreateInstance(QFileOpenEvent.Internal native)
        {
            return new QFileOpenEvent(native);
        }

        private static QFileOpenEvent.Internal* __CopyValue(QFileOpenEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QFileOpenEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QFileOpenEvent.Internal*) ret;
        }

        private QFileOpenEvent(QFileOpenEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFileOpenEvent(QFileOpenEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public QFileOpenEvent(string file)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(file).ToPointer(), file.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QFileOpenEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QFileOpenEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QToolBarChangeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public uint tog;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QToolBarChangeEventC2Eb")]
            internal static extern void ctor_0(global::System.IntPtr instance, bool t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QToolBarChangeEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QToolBarChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QToolBarChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QToolBarChangeEvent((QToolBarChangeEvent.Internal*) native);
        }

        public static QToolBarChangeEvent __CreateInstance(QToolBarChangeEvent.Internal native)
        {
            return new QToolBarChangeEvent(native);
        }

        private static QToolBarChangeEvent.Internal* __CopyValue(QToolBarChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QToolBarChangeEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QToolBarChangeEvent.Internal*) ret;
        }

        private QToolBarChangeEvent(QToolBarChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QToolBarChangeEvent(QToolBarChangeEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public QToolBarChangeEvent(bool t)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance, t);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QToolBarChangeEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QToolBarChangeEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QShortcutEvent class provides an event which is generated
    /// when the user presses a key combination.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Normally you do not need to use this class directly; QShortcut
    /// provides a higher-level interface to handle shortcut keys.</para>
    /// <para></para>
    /// <para>See also QShortcut.</para>
    /// </remarks>
    public unsafe partial class QShortcutEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public QKeySequence.Internal sequence;

            [FieldOffset(16)]
            public bool ambig;

            [FieldOffset(20)]
            public int sid;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QShortcutEventC2ERK12QKeySequenceib")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr key, int id, bool ambiguous);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QShortcutEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QShortcutEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QShortcutEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QShortcutEvent((QShortcutEvent.Internal*) native);
        }

        public static QShortcutEvent __CreateInstance(QShortcutEvent.Internal native)
        {
            return new QShortcutEvent(native);
        }

        private static QShortcutEvent.Internal* __CopyValue(QShortcutEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            QtGui.QShortcutEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QShortcutEvent.Internal*) ret;
        }

        private QShortcutEvent(QShortcutEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QShortcutEvent(QShortcutEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a shortcut event for the given key press, associated
        /// with the QShortcut ID id.</para>
        /// <para>ambiguous specifies whether there is more than one QShortcut for
        /// the same key sequence.</para>
        /// </summary>
        public QShortcutEvent(QKeySequence key, int id, bool ambiguous = false)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(key, null) ? global::System.IntPtr.Zero : key.__Instance;
            Internal.ctor_0(__Instance, arg0, id, ambiguous);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected QKeySequence Sequence
        {
            get
            {
                return QKeySequence.__CreateInstance(((Internal*) __Instance)->sequence);
            }

            set
            {
                ((Internal*) __Instance)->sequence = ReferenceEquals(value, null) ? new QKeySequence.Internal() : *(QKeySequence.Internal*) (value.__Instance);
            }
        }

        protected bool Ambig
        {
            get
            {
                return ((Internal*) __Instance)->ambig;
            }

            set
            {
                ((Internal*) __Instance)->ambig = value;
            }
        }

        protected int Sid
        {
            get
            {
                return ((Internal*) __Instance)->sid;
            }

            set
            {
                ((Internal*) __Instance)->sid = value;
            }
        }

        #region Virtual table interop

        // ~QShortcutEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QShortcutEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QWindowStateChangeEvent class provides the window state
    /// before a window state change.</para>
    /// </summary>
    public unsafe partial class QWindowStateChangeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.WindowState ostate;

            [FieldOffset(16)]
            public bool m_override;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN23QWindowStateChangeEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN23QWindowStateChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK23QWindowStateChangeEvent10isOverrideEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOverride_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QWindowStateChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QWindowStateChangeEvent((QWindowStateChangeEvent.Internal*) native);
        }

        public static QWindowStateChangeEvent __CreateInstance(QWindowStateChangeEvent.Internal native)
        {
            return new QWindowStateChangeEvent(native);
        }

        private static QWindowStateChangeEvent.Internal* __CopyValue(QWindowStateChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QWindowStateChangeEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QWindowStateChangeEvent.Internal*) ret;
        }

        private QWindowStateChangeEvent(QWindowStateChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QWindowStateChangeEvent(QWindowStateChangeEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public bool IsOverride
        {
            get
            {
                var __ret = Internal.IsOverride_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QWindowStateChangeEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindowStateChangeEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTouchEvent class contains parameters that describe a touch
    /// event.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para></para>
    /// <para>Enabling Touch Events</para>
    /// <para>Touch events occur when pressing, releasing, or moving one or
    /// more touch points on a touch device (such as a touch-screen or track-pad).
    /// To receive touch events, widgets have to have the Qt::WA_AcceptTouchEvents
    /// attribute set and graphics items need to have the acceptTouchEvents
    /// attribute set to true.</para>
    /// <para>When using QAbstractScrollArea based widgets, you should enable
    /// the Qt::WA_AcceptTouchEvents attribute on the scroll area's
    /// viewport.</para>
    /// <para>Similarly to QMouseEvent, Qt automatically grabs each touch point
    /// on the first press inside a widget, and the widget will receive all updates
    /// for the touch point until it is released. Note that it is possible for a
    /// widget to receive events for numerous touch points, and that multiple
    /// widgets may be receiving touch events at the same time.</para>
    /// <para></para>
    /// <para>Event Handling</para>
    /// <para>All touch events are of type QEvent::TouchBegin,
    /// QEvent::TouchUpdate, QEvent::TouchEnd or QEvent::TouchCancel. Reimplement
    /// QWidget::event() or QAbstractScrollArea::viewportEvent() for widgets and
    /// QGraphicsItem::sceneEvent() for items in a graphics view to receive touch
    /// events.</para>
    /// <para>Unlike widgets, QWindows receive touch events always, there is no
    /// need to opt in. When working directly with a QWindow, it is enough to
    /// reimplement QWindow::touchEvent().</para>
    /// <para>The QEvent::TouchUpdate and QEvent::TouchEnd events are sent to
    /// the widget or item that accepted the QEvent::TouchBegin event. If the
    /// QEvent::TouchBegin event is not accepted and not filtered by an event
    /// filter, then no further touch events are sent until the next
    /// QEvent::TouchBegin.</para>
    /// <para>Some systems may send an event of type QEvent::TouchCancel. Upon
    /// receiving this event applications are requested to ignore the entire active
    /// touch sequence. For example in a composited system the compositor may
    /// decide to treat certain gestures as system-wide gestures. Whenever such a
    /// decision is made (the gesture is recognized), the clients will be notified
    /// with a QEvent::TouchCancel event so they can update their state
    /// accordingly.</para>
    /// <para>The touchPoints() function returns a list of all touch points
    /// contained in the event. Note that this list may be empty, for example in
    /// case of a QEvent::TouchCancel event. Information about each touch point can
    /// be retrieved using the QTouchEvent::TouchPoint class. The
    /// Qt::TouchPointState enum describes the different states that a touch point
    /// may have.</para>
    /// <para>Note: The list of touchPoints() will never be partial: A touch
    /// event will always contain a touch point for each existing physical touch
    /// contacts targetting the window or widget to which the event is sent. For
    /// instance, assuming that all touches target the same window or widget, an
    /// event with a condition of touchPoints().count()==2 is guaranteed to imply
    /// that the number of fingers touching the touchscreen or touchpad is exactly
    /// two.</para>
    /// <para>Event Delivery and Propagation</para>
    /// <para>By default, QGuiApplication translates the first touch point in a
    /// QTouchEvent into a QMouseEvent. This makes it possible to enable touch
    /// events on existing widgets that do not normally handle QTouchEvent. See
    /// below for information on some special considerations needed when doing
    /// this.</para>
    /// <para>QEvent::TouchBegin is the first touch event sent to a widget. The
    /// QEvent::TouchBegin event contains a special accept flag that indicates
    /// whether the receiver wants the event. By default, the event is accepted.
    /// You should call ignore() if the touch event is not handled by your widget.
    /// The QEvent::TouchBegin event is propagated up the parent widget chain until
    /// a widget accepts it with accept(), or an event filter consumes it. For
    /// QGraphicsItems, the QEvent::TouchBegin event is propagated to items under
    /// the mouse (similar to mouse event propagation for QGraphicsItems).</para>
    /// <para></para>
    /// <para>Touch Point Grouping</para>
    /// <para>As mentioned above, it is possible that several widgets can be
    /// receiving QTouchEvents at the same time. However, Qt makes sure to never
    /// send duplicate QEvent::TouchBegin events to the same widget, which could
    /// theoretically happen during propagation if, for example, the user touched 2
    /// separate widgets in a QGroupBox and both widgets ignored the
    /// QEvent::TouchBegin event.</para>
    /// <para>To avoid this, Qt will group new touch points together using the
    /// following rules:</para>
    /// <para></para>
    /// <para>When the first touch point is detected, the destination widget is
    /// determined firstly by the location on screen and secondly by the
    /// propagation rules.</para>
    /// <para>When additional touch points are detected, Qt first looks to see
    /// if there are any active touch points on any ancestor or descendent of the
    /// widget under the new touch point. If there are, the new touch point is
    /// grouped with the first, and the new touch point will be sent in a single
    /// QTouchEvent to the widget that handled the first touch point. (The widget
    /// under the new touch point will not receive an event).</para>
    /// <para></para>
    /// <para>This makes it possible for sibling widgets to handle touch events
    /// independently while making sure that the sequence of QTouchEvents is always
    /// correct.</para>
    /// <para></para>
    /// <para>Mouse Events and Touch Event Synthesizing</para>
    /// <para>QTouchEvent delivery is independent from that of QMouseEvent. The
    /// application flags Qt::AA_SynthesizeTouchForUnhandledMouseEvents and
    /// Qt::AA_SynthesizeMouseForUnhandledTouchEvents can be used to enable or
    /// disable automatic synthesizing of touch events to mouse events and mouse
    /// events to touch events.</para>
    /// <para></para>
    /// <para>Caveats</para>
    /// <para></para>
    /// <para>As mentioned above, enabling touch events means multiple widgets
    /// can be receiving touch events simultaneously. Combined with the default
    /// QWidget::event() handling for QTouchEvents, this gives you great
    /// flexibility in designing touch user interfaces. Be aware of the
    /// implications. For example, it is possible that the user is moving a QSlider
    /// with one finger and pressing a QPushButton with another. The signals
    /// emitted by these widgets will be interleaved.</para>
    /// <para>Recursion into the event loop using one of the exec() methods
    /// (e.g., QDialog::exec() or QMenu::exec()) in a QTouchEvent event handler is
    /// not supported. Since there are multiple event recipients, recursion may
    /// cause problems, including but not limited to lost events and unexpected
    /// infinite recursion.</para>
    /// <para>QTouchEvents are not affected by a mouse grab or an active pop-up
    /// widget. The behavior of QTouchEvents is undefined when opening a pop-up or
    /// grabbing the mouse while there are more than one active touch
    /// points.</para>
    /// </remarks>
    public unsafe partial class QTouchEvent : QtGui.QInputEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct Internal
        {
            [FieldOffset(12)]
            internal QtCore.Qt.KeyboardModifier modState;

            [FieldOffset(16)]
            public uint ts;

            [FieldOffset(20)]
            public global::System.IntPtr _window;

            [FieldOffset(24)]
            public global::System.IntPtr _target;

            [FieldOffset(28)]
            public global::System.IntPtr _device;

            [FieldOffset(32)]
            internal QtCore.Qt.TouchPointState _touchPointStates;

            [FieldOffset(36)]
            internal QList.Internal _touchPoints;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTouchEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTouchEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>The TouchPoint class provides information about a touch point in
        /// a QTouchEvent.</para>
        /// </summary>
        public unsafe partial class TouchPoint : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr d;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTouchEvent10TouchPointC2Ei")]
                internal static extern void ctor_0(global::System.IntPtr instance, int id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTouchEvent10TouchPointC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTouchEvent10TouchPointD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK11QTouchEvent10TouchPoint2idEv")]
                internal static extern int Id_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTouchEvent10TouchPoint5setIdEi")]
                internal static extern void SetId_0(global::System.IntPtr instance, int id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK11QTouchEvent10TouchPoint8velocityEv")]
                internal static extern QVector2D.Internal Velocity_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTouchEvent10TouchPoint11setVelocityERK9QVector2D")]
                internal static extern void SetVelocity_0(global::System.IntPtr instance, global::System.IntPtr v);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK11QTouchEvent10TouchPoint5flagsEv")]
                internal static extern QTouchEvent.TouchPoint.InfoFlag Flags_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTouchEvent10TouchPoint8setFlagsE6QFlagsINS0_8InfoFlagEE")]
                internal static extern void SetFlags_0(global::System.IntPtr instance, QTouchEvent.TouchPoint.InfoFlag flags);
            }

            /// <summary>
            /// <para>The values of this enum describe additional information about a
            /// touch point.</para>
            /// </summary>
            public enum InfoFlag : uint
            {
                /// <summary>Indicates that the contact has been made by a designated pointing device (e.g. a pen) instead of a finger.</summary>
                Pen = 0x1
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static TouchPoint __CreateInstance(global::System.IntPtr native)
            {
                return new TouchPoint((TouchPoint.Internal*) native);
            }

            public static TouchPoint __CreateInstance(TouchPoint.Internal native)
            {
                return new TouchPoint(native);
            }

            private static TouchPoint.Internal* __CopyValue(TouchPoint.Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                QtGui.QTouchEvent.TouchPoint.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                return (TouchPoint.Internal*) ret;
            }

            private TouchPoint(TouchPoint.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected TouchPoint(TouchPoint.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TouchPoint(int id = -1)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                Internal.ctor_0(__Instance, id);
            }

            public TouchPoint(QTouchEvent.TouchPoint other)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
                Internal.cctor_1(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            /// <summary>
            /// <para>Returns the id number of this touch point.</para>
            /// <para>Do not assume that id numbers start at zero or that they are
            /// sequential. Such an assumption is often false due to the way the underlying
            /// drivers work.</para>
            /// </summary>
            public int Id
            {
                get
                {
                    var __ret = Internal.Id_0(__Instance);
                    return __ret;
                }

                set
                {
                    Internal.SetId_0(__Instance, value);
                }
            }

            /// <summary>
            /// <para>Returns a velocity vector for this touch point. The vector is in
            /// the screen's coordinate system, using pixels per seconds for the
            /// magnitude.</para>
            /// <para>Note: The returned vector is only valid if the touch device's
            /// capabilities include QTouchDevice::Velocity.See also
            /// QTouchDevice::capabilities() and device().</para>
            /// </summary>
            public QVector2D Velocity
            {
                get
                {
                    var __ret = Internal.Velocity_0(__Instance);
                    return QVector2D.__CreateInstance(__ret);
                }

                set
                {
                    var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    Internal.SetVelocity_0(__Instance, arg0);
                }
            }

            /// <summary>
            /// <para>Returns additional information about the touch point.</para>
            /// <para>See also QTouchEvent::TouchPoint::InfoFlags.</para>
            /// </summary>
            public QTouchEvent.TouchPoint.InfoFlag Flags
            {
                get
                {
                    var __ret = Internal.Flags_0(__Instance);
                    return __ret;
                }

                set
                {
                    var arg0 = value;
                    Internal.SetFlags_0(__Instance, arg0);
                }
            }
        }

        private readonly bool __ownsNativeInstance;

        public static new QTouchEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QTouchEvent((QTouchEvent.Internal*) native);
        }

        public static QTouchEvent __CreateInstance(QTouchEvent.Internal native)
        {
            return new QTouchEvent(native);
        }

        private static QTouchEvent.Internal* __CopyValue(QTouchEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(40);
            QtGui.QTouchEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QTouchEvent.Internal*) ret;
        }

        private QTouchEvent(QTouchEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTouchEvent(QTouchEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QInputEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected QWindow _window
        {
            get
            {
                return (((Internal*) __Instance)->_window == IntPtr.Zero) ? null : QWindow.__CreateInstance(((Internal*) __Instance)->_window);
            }

            set
            {
                ((Internal*) __Instance)->_window = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected QTouchDevice _device
        {
            get
            {
                return (((Internal*) __Instance)->_device == IntPtr.Zero) ? null : QTouchDevice.__CreateInstance(((Internal*) __Instance)->_device);
            }

            set
            {
                ((Internal*) __Instance)->_device = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected System.Collections.Generic.IList<QTouchEvent.TouchPoint> _touchPoints
        {
            get
            {
                var __qlistData = QListData.__CreateInstance(((Internal*) __Instance)->_touchPoints._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTouchEvent.TouchPoint>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTouchEvent.TouchPoint.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }

            set
            {
                var __qList = new QtCore.QList.Internal();
                var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
                __qlistDataData->alloc = value.Count;
                __qlistDataData->begin = 0;
                __qlistDataData->end = value.Count;
                fixed (void** __v = new void*[value.Count])
                {
                    __qlistDataData->array = __v;
                }

                for (int i = 0; i < value.Count; i++)
                {
                    __qlistDataData->array[i] = (void*) value[i].__Instance;
                }
                ((Internal*) __Instance)->_touchPoints = __qList;
            }
        }

        #region Virtual table interop

        // ~QTouchEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTouchEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QScrollPrepareEvent class is sent in preparation of
    /// scrolling.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The scroll prepare event is sent before scrolling (usually by
    /// QScroller) is started. The object receiving this event should set
    /// viewportSize, maxContentPos and contentPos. It also should accept this
    /// event to indicate that scrolling should be started.</para>
    /// <para>It is not guaranteed that a QScrollEvent will be sent after an
    /// acceepted QScrollPrepareEvent, e.g. in a case where the maximum content
    /// position is (0,0).</para>
    /// <para></para>
    /// <para>See also QScrollEvent and QScroller.</para>
    /// </remarks>
    public unsafe partial class QScrollPrepareEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public global::System.IntPtr m_target;

            [FieldOffset(16)]
            internal QtCore.QPointF.Internal m_startPos;

            [FieldOffset(32)]
            internal QtCore.QSizeF.Internal m_viewportSize;

            [FieldOffset(48)]
            internal QtCore.QRectF.Internal m_contentPosRange;

            [FieldOffset(80)]
            internal QtCore.QPointF.Internal m_contentPos;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QScrollPrepareEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QScrollPrepareEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QScrollPrepareEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QScrollPrepareEvent((QScrollPrepareEvent.Internal*) native);
        }

        public static QScrollPrepareEvent __CreateInstance(QScrollPrepareEvent.Internal native)
        {
            return new QScrollPrepareEvent(native);
        }

        private static QScrollPrepareEvent.Internal* __CopyValue(QScrollPrepareEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(96);
            QtGui.QScrollPrepareEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QScrollPrepareEvent.Internal*) ret;
        }

        private QScrollPrepareEvent(QScrollPrepareEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QScrollPrepareEvent(QScrollPrepareEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QScrollPrepareEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QScrollPrepareEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QScrollEvent class is sent when scrolling.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The scroll event is sent to indicate that the receiver should be
    /// scrolled. Usually the receiver should be something visual like QWidget or
    /// QGraphicsObject.</para>
    /// <para>Some care should be taken that no conflicting QScrollEvents are
    /// sent from two sources. Using QScroller::scrollTo is save however.</para>
    /// <para></para>
    /// <para>See also QScrollPrepareEvent and QScroller.</para>
    /// </remarks>
    public unsafe partial class QScrollEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct Internal
        {
            [FieldOffset(16)]
            internal QtCore.QPointF.Internal m_contentPos;

            [FieldOffset(32)]
            internal QtCore.QPointF.Internal m_overshoot;

            [FieldOffset(48)]
            public QScrollEvent.ScrollState m_state;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QScrollEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QScrollEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QScrollEvent11scrollStateEv")]
            internal static extern QScrollEvent.ScrollState scrollState_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the states a scroll event can have.</para>
        /// <para>See also QScrollEvent::scrollState().</para>
        /// </summary>
        public enum ScrollState : uint
        {
            /// <summary>Set for the first scroll event of a scroll activity.</summary>
            ScrollStarted = 0,
            /// <summary>Set for all but the first and the last scroll event of a scroll activity.</summary>
            ScrollUpdated = 1,
            /// <summary>Set for the last scroll event of a scroll activity.</summary>
            ScrollFinished = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QScrollEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QScrollEvent((QScrollEvent.Internal*) native);
        }

        public static QScrollEvent __CreateInstance(QScrollEvent.Internal native)
        {
            return new QScrollEvent(native);
        }

        private static QScrollEvent.Internal* __CopyValue(QScrollEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(56);
            QtGui.QScrollEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QScrollEvent.Internal*) ret;
        }

        private QScrollEvent(QScrollEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QScrollEvent(QScrollEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the current scroll state as a combination of
        /// ScrollStateFlag values. ScrollStarted (or ScrollFinished) will be set, if
        /// this scroll event is the first (or last) event in a scrolling activity.
        /// Please note that both values can be set at the same time, if the activity
        /// consists of a single QScrollEvent. All other scroll events in between will
        /// have their state set to ScrollUpdated.</para>
        /// <para>A widget could for example revert selections when scrolling is
        /// started and stopped.</para>
        /// </summary>
        public QScrollEvent.ScrollState scrollState
        {
            get
            {
                var __ret = Internal.scrollState_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QScrollEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QScrollEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QScreenOrientationChangeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public global::System.IntPtr m_screen;

            [FieldOffset(16)]
            public QtCore.Qt.ScreenOrientation m_orientation;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN29QScreenOrientationChangeEventC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN29QScreenOrientationChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK29QScreenOrientationChangeEvent6screenEv")]
            internal static extern global::System.IntPtr Screen_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QScreenOrientationChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QScreenOrientationChangeEvent((QScreenOrientationChangeEvent.Internal*) native);
        }

        public static QScreenOrientationChangeEvent __CreateInstance(QScreenOrientationChangeEvent.Internal native)
        {
            return new QScreenOrientationChangeEvent(native);
        }

        private static QScreenOrientationChangeEvent.Internal* __CopyValue(QScreenOrientationChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QScreenOrientationChangeEvent.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QScreenOrientationChangeEvent.Internal*) ret;
        }

        private QScreenOrientationChangeEvent(QScreenOrientationChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QScreenOrientationChangeEvent(QScreenOrientationChangeEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public QScreen Screen
        {
            get
            {
                var __ret = Internal.Screen_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QScreen.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QScreenOrientationChangeEvent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QScreenOrientationChangeEvent) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QApplicationStateChangeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(12)]
            public QtCore.Qt.ApplicationState m_applicationState;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN28QApplicationStateChangeEventC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN28QApplicationStateChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QApplicationStateChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QApplicationStateChangeEvent((QApplicationStateChangeEvent.Internal*) native);
        }

        public static QApplicationStateChangeEvent __CreateInstance(QApplicationStateChangeEvent.Internal native)
        {
            return new QApplicationStateChangeEvent(native);
        }

        private static QApplicationStateChangeEvent.Internal* __CopyValue(QApplicationStateChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QApplicationStateChangeEvent.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QApplicationStateChangeEvent.Internal*) ret;
        }

        private QApplicationStateChangeEvent(QApplicationStateChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QApplicationStateChangeEvent(QApplicationStateChangeEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    /// <summary>
    /// <para>The QAccessible class provides enums and static functions related
    /// to accessibility.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is part of Accessibility for QWidget
    /// Applications.</para>
    /// <para>Accessible applications can be used by people who are not able to
    /// use applications by conventional means.</para>
    /// <para>The functions in this class are used for communication between
    /// accessible applications (also called AT Servers) and accessibility tools
    /// (AT Clients), such as screen readers and braille displays. Clients and
    /// servers communicate in the following way:</para>
    /// <para></para>
    /// <para>AT Servers notify the clients about events through calls to the
    /// updateAccessibility() function.</para>
    /// <para>AT Clients request information about the objects in the server.
    /// The QAccessibleInterface class is the core interface, and encapsulates this
    /// information in a pure virtual API. Implementations of the interface are
    /// provided by Qt through the queryAccessibleInterface() API.</para>
    /// <para></para>
    /// <para>The communication between servers and clients is initialized by
    /// the setRootObject() function. Function pointers can be installed to replace
    /// or extend the default behavior of the static functions in
    /// QAccessible.</para>
    /// <para>Qt supports Microsoft Active Accessibility (MSAA), Mac OS X
    /// Accessibility, and the Unix/X11 AT-SPI standard. Other backends can be
    /// supported using QAccessibleBridge.</para>
    /// <para>In the Unix/X11 AT-SPI implementation, applications become
    /// accessible when two conditions are met:</para>
    /// <para></para>
    /// <para>org.a11y.Status.IsEnabled DBus property is true</para>
    /// <para>org.a11y.Status.ScreenReaderEnabled DBus property is true</para>
    /// <para></para>
    /// <para>An alternative to setting the DBus AT-SPI properties is to set
    /// the QT_LINUX_ACCESSIBILITY_ALWAYS_ON environment variable.</para>
    /// <para>In addition to QAccessible's static functions, Qt offers one
    /// generic interface, QAccessibleInterface, that can be used to wrap all
    /// widgets and objects (e.g., QPushButton). This single interface provides all
    /// the metadata necessary for the assistive technologies. Qt provides
    /// implementations of this interface for its built-in widgets as
    /// plugins.</para>
    /// <para>When you develop custom widgets, you can create custom subclasses
    /// of QAccessibleInterface and distribute them as plugins (using
    /// QAccessiblePlugin) or compile them into the application. Likewise, Qt's
    /// predefined accessibility support can be built as plugin (the default) or
    /// directly into the Qt library. The main advantage of using plugins is that
    /// the accessibility classes are only loaded into memory if they are actually
    /// used; they don't slow down the common case where no assistive technology is
    /// being used.</para>
    /// <para>Qt also includes two convenience classes, QAccessibleObject and
    /// QAccessibleWidget, that inherit from QAccessibleInterface and provide the
    /// lowest common denominator of metadata (e.g., widget geometry, window title,
    /// basic help text). You can use them as base classes when wrapping your
    /// custom QObject or QWidget subclasses.</para>
    /// <para></para>
    /// <para>See also QAccessibleInterface.</para>
    /// </remarks>
    public unsafe partial class QAccessible : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QAccessibleC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible20installUpdateHandlerEPFvP16QAccessibleEventE")]
            internal static extern global::System.IntPtr InstallUpdateHandler_0(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible25installActivationObserverEPNS_18ActivationObserverE")]
            internal static extern void InstallActivationObserver_0(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible24removeActivationObserverEPNS_18ActivationObserverE")]
            internal static extern void RemoveActivationObserver_0(global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible8uniqueIdEP20QAccessibleInterface")]
            internal static extern uint UniqueId_0(global::System.IntPtr iface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible19accessibleInterfaceEj")]
            internal static extern global::System.IntPtr AccessibleInterface_0(uint uniqueId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible27registerAccessibleInterfaceEP20QAccessibleInterface")]
            internal static extern uint RegisterAccessibleInterface_0(global::System.IntPtr iface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible25deleteAccessibleInterfaceEj")]
            internal static extern void DeleteAccessibleInterface_0(uint uniqueId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible19updateAccessibilityEP16QAccessibleEvent")]
            internal static extern void UpdateAccessibility_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible7cleanupEv")]
            internal static extern void Cleanup_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z21qAccessibleRoleStringN11QAccessible4RoleE")]
            internal static extern global::System.IntPtr QAccessibleRoleString_0(QAccessible.Role role);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z22qAccessibleEventStringN11QAccessible5EventE")]
            internal static extern global::System.IntPtr QAccessibleEventString_0(QAccessible.Event @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z37qAccessibleLocalizedActionDescriptionRK7QString")]
            internal static extern void QAccessibleLocalizedActionDescription_0(global::System.IntPtr @return, global::System.IntPtr actionName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible8isActiveEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Active_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QAccessible9setActiveEb")]
            internal static extern void SetActive_0(bool active);
        }

        /// <summary>
        /// <para>This enum type defines accessible event types.</para>
        /// <para>Internal: Used when creating subclasses of
        /// QAccessibleEvent.</para>
        /// <para>The values for this enum are defined to be the same as those
        /// defined in the IAccessible2 and MSAA specifications.</para>
        /// </summary>
        public enum Event : uint
        {
            /// <summary>A sound has been played by an object The QAccessible::State of an object has changed. This value is used internally for the QAccessibleStateChangeEvent.</summary>
            SoundPlayed = 0x1,
            /// <summary>A system alert (e.g., a message from a QMessageBox)</summary>
            Alert = 0x2,
            /// <summary>A window has been activated (i.e., a new window has gained focus on the desktop).</summary>
            ForegroundChanged = 0x3,
            /// <summary>A menu has been opened on the menubar (Qt uses PopupMenuStart for all menus).</summary>
            MenuStart = 0x4,
            /// <summary>A menu has been closed (Qt uses PopupMenuEnd for all menus).</summary>
            MenuEnd = 0x5,
            /// <summary>A pop-up menu has opened.</summary>
            PopupMenuStart = 0x6,
            /// <summary>A pop-up menu has closed.</summary>
            PopupMenuEnd = 0x7,
            /// <summary>Context help (QWhatsThis) for an object is initiated.</summary>
            ContextHelpStart = 0xc,
            /// <summary>Context help (QWhatsThis) for an object is finished.</summary>
            ContextHelpEnd = 0xd,
            /// <summary>A drag and drop operation is about to be initiated.</summary>
            DragDropStart = 0xe,
            /// <summary>A drag and drop operation is about to finished.</summary>
            DragDropEnd = 0xf,
            /// <summary>A dialog (QDialog) has been set visible.</summary>
            DialogStart = 0x10,
            /// <summary>A dialog (QDialog) has been hidden</summary>
            DialogEnd = 0x11,
            /// <summary>A scrollbar scroll operation is about to start; this may be caused by a mouse press on the slider handle, for example.</summary>
            ScrollingStart = 0x12,
            /// <summary>A scrollbar scroll operation has ended (the mouse has released the slider handle).</summary>
            ScrollingEnd = 0x13,
            /// <summary>A menu item is triggered.</summary>
            MenuCommand = 0x18,
            /// <summary>An action has been changed.</summary>
            ActionChanged = 0x101,
            ActiveDescendantChanged = 0x102,
            AttributeChanged = 0x103,
            /// <summary>The contents of a text document have changed.</summary>
            DocumentContentChanged = 0x104,
            /// <summary>A document has been loaded.</summary>
            DocumentLoadComplete = 0x105,
            /// <summary>A document load has been stopped.</summary>
            DocumentLoadStopped = 0x106,
            /// <summary>A document reload has been initiated.</summary>
            DocumentReload = 0x107,
            /// <summary>The end position of the display text for a hypertext link has changed.</summary>
            HyperlinkEndIndexChanged = 0x108,
            /// <summary>The number of anchors in a hypertext link has changed, perhaps because the display text has been split to provide more than one link.</summary>
            HyperlinkNumberOfAnchorsChanged = 0x109,
            /// <summary>The link for the selected hypertext link has changed.</summary>
            HyperlinkSelectedLinkChanged = 0x10a,
            /// <summary>A hypertext link has been activated, perhaps by being clicked or via a key press.</summary>
            HypertextLinkActivated = 0x10b,
            /// <summary>A hypertext link has been selected.</summary>
            HypertextLinkSelected = 0x10c,
            /// <summary>The start position of the display text for a hypertext link has changed.</summary>
            HyperlinkStartIndexChanged = 0x10d,
            /// <summary>The display text for a hypertext link has changed.</summary>
            HypertextChanged = 0x10e,
            HypertextNLinksChanged = 0x10f,
            ObjectAttributeChanged = 0x110,
            PageChanged = 0x111,
            SectionChanged = 0x112,
            /// <summary>A table caption has been changed.</summary>
            TableCaptionChanged = 0x113,
            /// <summary>The description of a table column, typically found in the column's header, has been changed.</summary>
            TableColumnDescriptionChanged = 0x114,
            /// <summary>A table column header has been changed. The model providing data for a table has been changed.</summary>
            TableColumnHeaderChanged = 0x115,
            TableModelChanged = 0x116,
            /// <summary>The description of a table row, typically found in the row's header, has been changed.</summary>
            TableRowDescriptionChanged = 0x117,
            /// <summary>A table row header has been changed.</summary>
            TableRowHeaderChanged = 0x118,
            /// <summary>The summary of a table has been changed. The caret has moved in an editable widget. The caret represents the cursor position in an editable widget with the input focus.</summary>
            TableSummaryChanged = 0x119,
            TextAttributeChanged = 0x11a,
            TextCaretMoved = 0x11b,
            /// <summary>A text column has been changed. Text has been inserted into an editable widget. Text has been removed from an editable widget. The selected text has changed in an editable widget. The text has been update in an editable widget. The QAccessible::Value of an object has changed.</summary>
            TextColumnChanged = 0x11d,
            TextInserted = 0x11e,
            TextRemoved = 0x11f,
            TextUpdated = 0x120,
            TextSelectionChanged = 0x121,
            VisibleDataChanged = 0x122,
            /// <summary>A new object is created.</summary>
            ObjectCreated = 0x8000,
            /// <summary>An object is deleted.</summary>
            ObjectDestroyed = 0x8001,
            /// <summary>An object is displayed; for example, with QWidget::show().</summary>
            ObjectShow = 0x8002,
            /// <summary>An object is hidden; for example, with QWidget::hide(). Any children the object that is hidden has do not send this event. It is not sent when an object is hidden as it is being obcured by others.</summary>
            ObjectHide = 0x8003,
            /// <summary>A layout or item view has added, removed, or moved an object (Qt does not use this event).</summary>
            ObjectReorder = 0x8004,
            /// <summary>An object has gained keyboard focus.</summary>
            Focus = 0x8005,
            /// <summary>The selection has changed in a menu or item view.</summary>
            Selection = 0x8006,
            /// <summary>An item has been added to the selection in an item view.</summary>
            SelectionAdd = 0x8007,
            /// <summary>An item has been removed from an item view selection.</summary>
            SelectionRemove = 0x8008,
            /// <summary>Several changes to a selection has occurred in an item view.</summary>
            SelectionWithin = 0x8009,
            StateChanged = 0x800a,
            /// <summary>An object's location on the screen has changed.</summary>
            LocationChanged = 0x800b,
            /// <summary>The QAccessible::Name property of an object has changed.</summary>
            NameChanged = 0x800c,
            /// <summary>The object's QAccessible::Description changed.</summary>
            DescriptionChanged = 0x800d,
            ValueChanged = 0x800e,
            /// <summary>An object's parent object changed.</summary>
            ParentChanged = 0x800f,
            /// <summary>The QAccessible::Help text property of an object has changed.</summary>
            HelpChanged = 0x80a0,
            /// <summary>The default QAccessible::Action for the accessible object has changed.</summary>
            DefaultActionChanged = 0x80b0,
            /// <summary>The keyboard accelerator for an action has been changed.</summary>
            AcceleratorChanged = 0x80c0,
            InvalidEvent = 32961
        }

        /// <summary>
        /// <para>This enum defines the role of an accessible object. The roles
        /// are:</para>
        /// </summary>
        public enum Role : uint
        {
            /// <summary>The object has no role. This usually indicates an invalid object.</summary>
            NoRole = 0x0,
            /// <summary>The title bar caption of a window.</summary>
            TitleBar = 0x1,
            /// <summary>A menu bar from which menus are opened by the user.</summary>
            MenuBar = 0x2,
            /// <summary>A scroll bar, which allows the user to scroll the visible area.</summary>
            ScrollBar = 0x3,
            /// <summary>A grip that the user can drag to change the size of widgets.</summary>
            Grip = 0x4,
            /// <summary>An object that represents a sound.</summary>
            Sound = 0x5,
            /// <summary>An object that represents the mouse cursor.</summary>
            Cursor = 0x6,
            /// <summary>An object that represents the system caret (text cursor).</summary>
            Caret = 0x7,
            /// <summary>An object that is used to alert the user.</summary>
            AlertMessage = 0x8,
            /// <summary>A top level window.</summary>
            Window = 0x9,
            /// <summary>The client area in a window.</summary>
            Client = 0xa,
            /// <summary>A menu which lists options that the user can select to perform an action.</summary>
            PopupMenu = 0xb,
            /// <summary>An item in a menu or menu bar.</summary>
            MenuItem = 0xc,
            /// <summary>A tool tip which provides information about other objects.</summary>
            ToolTip = 0xd,
            /// <summary>The application's main window.</summary>
            Application = 0xe,
            /// <summary>A document, for example in an office application.</summary>
            Document = 0xf,
            /// <summary>A generic container.</summary>
            Pane = 0x10,
            /// <summary>An object that displays a graphical representation of data.</summary>
            Chart = 0x11,
            /// <summary>A dialog box.</summary>
            Dialog = 0x12,
            /// <summary>An object that represents a border.</summary>
            Border = 0x13,
            /// <summary>An object that represents a logical grouping of other objects.</summary>
            Grouping = 0x14,
            /// <summary>A separator that divides space into logical areas.</summary>
            Separator = 0x15,
            /// <summary>A tool bar, which groups widgets that the user accesses frequently.</summary>
            ToolBar = 0x16,
            /// <summary>A status bar.</summary>
            StatusBar = 0x17,
            /// <summary>A table representing data in a grid of rows and columns.</summary>
            Table = 0x18,
            /// <summary>A header for a column of data.</summary>
            ColumnHeader = 0x19,
            /// <summary>A header for a row of data.</summary>
            RowHeader = 0x1a,
            /// <summary>A column of cells, usually within a table.</summary>
            Column = 0x1b,
            /// <summary>A row of cells, usually within a table.</summary>
            Row = 0x1c,
            /// <summary>A cell in a table.</summary>
            Cell = 0x1d,
            /// <summary>A link to something else.</summary>
            Link = 0x1e,
            /// <summary>An object that displays help in a separate, short lived window.</summary>
            HelpBalloon = 0x1f,
            /// <summary>An object that provids interactive help.</summary>
            Assistant = 0x20,
            /// <summary>A list of items, from which the user can select one or more items.</summary>
            List = 0x21,
            /// <summary>An item in a list of items.</summary>
            ListItem = 0x22,
            /// <summary>A list of items in a tree structure.</summary>
            Tree = 0x23,
            /// <summary>An item in a tree structure.</summary>
            TreeItem = 0x24,
            /// <summary>A page tab that the user can select to switch to a different page in a dialog.</summary>
            PageTab = 0x25,
            /// <summary>A property page where the user can change options and settings.</summary>
            PropertyPage = 0x26,
            /// <summary>An indicator that represents a current value or item.</summary>
            Indicator = 0x27,
            /// <summary>A graphic or picture, e.g. an icon.</summary>
            Graphic = 0x28,
            /// <summary>Static text, such as labels for other widgets.</summary>
            StaticText = 0x29,
            /// <summary>Editable text such as a line or text edit.</summary>
            EditableText = 0x2a,
            /// <summary>A button.</summary>
            Button = 0x2b,
            PushButton = 43,
            /// <summary>An object that represents an option that can be checked or unchecked. Some options provide a "mixed" state, e.g. neither checked nor unchecked.</summary>
            CheckBox = 0x2c,
            /// <summary>An object that represents an option that is mutually exclusive with other options.</summary>
            RadioButton = 0x2d,
            /// <summary>A list of choices that the user can select from.</summary>
            ComboBox = 0x2e,
            /// <summary>The object displays the progress of an operation in progress.</summary>
            ProgressBar = 0x30,
            /// <summary>An object that represents a dial or knob.</summary>
            Dial = 0x31,
            /// <summary>A hotkey field that allows the user to enter a key sequence.</summary>
            HotkeyField = 0x32,
            /// <summary>A slider that allows the user to select a value within a given range.</summary>
            Slider = 0x33,
            /// <summary>A spin box widget that allows the user to enter a value within a given range.</summary>
            SpinBox = 0x34,
            /// <summary>An object that displays graphics that the user can interact with.</summary>
            Canvas = 0x35,
            /// <summary>An object that displays an animation.</summary>
            Animation = 0x36,
            /// <summary>An object that represents a mathematical equation.</summary>
            Equation = 0x37,
            /// <summary>A button that drops down a list of items.</summary>
            ButtonDropDown = 0x38,
            /// <summary>A button that drops down a menu.</summary>
            ButtonMenu = 0x39,
            /// <summary>A button that drops down a grid.</summary>
            ButtonDropGrid = 0x3a,
            /// <summary>Blank space between other objects.</summary>
            Whitespace = 0x3b,
            /// <summary>A list of page tabs.</summary>
            PageTabList = 0x3c,
            /// <summary>A clock displaying time.</summary>
            Clock = 0x3d,
            /// <summary>A splitter distributing available space between its child widgets.</summary>
            Splitter = 0x3e,
            /// <summary>An object that can contain layered children, e.g. in a stack.</summary>
            LayeredPane = 0x80,
            /// <summary>A terminal or command line interface.</summary>
            Terminal = 0x81,
            /// <summary>The object represents the desktop or workspace.</summary>
            Desktop = 0x82,
            /// <summary>A paragraph of text (usually found in documents).</summary>
            Paragraph = 0x83,
            /// <summary>HTML document, usually in a browser.</summary>
            WebDocument = 0x84,
            /// <summary>A section (in a document).</summary>
            Section = 0x85,
            /// <summary>A dialog that lets the user choose a color.</summary>
            ColorChooser = 0x404,
            /// <summary>A footer in a page (usually in documents).</summary>
            Footer = 0x40e,
            /// <summary>A web form containing controls.</summary>
            Form = 0x410,
            /// <summary>A heading in a document.</summary>
            Heading = 0x414,
            /// <summary>A section whose content is parenthetic or ancillary to the main content of the resource.</summary>
            Note = 0x41b,
            /// <summary>A part of the document or web page that is complementary to the main content, usually a landmark (see WAI-ARIA).</summary>
            ComplementaryContent = 0x42c,
            /// <summary>The first value to be used for user defined roles.</summary>
            UserRole = 0xffff
        }

        /// <summary>
        /// <para>This enum specifies string information that an accessible object
        /// returns.</para>
        /// </summary>
        public enum Text : uint
        {
            /// <summary>The name of the object. This can be used both as an identifier or a short description by accessible clients.</summary>
            Name = 0,
            /// <summary>A short text describing the object.</summary>
            Description = 1,
            /// <summary>The value of the object.</summary>
            Value = 2,
            /// <summary>A longer text giving information about how to use the object.</summary>
            Help = 3,
            /// <summary>The keyboard shortcut that executes the object's default action.</summary>
            Accelerator = 4,
            DebugDescription = 5,
            /// <summary>The first value to be used for user defined text.</summary>
            UserText = 0xffff
        }

        /// <summary>
        /// <para>This enum type defines bit flags that can be combined to indicate
        /// the relationship between two accessible objects.</para>
        /// <para>Implementations of relations() return a combination of these
        /// flags. Some values are mutually exclusive.</para>
        /// </summary>
        public enum RelationFlag : uint
        {
            /// <summary>The first object is the label of the second object.</summary>
            Label = 0x1,
            /// <summary>The first object is labelled by the second object.</summary>
            Labelled = 0x2,
            /// <summary>The first object controls the second object.</summary>
            Controller = 0x4,
            /// <summary>The first object is controlled by the second object.</summary>
            Controlled = 0x8,
            /// <summary>Used as a mask to specify that we are interesting in information about all relations</summary>
            AllRelations = 0xffffffff
        }

        /// <summary>
        /// <para>QAccessibleInterface supports several sub interfaces. In order to
        /// provide more information about some objects, their accessible
        /// representation should implement one or more of these interfaces.</para>
        /// <para>Note: When subclassing one of these interfaces,
        /// QAccessibleInterface::interface_cast() needs to be implemented.See also
        /// QAccessibleInterface::interface_cast(), QAccessibleTextInterface,
        /// QAccessibleValueInterface, QAccessibleActionInterface,
        /// QAccessibleTableInterface, and QAccessibleTableCellInterface.</para>
        /// </summary>
        public enum InterfaceType : uint
        {
            /// <summary>For text that supports selections or is more than one line. Simple labels do not need to implement this interface. For text that can be edited by the user.</summary>
            TextInterface = 0,
            EditableTextInterface = 1,
            /// <summary>For objects that are used to manipulate a value, for example slider or scroll bar.</summary>
            ValueInterface = 2,
            /// <summary>For interactive objects that allow the user to trigger an action. Basically everything that allows for example mouse interaction. For objects that represent an image. This interface is generally less important.</summary>
            ActionInterface = 3,
            ImageInterface = 4,
            /// <summary>For lists, tables and trees.</summary>
            TableInterface = 5,
            /// <summary>For cells in a TableInterface object.</summary>
            TableCellInterface = 6
        }

        /// <summary>
        /// <para>This enum describes different types of text boundaries. It
        /// follows the IAccessible2 API and is used in the
        /// QAccessibleTextInterface.</para>
        /// <para>See also QAccessibleTextInterface.</para>
        /// </summary>
        public enum TextBoundaryType : uint
        {
            /// <summary>Use individual characters as boundary.</summary>
            CharBoundary = 0,
            /// <summary>Use words as boundaries.</summary>
            WordBoundary = 1,
            /// <summary>Use sentences as boundary.</summary>
            SentenceBoundary = 2,
            /// <summary>Use paragraphs as boundary.</summary>
            ParagraphBoundary = 3,
            /// <summary>Use newlines as boundary.</summary>
            LineBoundary = 4,
            /// <summary>No boundary (use the whole text).</summary>
            NoBoundary = 5
        }

        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void UpdateHandler(global::System.IntPtr @event);

        public unsafe partial class State : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public ulong disabled;

                [FieldOffset(0)]
                public ulong selected;

                [FieldOffset(0)]
                public ulong focusable;

                [FieldOffset(0)]
                public ulong focused;

                [FieldOffset(0)]
                public ulong pressed;

                [FieldOffset(0)]
                public ulong checkable;

                [FieldOffset(0)]
                public ulong @checked;

                [FieldOffset(0)]
                public ulong checkStateMixed;

                [FieldOffset(1)]
                public ulong readOnly;

                [FieldOffset(1)]
                public ulong hotTracked;

                [FieldOffset(1)]
                public ulong defaultButton;

                [FieldOffset(1)]
                public ulong expanded;

                [FieldOffset(1)]
                public ulong collapsed;

                [FieldOffset(1)]
                public ulong busy;

                [FieldOffset(1)]
                public ulong expandable;

                [FieldOffset(1)]
                public ulong marqueed;

                [FieldOffset(2)]
                public ulong animated;

                [FieldOffset(2)]
                public ulong invisible;

                [FieldOffset(2)]
                public ulong offscreen;

                [FieldOffset(2)]
                public ulong sizeable;

                [FieldOffset(2)]
                public ulong movable;

                [FieldOffset(2)]
                public ulong selfVoicing;

                [FieldOffset(2)]
                public ulong selectable;

                [FieldOffset(2)]
                public ulong linked;

                [FieldOffset(3)]
                public ulong traversed;

                [FieldOffset(3)]
                public ulong multiSelectable;

                [FieldOffset(3)]
                public ulong extSelectable;

                [FieldOffset(3)]
                public ulong passwordEdit;

                [FieldOffset(3)]
                public ulong hasPopup;

                [FieldOffset(3)]
                public ulong modal;

                [FieldOffset(3)]
                public ulong active;

                [FieldOffset(3)]
                public ulong invalid;

                [FieldOffset(4)]
                public ulong editable;

                [FieldOffset(4)]
                public ulong multiLine;

                [FieldOffset(4)]
                public ulong selectableText;

                [FieldOffset(4)]
                public ulong supportsAutoCompletion;

                [FieldOffset(4)]
                public ulong searchEdit;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QAccessible5StateC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZeqRKN11QAccessible5StateES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr first, global::System.IntPtr second);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static State __CreateInstance(global::System.IntPtr native)
            {
                return new State((State.Internal*) native);
            }

            public static State __CreateInstance(State.Internal native)
            {
                return new State(native);
            }

            private static State.Internal* __CopyValue(State.Internal native)
            {
                var ret = (State.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private State(State.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected State(State.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public static bool operator !=(QAccessible.State first, QAccessible.State second)
            {
                return !(first == second);
            }

            public static bool operator ==(QAccessible.State first, QAccessible.State second)
            {
                bool firstNull = ReferenceEquals(first, null);
                bool secondNull = ReferenceEquals(second, null);
                if (firstNull || secondNull)
                    return firstNull && secondNull;
                var arg0 = first.__Instance;
                var arg1 = second.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as State;
            }
        }

        public unsafe abstract partial class ActivationObserver : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QAccessible18ActivationObserverC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QAccessible18ActivationObserverD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            protected ActivationObserver(ActivationObserver.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public abstract void AccessibilityActiveChanged(bool active);

            #region Virtual table interop

            // void accessibilityActiveChanged(bool active)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
            internal delegate void _AccessibilityActiveChanged_0Delegate(global::System.IntPtr instance, bool active);
            private static _AccessibilityActiveChanged_0Delegate _AccessibilityActiveChanged_0DelegateInstance;

            private static void _AccessibilityActiveChanged_0DelegateHook(global::System.IntPtr instance, bool active)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (ActivationObserver) _References[instance].Target;
                target.AccessibilityActiveChanged(active);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[1];
                    _AccessibilityActiveChanged_0DelegateInstance += _AccessibilityActiveChanged_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibilityActiveChanged_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QAccessible __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessible((QAccessible.Internal*) native);
        }

        public static QAccessible __CreateInstance(QAccessible.Internal native)
        {
            return new QAccessible(native);
        }

        private static QAccessible.Internal* __CopyValue(QAccessible.Internal native)
        {
            var ret = (QAccessible.Internal*) Marshal.AllocHGlobal(1);
            *ret = native;
            return ret;
        }

        private QAccessible(QAccessible.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessible(QAccessible.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public static QAccessible.UpdateHandler InstallUpdateHandler(QAccessible.UpdateHandler _0)
        {
            var arg0 = Marshal.GetFunctionPointerForDelegate(_0);
            var __ret = Internal.InstallUpdateHandler_0(arg0);
            var __ptr0 = __ret;
            return (QAccessible.UpdateHandler)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(QAccessible.UpdateHandler));
        }

        public static void InstallActivationObserver(QAccessible.ActivationObserver _0)
        {
            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            Internal.InstallActivationObserver_0(arg0);
        }

        public static void RemoveActivationObserver(QAccessible.ActivationObserver _0)
        {
            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            Internal.RemoveActivationObserver_0(arg0);
        }

        /// <summary>
        /// <para>Returns the unique ID for the QAccessibleInterface iface.</para>
        /// </summary>
        public static uint UniqueId(QAccessibleInterface iface)
        {
            var arg0 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __ret = Internal.UniqueId_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the QAccessibleInterface belonging to the id.</para>
        /// <para>Returns 0 if the id is invalid.</para>
        /// </summary>
        public static QAccessibleInterface AccessibleInterface(uint uniqueId)
        {
            var arg0 = uniqueId;
            var __ret = Internal.AccessibleInterface_0(arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Call this function to ensure that manually created interfaces are
        /// properly memory managed.</para>
        /// <para>Must only be called exactly once per interface iface. This is
        /// implicitly called when calling queryAccessibleInterface, calling this
        /// function is only required when QAccessibleInterfaces are instantiated with
        /// the &quot;new&quot; operator. This is not recommended, whenever possible
        /// use the default functions and let queryAccessibleInterface() take care of
        /// this.</para>
        /// <para>When it is necessary to reimplement the
        /// QAccessibleInterface::child() function and returning the child after
        /// constructing it, this function needs to be called.</para>
        /// </summary>
        public static uint RegisterAccessibleInterface(QAccessibleInterface iface)
        {
            var arg0 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __ret = Internal.RegisterAccessibleInterface_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Removes the interface belonging to this id from the cache and
        /// deletes it. The id becomes invalid an may be re-used by the cache.</para>
        /// </summary>
        public static void DeleteAccessibleInterface(uint uniqueId)
        {
            var arg0 = uniqueId;
            Internal.DeleteAccessibleInterface_0(arg0);
        }

        /// <summary>
        /// <para>Notifies about a change that might be relevant for accessibility
        /// clients.</para>
        /// <para>event provides details about the change. These include the source
        /// of the change and the nature of the change. The event should contain enough
        /// information give meaningful notifications.</para>
        /// <para>For example, the type ValueChange indicates that the position of
        /// a slider has been changed.</para>
        /// <para>Call this function whenever the state of your accessible object
        /// or one of its sub-elements has been changed either programmatically (e.g.
        /// by calling QLabel::setText()) or by user interaction.</para>
        /// <para>If there are no accessibility tools listening to this event, the
        /// performance penalty for calling this function is small, but if determining
        /// the parameters of the call is expensive you can test
        /// QAccessible::isActive() to avoid unnecessary computation.</para>
        /// </summary>
        public static void UpdateAccessibility(QAccessibleEvent @event)
        {
            var arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            Internal.UpdateAccessibility_0(arg0);
        }

        public static void Cleanup()
        {
            Internal.Cleanup_0();
        }

        public static string QAccessibleRoleString(QAccessible.Role role)
        {
            var arg0 = role;
            var __ret = Internal.QAccessibleRoleString_0(arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string QAccessibleEventString(QAccessible.Event @event)
        {
            var arg0 = _event;
            var __ret = Internal.QAccessibleEventString_0(arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string QAccessibleLocalizedActionDescription(string actionName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(actionName).ToPointer(), actionName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.QAccessibleLocalizedActionDescription_0(new IntPtr(&__ret), arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns true if the platform requested accessibility
        /// information.</para>
        /// <para>This function will return false until a tool such as a screen
        /// reader accessed the accessibility framework. It is still possible to use
        /// QAccessible::queryAccessibleInterface() even if accessibility is not
        /// active. But there will be no notifications sent to the platform.</para>
        /// <para>It is recommended to use this function to prevent expensive
        /// notifications via updateAccessibility() when they are not needed.</para>
        /// </summary>
        public static bool Active
        {
            get
            {
                var __ret = Internal.Active_0();
                return __ret;
            }

            set
            {
                Internal.SetActive_0(value);
            }
        }
    }

    /// <summary>
    /// <para>The QAccessibleInterface class defines an interface that exposes
    /// information about accessible objects.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is part of Accessibility for QWidget
    /// Applications.</para>
    /// <para>Accessibility tools (also called AT Clients), such as screen
    /// readers or braille displays, require high-level information about
    /// accessible objects in an application. Accessible objects provide
    /// specialized input and output methods, making it possible for users to use
    /// accessibility tools with enabled applications (AT Servers).</para>
    /// <para>Every element that the user needs to interact with or react to is
    /// an accessible object, and should provide this information. These are mainly
    /// visual objects, such as widgets and widget elements, but can also be
    /// content, such as sounds.</para>
    /// <para>The AT client uses three basic concepts to acquire information
    /// about any accessible object in an application:</para>
    /// <para></para>
    /// <para>Properties The client can read information about accessible
    /// objects. In some cases the client can also modify these properties; such as
    /// text in a line edit.</para>
    /// <para>Actions The client can invoke actions like pressing a button or
    /// .</para>
    /// <para>Relationships and Navigation The client can traverse from one
    /// accessible object to another, using the relationships between
    /// objects.</para>
    /// <para></para>
    /// <para>The QAccessibleInterface defines the API for these three
    /// concepts.</para>
    /// <para></para>
    /// <para>Relationships and Navigation</para>
    /// <para>The functions childCount() and indexOfChild() return the number
    /// of children of an accessible object and the index a child object has in its
    /// parent. The childAt() function returns a child QAccessibleInterface that is
    /// found at a position. The child does not have to be a direct child. This
    /// allows bypassing intermediate layers when the parent already knows the
    /// top-most child. childAt() is used for hit testing (finding the object under
    /// the mouse).</para>
    /// <para>The relations() function provides information about the relations
    /// an object has to other objects, and parent() and child() allows traversing
    /// from one object to another object.</para>
    /// <para></para>
    /// <para>Properties</para>
    /// <para>The central property of an accessible objects is what role() it
    /// has. Different objects can have the same role, e.g. both the &quot;Add
    /// line&quot; element in a scroll bar and the OK button in a dialog have the
    /// same role, &quot;button&quot;. The role implies what kind of interaction
    /// the user can perform with the user interface element.</para>
    /// <para>An object's state() property is a combination of different state
    /// flags and can describe both how the object's state differs from a
    /// &quot;normal&quot; state, e.g. it might be unavailable, and also how it
    /// behaves, e.g. it might be selectable.</para>
    /// <para>The text() property provides textual information about the
    /// object. An object usually has a name, but can provide extended information
    /// such as a description, help text, or information about any keyboard
    /// accelerators it provides. Some objects allow changing the text() property
    /// through the setText() function, but this information is in most cases
    /// read-only.</para>
    /// <para>The rect() property provides information about the geometry of an
    /// accessible object. This information is usually only available for visual
    /// objects.</para>
    /// <para></para>
    /// <para>Interfaces</para>
    /// <para>To enable the user to interact with an accessible object the
    /// object must implement QAccessibleActionInterface in addition to
    /// QAccessibleInterface. Objects that support selections can define actions to
    /// change the selection.</para>
    /// <para>There are several other interfaces that should be implemented as
    /// required. QAccessibleTextInterface should be used for bigger texts edits
    /// such as document views. This interface should not be implemented for
    /// labels/single line edits.</para>
    /// <para>For sliders, scrollbars and other numerical value selectors
    /// QAccessibleValueInterface should be implemented.</para>
    /// <para>Lists, tables and trees should implement
    /// QAccessibleTableInterface.</para>
    /// <para></para>
    /// <para>See also QAccessible, QAccessibleActionInterface,
    /// QAccessibleTextInterface, QAccessibleValueInterface, and
    /// QAccessibleTableInterface.</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QAccessibleInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QAccessibleInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QAccessibleInterface10focusChildEv")]
            internal static extern global::System.IntPtr FocusChild_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QAccessibleInterface12virtual_hookEiPv")]
            internal static extern void Virtual_hook_0(global::System.IntPtr instance, int id, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QAccessibleInterface6windowEv")]
            internal static extern global::System.IntPtr Window_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QAccessibleInterface15foregroundColorEv")]
            internal static extern void ForegroundColor_0(global::System.IntPtr _return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QAccessibleInterface15backgroundColorEv")]
            internal static extern void BackgroundColor_0(global::System.IntPtr _return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleInterface(QAccessibleInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the object that has the keyboard focus.</para>
        /// <para>The object returned can be any descendant, including
        /// itself.</para>
        /// </summary>
        public virtual QAccessibleInterface FocusChild()
        {
            var __ret = Internal.FocusChild_0(__Instance);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the QAccessibleInterface of a child that contains the
        /// screen coordinates (x, y). If there are no children at this position this
        /// function returns 0. The returned accessible must be a child, but not
        /// necessarily a direct child.</para>
        /// <para>This function is only relyable for visible objects (invisible
        /// object might not be laid out correctly).</para>
        /// <para>All visual objects provide this information.</para>
        /// <para>A default implementation is provided for objects inheriting
        /// QAccessibleObject. This will iterate over all children. If the widget
        /// manages its children (e.g. a table) it will be more efficient to write a
        /// specialized implementation.</para>
        /// <para>See also rect().</para>
        /// </summary>
        public abstract QAccessibleInterface ChildAt(int x, int y);

        /// <summary>
        /// <para>Returns the accessible child with index index. 0-based index. The
        /// number of children of an object can be checked with childCount.</para>
        /// <para>Returns 0 when asking for an invalid child (e.g. when the child
        /// became invalid in the meantime).</para>
        /// <para>See also childCount() and parent().</para>
        /// </summary>
        public abstract QAccessibleInterface Child(int index);

        /// <summary>
        /// <para>Returns the 0-based index of the object child in this object's
        /// children list, or -1 if child is not a child of this object.</para>
        /// <para>All objects provide this information about their children.</para>
        /// <para>See also childCount().</para>
        /// </summary>
        public abstract int IndexOfChild(QAccessibleInterface child);

        /// <summary>
        /// <para>Returns the value of the text property t of the object.</para>
        /// <para>The QAccessible::Name is a string used by clients to identify,
        /// find, or announce an accessible object for the user. All objects must have
        /// a name that is unique within their container. The name can be used
        /// differently by clients, so the name should both give a short description of
        /// the object and be unique.</para>
        /// <para>An accessible object's QAccessible::Description provides textual
        /// information about an object's visual appearance. The description is
        /// primarily used to provide greater context for vision-impaired users, but is
        /// also used for context searching or other applications. Not all objects have
        /// a description. An &quot;OK&quot; button would not need a description, but a
        /// tool button that shows a picture of a smiley would.</para>
        /// <para>The QAccessible::Value of an accessible object represents visual
        /// information contained by the object, e.g. the text in a line edit. Usually,
        /// the value can be modified by the user. Not all objects have a value, e.g.
        /// static text labels don't, and some objects have a state that already is the
        /// value, e.g. toggle buttons.</para>
        /// <para>The QAccessible::Help text provides information about the
        /// function and usage of an accessible object. Not all objects provide this
        /// information.</para>
        /// <para>The QAccessible::Accelerator is a keyboard shortcut that
        /// activates the object's default action. A keyboard shortcut is the
        /// underlined character in the text of a menu, menu item or widget, and is
        /// either the character itself, or a combination of this character and a
        /// modifier key like Alt, Ctrl or Shift. Command controls like tool buttons
        /// also have shortcut keys and usually display them in their tooltip.</para>
        /// <para>All objects provide a string for QAccessible::Name.</para>
        /// <para>See also setText(), role(), and state().</para>
        /// </summary>
        public abstract string Text(QAccessible.Text t);

        /// <summary>
        /// <para>Sets the text property t of the object to text.</para>
        /// <para>Note that the text properties of most objects are read-only so
        /// calling this function might have no effect.</para>
        /// <para>See also text().</para>
        /// </summary>
        public abstract void SetText(QAccessible.Text t, string text);

        public virtual void Virtual_hook(int id, global::System.IntPtr data)
        {
            var arg1 = data;
            Internal.Virtual_hook_0(__Instance, id, arg1);
        }

        /// <summary>
        /// <para>Returns true if all the data necessary to use this interface
        /// implementation is valid (e.g. all pointers are non-null); otherwise returns
        /// false.</para>
        /// <para>See also object().</para>
        /// </summary>
        public abstract bool IsValid
        {
            get;
        }

        /// <summary>
        /// <para>Returns the window associated with the underlying object. For
        /// instance, QAccessibleWidget reimplements this and returns the
        /// windowHandle() of the QWidget.</para>
        /// <para>It is used on some platforms to be able to notify the AT client
        /// about state changes. The backend will traverse up all ancestors until it
        /// finds a window. (This means that at least one interface among the ancestors
        /// should return a valid QWindow pointer).</para>
        /// <para>The default implementation returns 0.</para>
        /// </summary>
        public virtual QWindow Window
        {
            get
            {
                var __ret = Internal.Window_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the QAccessibleInterface of the parent in the accessible
        /// object hierarchy.</para>
        /// <para>Returns 0 if no parent exists (e.g. for the top level application
        /// object).</para>
        /// <para>See also child().</para>
        /// </summary>
        public abstract QAccessibleInterface Parent
        {
            get;
        }

        /// <summary>
        /// <para>Returns the number of children that belong to this object. A
        /// child can provide accessibility information on its own (e.g. a child
        /// widget), or be a sub-element of this accessible object.</para>
        /// <para>All objects provide this information.</para>
        /// <para>See also indexOfChild().</para>
        /// </summary>
        public abstract int ChildCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the role of the object. The role of an object is usually
        /// static.</para>
        /// <para>All accessible objects have a role.</para>
        /// <para>See also text() and state().</para>
        /// </summary>
        public abstract QAccessible.Role Role
        {
            get;
        }

        /// <summary>
        /// <para>Returns the current state of the object. The returned value is a
        /// combination of the flags in the QAccessible::StateFlag enumeration.</para>
        /// <para>All accessible objects have a state.</para>
        /// <para>See also text() and role().</para>
        /// </summary>
        public abstract QAccessible.State State
        {
            get;
        }

        /// <summary>
        /// <para>Returns the accessible's foreground color if applicable or an
        /// invalid QColor.</para>
        /// <para>See also backgroundColor().</para>
        /// </summary>
        public virtual QColor ForegroundColor
        {
            get
            {
                var __ret = new QtGui.QColor.Internal();
                Internal.ForegroundColor_0(new IntPtr(&__ret), __Instance);
                return QColor.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the accessible's background color if applicable or an
        /// invalid QColor.</para>
        /// <para>See also foregroundColor().</para>
        /// </summary>
        public virtual QColor BackgroundColor
        {
            get
            {
                var __ret = new QtGui.QColor.Internal();
                Internal.BackgroundColor_0(new IntPtr(&__ret), __Instance);
                return QColor.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // virtual ~QAccessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            target.Dispose();
        }

        // bool isValid()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _IsValid_0Delegate(global::System.IntPtr instance);
        private static _IsValid_0Delegate _IsValid_0DelegateInstance;

        private static bool _IsValid_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.IsValid;
            return _ret;
        }

        // QWindow *window()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Window_0Delegate(global::System.IntPtr instance);
        private static _Window_0Delegate _Window_0DelegateInstance;

        private static global::System.IntPtr _Window_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.Window;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *focusChild()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _FocusChild_0Delegate(global::System.IntPtr instance);
        private static _FocusChild_0Delegate _FocusChild_0DelegateInstance;

        private static global::System.IntPtr _FocusChild_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.FocusChild();
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *childAt(int x, int y)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _ChildAt_0Delegate(global::System.IntPtr instance, int x, int y);
        private static _ChildAt_0Delegate _ChildAt_0DelegateInstance;

        private static global::System.IntPtr _ChildAt_0DelegateHook(global::System.IntPtr instance, int x, int y)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.ChildAt(x, y);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *parent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Parent_0Delegate(global::System.IntPtr instance);
        private static _Parent_0Delegate _Parent_0DelegateInstance;

        private static global::System.IntPtr _Parent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.Parent;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *child(int index)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Child_0Delegate(global::System.IntPtr instance, int index);
        private static _Child_0Delegate _Child_0DelegateInstance;

        private static global::System.IntPtr _Child_0DelegateHook(global::System.IntPtr instance, int index)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.Child(index);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int childCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ChildCount_0Delegate(global::System.IntPtr instance);
        private static _ChildCount_0Delegate _ChildCount_0DelegateInstance;

        private static int _ChildCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.ChildCount;
            return _ret;
        }

        // int indexOfChild(const QAccessibleInterface *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _IndexOfChild_0Delegate(global::System.IntPtr instance, global::System.IntPtr child);
        private static _IndexOfChild_0Delegate _IndexOfChild_0DelegateInstance;

        private static int _IndexOfChild_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr child)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.IndexOfChild((child == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(child));
            return _ret;
        }

        // QString text(QAccessible::Text t)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _Text_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, QAccessible.Text t);
        private static _Text_0Delegate _Text_0DelegateInstance;

        private static QString.Internal _Text_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, QAccessible.Text t)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.Text(t);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // void setText(QAccessible::Text t, const QString &text)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetText_0Delegate(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text);
        private static _SetText_0Delegate _SetText_0DelegateInstance;

        private static void _SetText_0DelegateHook(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            target.SetText(t, Marshal.PtrToStringUni(new IntPtr(new QString(text).Utf16)));
        }

        // QAccessible::Role role()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QAccessible.Role _Role_0Delegate(global::System.IntPtr instance);
        private static _Role_0Delegate _Role_0DelegateInstance;

        private static QAccessible.Role _Role_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.Role;
            return _ret;
        }

        // QAccessible::State state()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QAccessible.State.Internal _State_0Delegate(global::System.IntPtr instance);
        private static _State_0Delegate _State_0DelegateInstance;

        private static QAccessible.State.Internal _State_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.State;
            return ReferenceEquals(_ret, null) ? new QAccessible.State.Internal() : *(QAccessible.State.Internal*) (_ret.__Instance);
        }

        // QColor foregroundColor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QColor.Internal _ForegroundColor_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _ForegroundColor_0Delegate _ForegroundColor_0DelegateInstance;

        private static QColor.Internal _ForegroundColor_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.ForegroundColor;
            return ReferenceEquals(_ret, null) ? new QColor.Internal() : *(QColor.Internal*) (_ret.__Instance);
        }

        // QColor backgroundColor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QColor.Internal _BackgroundColor_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _BackgroundColor_0Delegate _BackgroundColor_0DelegateInstance;

        private static QColor.Internal _BackgroundColor_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            var _ret = target.BackgroundColor;
            return ReferenceEquals(_ret, null) ? new QColor.Internal() : *(QColor.Internal*) (_ret.__Instance);
        }

        // void virtual_hook(int id, void *data)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Virtual_hook_0Delegate(global::System.IntPtr instance, int id, global::System.IntPtr data);
        private static _Virtual_hook_0Delegate _Virtual_hook_0DelegateInstance;

        private static void _Virtual_hook_0DelegateHook(global::System.IntPtr instance, int id, global::System.IntPtr data)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleInterface) _References[instance].Target;
            target.Virtual_hook(id, data);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[16];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsValid_0DelegateInstance += _IsValid_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsValid_0DelegateInstance).ToPointer();
                _Window_0DelegateInstance += _Window_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Window_0DelegateInstance).ToPointer();
                _FocusChild_0DelegateInstance += _FocusChild_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_FocusChild_0DelegateInstance).ToPointer();
                _ChildAt_0DelegateInstance += _ChildAt_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ChildAt_0DelegateInstance).ToPointer();
                _Parent_0DelegateInstance += _Parent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Parent_0DelegateInstance).ToPointer();
                _Child_0DelegateInstance += _Child_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_Child_0DelegateInstance).ToPointer();
                _ChildCount_0DelegateInstance += _ChildCount_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_ChildCount_0DelegateInstance).ToPointer();
                _IndexOfChild_0DelegateInstance += _IndexOfChild_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_IndexOfChild_0DelegateInstance).ToPointer();
                _Text_0DelegateInstance += _Text_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_Text_0DelegateInstance).ToPointer();
                _SetText_0DelegateInstance += _SetText_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetText_0DelegateInstance).ToPointer();
                _Role_0DelegateInstance += _Role_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_Role_0DelegateInstance).ToPointer();
                _State_0DelegateInstance += _State_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_State_0DelegateInstance).ToPointer();
                _ForegroundColor_0DelegateInstance += _ForegroundColor_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_ForegroundColor_0DelegateInstance).ToPointer();
                _BackgroundColor_0DelegateInstance += _BackgroundColor_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_BackgroundColor_0DelegateInstance).ToPointer();
                _Virtual_hook_0DelegateInstance += _Virtual_hook_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_Virtual_hook_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(20 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = _Thunks[1];
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = _Thunks[3];
                *(void**)(vfptr0 + 28) = _Thunks[4];
                *(void**)(vfptr0 + 32) = _Thunks[5];
                *(void**)(vfptr0 + 36) = _Thunks[6];
                *(void**)(vfptr0 + 40) = _Thunks[7];
                *(void**)(vfptr0 + 44) = _Thunks[8];
                *(void**)(vfptr0 + 48) = _Thunks[9];
                *(void**)(vfptr0 + 52) = _Thunks[10];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[11];
                *(void**)(vfptr0 + 64) = _Thunks[12];
                *(void**)(vfptr0 + 68) = _Thunks[13];
                *(void**)(vfptr0 + 72) = _Thunks[14];
                *(void**)(vfptr0 + 76) = _Thunks[15];
                *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTextInterface class implements support for text
    /// handling.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This interface corresponds to the IAccessibleText interface. It
    /// should be implemented for widgets that display more text than a plain
    /// label. Labels should be represented by only QAccessibleInterface and return
    /// their text as name (QAccessibleInterface::text() with QAccessible::Name as
    /// type). The QAccessibleTextInterface is typically for text that a screen
    /// reader might want to read line by line, and for widgets that support text
    /// selection and input. This interface is, for example, implemented for
    /// QLineEdit.</para>
    /// <para>IAccessible2 Specification</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleTextInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QAccessibleTextInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QAccessibleTextInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QAccessibleTextInterface16textBeforeOffsetEiN11QAccessible16TextBoundaryTypeEPiS2_")]
            internal static extern void TextBeforeOffset_0(global::System.IntPtr _return, global::System.IntPtr instance, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QAccessibleTextInterface15textAfterOffsetEiN11QAccessible16TextBoundaryTypeEPiS2_")]
            internal static extern void TextAfterOffset_0(global::System.IntPtr _return, global::System.IntPtr instance, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QAccessibleTextInterface12textAtOffsetEiN11QAccessible16TextBoundaryTypeEPiS2_")]
            internal static extern void TextAtOffset_0(global::System.IntPtr _return, global::System.IntPtr instance, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleTextInterface(QAccessibleTextInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns a selection. The size of the selection is returned in
        /// startOffset and endOffset. If there is no selection both startOffset and
        /// endOffset are 0.</para>
        /// <para>The accessibility APIs support multiple selections. For most
        /// widgets though, only one selection is supported with selectionIndex equal
        /// to 0.</para>
        /// <para>See also setSelection().</para>
        /// </summary>
        public abstract void Selection(int selectionIndex, int* startOffset, int* endOffset);

        /// <summary>
        /// <para>Select the text from startOffset to endOffset. The startOffset is
        /// the first character that will be selected. The endOffset is the first
        /// character that will not be selected.</para>
        /// <para>When the object supports multiple selections (e.g. in a word
        /// processor), this adds a new selection, otherwise it replaces the previous
        /// selection.</para>
        /// <para>The selection will be endOffset - startOffset characters
        /// long.</para>
        /// </summary>
        public abstract void AddSelection(int startOffset, int endOffset);

        /// <summary>
        /// <para>Clears the selection with index selectionIndex.</para>
        /// </summary>
        public abstract void RemoveSelection(int selectionIndex);

        /// <summary>
        /// <para>Set the selection selectionIndex to the range from startOffset to
        /// endOffset.</para>
        /// <para>See also selection(), addSelection(), and
        /// removeSelection().</para>
        /// </summary>
        public abstract void SetSelection(int selectionIndex, int startOffset, int endOffset);

        /// <summary>
        /// <para>Returns the text from startOffset to endOffset. The startOffset
        /// is the first character that will be returned. The endOffset is the first
        /// character that will not be returned.</para>
        /// </summary>
        public abstract string Text(int startOffset, int endOffset);

        /// <summary>
        /// <para>Returns the text item of type boundaryType that is close to
        /// offset offset and sets startOffset and endOffset values to the start and
        /// end positions of that item; returns an empty string if there is no such an
        /// item. Sets startOffset and endOffset values to -1 on error.</para>
        /// <para>This default implementation is provided for small text edits. A
        /// word processor or text editor should provide their own efficient
        /// implementations. This function makes no distinction between paragraphs and
        /// lines.</para>
        /// <para>Note: this function can not take the cursor position into
        /// account. By convention an offset of -2 means that this function should use
        /// the cursor position as offset. Thus an offset of -2 must be converted to
        /// the cursor position before calling this function. An offset of -1 is used
        /// for the text length and custom implementations of this function have to
        /// return the result as if the length was passed in as offset.</para>
        /// </summary>
        public virtual string TextBeforeOffset(int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset)
        {
            var arg1 = boundaryType;
            var arg2 = startOffset;
            var arg3 = endOffset;
            var __ret = new QtCore.QString.Internal();
            Internal.TextBeforeOffset_0(new IntPtr(&__ret), __Instance, offset, arg1, arg2, arg3);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the text item of type boundaryType that is right after
        /// offset offset and sets startOffset and endOffset values to the start and
        /// end positions of that item; returns an empty string if there is no such an
        /// item. Sets startOffset and endOffset values to -1 on error.</para>
        /// <para>This default implementation is provided for small text edits. A
        /// word processor or text editor should provide their own efficient
        /// implementations. This function makes no distinction between paragraphs and
        /// lines.</para>
        /// <para>Note: this function can not take the cursor position into
        /// account. By convention an offset of -2 means that this function should use
        /// the cursor position as offset. Thus an offset of -2 must be converted to
        /// the cursor position before calling this function. An offset of -1 is used
        /// for the text length and custom implementations of this function have to
        /// return the result as if the length was passed in as offset.</para>
        /// <para></para>
        /// <para>[virtual] QString QAccessibleTextInterface::textAtOffset(int
        /// offset, QAccessible::TextBoundaryType boundaryType, int * startOffset, int
        /// * endOffset) const</para>
        /// <para>Returns the text item of type boundaryType at offset offset and
        /// sets startOffset and endOffset values to the start and end positions of
        /// that item; returns an empty string if there is no such an item. Sets
        /// startOffset and endOffset values to -1 on error.</para>
        /// <para>This default implementation is provided for small text edits. A
        /// word processor or text editor should provide their own efficient
        /// implementations. This function makes no distinction between paragraphs and
        /// lines.</para>
        /// <para>Note: this function can not take the cursor position into
        /// account. By convention an offset of -2 means that this function should use
        /// the cursor position as offset. Thus an offset of -2 must be converted to
        /// the cursor position before calling this function. An offset of -1 is used
        /// for the text length and custom implementations of this function have to
        /// return the result as if the length was passed in as offset.</para>
        /// <para></para>
        /// <para>[virtual] QString QAccessibleTextInterface::textBeforeOffset(int
        /// offset, QAccessible::TextBoundaryType boundaryType, int * startOffset, int
        /// * endOffset) const</para>
        /// <para>Returns the text item of type boundaryType that is close to
        /// offset offset and sets startOffset and endOffset values to the start and
        /// end positions of that item; returns an empty string if there is no such an
        /// item. Sets startOffset and endOffset values to -1 on error.</para>
        /// <para>This default implementation is provided for small text edits. A
        /// word processor or text editor should provide their own efficient
        /// implementations. This function makes no distinction between paragraphs and
        /// lines.</para>
        /// <para>Note: this function can not take the cursor position into
        /// account. By convention an offset of -2 means that this function should use
        /// the cursor position as offset. Thus an offset of -2 must be converted to
        /// the cursor position before calling this function. An offset of -1 is used
        /// for the text length and custom implementations of this function have to
        /// return the result as if the length was passed in as offset.</para>
        /// </summary>
        public virtual string TextAfterOffset(int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset)
        {
            var arg1 = boundaryType;
            var arg2 = startOffset;
            var arg3 = endOffset;
            var __ret = new QtCore.QString.Internal();
            Internal.TextAfterOffset_0(new IntPtr(&__ret), __Instance, offset, arg1, arg2, arg3);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the text item of type boundaryType at offset offset and
        /// sets startOffset and endOffset values to the start and end positions of
        /// that item; returns an empty string if there is no such an item. Sets
        /// startOffset and endOffset values to -1 on error.</para>
        /// <para>This default implementation is provided for small text edits. A
        /// word processor or text editor should provide their own efficient
        /// implementations. This function makes no distinction between paragraphs and
        /// lines.</para>
        /// <para>Note: this function can not take the cursor position into
        /// account. By convention an offset of -2 means that this function should use
        /// the cursor position as offset. Thus an offset of -2 must be converted to
        /// the cursor position before calling this function. An offset of -1 is used
        /// for the text length and custom implementations of this function have to
        /// return the result as if the length was passed in as offset.</para>
        /// <para></para>
        /// <para>[virtual] QString QAccessibleTextInterface::textBeforeOffset(int
        /// offset, QAccessible::TextBoundaryType boundaryType, int * startOffset, int
        /// * endOffset) const</para>
        /// <para>Returns the text item of type boundaryType that is close to
        /// offset offset and sets startOffset and endOffset values to the start and
        /// end positions of that item; returns an empty string if there is no such an
        /// item. Sets startOffset and endOffset values to -1 on error.</para>
        /// <para>This default implementation is provided for small text edits. A
        /// word processor or text editor should provide their own efficient
        /// implementations. This function makes no distinction between paragraphs and
        /// lines.</para>
        /// <para>Note: this function can not take the cursor position into
        /// account. By convention an offset of -2 means that this function should use
        /// the cursor position as offset. Thus an offset of -2 must be converted to
        /// the cursor position before calling this function. An offset of -1 is used
        /// for the text length and custom implementations of this function have to
        /// return the result as if the length was passed in as offset.</para>
        /// </summary>
        public virtual string TextAtOffset(int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset)
        {
            var arg1 = boundaryType;
            var arg2 = startOffset;
            var arg3 = endOffset;
            var __ret = new QtCore.QString.Internal();
            Internal.TextAtOffset_0(new IntPtr(&__ret), __Instance, offset, arg1, arg2, arg3);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Ensures that the text between startIndex and endIndex is
        /// visible.</para>
        /// </summary>
        public abstract void ScrollToSubstring(int startIndex, int endIndex);

        /// <summary>
        /// <para>Returns the text attributes at the position offset. In addition
        /// the range of the attributes is returned in startOffset and
        /// endOffset.</para>
        /// </summary>
        public abstract string Attributes(int offset, int* startOffset, int* endOffset);

        /// <summary>
        /// <para>Returns the current cursor position.</para>
        /// <para>See also setCursorPosition().</para>
        /// <para></para>
        /// <para>Moves the cursor to position.</para>
        /// <para>See also cursorPosition().</para>
        /// </summary>
        public abstract int CursorPosition
        {
            get;

            set;
        }

        /// <summary>
        /// <para>Returns the number of selections in this text.</para>
        /// </summary>
        public abstract int SelectionCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the length of the text (total size including
        /// spaces).</para>
        /// </summary>
        public abstract int CharacterCount
        {
            get;
        }

        #region Virtual table interop

        // void selection(int selectionIndex, int *startOffset, int *endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Selection_0Delegate(global::System.IntPtr instance, int selectionIndex, int* startOffset, int* endOffset);
        private static _Selection_0Delegate _Selection_0DelegateInstance;

        private static void _Selection_0DelegateHook(global::System.IntPtr instance, int selectionIndex, int* startOffset, int* endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            target.Selection(selectionIndex, startOffset, endOffset);
        }

        // int selectionCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _SelectionCount_0Delegate(global::System.IntPtr instance);
        private static _SelectionCount_0Delegate _SelectionCount_0DelegateInstance;

        private static int _SelectionCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.SelectionCount;
            return _ret;
        }

        // void addSelection(int startOffset, int endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _AddSelection_0Delegate(global::System.IntPtr instance, int startOffset, int endOffset);
        private static _AddSelection_0Delegate _AddSelection_0DelegateInstance;

        private static void _AddSelection_0DelegateHook(global::System.IntPtr instance, int startOffset, int endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            target.AddSelection(startOffset, endOffset);
        }

        // void removeSelection(int selectionIndex)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _RemoveSelection_0Delegate(global::System.IntPtr instance, int selectionIndex);
        private static _RemoveSelection_0Delegate _RemoveSelection_0DelegateInstance;

        private static void _RemoveSelection_0DelegateHook(global::System.IntPtr instance, int selectionIndex)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            target.RemoveSelection(selectionIndex);
        }

        // void setSelection(int selectionIndex, int startOffset, int endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetSelection_0Delegate(global::System.IntPtr instance, int selectionIndex, int startOffset, int endOffset);
        private static _SetSelection_0Delegate _SetSelection_0DelegateInstance;

        private static void _SetSelection_0DelegateHook(global::System.IntPtr instance, int selectionIndex, int startOffset, int endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            target.SetSelection(selectionIndex, startOffset, endOffset);
        }

        // int cursorPosition()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _CursorPosition_0Delegate(global::System.IntPtr instance);
        private static _CursorPosition_0Delegate _CursorPosition_0DelegateInstance;

        private static int _CursorPosition_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.CursorPosition;
            return _ret;
        }

        // void setCursorPosition(int position)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetCursorPosition_0Delegate(global::System.IntPtr instance, int position);
        private static _SetCursorPosition_0Delegate _SetCursorPosition_0DelegateInstance;

        private static void _SetCursorPosition_0DelegateHook(global::System.IntPtr instance, int position)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            target.CursorPosition = position;
        }

        // QString text(int startOffset, int endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _Text_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int startOffset, int endOffset);
        private static _Text_0Delegate _Text_0DelegateInstance;

        private static QString.Internal _Text_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int startOffset, int endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.Text(startOffset, endOffset);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // QString textBeforeOffset(int offset, QAccessible::TextBoundaryType boundaryType, int *startOffset, int *endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _TextBeforeOffset_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset);
        private static _TextBeforeOffset_0Delegate _TextBeforeOffset_0DelegateInstance;

        private static QString.Internal _TextBeforeOffset_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.TextBeforeOffset(offset, boundaryType, startOffset, endOffset);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // QString textAfterOffset(int offset, QAccessible::TextBoundaryType boundaryType, int *startOffset, int *endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _TextAfterOffset_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset);
        private static _TextAfterOffset_0Delegate _TextAfterOffset_0DelegateInstance;

        private static QString.Internal _TextAfterOffset_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.TextAfterOffset(offset, boundaryType, startOffset, endOffset);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // QString textAtOffset(int offset, QAccessible::TextBoundaryType boundaryType, int *startOffset, int *endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _TextAtOffset_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset);
        private static _TextAtOffset_0Delegate _TextAtOffset_0DelegateInstance;

        private static QString.Internal _TextAtOffset_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int offset, QAccessible.TextBoundaryType boundaryType, int* startOffset, int* endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.TextAtOffset(offset, boundaryType, startOffset, endOffset);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // int characterCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _CharacterCount_0Delegate(global::System.IntPtr instance);
        private static _CharacterCount_0Delegate _CharacterCount_0DelegateInstance;

        private static int _CharacterCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.CharacterCount;
            return _ret;
        }

        // void scrollToSubstring(int startIndex, int endIndex)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _ScrollToSubstring_0Delegate(global::System.IntPtr instance, int startIndex, int endIndex);
        private static _ScrollToSubstring_0Delegate _ScrollToSubstring_0DelegateInstance;

        private static void _ScrollToSubstring_0DelegateHook(global::System.IntPtr instance, int startIndex, int endIndex)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            target.ScrollToSubstring(startIndex, endIndex);
        }

        // QString attributes(int offset, int *startOffset, int *endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _Attributes_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int offset, int* startOffset, int* endOffset);
        private static _Attributes_0Delegate _Attributes_0DelegateInstance;

        private static QString.Internal _Attributes_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int offset, int* startOffset, int* endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInterface) _References[instance].Target;
            var _ret = target.Attributes(offset, startOffset, endOffset);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[14];
                _Selection_0DelegateInstance += _Selection_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Selection_0DelegateInstance).ToPointer();
                _SelectionCount_0DelegateInstance += _SelectionCount_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SelectionCount_0DelegateInstance).ToPointer();
                _AddSelection_0DelegateInstance += _AddSelection_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AddSelection_0DelegateInstance).ToPointer();
                _RemoveSelection_0DelegateInstance += _RemoveSelection_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_RemoveSelection_0DelegateInstance).ToPointer();
                _SetSelection_0DelegateInstance += _SetSelection_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetSelection_0DelegateInstance).ToPointer();
                _CursorPosition_0DelegateInstance += _CursorPosition_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_CursorPosition_0DelegateInstance).ToPointer();
                _SetCursorPosition_0DelegateInstance += _SetCursorPosition_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetCursorPosition_0DelegateInstance).ToPointer();
                _Text_0DelegateInstance += _Text_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_Text_0DelegateInstance).ToPointer();
                _TextBeforeOffset_0DelegateInstance += _TextBeforeOffset_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_TextBeforeOffset_0DelegateInstance).ToPointer();
                _TextAfterOffset_0DelegateInstance += _TextAfterOffset_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_TextAfterOffset_0DelegateInstance).ToPointer();
                _TextAtOffset_0DelegateInstance += _TextAtOffset_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_TextAtOffset_0DelegateInstance).ToPointer();
                _CharacterCount_0DelegateInstance += _CharacterCount_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_CharacterCount_0DelegateInstance).ToPointer();
                _ScrollToSubstring_0DelegateInstance += _ScrollToSubstring_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_ScrollToSubstring_0DelegateInstance).ToPointer();
                _Attributes_0DelegateInstance += _Attributes_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_Attributes_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(17 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = _Thunks[4];
                *(void**)(vfptr0 + 28) = _Thunks[5];
                *(void**)(vfptr0 + 32) = _Thunks[6];
                *(void**)(vfptr0 + 36) = _Thunks[7];
                *(void**)(vfptr0 + 40) = _Thunks[8];
                *(void**)(vfptr0 + 44) = _Thunks[9];
                *(void**)(vfptr0 + 48) = _Thunks[10];
                *(void**)(vfptr0 + 52) = _Thunks[11];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                *(void**)(vfptr0 + 64) = _Thunks[12];
                *(void**)(vfptr0 + 68) = _Thunks[13];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleEditableTextInterface class implements support for
    /// objects with editable text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>When implementing this interface you will almost certainly also
    /// want to implement QAccessibleTextInterface.</para>
    /// <para>IAccessible2 Specification</para>
    /// <para></para>
    /// <para>See also QAccessibleInterface.</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleEditableTextInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QAccessibleEditableTextInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QAccessibleEditableTextInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleEditableTextInterface(QAccessibleEditableTextInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Deletes the text from startOffset to endOffset.</para>
        /// </summary>
        public abstract void DeleteText(int startOffset, int endOffset);

        /// <summary>
        /// <para>Inserts text at position offset.</para>
        /// </summary>
        public abstract void InsertText(int offset, string text);

        /// <summary>
        /// <para>Removes the text from startOffset to endOffset and instead
        /// inserts text.</para>
        /// </summary>
        public abstract void ReplaceText(int startOffset, int endOffset, string text);

        #region Virtual table interop

        // void deleteText(int startOffset, int endOffset)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _DeleteText_0Delegate(global::System.IntPtr instance, int startOffset, int endOffset);
        private static _DeleteText_0Delegate _DeleteText_0DelegateInstance;

        private static void _DeleteText_0DelegateHook(global::System.IntPtr instance, int startOffset, int endOffset)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleEditableTextInterface) _References[instance].Target;
            target.DeleteText(startOffset, endOffset);
        }

        // void insertText(int offset, const QString &text)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InsertText_0Delegate(global::System.IntPtr instance, int offset, global::System.IntPtr text);
        private static _InsertText_0Delegate _InsertText_0DelegateInstance;

        private static void _InsertText_0DelegateHook(global::System.IntPtr instance, int offset, global::System.IntPtr text)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleEditableTextInterface) _References[instance].Target;
            target.InsertText(offset, Marshal.PtrToStringUni(new IntPtr(new QString(text).Utf16)));
        }

        // void replaceText(int startOffset, int endOffset, const QString &text)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _ReplaceText_0Delegate(global::System.IntPtr instance, int startOffset, int endOffset, global::System.IntPtr text);
        private static _ReplaceText_0Delegate _ReplaceText_0DelegateInstance;

        private static void _ReplaceText_0DelegateHook(global::System.IntPtr instance, int startOffset, int endOffset, global::System.IntPtr text)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleEditableTextInterface) _References[instance].Target;
            target.ReplaceText(startOffset, endOffset, Marshal.PtrToStringUni(new IntPtr(new QString(text).Utf16)));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _DeleteText_0DelegateInstance += _DeleteText_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DeleteText_0DelegateInstance).ToPointer();
                _InsertText_0DelegateInstance += _InsertText_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_InsertText_0DelegateInstance).ToPointer();
                _ReplaceText_0DelegateInstance += _ReplaceText_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ReplaceText_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleValueInterface class implements support for
    /// objects that manipulate a value.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This interface should be implemented by accessible objects that
    /// represent a value. Examples are spinner, slider, dial and scroll
    /// bar.</para>
    /// <para>Instead of forcing the user to deal with the individual parts of
    /// the widgets, this interface gives an easier approach to the kind of widget
    /// it represents.</para>
    /// <para>Usually this interface is implemented by classes that also
    /// implement QAccessibleInterface.</para>
    /// <para>IAccessible2 Specification</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleValueInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN25QAccessibleValueInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN25QAccessibleValueInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleValueInterface(QAccessibleValueInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    /// <summary>
    /// <para>The QAccessibleTableCellInterface class implements support for
    /// the IAccessibleTable2 Cell interface.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>IAccessible2 Specification</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleTableCellInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN29QAccessibleTableCellInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN29QAccessibleTableCellInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleTableCellInterface(QAccessibleTableCellInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns a boolean value indicating whether this cell is
        /// selected.</para>
        /// </summary>
        public abstract bool IsSelected
        {
            get;
        }

        /// <summary>
        /// <para>Returns the column headers as an array of cell
        /// accessibles.</para>
        /// </summary>
        public abstract System.Collections.Generic.IList<QAccessibleInterface> ColumnHeaderCells
        {
            get;
        }

        /// <summary>
        /// <para>Returns the row headers as an array of cell accessibles.</para>
        /// </summary>
        public abstract System.Collections.Generic.IList<QAccessibleInterface> RowHeaderCells
        {
            get;
        }

        /// <summary>
        /// <para>Translates this cell accessible into the corresponding column
        /// index.</para>
        /// </summary>
        public abstract int ColumnIndex
        {
            get;
        }

        /// <summary>
        /// <para>Translates this cell accessible into the corresponding row
        /// index.</para>
        /// </summary>
        public abstract int RowIndex
        {
            get;
        }

        /// <summary>
        /// <para>Returns the number of columns occupied by this cell
        /// accessible.</para>
        /// </summary>
        public abstract int ColumnExtent
        {
            get;
        }

        /// <summary>
        /// <para>Returns the number of rows occupied by this cell
        /// accessible.</para>
        /// </summary>
        public abstract int RowExtent
        {
            get;
        }

        /// <summary>
        /// <para>Returns the QAccessibleInterface of the table containing this
        /// cell.</para>
        /// </summary>
        public abstract QAccessibleInterface Table
        {
            get;
        }

        #region Virtual table interop

        // bool isSelected()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _IsSelected_0Delegate(global::System.IntPtr instance);
        private static _IsSelected_0Delegate _IsSelected_0DelegateInstance;

        private static bool _IsSelected_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.IsSelected;
            return _ret;
        }

        // QList<QAccessibleInterface*> columnHeaderCells()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QList.Internal _ColumnHeaderCells_0Delegate(global::System.IntPtr instance);
        private static _ColumnHeaderCells_0Delegate _ColumnHeaderCells_0DelegateInstance;

        private static QList.Internal _ColumnHeaderCells_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.ColumnHeaderCells;
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = _ret.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = _ret.Count;
            fixed (void** __v = new void*[_ret.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < _ret.Count; i++)
            {
                __qlistDataData->array[i] = (void*) _ret[i].__Instance;
            }
            return __qList;
        }

        // QList<QAccessibleInterface*> rowHeaderCells()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QList.Internal _RowHeaderCells_0Delegate(global::System.IntPtr instance);
        private static _RowHeaderCells_0Delegate _RowHeaderCells_0DelegateInstance;

        private static QList.Internal _RowHeaderCells_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.RowHeaderCells;
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = _ret.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = _ret.Count;
            fixed (void** __v = new void*[_ret.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < _ret.Count; i++)
            {
                __qlistDataData->array[i] = (void*) _ret[i].__Instance;
            }
            return __qList;
        }

        // int columnIndex()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ColumnIndex_0Delegate(global::System.IntPtr instance);
        private static _ColumnIndex_0Delegate _ColumnIndex_0DelegateInstance;

        private static int _ColumnIndex_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.ColumnIndex;
            return _ret;
        }

        // int rowIndex()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _RowIndex_0Delegate(global::System.IntPtr instance);
        private static _RowIndex_0Delegate _RowIndex_0DelegateInstance;

        private static int _RowIndex_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.RowIndex;
            return _ret;
        }

        // int columnExtent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ColumnExtent_0Delegate(global::System.IntPtr instance);
        private static _ColumnExtent_0Delegate _ColumnExtent_0DelegateInstance;

        private static int _ColumnExtent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.ColumnExtent;
            return _ret;
        }

        // int rowExtent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _RowExtent_0Delegate(global::System.IntPtr instance);
        private static _RowExtent_0Delegate _RowExtent_0DelegateInstance;

        private static int _RowExtent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.RowExtent;
            return _ret;
        }

        // QAccessibleInterface* table()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Table_0Delegate(global::System.IntPtr instance);
        private static _Table_0Delegate _Table_0DelegateInstance;

        private static global::System.IntPtr _Table_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableCellInterface) _References[instance].Target;
            var _ret = target.Table;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _IsSelected_0DelegateInstance += _IsSelected_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsSelected_0DelegateInstance).ToPointer();
                _ColumnHeaderCells_0DelegateInstance += _ColumnHeaderCells_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ColumnHeaderCells_0DelegateInstance).ToPointer();
                _RowHeaderCells_0DelegateInstance += _RowHeaderCells_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RowHeaderCells_0DelegateInstance).ToPointer();
                _ColumnIndex_0DelegateInstance += _ColumnIndex_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ColumnIndex_0DelegateInstance).ToPointer();
                _RowIndex_0DelegateInstance += _RowIndex_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_RowIndex_0DelegateInstance).ToPointer();
                _ColumnExtent_0DelegateInstance += _ColumnExtent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ColumnExtent_0DelegateInstance).ToPointer();
                _RowExtent_0DelegateInstance += _RowExtent_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_RowExtent_0DelegateInstance).ToPointer();
                _Table_0DelegateInstance += _Table_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_Table_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = _Thunks[4];
                *(void**)(vfptr0 + 28) = _Thunks[5];
                *(void**)(vfptr0 + 32) = _Thunks[6];
                *(void**)(vfptr0 + 36) = _Thunks[7];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTableInterface class implements support for the
    /// IAccessibleTable2 interface.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>IAccessible2 Specification</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleTableInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN25QAccessibleTableInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN25QAccessibleTableInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleTableInterface(QAccessibleTableInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the cell at the specified row and column in the
        /// table.</para>
        /// </summary>
        public abstract QAccessibleInterface CellAt(int row, int column);

        /// <summary>
        /// <para>Returns the description text of the specified column in the
        /// table.</para>
        /// </summary>
        public abstract string ColumnDescription(int column);

        /// <summary>
        /// <para>Returns the description text of the specified row in the
        /// table.</para>
        /// </summary>
        public abstract string RowDescription(int row);

        /// <summary>
        /// <para>Returns a boolean value indicating whether the specified column
        /// is completely selected.</para>
        /// </summary>
        public abstract bool IsColumnSelected(int column);

        /// <summary>
        /// <para>Returns a boolean value indicating whether the specified row is
        /// completely selected.</para>
        /// </summary>
        public abstract bool IsRowSelected(int row);

        /// <summary>
        /// <para>Selects row. This function might unselect all previously selected
        /// rows. Returns true if the selection was successful.</para>
        /// </summary>
        public abstract bool SelectRow(int row);

        /// <summary>
        /// <para>Selects column. This function might unselect all previously
        /// selected columns. Returns true if the selection was successful.</para>
        /// </summary>
        public abstract bool SelectColumn(int column);

        /// <summary>
        /// <para>Unselects row, leaving other selected rows selected (if any).
        /// Returns true if the selection was successful.</para>
        /// </summary>
        public abstract bool UnselectRow(int row);

        /// <summary>
        /// <para>Unselects column, leaving other selected columns selected (if
        /// any). Returns true if the selection was successful.</para>
        /// </summary>
        public abstract bool UnselectColumn(int column);

        /// <summary>
        /// <para>Informs about a change in the model's layout. The event contains
        /// the details.</para>
        /// <para>See also QAccessibleTableModelChangeEvent.</para>
        /// </summary>
        public abstract void ModelChange(QAccessibleTableModelChangeEvent _event);

        /// <summary>
        /// <para>Returns the caption for the table.</para>
        /// </summary>
        public abstract QAccessibleInterface Caption
        {
            get;
        }

        /// <summary>
        /// <para>Returns a QAccessibleInterface that represents a summary of the
        /// table. This function may return 0 if no such interface exists.</para>
        /// </summary>
        public abstract QAccessibleInterface Summary
        {
            get;
        }

        /// <summary>
        /// <para>Returns the total number of selected cells.</para>
        /// </summary>
        public abstract int SelectedCellCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the list of selected cell (by their index as
        /// QAccessibleInterface::child() accepts).</para>
        /// </summary>
        public abstract System.Collections.Generic.IList<QAccessibleInterface> SelectedCells
        {
            get;
        }

        /// <summary>
        /// <para>Returns the total number of selected columns.</para>
        /// </summary>
        public abstract int SelectedColumnCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the total number of selected rows.</para>
        /// </summary>
        public abstract int SelectedRowCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the total number of columns in table.</para>
        /// </summary>
        public abstract int ColumnCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the total number of rows in table.</para>
        /// </summary>
        public abstract int RowCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the list of currently selected columns.</para>
        /// </summary>
        public abstract System.Collections.Generic.IList<int> SelectedColumns
        {
            get;
        }

        /// <summary>
        /// <para>Returns the list of currently selected columns.</para>
        /// </summary>
        public abstract System.Collections.Generic.IList<int> SelectedRows
        {
            get;
        }

        #region Virtual table interop

        // QAccessibleInterface *caption()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Caption_0Delegate(global::System.IntPtr instance);
        private static _Caption_0Delegate _Caption_0DelegateInstance;

        private static global::System.IntPtr _Caption_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.Caption;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *summary()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Summary_0Delegate(global::System.IntPtr instance);
        private static _Summary_0Delegate _Summary_0DelegateInstance;

        private static global::System.IntPtr _Summary_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.Summary;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *cellAt (int row, int column)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _CellAt_0Delegate(global::System.IntPtr instance, int row, int column);
        private static _CellAt_0Delegate _CellAt_0DelegateInstance;

        private static global::System.IntPtr _CellAt_0DelegateHook(global::System.IntPtr instance, int row, int column)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.CellAt(row, column);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int selectedCellCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _SelectedCellCount_0Delegate(global::System.IntPtr instance);
        private static _SelectedCellCount_0Delegate _SelectedCellCount_0DelegateInstance;

        private static int _SelectedCellCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectedCellCount;
            return _ret;
        }

        // QList<QAccessibleInterface*> selectedCells()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QList.Internal _SelectedCells_0Delegate(global::System.IntPtr instance);
        private static _SelectedCells_0Delegate _SelectedCells_0DelegateInstance;

        private static QList.Internal _SelectedCells_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectedCells;
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = _ret.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = _ret.Count;
            fixed (void** __v = new void*[_ret.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < _ret.Count; i++)
            {
                __qlistDataData->array[i] = (void*) _ret[i].__Instance;
            }
            return __qList;
        }

        // QString columnDescription(int column)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _ColumnDescription_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int column);
        private static _ColumnDescription_0Delegate _ColumnDescription_0DelegateInstance;

        private static QString.Internal _ColumnDescription_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int column)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.ColumnDescription(column);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // QString rowDescription(int row)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _RowDescription_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, int row);
        private static _RowDescription_0Delegate _RowDescription_0DelegateInstance;

        private static QString.Internal _RowDescription_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, int row)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.RowDescription(row);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // int selectedColumnCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _SelectedColumnCount_0Delegate(global::System.IntPtr instance);
        private static _SelectedColumnCount_0Delegate _SelectedColumnCount_0DelegateInstance;

        private static int _SelectedColumnCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectedColumnCount;
            return _ret;
        }

        // int selectedRowCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _SelectedRowCount_0Delegate(global::System.IntPtr instance);
        private static _SelectedRowCount_0Delegate _SelectedRowCount_0DelegateInstance;

        private static int _SelectedRowCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectedRowCount;
            return _ret;
        }

        // int columnCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ColumnCount_0Delegate(global::System.IntPtr instance);
        private static _ColumnCount_0Delegate _ColumnCount_0DelegateInstance;

        private static int _ColumnCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.ColumnCount;
            return _ret;
        }

        // int rowCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _RowCount_0Delegate(global::System.IntPtr instance);
        private static _RowCount_0Delegate _RowCount_0DelegateInstance;

        private static int _RowCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.RowCount;
            return _ret;
        }

        // QList<int> selectedColumns()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QList.Internal _SelectedColumns_0Delegate(global::System.IntPtr instance);
        private static _SelectedColumns_0Delegate _SelectedColumns_0DelegateInstance;

        private static QList.Internal _SelectedColumns_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectedColumns;
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = _ret.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = _ret.Count;
            fixed (void** __v = new void*[_ret.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < _ret.Count; i++)
            {
                __qlistDataData->array[i] = (void*) _ret[i].__Instance;
            }
            return __qList;
        }

        // QList<int> selectedRows()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QList.Internal _SelectedRows_0Delegate(global::System.IntPtr instance);
        private static _SelectedRows_0Delegate _SelectedRows_0DelegateInstance;

        private static QList.Internal _SelectedRows_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectedRows;
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = _ret.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = _ret.Count;
            fixed (void** __v = new void*[_ret.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < _ret.Count; i++)
            {
                __qlistDataData->array[i] = (void*) _ret[i].__Instance;
            }
            return __qList;
        }

        // bool isColumnSelected(int column)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _IsColumnSelected_0Delegate(global::System.IntPtr instance, int column);
        private static _IsColumnSelected_0Delegate _IsColumnSelected_0DelegateInstance;

        private static bool _IsColumnSelected_0DelegateHook(global::System.IntPtr instance, int column)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.IsColumnSelected(column);
            return _ret;
        }

        // bool isRowSelected(int row)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _IsRowSelected_0Delegate(global::System.IntPtr instance, int row);
        private static _IsRowSelected_0Delegate _IsRowSelected_0DelegateInstance;

        private static bool _IsRowSelected_0DelegateHook(global::System.IntPtr instance, int row)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.IsRowSelected(row);
            return _ret;
        }

        // bool selectRow(int row)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _SelectRow_0Delegate(global::System.IntPtr instance, int row);
        private static _SelectRow_0Delegate _SelectRow_0DelegateInstance;

        private static bool _SelectRow_0DelegateHook(global::System.IntPtr instance, int row)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectRow(row);
            return _ret;
        }

        // bool selectColumn(int column)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _SelectColumn_0Delegate(global::System.IntPtr instance, int column);
        private static _SelectColumn_0Delegate _SelectColumn_0DelegateInstance;

        private static bool _SelectColumn_0DelegateHook(global::System.IntPtr instance, int column)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.SelectColumn(column);
            return _ret;
        }

        // bool unselectRow(int row)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _UnselectRow_0Delegate(global::System.IntPtr instance, int row);
        private static _UnselectRow_0Delegate _UnselectRow_0DelegateInstance;

        private static bool _UnselectRow_0DelegateHook(global::System.IntPtr instance, int row)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.UnselectRow(row);
            return _ret;
        }

        // bool unselectColumn(int column)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _UnselectColumn_0Delegate(global::System.IntPtr instance, int column);
        private static _UnselectColumn_0Delegate _UnselectColumn_0DelegateInstance;

        private static bool _UnselectColumn_0DelegateHook(global::System.IntPtr instance, int column)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            var _ret = target.UnselectColumn(column);
            return _ret;
        }

        // void modelChange(QAccessibleTableModelChangeEvent *event)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _ModelChange_0Delegate(global::System.IntPtr instance, global::System.IntPtr _event);
        private static _ModelChange_0Delegate _ModelChange_0DelegateInstance;

        private static void _ModelChange_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _event)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableInterface) _References[instance].Target;
            target.ModelChange((_event == IntPtr.Zero) ? null : QAccessibleTableModelChangeEvent.__CreateInstance(_event));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[20];
                _Caption_0DelegateInstance += _Caption_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Caption_0DelegateInstance).ToPointer();
                _Summary_0DelegateInstance += _Summary_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Summary_0DelegateInstance).ToPointer();
                _CellAt_0DelegateInstance += _CellAt_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CellAt_0DelegateInstance).ToPointer();
                _SelectedCellCount_0DelegateInstance += _SelectedCellCount_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SelectedCellCount_0DelegateInstance).ToPointer();
                _SelectedCells_0DelegateInstance += _SelectedCells_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SelectedCells_0DelegateInstance).ToPointer();
                _ColumnDescription_0DelegateInstance += _ColumnDescription_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ColumnDescription_0DelegateInstance).ToPointer();
                _RowDescription_0DelegateInstance += _RowDescription_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_RowDescription_0DelegateInstance).ToPointer();
                _SelectedColumnCount_0DelegateInstance += _SelectedColumnCount_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_SelectedColumnCount_0DelegateInstance).ToPointer();
                _SelectedRowCount_0DelegateInstance += _SelectedRowCount_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SelectedRowCount_0DelegateInstance).ToPointer();
                _ColumnCount_0DelegateInstance += _ColumnCount_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_ColumnCount_0DelegateInstance).ToPointer();
                _RowCount_0DelegateInstance += _RowCount_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_RowCount_0DelegateInstance).ToPointer();
                _SelectedColumns_0DelegateInstance += _SelectedColumns_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_SelectedColumns_0DelegateInstance).ToPointer();
                _SelectedRows_0DelegateInstance += _SelectedRows_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_SelectedRows_0DelegateInstance).ToPointer();
                _IsColumnSelected_0DelegateInstance += _IsColumnSelected_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_IsColumnSelected_0DelegateInstance).ToPointer();
                _IsRowSelected_0DelegateInstance += _IsRowSelected_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_IsRowSelected_0DelegateInstance).ToPointer();
                _SelectRow_0DelegateInstance += _SelectRow_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_SelectRow_0DelegateInstance).ToPointer();
                _SelectColumn_0DelegateInstance += _SelectColumn_0DelegateHook;
                _Thunks[16] = Marshal.GetFunctionPointerForDelegate(_SelectColumn_0DelegateInstance).ToPointer();
                _UnselectRow_0DelegateInstance += _UnselectRow_0DelegateHook;
                _Thunks[17] = Marshal.GetFunctionPointerForDelegate(_UnselectRow_0DelegateInstance).ToPointer();
                _UnselectColumn_0DelegateInstance += _UnselectColumn_0DelegateHook;
                _Thunks[18] = Marshal.GetFunctionPointerForDelegate(_UnselectColumn_0DelegateInstance).ToPointer();
                _ModelChange_0DelegateInstance += _ModelChange_0DelegateHook;
                _Thunks[19] = Marshal.GetFunctionPointerForDelegate(_ModelChange_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(21 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = _Thunks[4];
                *(void**)(vfptr0 + 28) = _Thunks[5];
                *(void**)(vfptr0 + 32) = _Thunks[6];
                *(void**)(vfptr0 + 36) = _Thunks[7];
                *(void**)(vfptr0 + 40) = _Thunks[8];
                *(void**)(vfptr0 + 44) = _Thunks[9];
                *(void**)(vfptr0 + 48) = _Thunks[10];
                *(void**)(vfptr0 + 52) = _Thunks[11];
                *(void**)(vfptr0 + 56) = _Thunks[12];
                *(void**)(vfptr0 + 60) = _Thunks[13];
                *(void**)(vfptr0 + 64) = _Thunks[14];
                *(void**)(vfptr0 + 68) = _Thunks[15];
                *(void**)(vfptr0 + 72) = _Thunks[16];
                *(void**)(vfptr0 + 76) = _Thunks[17];
                *(void**)(vfptr0 + 80) = _Thunks[18];
                *(void**)(vfptr0 + 84) = _Thunks[19];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleActionInterface class implements support for
    /// invocable actions in the interface.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Accessible objects should implement the action interface if they
    /// support user interaction. Usually this interface is implemented by classes
    /// that also implement QAccessibleInterface.</para>
    /// <para>The supported actions should use the predefined actions offered
    /// in this class unless they do not fit a predefined action. In that case a
    /// custom action can be added.</para>
    /// <para>When subclassing QAccessibleActionInterface you need to provide a
    /// list of actionNames which is the primary means to discover the available
    /// actions. Action names are never localized. In order to present actions to
    /// the user there are two functions that need to return localized versions of
    /// the name and give a description of the action. For the predefined action
    /// names use QAccessibleActionInterface::localizedActionName() and
    /// QAccessibleActionInterface::localizedActionDescription() to return their
    /// localized counterparts.</para>
    /// <para>In general you should use one of the predefined action names,
    /// unless describing an action that does not fit these:</para>
    /// <para></para>
    /// <para> Action nameDescription</para>
    /// <para>toggleAction()	toggles the item (checkbox, radio button, switch,
    /// ...)</para>
    /// <para>decreaseAction()	decrease the value of the accessible (e.g.
    /// spinbox)</para>
    /// <para>increaseAction()	increase the value of the accessible (e.g.
    /// spinbox)</para>
    /// <para>pressAction()	press or click or activate the accessible (should
    /// correspont to clicking the object with the mouse)</para>
    /// <para>setFocusAction()	set the focus to this accessible</para>
    /// <para>showMenuAction()	show a context menu, corresponds to
    /// right-clicks</para>
    /// <para></para>
    /// <para>In order to invoke the action, doAction() is called with an
    /// action name.</para>
    /// <para>Most widgets will simply implement pressAction(). This is what
    /// happens when the widget is activated by being clicked, space pressed or
    /// similar.</para>
    /// <para>IAccessible2 Specification</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleActionInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleActionInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleActionInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK26QAccessibleActionInterface19localizedActionNameERK7QString")]
            internal static extern void LocalizedActionName_0(global::System.IntPtr _return, global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK26QAccessibleActionInterface26localizedActionDescriptionERK7QString")]
            internal static extern void LocalizedActionDescription_0(global::System.IntPtr _return, global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26QAccessibleActionInterface14showMenuActionEv")]
            internal static extern global::System.IntPtr ShowMenuAction_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26QAccessibleActionInterface14setFocusActionEv")]
            internal static extern global::System.IntPtr SetFocusAction_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26QAccessibleActionInterface11pressActionEv")]
            internal static extern global::System.IntPtr PressAction_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26QAccessibleActionInterface14increaseActionEv")]
            internal static extern global::System.IntPtr IncreaseAction_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26QAccessibleActionInterface14decreaseActionEv")]
            internal static extern global::System.IntPtr DecreaseAction_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26QAccessibleActionInterface12toggleActionEv")]
            internal static extern global::System.IntPtr ToggleAction_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleActionInterface(QAccessibleActionInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns a localized action name of actionName.</para>
        /// <para>For custom actions this function has to be re-implemented. When
        /// using one of the default names, you can call this function in
        /// QAccessibleActionInterface to get the localized string.</para>
        /// <para>See also actionNames() and localizedActionDescription().</para>
        /// </summary>
        public virtual string LocalizedActionName(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.LocalizedActionName_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns a localized action description of the action
        /// actionName.</para>
        /// <para>When using one of the default names, you can call this function
        /// in QAccessibleActionInterface to get the localized string.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public virtual string LocalizedActionDescription(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.LocalizedActionDescription_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Invokes the action specified by actionName. Note that actionName
        /// is the non-localized name as returned by actionNames() This function is
        /// usually implemented by calling the same functions that other user
        /// interaction, such as clicking the object, would trigger.</para>
        /// <para>See also actionNames().</para>
        /// </summary>
        public abstract void DoAction(string actionName);

        /// <summary>
        /// <para>Returns the name of the show menu default action.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public static string ShowMenuAction()
        {
            var __ret = Internal.ShowMenuAction_0();
            if (__ret == global::System.IntPtr.Zero) return null;
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the name of the set focus default action.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public static string SetFocusAction()
        {
            var __ret = Internal.SetFocusAction_0();
            if (__ret == global::System.IntPtr.Zero) return null;
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the name of the press default action.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public static string PressAction
        {
            get
            {
                var __ret = Internal.PressAction_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the name of the increase default action.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public static string IncreaseAction
        {
            get
            {
                var __ret = Internal.IncreaseAction_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the name of the decrease default action.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public static string DecreaseAction
        {
            get
            {
                var __ret = Internal.DecreaseAction_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the name of the toggle default action.</para>
        /// <para>See also actionNames() and localizedActionName().</para>
        /// </summary>
        public static string ToggleAction
        {
            get
            {
                var __ret = Internal.ToggleAction_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        #region Virtual table interop

        // QString localizedActionName(const QString &name)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _LocalizedActionName_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, global::System.IntPtr name);
        private static _LocalizedActionName_0Delegate _LocalizedActionName_0DelegateInstance;

        private static QString.Internal _LocalizedActionName_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, global::System.IntPtr name)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleActionInterface) _References[instance].Target;
            var _ret = target.LocalizedActionName(Marshal.PtrToStringUni(new IntPtr(new QString(name).Utf16)));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // QString localizedActionDescription(const QString &name)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _LocalizedActionDescription_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, global::System.IntPtr name);
        private static _LocalizedActionDescription_0Delegate _LocalizedActionDescription_0DelegateInstance;

        private static QString.Internal _LocalizedActionDescription_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, global::System.IntPtr name)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleActionInterface) _References[instance].Target;
            var _ret = target.LocalizedActionDescription(Marshal.PtrToStringUni(new IntPtr(new QString(name).Utf16)));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // void doAction(const QString &actionName)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _DoAction_0Delegate(global::System.IntPtr instance, global::System.IntPtr actionName);
        private static _DoAction_0Delegate _DoAction_0DelegateInstance;

        private static void _DoAction_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr actionName)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleActionInterface) _References[instance].Target;
            target.DoAction(Marshal.PtrToStringUni(new IntPtr(new QString(actionName).Utf16)));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _LocalizedActionName_0DelegateInstance += _LocalizedActionName_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LocalizedActionName_0DelegateInstance).ToPointer();
                _LocalizedActionDescription_0DelegateInstance += _LocalizedActionDescription_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LocalizedActionDescription_0DelegateInstance).ToPointer();
                _DoAction_0DelegateInstance += _DoAction_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoAction_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[0];
                *(void**)(vfptr0 + 16) = _Thunks[1];
                *(void**)(vfptr0 + 20) = _Thunks[2];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe abstract partial class QAccessibleImageInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN25QAccessibleImageInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN25QAccessibleImageInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleImageInterface(QAccessibleImageInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public abstract string ImageDescription
        {
            get;
        }

        #region Virtual table interop

        // QString imageDescription()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _ImageDescription_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _ImageDescription_0Delegate _ImageDescription_0DelegateInstance;

        private static QString.Internal _ImageDescription_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleImageInterface) _References[instance].Target;
            var _ret = target.ImageDescription;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _ImageDescription_0DelegateInstance += _ImageDescription_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ImageDescription_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleEvent class is the base class for accessibility
    /// notifications.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// <para>The event type is one of the values of QAccessible::Event. There
    /// are a number of subclasses that should be used to provide more details
    /// about the event.</para>
    /// <para>For example to notify about a focus change when re-implementing
    /// QWidget::setFocus, the event could be used as follows:</para>
    /// <para>void MyWidget::setFocus(Qt::FocusReason reason)</para>
    /// <para>{</para>
    /// <para>    // handle custom focus setting...</para>
    /// <para>    QAccessibleEvent event(f, QAccessible::Focus);</para>
    /// <para>    QAccessible::updateAccessibility(&amp;event);</para>
    /// <para>}</para>
    /// <para>To enable in process screen readers, all events must be sent
    /// after the change has happened.</para>
    /// </remarks>
    public unsafe partial class QAccessibleEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QAccessibleEventC2ERKS_")]
            internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QAccessibleEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QAccessibleEvent8uniqueIdEv")]
            internal static extern uint UniqueId_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QAccessibleEvent19accessibleInterfaceEv")]
            internal static extern global::System.IntPtr AccessibleInterface_0(global::System.IntPtr instance);
        }

        protected unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public int m_child;

                [FieldOffset(0)]
                public uint m_uniqueId;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QAccessibleEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleEvent((QAccessibleEvent.Internal*) native);
        }

        public static QAccessibleEvent __CreateInstance(QAccessibleEvent.Internal native)
        {
            return new QAccessibleEvent(native);
        }

        private static QAccessibleEvent.Internal* __CopyValue(QAccessibleEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QAccessibleEvent.Internal.cctor_0(ret, new global::System.IntPtr(&native));
            return (QAccessibleEvent.Internal*) ret;
        }

        private QAccessibleEvent(QAccessibleEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleEvent(QAccessibleEvent.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected QAccessible.Event M_type
        {
            get
            {
                return ((Internal*) __Instance)->m_type;
            }

            set
            {
                ((Internal*) __Instance)->m_type = value;
            }
        }

        public uint UniqueId
        {
            get
            {
                var __ret = Internal.UniqueId_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the QAccessibleInterface associated with the event. The
        /// caller of this function takes ownership of the returned interface.</para>
        /// </summary>
        public virtual QAccessibleInterface AccessibleInterface
        {
            get
            {
                var __ret = Internal.AccessibleInterface_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleStateChangeEvent notfies the accessibility
    /// framework that the state of an object has changed.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// <para></para>
    /// <para>See also QAccessibleInterface::state().</para>
    /// </remarks>
    public unsafe partial class QAccessibleStateChangeEvent : QtGui.QAccessibleEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public QAccessible.State.Internal m_changedStates;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAccessibleStateChangeEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAccessibleStateChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleStateChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleStateChangeEvent((QAccessibleStateChangeEvent.Internal*) native);
        }

        public static QAccessibleStateChangeEvent __CreateInstance(QAccessibleStateChangeEvent.Internal native)
        {
            return new QAccessibleStateChangeEvent(native);
        }

        private static QAccessibleStateChangeEvent.Internal* __CopyValue(QAccessibleStateChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            QtGui.QAccessibleStateChangeEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleStateChangeEvent.Internal*) ret;
        }

        private QAccessibleStateChangeEvent(QAccessibleStateChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleStateChangeEvent(QAccessibleStateChangeEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected QAccessible.State M_changedStates
        {
            get
            {
                return QAccessible.State.__CreateInstance(((Internal*) __Instance)->m_changedStates);
            }

            set
            {
                ((Internal*) __Instance)->m_changedStates = ReferenceEquals(value, null) ? new QAccessible.State.Internal() : *(QAccessible.State.Internal*) (value.__Instance);
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleStateChangeEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTextCursorEvent class notifies of cursor
    /// movements.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// </remarks>
    public unsafe partial class QAccessibleTextCursorEvent : QtGui.QAccessibleEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public int m_cursorPosition;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextCursorEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextCursorEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleTextCursorEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTextCursorEvent((QAccessibleTextCursorEvent.Internal*) native);
        }

        public static QAccessibleTextCursorEvent __CreateInstance(QAccessibleTextCursorEvent.Internal native)
        {
            return new QAccessibleTextCursorEvent(native);
        }

        private static QAccessibleTextCursorEvent.Internal* __CopyValue(QAccessibleTextCursorEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QAccessibleTextCursorEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleTextCursorEvent.Internal*) ret;
        }

        private QAccessibleTextCursorEvent(QAccessibleTextCursorEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTextCursorEvent(QAccessibleTextCursorEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int M_cursorPosition
        {
            get
            {
                return ((Internal*) __Instance)->m_cursorPosition;
            }

            set
            {
                ((Internal*) __Instance)->m_cursorPosition = value;
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextCursorEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QAccessibleTextSelectionEvent : QtGui.QAccessibleTextCursorEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public int m_cursorPosition;

            [FieldOffset(20)]
            public int m_selectionStart;

            [FieldOffset(24)]
            public int m_selectionEnd;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN29QAccessibleTextSelectionEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN29QAccessibleTextSelectionEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleTextSelectionEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTextSelectionEvent((QAccessibleTextSelectionEvent.Internal*) native);
        }

        public static QAccessibleTextSelectionEvent __CreateInstance(QAccessibleTextSelectionEvent.Internal native)
        {
            return new QAccessibleTextSelectionEvent(native);
        }

        private static QAccessibleTextSelectionEvent.Internal* __CopyValue(QAccessibleTextSelectionEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            QtGui.QAccessibleTextSelectionEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleTextSelectionEvent.Internal*) ret;
        }

        private QAccessibleTextSelectionEvent(QAccessibleTextSelectionEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTextSelectionEvent(QAccessibleTextSelectionEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTextCursorEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int M_selectionStart
        {
            get
            {
                return ((Internal*) __Instance)->m_selectionStart;
            }

            set
            {
                ((Internal*) __Instance)->m_selectionStart = value;
            }
        }

        protected int M_selectionEnd
        {
            get
            {
                return ((Internal*) __Instance)->m_selectionEnd;
            }

            set
            {
                ((Internal*) __Instance)->m_selectionEnd = value;
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextSelectionEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTextInsertEvent class notifies of text being
    /// inserted.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// </remarks>
    public unsafe partial class QAccessibleTextInsertEvent : QtGui.QAccessibleTextCursorEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public int m_cursorPosition;

            [FieldOffset(20)]
            public int m_position;

            [FieldOffset(24)]
            internal QString.Internal m_text;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextInsertEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextInsertEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleTextInsertEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTextInsertEvent((QAccessibleTextInsertEvent.Internal*) native);
        }

        public static QAccessibleTextInsertEvent __CreateInstance(QAccessibleTextInsertEvent.Internal native)
        {
            return new QAccessibleTextInsertEvent(native);
        }

        private static QAccessibleTextInsertEvent.Internal* __CopyValue(QAccessibleTextInsertEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            QtGui.QAccessibleTextInsertEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleTextInsertEvent.Internal*) ret;
        }

        private QAccessibleTextInsertEvent(QAccessibleTextInsertEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTextInsertEvent(QAccessibleTextInsertEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTextCursorEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int M_position
        {
            get
            {
                return ((Internal*) __Instance)->m_position;
            }

            set
            {
                ((Internal*) __Instance)->m_position = value;
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextInsertEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTextRemoveEvent class notifies of text being
    /// deleted.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// </remarks>
    public unsafe partial class QAccessibleTextRemoveEvent : QtGui.QAccessibleTextCursorEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public int m_cursorPosition;

            [FieldOffset(20)]
            public int m_position;

            [FieldOffset(24)]
            internal QString.Internal m_text;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextRemoveEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextRemoveEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleTextRemoveEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTextRemoveEvent((QAccessibleTextRemoveEvent.Internal*) native);
        }

        public static QAccessibleTextRemoveEvent __CreateInstance(QAccessibleTextRemoveEvent.Internal native)
        {
            return new QAccessibleTextRemoveEvent(native);
        }

        private static QAccessibleTextRemoveEvent.Internal* __CopyValue(QAccessibleTextRemoveEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            QtGui.QAccessibleTextRemoveEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleTextRemoveEvent.Internal*) ret;
        }

        private QAccessibleTextRemoveEvent(QAccessibleTextRemoveEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTextRemoveEvent(QAccessibleTextRemoveEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTextCursorEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int M_position
        {
            get
            {
                return ((Internal*) __Instance)->m_position;
            }

            set
            {
                ((Internal*) __Instance)->m_position = value;
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextRemoveEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTextUpdateEvent class notifies about text changes.
    /// This is for accessibles that support editable text such as line edits. This
    /// event occurs for example when a portion of selected text gets replaced by
    /// pasting a new text or in override mode of editors.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// </remarks>
    public unsafe partial class QAccessibleTextUpdateEvent : QtGui.QAccessibleTextCursorEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public int m_cursorPosition;

            [FieldOffset(20)]
            public int m_position;

            [FieldOffset(24)]
            internal QString.Internal m_oldText;

            [FieldOffset(28)]
            internal QString.Internal m_text;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextUpdateEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN26QAccessibleTextUpdateEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleTextUpdateEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTextUpdateEvent((QAccessibleTextUpdateEvent.Internal*) native);
        }

        public static QAccessibleTextUpdateEvent __CreateInstance(QAccessibleTextUpdateEvent.Internal native)
        {
            return new QAccessibleTextUpdateEvent(native);
        }

        private static QAccessibleTextUpdateEvent.Internal* __CopyValue(QAccessibleTextUpdateEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QAccessibleTextUpdateEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleTextUpdateEvent.Internal*) ret;
        }

        private QAccessibleTextUpdateEvent(QAccessibleTextUpdateEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTextUpdateEvent(QAccessibleTextUpdateEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTextCursorEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected int M_position
        {
            get
            {
                return ((Internal*) __Instance)->m_position;
            }

            set
            {
                ((Internal*) __Instance)->m_position = value;
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTextUpdateEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleValueChangeEvent describes a change in value for
    /// an accessible object.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>It contains the new value.</para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// </remarks>
    public unsafe partial class QAccessibleValueChangeEvent : QtGui.QAccessibleEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            internal QtCore.QVariant.Internal m_value;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAccessibleValueChangeEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAccessibleValueChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleValueChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleValueChangeEvent((QAccessibleValueChangeEvent.Internal*) native);
        }

        public static QAccessibleValueChangeEvent __CreateInstance(QAccessibleValueChangeEvent.Internal native)
        {
            return new QAccessibleValueChangeEvent(native);
        }

        private static QAccessibleValueChangeEvent.Internal* __CopyValue(QAccessibleValueChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QAccessibleValueChangeEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleValueChangeEvent.Internal*) ret;
        }

        private QAccessibleValueChangeEvent(QAccessibleValueChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleValueChangeEvent(QAccessibleValueChangeEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleValueChangeEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QAccessibleTableModelChangeEvent signifies a change in a
    /// table, list, or tree where cells are added or removed. If the change
    /// affected a number of rows, firstColumn and lastColumn will return -1.
    /// Likewise for columns, the row functions may return -1.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used with
    /// QAccessible::updateAccessibility().</para>
    /// </remarks>
    public unsafe partial class QAccessibleTableModelChangeEvent : QtGui.QAccessibleEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QAccessible.Event m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_object;

            [FieldOffset(12)]
            internal QAccessibleEvent._.Internal __;

            [FieldOffset(16)]
            public QAccessibleTableModelChangeEvent.ModelChangeType m_modelChangeType;

            [FieldOffset(20)]
            public int m_firstRow;

            [FieldOffset(24)]
            public int m_firstColumn;

            [FieldOffset(28)]
            public int m_lastRow;

            [FieldOffset(32)]
            public int m_lastColumn;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QAccessibleTableModelChangeEventC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QAccessibleTableModelChangeEventD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes different types of changes in the table
        /// model.</para>
        /// </summary>
        public enum ModelChangeType : uint
        {
            /// <summary>The model has been reset, all previous knowledge about the model is now invalid.</summary>
            ModelReset = 0,
            /// <summary>No cells have been added or removed, but the data of the specified cell range is invalid.</summary>
            DataChanged = 1,
            /// <summary>New rows have been inserted.</summary>
            RowsInserted = 2,
            /// <summary>New columns have been inserted.</summary>
            ColumnsInserted = 3,
            /// <summary>Rows have been removed.</summary>
            RowsRemoved = 4,
            /// <summary>Columns have been removed.</summary>
            ColumnsRemoved = 5
        }

        private readonly bool __ownsNativeInstance;

        public static new QAccessibleTableModelChangeEvent __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTableModelChangeEvent((QAccessibleTableModelChangeEvent.Internal*) native);
        }

        public static QAccessibleTableModelChangeEvent __CreateInstance(QAccessibleTableModelChangeEvent.Internal native)
        {
            return new QAccessibleTableModelChangeEvent(native);
        }

        private static QAccessibleTableModelChangeEvent.Internal* __CopyValue(QAccessibleTableModelChangeEvent.Internal native)
        {
            var ret = Marshal.AllocHGlobal(36);
            QtGui.QAccessibleTableModelChangeEvent.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QAccessibleTableModelChangeEvent.Internal*) ret;
        }

        private QAccessibleTableModelChangeEvent(QAccessibleTableModelChangeEvent.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTableModelChangeEvent(QAccessibleTableModelChangeEvent.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleEvent.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected QAccessibleTableModelChangeEvent.ModelChangeType M_modelChangeType
        {
            get
            {
                return ((Internal*) __Instance)->m_modelChangeType;
            }

            set
            {
                ((Internal*) __Instance)->m_modelChangeType = value;
            }
        }

        protected int M_firstRow
        {
            get
            {
                return ((Internal*) __Instance)->m_firstRow;
            }

            set
            {
                ((Internal*) __Instance)->m_firstRow = value;
            }
        }

        protected int M_firstColumn
        {
            get
            {
                return ((Internal*) __Instance)->m_firstColumn;
            }

            set
            {
                ((Internal*) __Instance)->m_firstColumn = value;
            }
        }

        protected int M_lastRow
        {
            get
            {
                return ((Internal*) __Instance)->m_lastRow;
            }

            set
            {
                ((Internal*) __Instance)->m_lastRow = value;
            }
        }

        protected int M_lastColumn
        {
            get
            {
                return ((Internal*) __Instance)->m_lastColumn;
            }

            set
            {
                ((Internal*) __Instance)->m_lastColumn = value;
            }
        }

        #region Virtual table interop

        // QAccessibleInterface *accessibleInterface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleInterface_0Delegate(global::System.IntPtr instance);
        private static _AccessibleInterface_0Delegate _AccessibleInterface_0DelegateInstance;

        private static global::System.IntPtr _AccessibleInterface_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleTableModelChangeEvent) _References[instance].Target;
            var _ret = target.AccessibleInterface;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AccessibleInterface_0DelegateInstance += _AccessibleInterface_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AccessibleInterface_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QAccessibleInterfaceInternal : QtGui.QAccessibleInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleInterfaceInternal((QAccessibleInterface.Internal*) native);
        }

        public static QAccessibleInterface __CreateInstance(QAccessibleInterface.Internal native)
        {
            return new QAccessibleInterfaceInternal(native);
        }

        private static QAccessibleInterface.Internal* __CopyValue(QAccessibleInterface.Internal native)
        {
            var ret = (QAccessibleInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleInterfaceInternal(QAccessibleInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleInterfaceInternal(QAccessibleInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QAccessibleInterface ChildAt(int x, int y)
        {
            void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 7 * 4);
            var ___ChildAt_0Delegate = (_ChildAt_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ChildAt_0Delegate));
            var __ret = ___ChildAt_0Delegate(__Instance, x, y);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        public override QAccessibleInterface Child(int index)
        {
            void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 9 * 4);
            var ___Child_0Delegate = (_Child_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Child_0Delegate));
            var __ret = ___Child_0Delegate(__Instance, index);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        public override int IndexOfChild(QAccessibleInterface _0)
        {
            void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 11 * 4);
            var ___IndexOfChild_0Delegate = (_IndexOfChild_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_IndexOfChild_0Delegate));
            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = ___IndexOfChild_0Delegate(__Instance, arg0);
            return __ret;
        }

        public override string Text(QAccessible.Text t)
        {
            void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___Text_0Delegate = (_Text_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Text_0Delegate));
            var arg0 = t;
            var __ret = new QtCore.QString.Internal();
            ___Text_0Delegate(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override void SetText(QAccessible.Text t, string text)
        {
            void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 13 * 4);
            var ___SetText_0Delegate = (_SetText_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SetText_0Delegate));
            var arg0 = t;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            ___SetText_0Delegate(__Instance, arg0, arg1);
        }

        public override bool IsValid
        {
            get
            {
                void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___IsValid_0Delegate = (_IsValid_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_IsValid_0Delegate));
                var __ret = ___IsValid_0Delegate(__Instance);
                return __ret;
            }
        }

        public override QAccessibleInterface Parent
        {
            get
            {
                void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 8 * 4);
                var ___Parent_0Delegate = (_Parent_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Parent_0Delegate));
                var __ret = ___Parent_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        public override int ChildCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 10 * 4);
                var ___ChildCount_0Delegate = (_ChildCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ChildCount_0Delegate));
                var __ret = ___ChildCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override QAccessible.Role Role
        {
            get
            {
                void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 15 * 4);
                var ___Role_0Delegate = (_Role_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Role_0Delegate));
                var __ret = ___Role_0Delegate(__Instance);
                return __ret;
            }
        }

        public override QAccessible.State State
        {
            get
            {
                void* slot = *(void**) (((QAccessibleInterface.Internal*) __Instance)->vfptr0 + 16 * 4);
                var ___State_0Delegate = (_State_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_State_0Delegate));
                var __ret = ___State_0Delegate(__Instance);
                return QAccessible.State.__CreateInstance(__ret);
            }
        }
    }

    internal unsafe partial class QAccessibleTextInterfaceInternal : QtGui.QAccessibleTextInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleTextInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTextInterfaceInternal((QAccessibleTextInterface.Internal*) native);
        }

        public static QAccessibleTextInterface __CreateInstance(QAccessibleTextInterface.Internal native)
        {
            return new QAccessibleTextInterfaceInternal(native);
        }

        private static QAccessibleTextInterface.Internal* __CopyValue(QAccessibleTextInterface.Internal native)
        {
            var ret = (QAccessibleTextInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleTextInterfaceInternal(QAccessibleTextInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTextInterfaceInternal(QAccessibleTextInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTextInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override void Selection(int selectionIndex, int* startOffset, int* endOffset)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 2 * 4);
            var ___Selection_0Delegate = (_Selection_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Selection_0Delegate));
            var arg1 = startOffset;
            var arg2 = endOffset;
            ___Selection_0Delegate(__Instance, selectionIndex, arg1, arg2);
        }

        public override void AddSelection(int startOffset, int endOffset)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 4 * 4);
            var ___AddSelection_0Delegate = (_AddSelection_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_AddSelection_0Delegate));
            ___AddSelection_0Delegate(__Instance, startOffset, endOffset);
        }

        public override void RemoveSelection(int selectionIndex)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 5 * 4);
            var ___RemoveSelection_0Delegate = (_RemoveSelection_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_RemoveSelection_0Delegate));
            ___RemoveSelection_0Delegate(__Instance, selectionIndex);
        }

        public override void SetSelection(int selectionIndex, int startOffset, int endOffset)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 6 * 4);
            var ___SetSelection_0Delegate = (_SetSelection_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SetSelection_0Delegate));
            ___SetSelection_0Delegate(__Instance, selectionIndex, startOffset, endOffset);
        }

        public override string Text(int startOffset, int endOffset)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 9 * 4);
            var ___Text_0Delegate = (_Text_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Text_0Delegate));
            var __ret = new QtCore.QString.Internal();
            ___Text_0Delegate(new IntPtr(&__ret), __Instance, startOffset, endOffset);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override void ScrollToSubstring(int startIndex, int endIndex)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 16 * 4);
            var ___ScrollToSubstring_0Delegate = (_ScrollToSubstring_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ScrollToSubstring_0Delegate));
            ___ScrollToSubstring_0Delegate(__Instance, startIndex, endIndex);
        }

        public override string Attributes(int offset, int* startOffset, int* endOffset)
        {
            void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 17 * 4);
            var ___Attributes_0Delegate = (_Attributes_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Attributes_0Delegate));
            var arg1 = startOffset;
            var arg2 = endOffset;
            var __ret = new QtCore.QString.Internal();
            ___Attributes_0Delegate(new IntPtr(&__ret), __Instance, offset, arg1, arg2);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override int CursorPosition
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 7 * 4);
                var ___CursorPosition_0Delegate = (_CursorPosition_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_CursorPosition_0Delegate));
                var __ret = ___CursorPosition_0Delegate(__Instance);
                return __ret;
            }

            set
            {
                void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 8 * 4);
                var ___SetCursorPosition_0Delegate = (_SetCursorPosition_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SetCursorPosition_0Delegate));
                ___SetCursorPosition_0Delegate(__Instance, position);
            }
        }

        public override int SelectionCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 3 * 4);
                var ___SelectionCount_0Delegate = (_SelectionCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectionCount_0Delegate));
                var __ret = ___SelectionCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int CharacterCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTextInterface.Internal*) __Instance)->vfptr0 + 13 * 4);
                var ___CharacterCount_0Delegate = (_CharacterCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_CharacterCount_0Delegate));
                var __ret = ___CharacterCount_0Delegate(__Instance);
                return __ret;
            }
        }
    }

    internal unsafe partial class QAccessibleEditableTextInterfaceInternal : QtGui.QAccessibleEditableTextInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleEditableTextInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleEditableTextInterfaceInternal((QAccessibleEditableTextInterface.Internal*) native);
        }

        public static QAccessibleEditableTextInterface __CreateInstance(QAccessibleEditableTextInterface.Internal native)
        {
            return new QAccessibleEditableTextInterfaceInternal(native);
        }

        private static QAccessibleEditableTextInterface.Internal* __CopyValue(QAccessibleEditableTextInterface.Internal native)
        {
            var ret = (QAccessibleEditableTextInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleEditableTextInterfaceInternal(QAccessibleEditableTextInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleEditableTextInterfaceInternal(QAccessibleEditableTextInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleEditableTextInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override void DeleteText(int startOffset, int endOffset)
        {
            void* slot = *(void**) (((QAccessibleEditableTextInterface.Internal*) __Instance)->vfptr0 + 2 * 4);
            var ___DeleteText_0Delegate = (_DeleteText_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_DeleteText_0Delegate));
            ___DeleteText_0Delegate(__Instance, startOffset, endOffset);
        }

        public override void InsertText(int offset, string text)
        {
            void* slot = *(void**) (((QAccessibleEditableTextInterface.Internal*) __Instance)->vfptr0 + 3 * 4);
            var ___InsertText_0Delegate = (_InsertText_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_InsertText_0Delegate));
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            ___InsertText_0Delegate(__Instance, offset, arg1);
        }

        public override void ReplaceText(int startOffset, int endOffset, string text)
        {
            void* slot = *(void**) (((QAccessibleEditableTextInterface.Internal*) __Instance)->vfptr0 + 4 * 4);
            var ___ReplaceText_0Delegate = (_ReplaceText_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ReplaceText_0Delegate));
            var __qstring2 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg2 = ReferenceEquals(__qstring2, null) ? global::System.IntPtr.Zero : __qstring2.__Instance;
            ___ReplaceText_0Delegate(__Instance, startOffset, endOffset, arg2);
        }
    }

    internal unsafe partial class QAccessibleValueInterfaceInternal : QtGui.QAccessibleValueInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleValueInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleValueInterfaceInternal((QAccessibleValueInterface.Internal*) native);
        }

        public static QAccessibleValueInterface __CreateInstance(QAccessibleValueInterface.Internal native)
        {
            return new QAccessibleValueInterfaceInternal(native);
        }

        private static QAccessibleValueInterface.Internal* __CopyValue(QAccessibleValueInterface.Internal native)
        {
            var ret = (QAccessibleValueInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleValueInterfaceInternal(QAccessibleValueInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleValueInterfaceInternal(QAccessibleValueInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleValueInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    internal unsafe partial class QAccessibleTableCellInterfaceInternal : QtGui.QAccessibleTableCellInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleTableCellInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTableCellInterfaceInternal((QAccessibleTableCellInterface.Internal*) native);
        }

        public static QAccessibleTableCellInterface __CreateInstance(QAccessibleTableCellInterface.Internal native)
        {
            return new QAccessibleTableCellInterfaceInternal(native);
        }

        private static QAccessibleTableCellInterface.Internal* __CopyValue(QAccessibleTableCellInterface.Internal native)
        {
            var ret = (QAccessibleTableCellInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleTableCellInterfaceInternal(QAccessibleTableCellInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTableCellInterfaceInternal(QAccessibleTableCellInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTableCellInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override bool IsSelected
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___IsSelected_0Delegate = (_IsSelected_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_IsSelected_0Delegate));
                var __ret = ___IsSelected_0Delegate(__Instance);
                return __ret;
            }
        }

        public override System.Collections.Generic.IList<QAccessibleInterface> ColumnHeaderCells
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 3 * 4);
                var ___ColumnHeaderCells_0Delegate = (_ColumnHeaderCells_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ColumnHeaderCells_0Delegate));
                var __ret = ___ColumnHeaderCells_0Delegate(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QAccessibleInterface>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QAccessibleInterfaceInternal.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        public override System.Collections.Generic.IList<QAccessibleInterface> RowHeaderCells
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 4 * 4);
                var ___RowHeaderCells_0Delegate = (_RowHeaderCells_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_RowHeaderCells_0Delegate));
                var __ret = ___RowHeaderCells_0Delegate(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QAccessibleInterface>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QAccessibleInterfaceInternal.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        public override int ColumnIndex
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 5 * 4);
                var ___ColumnIndex_0Delegate = (_ColumnIndex_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ColumnIndex_0Delegate));
                var __ret = ___ColumnIndex_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int RowIndex
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 6 * 4);
                var ___RowIndex_0Delegate = (_RowIndex_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_RowIndex_0Delegate));
                var __ret = ___RowIndex_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int ColumnExtent
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 7 * 4);
                var ___ColumnExtent_0Delegate = (_ColumnExtent_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ColumnExtent_0Delegate));
                var __ret = ___ColumnExtent_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int RowExtent
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 8 * 4);
                var ___RowExtent_0Delegate = (_RowExtent_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_RowExtent_0Delegate));
                var __ret = ___RowExtent_0Delegate(__Instance);
                return __ret;
            }
        }

        public override QAccessibleInterface Table
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableCellInterface.Internal*) __Instance)->vfptr0 + 9 * 4);
                var ___Table_0Delegate = (_Table_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Table_0Delegate));
                var __ret = ___Table_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }
    }

    internal unsafe partial class QAccessibleTableInterfaceInternal : QtGui.QAccessibleTableInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleTableInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleTableInterfaceInternal((QAccessibleTableInterface.Internal*) native);
        }

        public static QAccessibleTableInterface __CreateInstance(QAccessibleTableInterface.Internal native)
        {
            return new QAccessibleTableInterfaceInternal(native);
        }

        private static QAccessibleTableInterface.Internal* __CopyValue(QAccessibleTableInterface.Internal native)
        {
            var ret = (QAccessibleTableInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleTableInterfaceInternal(QAccessibleTableInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleTableInterfaceInternal(QAccessibleTableInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleTableInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QAccessibleInterface CellAt(int row, int column)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 4 * 4);
            var ___CellAt_0Delegate = (_CellAt_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_CellAt_0Delegate));
            var __ret = ___CellAt_0Delegate(__Instance, row, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        public override string ColumnDescription(int column)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 7 * 4);
            var ___ColumnDescription_0Delegate = (_ColumnDescription_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ColumnDescription_0Delegate));
            var __ret = new QtCore.QString.Internal();
            ___ColumnDescription_0Delegate(new IntPtr(&__ret), __Instance, column);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override string RowDescription(int row)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 8 * 4);
            var ___RowDescription_0Delegate = (_RowDescription_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_RowDescription_0Delegate));
            var __ret = new QtCore.QString.Internal();
            ___RowDescription_0Delegate(new IntPtr(&__ret), __Instance, row);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override bool IsColumnSelected(int column)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 15 * 4);
            var ___IsColumnSelected_0Delegate = (_IsColumnSelected_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_IsColumnSelected_0Delegate));
            var __ret = ___IsColumnSelected_0Delegate(__Instance, column);
            return __ret;
        }

        public override bool IsRowSelected(int row)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 16 * 4);
            var ___IsRowSelected_0Delegate = (_IsRowSelected_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_IsRowSelected_0Delegate));
            var __ret = ___IsRowSelected_0Delegate(__Instance, row);
            return __ret;
        }

        public override bool SelectRow(int row)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 17 * 4);
            var ___SelectRow_0Delegate = (_SelectRow_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectRow_0Delegate));
            var __ret = ___SelectRow_0Delegate(__Instance, row);
            return __ret;
        }

        public override bool SelectColumn(int column)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 18 * 4);
            var ___SelectColumn_0Delegate = (_SelectColumn_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectColumn_0Delegate));
            var __ret = ___SelectColumn_0Delegate(__Instance, column);
            return __ret;
        }

        public override bool UnselectRow(int row)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 19 * 4);
            var ___UnselectRow_0Delegate = (_UnselectRow_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_UnselectRow_0Delegate));
            var __ret = ___UnselectRow_0Delegate(__Instance, row);
            return __ret;
        }

        public override bool UnselectColumn(int column)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 20 * 4);
            var ___UnselectColumn_0Delegate = (_UnselectColumn_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_UnselectColumn_0Delegate));
            var __ret = ___UnselectColumn_0Delegate(__Instance, column);
            return __ret;
        }

        public override void ModelChange(QAccessibleTableModelChangeEvent _event)
        {
            void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 21 * 4);
            var ___ModelChange_0Delegate = (_ModelChange_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ModelChange_0Delegate));
            var arg0 = ReferenceEquals(_event, null) ? global::System.IntPtr.Zero : _event.__Instance;
            ___ModelChange_0Delegate(__Instance, arg0);
        }

        public override QAccessibleInterface Caption
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___Caption_0Delegate = (_Caption_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Caption_0Delegate));
                var __ret = ___Caption_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        public override QAccessibleInterface Summary
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 3 * 4);
                var ___Summary_0Delegate = (_Summary_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Summary_0Delegate));
                var __ret = ___Summary_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        public override int SelectedCellCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 5 * 4);
                var ___SelectedCellCount_0Delegate = (_SelectedCellCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectedCellCount_0Delegate));
                var __ret = ___SelectedCellCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override System.Collections.Generic.IList<QAccessibleInterface> SelectedCells
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 6 * 4);
                var ___SelectedCells_0Delegate = (_SelectedCells_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectedCells_0Delegate));
                var __ret = ___SelectedCells_0Delegate(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QAccessibleInterface>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QAccessibleInterfaceInternal.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        public override int SelectedColumnCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 9 * 4);
                var ___SelectedColumnCount_0Delegate = (_SelectedColumnCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectedColumnCount_0Delegate));
                var __ret = ___SelectedColumnCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int SelectedRowCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 10 * 4);
                var ___SelectedRowCount_0Delegate = (_SelectedRowCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectedRowCount_0Delegate));
                var __ret = ___SelectedRowCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int ColumnCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 11 * 4);
                var ___ColumnCount_0Delegate = (_ColumnCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ColumnCount_0Delegate));
                var __ret = ___ColumnCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override int RowCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 12 * 4);
                var ___RowCount_0Delegate = (_RowCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_RowCount_0Delegate));
                var __ret = ___RowCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override System.Collections.Generic.IList<int> SelectedColumns
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 13 * 4);
                var ___SelectedColumns_0Delegate = (_SelectedColumns_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectedColumns_0Delegate));
                var __ret = ___SelectedColumns_0Delegate(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<int>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(*(int*) __qlistData.At(i));
                }
                return __list;
            }
        }

        public override System.Collections.Generic.IList<int> SelectedRows
        {
            get
            {
                void* slot = *(void**) (((QAccessibleTableInterface.Internal*) __Instance)->vfptr0 + 14 * 4);
                var ___SelectedRows_0Delegate = (_SelectedRows_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SelectedRows_0Delegate));
                var __ret = ___SelectedRows_0Delegate(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<int>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(*(int*) __qlistData.At(i));
                }
                return __list;
            }
        }
    }

    internal unsafe partial class QAccessibleActionInterfaceInternal : QtGui.QAccessibleActionInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleActionInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleActionInterfaceInternal((QAccessibleActionInterface.Internal*) native);
        }

        public static QAccessibleActionInterface __CreateInstance(QAccessibleActionInterface.Internal native)
        {
            return new QAccessibleActionInterfaceInternal(native);
        }

        private static QAccessibleActionInterface.Internal* __CopyValue(QAccessibleActionInterface.Internal native)
        {
            var ret = (QAccessibleActionInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleActionInterfaceInternal(QAccessibleActionInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleActionInterfaceInternal(QAccessibleActionInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleActionInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override void DoAction(string actionName)
        {
            void* slot = *(void**) (((QAccessibleActionInterface.Internal*) __Instance)->vfptr0 + 5 * 4);
            var ___DoAction_0Delegate = (_DoAction_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_DoAction_0Delegate));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(actionName).ToPointer(), actionName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            ___DoAction_0Delegate(__Instance, arg0);
        }
    }

    internal unsafe partial class QAccessibleImageInterfaceInternal : QtGui.QAccessibleImageInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleImageInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleImageInterfaceInternal((QAccessibleImageInterface.Internal*) native);
        }

        public static QAccessibleImageInterface __CreateInstance(QAccessibleImageInterface.Internal native)
        {
            return new QAccessibleImageInterfaceInternal(native);
        }

        private static QAccessibleImageInterface.Internal* __CopyValue(QAccessibleImageInterface.Internal native)
        {
            var ret = (QAccessibleImageInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleImageInterfaceInternal(QAccessibleImageInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleImageInterfaceInternal(QAccessibleImageInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleImageInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override string ImageDescription
        {
            get
            {
                void* slot = *(void**) (((QAccessibleImageInterface.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___ImageDescription_0Delegate = (_ImageDescription_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ImageDescription_0Delegate));
                var __ret = new QtCore.QString.Internal();
                ___ImageDescription_0Delegate(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    public unsafe abstract partial class QAccessibleBridge : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessibleBridgeC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessibleBridgeD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleBridge(QAccessibleBridge.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public abstract void SetRootObject(QAccessibleInterface _194);

        public abstract void NotifyAccessibilityUpdate(QAccessibleEvent _event);

        #region Virtual table interop

        // void setRootObject(QAccessibleInterface *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetRootObject_0Delegate(global::System.IntPtr instance, global::System.IntPtr _194);
        private static _SetRootObject_0Delegate _SetRootObject_0DelegateInstance;

        private static void _SetRootObject_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _194)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleBridge) _References[instance].Target;
            target.SetRootObject((_194 == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(_194));
        }

        // void notifyAccessibilityUpdate(QAccessibleEvent *event)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _NotifyAccessibilityUpdate_0Delegate(global::System.IntPtr instance, global::System.IntPtr _event);
        private static _NotifyAccessibilityUpdate_0Delegate _NotifyAccessibilityUpdate_0DelegateInstance;

        private static void _NotifyAccessibilityUpdate_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _event)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleBridge) _References[instance].Target;
            target.NotifyAccessibilityUpdate((_event == IntPtr.Zero) ? null : QAccessibleEvent.__CreateInstance(_event));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _SetRootObject_0DelegateInstance += _SetRootObject_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetRootObject_0DelegateInstance).ToPointer();
                _NotifyAccessibilityUpdate_0DelegateInstance += _NotifyAccessibilityUpdate_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_NotifyAccessibilityUpdate_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = _Thunks[1];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe abstract partial class QAccessibleBridgePlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN23QAccessibleBridgePluginC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN23QAccessibleBridgePluginD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleBridgePlugin(QAccessibleBridgePlugin.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public abstract QAccessibleBridge Create(string key);

        #region Virtual table interop

        // ~QAccessibleBridgePlugin()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleBridgePlugin) _References[instance].Target;
            target.Dispose();
        }

        // QAccessibleBridge *create(const QString &key)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Create_0Delegate(global::System.IntPtr instance, global::System.IntPtr key);
        private static _Create_0Delegate _Create_0DelegateInstance;

        private static global::System.IntPtr _Create_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr key)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleBridgePlugin) _References[instance].Target;
            var _ret = target.Create(Marshal.PtrToStringUni(new IntPtr(new QString(key).Utf16)));
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Create_0DelegateInstance += _Create_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Create_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(12 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QAccessibleBridgeInternal : QtGui.QAccessibleBridge, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleBridgeInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleBridgeInternal((QAccessibleBridge.Internal*) native);
        }

        public static QAccessibleBridge __CreateInstance(QAccessibleBridge.Internal native)
        {
            return new QAccessibleBridgeInternal(native);
        }

        private static QAccessibleBridge.Internal* __CopyValue(QAccessibleBridge.Internal native)
        {
            var ret = (QAccessibleBridge.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAccessibleBridgeInternal(QAccessibleBridge.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleBridgeInternal(QAccessibleBridge.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleBridge.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override void SetRootObject(QAccessibleInterface _194)
        {
            void* slot = *(void**) (((QAccessibleBridge.Internal*) __Instance)->vfptr0 + 2 * 4);
            var ___SetRootObject_0Delegate = (_SetRootObject_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_SetRootObject_0Delegate));
            var arg0 = ReferenceEquals(_194, null) ? global::System.IntPtr.Zero : _194.__Instance;
            ___SetRootObject_0Delegate(__Instance, arg0);
        }

        public override void NotifyAccessibilityUpdate(QAccessibleEvent _event)
        {
            void* slot = *(void**) (((QAccessibleBridge.Internal*) __Instance)->vfptr0 + 3 * 4);
            var ___NotifyAccessibilityUpdate_0Delegate = (_NotifyAccessibilityUpdate_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_NotifyAccessibilityUpdate_0Delegate));
            var arg0 = ReferenceEquals(_event, null) ? global::System.IntPtr.Zero : _event.__Instance;
            ___NotifyAccessibilityUpdate_0Delegate(__Instance, arg0);
        }
    }

    internal unsafe partial class QAccessibleBridgePluginInternal : QtGui.QAccessibleBridgePlugin, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleBridgePluginInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleBridgePluginInternal((QAccessibleBridgePlugin.Internal*) native);
        }

        public static QAccessibleBridgePlugin __CreateInstance(QAccessibleBridgePlugin.Internal native)
        {
            return new QAccessibleBridgePluginInternal(native);
        }

        private static QAccessibleBridgePlugin.Internal* __CopyValue(QAccessibleBridgePlugin.Internal native)
        {
            var ret = (QAccessibleBridgePlugin.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QAccessibleBridgePluginInternal(QAccessibleBridgePlugin.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleBridgePluginInternal(QAccessibleBridgePlugin.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleBridgePlugin.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QAccessibleBridge Create(string key)
        {
            void* slot = *(void**) (((QAccessibleBridgePlugin.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___Create_0Delegate = (_Create_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Create_0Delegate));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = ___Create_0Delegate(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleBridgeInternal.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QAccessibleObject class implements parts of the
    /// QAccessibleInterface for QObjects.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is part of Accessibility for QWidget
    /// Applications.</para>
    /// <para>This class is mainly provided for convenience. All subclasses of
    /// the QAccessibleInterface that provide implementations of non-widget objects
    /// should use this class as their base class.</para>
    /// <para></para>
    /// <para>See also QAccessible and QAccessibleWidget.</para>
    /// </remarks>
    public unsafe abstract partial class QAccessibleObject : QtGui.QAccessibleInterface, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr d;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessibleObjectC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessibleObjectD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessibleObject7setTextEN11QAccessible4TextERK7QString")]
            internal static extern void SetText_0(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QAccessibleObject7childAtEii")]
            internal static extern global::System.IntPtr ChildAt_0(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QAccessibleObject7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        protected QAccessibleObject(QAccessibleObject.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleInterface.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Reimplemented from QAccessibleInterface::setText().</para>
        /// </summary>
        public override void SetText(QAccessible.Text t, string text)
        {
            var arg0 = t;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.SetText_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Reimplemented from QAccessibleInterface::childAt().</para>
        /// </summary>
        public override QAccessibleInterface ChildAt(int x, int y)
        {
            var __ret = Internal.ChildAt_0(__Instance, x, y);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Reimplemented from QAccessibleInterface::isValid().</para>
        /// </summary>
        public override bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QAccessibleObject()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            target.Dispose();
        }

        // bool isValid()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _IsValid_0Delegate(global::System.IntPtr instance);
        private static _IsValid_0Delegate _IsValid_0DelegateInstance;

        private static bool _IsValid_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.IsValid;
            return _ret;
        }

        // QWindow *window()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Window_0Delegate(global::System.IntPtr instance);
        private static _Window_0Delegate _Window_0DelegateInstance;

        private static global::System.IntPtr _Window_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.Window;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *focusChild()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _FocusChild_0Delegate(global::System.IntPtr instance);
        private static _FocusChild_0Delegate _FocusChild_0DelegateInstance;

        private static global::System.IntPtr _FocusChild_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.FocusChild();
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *childAt(int x, int y)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _ChildAt_0Delegate(global::System.IntPtr instance, int x, int y);
        private static _ChildAt_0Delegate _ChildAt_0DelegateInstance;

        private static global::System.IntPtr _ChildAt_0DelegateHook(global::System.IntPtr instance, int x, int y)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.ChildAt(x, y);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *parent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Parent_0Delegate(global::System.IntPtr instance);
        private static _Parent_0Delegate _Parent_0DelegateInstance;

        private static global::System.IntPtr _Parent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.Parent;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *child(int index)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Child_0Delegate(global::System.IntPtr instance, int index);
        private static _Child_0Delegate _Child_0DelegateInstance;

        private static global::System.IntPtr _Child_0DelegateHook(global::System.IntPtr instance, int index)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.Child(index);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int childCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ChildCount_0Delegate(global::System.IntPtr instance);
        private static _ChildCount_0Delegate _ChildCount_0DelegateInstance;

        private static int _ChildCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.ChildCount;
            return _ret;
        }

        // int indexOfChild(const QAccessibleInterface *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _IndexOfChild_0Delegate(global::System.IntPtr instance, global::System.IntPtr child);
        private static _IndexOfChild_0Delegate _IndexOfChild_0DelegateInstance;

        private static int _IndexOfChild_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr child)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.IndexOfChild((child == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(child));
            return _ret;
        }

        // QString text(QAccessible::Text t)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _Text_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, QAccessible.Text t);
        private static _Text_0Delegate _Text_0DelegateInstance;

        private static QString.Internal _Text_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, QAccessible.Text t)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.Text(t);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // void setText(QAccessible::Text t, const QString &text)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetText_0Delegate(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text);
        private static _SetText_0Delegate _SetText_0DelegateInstance;

        private static void _SetText_0DelegateHook(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            target.SetText(t, Marshal.PtrToStringUni(new IntPtr(new QString(text).Utf16)));
        }

        // QAccessible::Role role()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QAccessible.Role _Role_0Delegate(global::System.IntPtr instance);
        private static _Role_0Delegate _Role_0DelegateInstance;

        private static QAccessible.Role _Role_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.Role;
            return _ret;
        }

        // QAccessible::State state()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QAccessible.State.Internal _State_0Delegate(global::System.IntPtr instance);
        private static _State_0Delegate _State_0DelegateInstance;

        private static QAccessible.State.Internal _State_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.State;
            return ReferenceEquals(_ret, null) ? new QAccessible.State.Internal() : *(QAccessible.State.Internal*) (_ret.__Instance);
        }

        // QColor foregroundColor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QColor.Internal _ForegroundColor_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _ForegroundColor_0Delegate _ForegroundColor_0DelegateInstance;

        private static QColor.Internal _ForegroundColor_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.ForegroundColor;
            return ReferenceEquals(_ret, null) ? new QColor.Internal() : *(QColor.Internal*) (_ret.__Instance);
        }

        // QColor backgroundColor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QColor.Internal _BackgroundColor_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _BackgroundColor_0Delegate _BackgroundColor_0DelegateInstance;

        private static QColor.Internal _BackgroundColor_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            var _ret = target.BackgroundColor;
            return ReferenceEquals(_ret, null) ? new QColor.Internal() : *(QColor.Internal*) (_ret.__Instance);
        }

        // void virtual_hook(int id, void *data)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Virtual_hook_0Delegate(global::System.IntPtr instance, int id, global::System.IntPtr data);
        private static _Virtual_hook_0Delegate _Virtual_hook_0DelegateInstance;

        private static void _Virtual_hook_0DelegateHook(global::System.IntPtr instance, int id, global::System.IntPtr data)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleObject) _References[instance].Target;
            target.Virtual_hook(id, data);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[16];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsValid_0DelegateInstance += _IsValid_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsValid_0DelegateInstance).ToPointer();
                _Window_0DelegateInstance += _Window_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Window_0DelegateInstance).ToPointer();
                _FocusChild_0DelegateInstance += _FocusChild_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_FocusChild_0DelegateInstance).ToPointer();
                _ChildAt_0DelegateInstance += _ChildAt_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ChildAt_0DelegateInstance).ToPointer();
                _Parent_0DelegateInstance += _Parent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Parent_0DelegateInstance).ToPointer();
                _Child_0DelegateInstance += _Child_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_Child_0DelegateInstance).ToPointer();
                _ChildCount_0DelegateInstance += _ChildCount_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_ChildCount_0DelegateInstance).ToPointer();
                _IndexOfChild_0DelegateInstance += _IndexOfChild_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_IndexOfChild_0DelegateInstance).ToPointer();
                _Text_0DelegateInstance += _Text_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_Text_0DelegateInstance).ToPointer();
                _SetText_0DelegateInstance += _SetText_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_SetText_0DelegateInstance).ToPointer();
                _Role_0DelegateInstance += _Role_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_Role_0DelegateInstance).ToPointer();
                _State_0DelegateInstance += _State_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_State_0DelegateInstance).ToPointer();
                _ForegroundColor_0DelegateInstance += _ForegroundColor_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_ForegroundColor_0DelegateInstance).ToPointer();
                _BackgroundColor_0DelegateInstance += _BackgroundColor_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_BackgroundColor_0DelegateInstance).ToPointer();
                _Virtual_hook_0DelegateInstance += _Virtual_hook_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_Virtual_hook_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(20 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = _Thunks[1];
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = _Thunks[3];
                *(void**)(vfptr0 + 28) = _Thunks[4];
                *(void**)(vfptr0 + 32) = _Thunks[5];
                *(void**)(vfptr0 + 36) = _Thunks[6];
                *(void**)(vfptr0 + 40) = _Thunks[7];
                *(void**)(vfptr0 + 44) = _Thunks[8];
                *(void**)(vfptr0 + 48) = _Thunks[9];
                *(void**)(vfptr0 + 52) = _Thunks[10];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[11];
                *(void**)(vfptr0 + 64) = _Thunks[12];
                *(void**)(vfptr0 + 68) = _Thunks[13];
                *(void**)(vfptr0 + 72) = _Thunks[14];
                *(void**)(vfptr0 + 76) = _Thunks[15];
                *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QAccessibleApplication : QtGui.QAccessibleObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr d;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QAccessibleApplicationC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QAccessibleApplicationC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN22QAccessibleApplicationD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication12indexOfChildEPK20QAccessibleInterface")]
            internal static extern int IndexOfChild_0(global::System.IntPtr instance, global::System.IntPtr _199);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication10focusChildEv")]
            internal static extern global::System.IntPtr FocusChild_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication5childEi")]
            internal static extern global::System.IntPtr Child_0(global::System.IntPtr instance, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication4textEN11QAccessible4TextE")]
            internal static extern void Text_0(global::System.IntPtr _return, global::System.IntPtr instance, QAccessible.Text t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication6windowEv")]
            internal static extern global::System.IntPtr Window_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication10childCountEv")]
            internal static extern int ChildCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication6parentEv")]
            internal static extern global::System.IntPtr Parent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication4roleEv")]
            internal static extern QAccessible.Role Role_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK22QAccessibleApplication5stateEv")]
            internal static extern QAccessible.State.Internal State_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static QAccessibleApplication __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleApplication((QAccessibleApplication.Internal*) native);
        }

        public static QAccessibleApplication __CreateInstance(QAccessibleApplication.Internal native)
        {
            return new QAccessibleApplication(native);
        }

        private static QAccessibleApplication.Internal* __CopyValue(QAccessibleApplication.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QAccessibleApplication.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QAccessibleApplication.Internal*) ret;
        }

        private QAccessibleApplication(QAccessibleApplication.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleApplication(QAccessibleApplication.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleObject.Internal*) native)
        {
        }

        public QAccessibleApplication()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override int IndexOfChild(QAccessibleInterface _199)
        {
            var arg0 = ReferenceEquals(_199, null) ? global::System.IntPtr.Zero : _199.__Instance;
            var __ret = Internal.IndexOfChild_0(__Instance, arg0);
            return __ret;
        }

        public override QAccessibleInterface FocusChild()
        {
            var __ret = Internal.FocusChild_0(__Instance);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        public override QAccessibleInterface Child(int index)
        {
            var __ret = Internal.Child_0(__Instance, index);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        public override string Text(QAccessible.Text t)
        {
            var arg0 = t;
            var __ret = new QtCore.QString.Internal();
            Internal.Text_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override QWindow Window
        {
            get
            {
                var __ret = Internal.Window_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
            }
        }

        public override int ChildCount
        {
            get
            {
                var __ret = Internal.ChildCount_0(__Instance);
                return __ret;
            }
        }

        public override QAccessibleInterface Parent
        {
            get
            {
                var __ret = Internal.Parent_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        public override QAccessible.Role Role
        {
            get
            {
                var __ret = Internal.Role_0(__Instance);
                return __ret;
            }
        }

        public override QAccessible.State State
        {
            get
            {
                var __ret = Internal.State_0(__Instance);
                return QAccessible.State.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // bool isValid()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _IsValid_0Delegate(global::System.IntPtr instance);
        private static _IsValid_0Delegate _IsValid_0DelegateInstance;

        private static bool _IsValid_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.IsValid;
            return _ret;
        }

        // QWindow *window()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Window_0Delegate(global::System.IntPtr instance);
        private static _Window_0Delegate _Window_0DelegateInstance;

        private static global::System.IntPtr _Window_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.Window;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *focusChild()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _FocusChild_0Delegate(global::System.IntPtr instance);
        private static _FocusChild_0Delegate _FocusChild_0DelegateInstance;

        private static global::System.IntPtr _FocusChild_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.FocusChild();
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *childAt(int x, int y)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _ChildAt_0Delegate(global::System.IntPtr instance, int x, int y);
        private static _ChildAt_0Delegate _ChildAt_0DelegateInstance;

        private static global::System.IntPtr _ChildAt_0DelegateHook(global::System.IntPtr instance, int x, int y)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.ChildAt(x, y);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *parent()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Parent_0Delegate(global::System.IntPtr instance);
        private static _Parent_0Delegate _Parent_0DelegateInstance;

        private static global::System.IntPtr _Parent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.Parent;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QAccessibleInterface *child(int index)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Child_0Delegate(global::System.IntPtr instance, int index);
        private static _Child_0Delegate _Child_0DelegateInstance;

        private static global::System.IntPtr _Child_0DelegateHook(global::System.IntPtr instance, int index)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.Child(index);
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int childCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ChildCount_0Delegate(global::System.IntPtr instance);
        private static _ChildCount_0Delegate _ChildCount_0DelegateInstance;

        private static int _ChildCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.ChildCount;
            return _ret;
        }

        // int indexOfChild(const QAccessibleInterface*)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _IndexOfChild_0Delegate(global::System.IntPtr instance, global::System.IntPtr _199);
        private static _IndexOfChild_0Delegate _IndexOfChild_0DelegateInstance;

        private static int _IndexOfChild_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _199)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.IndexOfChild((_199 == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(_199));
            return _ret;
        }

        // QString text(QAccessible::Text t)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _Text_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return, QAccessible.Text t);
        private static _Text_0Delegate _Text_0DelegateInstance;

        private static QString.Internal _Text_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return, QAccessible.Text t)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.Text(t);
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // void setText(QAccessible::Text t, const QString &text)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetText_0Delegate(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text);
        private static _SetText_0Delegate _SetText_0DelegateInstance;

        private static void _SetText_0DelegateHook(global::System.IntPtr instance, QAccessible.Text t, global::System.IntPtr text)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            target.SetText(t, Marshal.PtrToStringUni(new IntPtr(new QString(text).Utf16)));
        }

        // QAccessible::Role role()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QAccessible.Role _Role_0Delegate(global::System.IntPtr instance);
        private static _Role_0Delegate _Role_0DelegateInstance;

        private static QAccessible.Role _Role_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.Role;
            return _ret;
        }

        // QAccessible::State state()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QAccessible.State.Internal _State_0Delegate(global::System.IntPtr instance);
        private static _State_0Delegate _State_0DelegateInstance;

        private static QAccessible.State.Internal _State_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.State;
            return ReferenceEquals(_ret, null) ? new QAccessible.State.Internal() : *(QAccessible.State.Internal*) (_ret.__Instance);
        }

        // QColor foregroundColor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QColor.Internal _ForegroundColor_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _ForegroundColor_0Delegate _ForegroundColor_0DelegateInstance;

        private static QColor.Internal _ForegroundColor_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.ForegroundColor;
            return ReferenceEquals(_ret, null) ? new QColor.Internal() : *(QColor.Internal*) (_ret.__Instance);
        }

        // QColor backgroundColor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QColor.Internal _BackgroundColor_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _BackgroundColor_0Delegate _BackgroundColor_0DelegateInstance;

        private static QColor.Internal _BackgroundColor_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            var _ret = target.BackgroundColor;
            return ReferenceEquals(_ret, null) ? new QColor.Internal() : *(QColor.Internal*) (_ret.__Instance);
        }

        // void virtual_hook(int id, void *data)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Virtual_hook_0Delegate(global::System.IntPtr instance, int id, global::System.IntPtr data);
        private static _Virtual_hook_0Delegate _Virtual_hook_0DelegateInstance;

        private static void _Virtual_hook_0DelegateHook(global::System.IntPtr instance, int id, global::System.IntPtr data)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessibleApplication) _References[instance].Target;
            target.Virtual_hook(id, data);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[15];
                _IsValid_0DelegateInstance += _IsValid_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_IsValid_0DelegateInstance).ToPointer();
                _Window_0DelegateInstance += _Window_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Window_0DelegateInstance).ToPointer();
                _FocusChild_0DelegateInstance += _FocusChild_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_FocusChild_0DelegateInstance).ToPointer();
                _ChildAt_0DelegateInstance += _ChildAt_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ChildAt_0DelegateInstance).ToPointer();
                _Parent_0DelegateInstance += _Parent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Parent_0DelegateInstance).ToPointer();
                _Child_0DelegateInstance += _Child_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Child_0DelegateInstance).ToPointer();
                _ChildCount_0DelegateInstance += _ChildCount_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ChildCount_0DelegateInstance).ToPointer();
                _IndexOfChild_0DelegateInstance += _IndexOfChild_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_IndexOfChild_0DelegateInstance).ToPointer();
                _Text_0DelegateInstance += _Text_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_Text_0DelegateInstance).ToPointer();
                _SetText_0DelegateInstance += _SetText_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_SetText_0DelegateInstance).ToPointer();
                _Role_0DelegateInstance += _Role_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_Role_0DelegateInstance).ToPointer();
                _State_0DelegateInstance += _State_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_State_0DelegateInstance).ToPointer();
                _ForegroundColor_0DelegateInstance += _ForegroundColor_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_ForegroundColor_0DelegateInstance).ToPointer();
                _BackgroundColor_0DelegateInstance += _BackgroundColor_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_BackgroundColor_0DelegateInstance).ToPointer();
                _Virtual_hook_0DelegateInstance += _Virtual_hook_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_Virtual_hook_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(20 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = _Thunks[0];
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = _Thunks[1];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = _Thunks[2];
                *(void**)(vfptr0 + 28) = _Thunks[3];
                *(void**)(vfptr0 + 32) = _Thunks[4];
                *(void**)(vfptr0 + 36) = _Thunks[5];
                *(void**)(vfptr0 + 40) = _Thunks[6];
                *(void**)(vfptr0 + 44) = _Thunks[7];
                *(void**)(vfptr0 + 48) = _Thunks[8];
                *(void**)(vfptr0 + 52) = _Thunks[9];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[10];
                *(void**)(vfptr0 + 64) = _Thunks[11];
                *(void**)(vfptr0 + 68) = _Thunks[12];
                *(void**)(vfptr0 + 72) = _Thunks[13];
                *(void**)(vfptr0 + 76) = _Thunks[14];
                *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QAccessibleObjectInternal : QtGui.QAccessibleObject, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessibleObjectInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessibleObjectInternal((QAccessibleObject.Internal*) native);
        }

        public static QAccessibleObject __CreateInstance(QAccessibleObject.Internal native)
        {
            return new QAccessibleObjectInternal(native);
        }

        private static QAccessibleObject.Internal* __CopyValue(QAccessibleObject.Internal native)
        {
            var ret = (QAccessibleObject.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QAccessibleObjectInternal(QAccessibleObject.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessibleObjectInternal(QAccessibleObject.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessibleObject.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QAccessibleInterface Child(int index)
        {
            void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 9 * 4);
            var ___Child_0Delegate = (_Child_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Child_0Delegate));
            var __ret = ___Child_0Delegate(__Instance, index);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
        }

        public override int IndexOfChild(QAccessibleInterface _0)
        {
            void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 11 * 4);
            var ___IndexOfChild_0Delegate = (_IndexOfChild_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_IndexOfChild_0Delegate));
            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = ___IndexOfChild_0Delegate(__Instance, arg0);
            return __ret;
        }

        public override string Text(QAccessible.Text t)
        {
            void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___Text_0Delegate = (_Text_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Text_0Delegate));
            var arg0 = t;
            var __ret = new QtCore.QString.Internal();
            ___Text_0Delegate(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        public override QAccessibleInterface Parent
        {
            get
            {
                void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 8 * 4);
                var ___Parent_0Delegate = (_Parent_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Parent_0Delegate));
                var __ret = ___Parent_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        public override int ChildCount
        {
            get
            {
                void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 10 * 4);
                var ___ChildCount_0Delegate = (_ChildCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ChildCount_0Delegate));
                var __ret = ___ChildCount_0Delegate(__Instance);
                return __ret;
            }
        }

        public override QAccessible.Role Role
        {
            get
            {
                void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 15 * 4);
                var ___Role_0Delegate = (_Role_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Role_0Delegate));
                var __ret = ___Role_0Delegate(__Instance);
                return __ret;
            }
        }

        public override QAccessible.State State
        {
            get
            {
                void* slot = *(void**) (((QAccessibleObject.Internal*) __Instance)->vfptr0 + 16 * 4);
                var ___State_0Delegate = (_State_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_State_0Delegate));
                var __ret = ___State_0Delegate(__Instance);
                return QAccessible.State.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QAccessiblePlugin class provides an abstract base class for
    /// plugins provinding accessibility information for user interface
    /// elements.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Writing an accessibility plugin is achieved by subclassing this
    /// base class, reimplementing the pure virtual function create(), and
    /// exporting the class with the Q_PLUGIN_METADATA() macro.</para>
    /// <para></para>
    /// <para>See also How to Create Qt Plugins.</para>
    /// </remarks>
    public unsafe abstract partial class QAccessiblePlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessiblePluginC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAccessiblePluginD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAccessiblePlugin(QAccessiblePlugin.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QAccessiblePlugin()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAccessiblePlugin) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(12 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QAccessiblePluginInternal : QtGui.QAccessiblePlugin, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAccessiblePluginInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAccessiblePluginInternal((QAccessiblePlugin.Internal*) native);
        }

        public static QAccessiblePlugin __CreateInstance(QAccessiblePlugin.Internal native)
        {
            return new QAccessiblePluginInternal(native);
        }

        private static QAccessiblePlugin.Internal* __CopyValue(QAccessiblePlugin.Internal native)
        {
            var ret = (QAccessiblePlugin.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QAccessiblePluginInternal(QAccessiblePlugin.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAccessiblePluginInternal(QAccessiblePlugin.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAccessiblePlugin.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QPaintDevice class is the base class of objects that can be
    /// painted on with QPainter.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A paint device is an abstraction of a two-dimensional space that
    /// can be drawn on using a QPainter. Its default coordinate system has its
    /// origin located at the top-left position. X increases to the right and Y
    /// increases downwards. The unit is one pixel.</para>
    /// <para>The drawing capabilities of QPaintDevice are currently
    /// implemented by the QWidget, QImage, QPixmap, QGLPixelBuffer, QPicture, and
    /// QPrinter subclasses.</para>
    /// <para>To implement support for a new backend, you must derive from
    /// QPaintDevice and reimplement the virtual paintEngine() function to tell
    /// QPainter which paint engine should be used to draw on this particular
    /// device. Note that you also must create a corresponding paint engine to be
    /// able to draw on the device, i.e derive from QPaintEngine and reimplement
    /// its virtual functions.</para>
    /// <para>Warning: Qt requires that a QGuiApplication object exists before
    /// any paint devices can be created. Paint devices access window system
    /// resources, and these resources are not initialized before an application
    /// object is created.</para>
    /// <para>The QPaintDevice class provides several functions returning the
    /// various device metrics: The depth() function returns its bit depth (number
    /// of bit planes). The height() function returns its height in default
    /// coordinate system units (e.g. pixels for QPixmap and QWidget) while
    /// heightMM() returns the height of the device in millimeters. Similiarily,
    /// the width() and widthMM() functions return the width of the device in
    /// default coordinate system units and in millimeters, respectively.
    /// Alternatively, the protected metric() function can be used to retrieve the
    /// metric information by specifying the desired PaintDeviceMetric as
    /// argument.</para>
    /// <para>The logicalDpiX() and logicalDpiY() functions return the
    /// horizontal and vertical resolution of the device in dots per inch. The
    /// physicalDpiX() and physicalDpiY() functions also return the resolution of
    /// the device in dots per inch, but note that if the logical and physical
    /// resolution differ, the corresponding QPaintEngine must handle the mapping.
    /// Finally, the colorCount() function returns the number of different colors
    /// available for the paint device.</para>
    /// <para></para>
    /// <para>See also QPaintEngine, QPainter, Coordinate System, and Paint
    /// System.</para>
    /// </remarks>
    public unsafe abstract partial class QPaintDevice : QtGui.IQPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintDeviceC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintDeviceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintDeviceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice11initPainterEP8QPainter")]
            internal static extern void InitPainter_0(global::System.IntPtr instance, global::System.IntPtr painter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice11initPainterEP8QPainter")]
            internal static extern void InitPainter_0(global::System.IntPtr instance, global::System.IntPtr painter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice6metricENS_17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z22qt_paint_device_metricPK12QPaintDeviceNS_17PaintDeviceMetricE")]
            internal static extern int Qt_paint_device_metric_0(global::System.IntPtr device, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice13sharedPainterEv")]
            internal static extern global::System.IntPtr SharedPainter_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Describes the various metrics of a paint device.</para>
        /// <para>See also metric().</para>
        /// </summary>
        public enum PaintDeviceMetric : uint
        {
            /// <summary>The width of the paint device in default coordinate system units (e.g. pixels for QPixmap and QWidget). See also width().</summary>
            PdmWidth = 1,
            /// <summary>The height of the paint device in default coordinate system units (e.g. pixels for QPixmap and QWidget). See also height().</summary>
            PdmHeight = 2,
            /// <summary>The width of the paint device in millimeters. See also widthMM().</summary>
            PdmWidthMM = 3,
            /// <summary>The height of the paint device in millimeters. See also heightMM().</summary>
            PdmHeightMM = 4,
            /// <summary>The number of different colors available for the paint device. See also colorCount().</summary>
            PdmNumColors = 5,
            /// <summary>The bit depth (number of bit planes) of the paint device. See also depth().</summary>
            PdmDepth = 6,
            /// <summary>The horizontal resolution of the device in dots per inch. See also logicalDpiX().</summary>
            PdmDpiX = 7,
            /// <summary>The vertical resolution of the device in dots per inch. See also logicalDpiY().</summary>
            PdmDpiY = 8,
            /// <summary>The horizontal resolution of the device in dots per inch. See also physicalDpiX().</summary>
            PdmPhysicalDpiX = 9,
            /// <summary>The vertical resolution of the device in dots per inch. See also physicalDpiY().</summary>
            PdmPhysicalDpiY = 10,
            /// <summary>The device pixel ratio for device. Common values are 1 for normal-dpi displays and 2 for high-dpi "retina" displays.</summary>
            PdmDevicePixelRatio = 11
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QPaintDevice(QPaintDevice.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a paint device. This constructor can be invoked only
        /// from subclasses of QPaintDevice.</para>
        /// </summary>
        protected QPaintDevice()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected virtual void InitPainter(QPainter painter)
        {
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            Internal.InitPainter_0(__Instance, arg0);
        }

        protected virtual void InitPainter(QPainter painter)
        {
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            Internal.InitPainter_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns the metric information for the given paint device
        /// metric.</para>
        /// <para>See also PaintDeviceMetric.</para>
        /// </summary>
        protected virtual int Metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        public static int Qt_paint_device_metric(QPaintDevice device, QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var arg1 = metric;
            var __ret = Internal.Qt_paint_device_metric_0(arg0, arg1);
            return __ret;
        }

        public virtual QPainter SharedPainter
        {
            get
            {
                var __ret = Internal.SharedPainter_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPainter.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the paint engine used for drawing on the
        /// device.</para>
        /// </summary>
        public abstract QPaintEngine PaintEngine
        {
            get;
        }

        #region Virtual table interop

        // virtual ~QPaintDevice()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDevice) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDevice) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDevice) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDevice) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDevice) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QPaintDeviceInternal : QtGui.QPaintDevice, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QPaintDeviceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QPaintDeviceInternal((QPaintDevice.Internal*) native);
        }

        public static QPaintDevice __CreateInstance(QPaintDevice.Internal native)
        {
            return new QPaintDeviceInternal(native);
        }

        private static QPaintDevice.Internal* __CopyValue(QPaintDevice.Internal native)
        {
            var ret = (QPaintDevice.Internal*) Marshal.AllocHGlobal(12);
            *ret = native;
            return ret;
        }

        private QPaintDeviceInternal(QPaintDevice.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPaintDeviceInternal(QPaintDevice.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDevice.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QPaintEngine PaintEngine
        {
            get
            {
                void* slot = *(void**) (((QPaintDevice.Internal*) __Instance)->vfptr0 + 3 * 4);
                var ___PaintEngine_0Delegate = (_PaintEngine_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_PaintEngine_0Delegate));
                var __ret = ___PaintEngine_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial interface IQPaintDevice
    {
        global::System.IntPtr __Instance { get; }

        QPainter SharedPainter { get; }

        QPaintEngine PaintEngine { get; }
    }

    /// <summary>
    /// <para>The QPolygon class provides a vector of points using integer
    /// precision.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A QPolygon object is a QVector&lt;QPoint&gt;. The easiest way to
    /// add points to a QPolygon is to use QVector's streaming operator, as
    /// illustrated below:</para>
    /// <para>        QPolygon polygon;</para>
    /// <para>        polygon &lt;&lt; QPoint(10, 20) &lt;&lt; QPoint(20,
    /// 30);</para>
    /// <para>In addition to the functions provided by QVector, QPolygon
    /// provides some point-specific functions.</para>
    /// <para>Each point in a polygon can be retrieved by passing its index to
    /// the point() function. To populate the polygon, QPolygon provides the
    /// setPoint() function to set the point at a given index, the setPoints()
    /// function to set all the points in the polygon (resizing it to the given
    /// number of points), and the putPoints() function which copies a number of
    /// given points into the polygon from a specified index (resizing the polygon
    /// if necessary).</para>
    /// <para>QPolygon provides the boundingRect() and translate() functions
    /// for geometry functions. Use the QMatrix::map() function for more general
    /// transformations of QPolygons.</para>
    /// <para>The QPolygon class is implicitly shared.</para>
    /// <para></para>
    /// <para>See also QVector, QPolygonF, and QLine.</para>
    /// </remarks>
    public unsafe partial class QPolygon : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygonC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygonC2EiPKi")]
            internal static extern void ctor_5(global::System.IntPtr instance, int nPoints, int* points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygonD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygon9translateEii")]
            internal static extern void Translate_0(global::System.IntPtr instance, int dx, int dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPolygon10translatedEii")]
            internal static extern void Translated_0(global::System.IntPtr @return, global::System.IntPtr instance, int dx, int dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPolygon5pointEiPiS0_")]
            internal static extern void Point_0(global::System.IntPtr instance, int i, int* x, int* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygon9setPointsEiPKi")]
            internal static extern void SetPoints_0(global::System.IntPtr instance, int nPoints, int* points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8QPolygon9setPointsEiiiz")]
            internal static extern void SetPoints_1(global::System.IntPtr instance, int nPoints, int firstx, int firsty);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygon9putPointsEiiPKi")]
            internal static extern void PutPoints_0(global::System.IntPtr instance, int index, int nPoints, int* points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8QPolygon9putPointsEiiiiz")]
            internal static extern void PutPoints_1(global::System.IntPtr instance, int index, int nPoints, int firstx, int firsty);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPolygon9putPointsEiiRKS_i")]
            internal static extern void PutPoints_2(global::System.IntPtr instance, int index, int nPoints, global::System.IntPtr from, int fromIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPolygon6unitedERKS_")]
            internal static extern void United_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPolygon11intersectedERKS_")]
            internal static extern void Intersected_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPolygon10subtractedERKS_")]
            internal static extern void Subtracted_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPolygon __CreateInstance(global::System.IntPtr native)
        {
            return new QPolygon((QPolygon.Internal*) native);
        }

        public static QPolygon __CreateInstance(QPolygon.Internal native)
        {
            return new QPolygon(native);
        }

        private static QPolygon.Internal* __CopyValue(QPolygon.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QPolygon.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QPolygon.Internal*) ret;
        }

        private QPolygon(QPolygon.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPolygon(QPolygon.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public QPolygon(int nPoints, int* points)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg1 = points;
            Internal.ctor_5(__Instance, nPoints, arg1);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Translates all points in the polygon by (dx, dy).</para>
        /// <para>See also translated().</para>
        /// </summary>
        public void Translate(int dx, int dy)
        {
            Internal.Translate_0(__Instance, dx, dy);
        }

        /// <summary>
        /// <para>Returns a copy of the polygon that is translated by (dx,
        /// dy).</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also translate().</para>
        /// </summary>
        public QPolygon Translated(int dx, int dy)
        {
            var __ret = new QtGui.QPolygon.Internal();
            Internal.Translated_0(new IntPtr(&__ret), __Instance, dx, dy);
            return QPolygon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Extracts the coordinates of the point at the given index to *x
        /// and *y (if they are valid pointers).</para>
        /// <para>See also setPoint().</para>
        /// </summary>
        public void Point(int i, int* x, int* y)
        {
            var arg1 = x;
            var arg2 = y;
            Internal.Point_0(__Instance, i, arg1, arg2);
        }

        /// <summary>
        /// <para>Resizes the polygon to nPoints and populates it with the given
        /// points.</para>
        /// <para>The example code creates a polygon with two points (10, 20) and
        /// (30, 40):</para>
        /// <para>        static const int points[] = { 10, 20, 30, 40 };</para>
        /// <para>        QPolygon polygon;</para>
        /// <para>        polygon.setPoints(2, points);</para>
        /// <para>See also setPoint() and putPoints().</para>
        /// </summary>
        public void SetPoints(int nPoints, int* points)
        {
            var arg1 = points;
            Internal.SetPoints_0(__Instance, nPoints, arg1);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Resizes the polygon to nPoints and populates it with the points
        /// specified by the variable argument list. The points are given as a sequence
        /// of integers, starting with firstx then firsty, and so on.</para>
        /// <para>The example code creates a polygon with two points (10, 20) and
        /// (30, 40):</para>
        /// <para>        QPolygon polygon;</para>
        /// <para>        polygon.setPoints(2, 10, 20, 30, 40);</para>
        /// </summary>
        public void SetPoints(int nPoints, int firstx, int firsty)
        {
            Internal.SetPoints_1(__Instance, nPoints, firstx, firsty);
        }

        public void PutPoints(int index, int nPoints, int* points)
        {
            var arg2 = points;
            Internal.PutPoints_0(__Instance, index, nPoints, arg2);
        }

        /// <summary>
        /// <para>Copies nPoints points from the variable argument list into this
        /// polygon from the given index.</para>
        /// <para>The points are given as a sequence of integers, starting with
        /// firstx then firsty, and so on. The polygon is resized if index+nPoints
        /// exceeds its current size.</para>
        /// <para>The example code creates a polygon with three points (4,5), (6,7)
        /// and (8,9), by expanding the polygon from 1 to 3 points:</para>
        /// <para>        QPolygon polygon(1);</para>
        /// <para>        polygon[0] = QPoint(4, 5);</para>
        /// <para>        polygon.putPoints(1, 2, 6,7, 8,9);</para>
        /// <para>The following code has the same result, but here the putPoints()
        /// function overwrites rather than extends:</para>
        /// <para>        QPolygon polygon(3);</para>
        /// <para>        polygon.putPoints(0, 3, 4,5, 0,0, 8,9);</para>
        /// <para>        polygon.putPoints(1, 1, 6,7);</para>
        /// <para>See also setPoints().</para>
        /// </summary>
        public void PutPoints(int index, int nPoints, int firstx, int firsty)
        {
            Internal.PutPoints_1(__Instance, index, nPoints, firstx, firsty);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Copies nPoints points from the given fromIndex ( 0 by default) in
        /// fromPolygon into this polygon, starting at the specified index. For
        /// example:</para>
        /// <para>        QPolygon polygon1;</para>
        /// <para>        polygon1.putPoints(0, 3, 1,2, 0,0, 5,6);</para>
        /// <para>        // polygon1 is now the three-point polygon(1,2, 0,0,
        /// 5,6);</para>
        /// <para></para>
        /// <para>        QPolygon polygon2;</para>
        /// <para>        polygon2.putPoints(0, 3, 4,4, 5,5, 6,6);</para>
        /// <para>        // polygon2 is now (4,4, 5,5, 6,6);</para>
        /// <para></para>
        /// <para>        polygon1.putPoints(2, 3, polygon2);</para>
        /// <para>        // polygon1 is now the five-point polygon(1,2, 0,0, 4,4,
        /// 5,5, 6,6);</para>
        /// </summary>
        public void PutPoints(int index, int nPoints, QPolygon from, int fromIndex = 0)
        {
            var arg2 = ReferenceEquals(from, null) ? global::System.IntPtr.Zero : from.__Instance;
            Internal.PutPoints_2(__Instance, index, nPoints, arg2, fromIndex);
        }

        /// <summary>
        /// <para>Returns a polygon which is the union of this polygon and
        /// r.</para>
        /// <para>Set operations on polygons, will treat the polygons as areas, and
        /// implicitly close the polygon.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also intersected() and subtracted().</para>
        /// </summary>
        public QPolygon United(QPolygon r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPolygon.Internal();
            Internal.United_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a polygon which is the intersection of this polygon and
        /// r.</para>
        /// <para>Set operations on polygons will treat the polygons as areas.
        /// Non-closed polygons will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public QPolygon Intersected(QPolygon r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPolygon.Internal();
            Internal.Intersected_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a polygon which is r subtracted from this polygon.</para>
        /// <para>Set operations on polygons will treat the polygons as areas.
        /// Non-closed polygons will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public QPolygon Subtracted(QPolygon r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPolygon.Internal();
            Internal.Subtracted_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygon.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QPolygonF class provides a vector of points using floating
    /// point precision.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A QPolygonF is a QVector&lt;QPointF&gt;. The easiest way to add
    /// points to a QPolygonF is to use its streaming operator, as illustrated
    /// below:</para>
    /// <para>        QPolygonF polygon;</para>
    /// <para>        polygon &lt;&lt; QPointF(10.4, 20.5) &lt;&lt;
    /// QPointF(20.2, 30.2);</para>
    /// <para>In addition to the functions provided by QVector, QPolygonF
    /// provides the boundingRect() and translate() functions for geometry
    /// operations. Use the QMatrix::map() function for more general
    /// transformations of QPolygonFs.</para>
    /// <para>QPolygonF also provides the isClosed() function to determine
    /// whether a polygon's start and end points are the same, and the toPolygon()
    /// function returning an integer precision copy of this polygon.</para>
    /// <para>The QPolygonF class is implicitly shared.</para>
    /// <para></para>
    /// <para>See also QVector, QPolygon, and QLineF.</para>
    /// </remarks>
    public unsafe partial class QPolygonF : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPolygonFC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPolygonFC2ERK8QPolygon")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPolygonFD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPolygonF9toPolygonEv")]
            internal static extern void ToPolygon_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPolygonF6unitedERKS_")]
            internal static extern void United_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPolygonF11intersectedERKS_")]
            internal static extern void Intersected_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPolygonF10subtractedERKS_")]
            internal static extern void Subtracted_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPolygonF __CreateInstance(global::System.IntPtr native)
        {
            return new QPolygonF((QPolygonF.Internal*) native);
        }

        public static QPolygonF __CreateInstance(QPolygonF.Internal native)
        {
            return new QPolygonF(native);
        }

        private static QPolygonF.Internal* __CopyValue(QPolygonF.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QPolygonF.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QPolygonF.Internal*) ret;
        }

        private QPolygonF(QPolygonF.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPolygonF(QPolygonF.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a float based polygon from the specified integer based
        /// polygon.</para>
        /// <para>See also toPolygon().</para>
        /// </summary>
        public QPolygonF(QPolygon a)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            Internal.ctor_5(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Creates and returns a QPolygon by converting each QPointF to a
        /// QPoint.</para>
        /// <para>See also QPointF::toPoint().</para>
        /// </summary>
        public QPolygon ToPolygon()
        {
            var __ret = new QtGui.QPolygon.Internal();
            Internal.ToPolygon_0(new IntPtr(&__ret), __Instance);
            return QPolygon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a polygon which is the union of this polygon and
        /// r.</para>
        /// <para>Set operations on polygons will treat the polygons as areas.
        /// Non-closed polygons will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also intersected() and subtracted().</para>
        /// </summary>
        public QPolygonF United(QPolygonF r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.United_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a polygon which is the intersection of this polygon and
        /// r.</para>
        /// <para>Set operations on polygons will treat the polygons as areas.
        /// Non-closed polygons will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public QPolygonF Intersected(QPolygonF r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.Intersected_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a polygon which is r subtracted from this polygon.</para>
        /// <para>Set operations on polygons will treat the polygons as areas.
        /// Non-closed polygons will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public QPolygonF Subtracted(QPolygonF r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.Subtracted_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QMatrix class specifies 2D transformations of a coordinate
    /// system.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A matrix specifies how to translate, scale, shear or rotate the
    /// coordinate system, and is typically used when rendering graphics. QMatrix,
    /// in contrast to QTransform, does not allow perspective transformations.
    /// QTransform is the recommended transformation class in Qt.</para>
    /// <para>A QMatrix object can be built using the setMatrix(), scale(),
    /// rotate(), translate() and shear() functions. Alternatively, it can be built
    /// by applying basic matrix operations. The matrix can also be defined when
    /// constructed, and it can be reset to the identity matrix (the default) using
    /// the reset() function.</para>
    /// <para>The QMatrix class supports mapping of graphic primitives: A given
    /// point, line, polygon, region, or painter path can be mapped to the
    /// coordinate system defined by this matrix using the map() function. In case
    /// of a rectangle, its coordinates can be transformed using the mapRect()
    /// function. A rectangle can also be transformed into a polygon (mapped to the
    /// coordinate system defined by this matrix), using the mapToPolygon()
    /// function.</para>
    /// <para>QMatrix provides the isIdentity() function which returns true if
    /// the matrix is the identity matrix, and the isInvertible() function which
    /// returns true if the matrix is non-singular (i.e. AB = BA = I). The
    /// inverted() function returns an inverted copy of this matrix if it is
    /// invertible (otherwise it returns the identity matrix). In addition, QMatrix
    /// provides the determinant() function returning the matrix's
    /// determinant.</para>
    /// <para>Finally, the QMatrix class supports matrix multiplication, and
    /// objects of the class can be streamed as well as compared.</para>
    /// <para></para>
    /// <para>Rendering Graphics</para>
    /// <para>When rendering graphics, the matrix defines the transformations
    /// but the actual transformation is performed by the drawing routines in
    /// QPainter.</para>
    /// <para>By default, QPainter operates on the associated device's own
    /// coordinate system. The standard coordinate system of a QPaintDevice has its
    /// origin located at the top-left position. The x values increase to the
    /// right; y values increase downward. For a complete description, see the
    /// coordinate system documentation.</para>
    /// <para>QPainter has functions to translate, scale, shear and rotate the
    /// coordinate system without using a QMatrix. For example:</para>
    /// <para></para>
    /// <para> 	void SimpleTransformation::paintEvent(QPaintEvent *)</para>
    /// <para>{</para>
    /// <para>    QPainter painter(this);</para>
    /// <para>    painter.setPen(QPen(Qt::blue, 1, Qt::DashLine));</para>
    /// <para>    painter.drawRect(0, 0, 100, 100);</para>
    /// <para></para>
    /// <para>    painter.rotate(45);</para>
    /// <para></para>
    /// <para>    painter.setFont(QFont(&quot;Helvetica&quot;, 24));</para>
    /// <para>    painter.setPen(QPen(Qt::black, 1));</para>
    /// <para>    painter.drawText(20, 10, &quot;QMatrix&quot;);</para>
    /// <para>}</para>
    /// </remarks>
    public unsafe partial class QMatrix : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public double _m11;

            [FieldOffset(8)]
            public double _m12;

            [FieldOffset(16)]
            public double _m21;

            [FieldOffset(24)]
            public double _m22;

            [FieldOffset(32)]
            public double _dx;

            [FieldOffset(40)]
            public double _dy;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QMatrixC2Ev")]
            internal static extern void ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QMatrixC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrix3mapEiiPiS0_")]
            internal static extern void Map_0(global::System.IntPtr instance, int x, int y, int* tx, int* ty);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrix3mapERK9QPolygonF")]
            internal static extern void Map_6(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrix3mapERK8QPolygon")]
            internal static extern void Map_7(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrix3mapERK7QRegion")]
            internal static extern void Map_8(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrix3mapERK12QPainterPath")]
            internal static extern void Map_9(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QMatrix5resetEv")]
            internal static extern void Reset_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrix8invertedEPb")]
            internal static extern void Inverted_0(global::System.IntPtr @return, global::System.IntPtr instance, bool* invertible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrixeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrixneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QMatrixmlERKS_")]
            internal static extern void OperatorStar_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr o);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QMatrix __CreateInstance(global::System.IntPtr native)
        {
            return new QMatrix((QMatrix.Internal*) native);
        }

        public static QMatrix __CreateInstance(QMatrix.Internal native)
        {
            return new QMatrix(native);
        }

        private static QMatrix.Internal* __CopyValue(QMatrix.Internal native)
        {
            var ret = Marshal.AllocHGlobal(48);
            QtGui.QMatrix.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QMatrix.Internal*) ret;
        }

        private QMatrix(QMatrix.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QMatrix(QMatrix.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an identity matrix.</para>
        /// <para>All elements are set to zero except m11 and m22 (specifying the
        /// scale), which are set to 1.</para>
        /// <para>See also reset().</para>
        /// </summary>
        public QMatrix()
        {
            __Instance = Marshal.AllocHGlobal(48);
            __ownsNativeInstance = true;
            Internal.ctor_1(__Instance);
        }

        /// <summary>
        /// <para>Constructs a matrix that is a copy of the given matrix.</para>
        /// </summary>
        public QMatrix(QMatrix matrix)
        {
            __Instance = Marshal.AllocHGlobal(48);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            Internal.cctor_3(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Maps the given coordinates x and y into the coordinate system
        /// defined by this matrix. The resulting values are put in *tx and *ty,
        /// respectively. Note that the transformed coordinates are rounded to the
        /// nearest integer.</para>
        /// </summary>
        public void Map(int x, int y, int* tx, int* ty)
        {
            var arg2 = tx;
            var arg3 = ty;
            Internal.Map_0(__Instance, x, y, arg2, arg3);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QPolygonF object that is a copy of the
        /// given polygon, mapped into the coordinate system defined by this
        /// matrix.</para>
        /// </summary>
        public QPolygonF Map(QPolygonF a)
        {
            var arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.Map_6(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QPolygon object that is a copy of the given
        /// polygon, mapped into the coordinate system defined by this matrix. Note
        /// that the transformed coordinates are rounded to the nearest integer.</para>
        /// </summary>
        public QPolygon Map(QPolygon a)
        {
            var arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var __ret = new QtGui.QPolygon.Internal();
            Internal.Map_7(new IntPtr(&__ret), __Instance, arg0);
            return QPolygon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QRegion object that is a copy of the given
        /// region, mapped into the coordinate system defined by this matrix.</para>
        /// <para>Calling this method can be rather expensive if rotations or
        /// shearing are used.</para>
        /// </summary>
        public QRegion Map(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.Map_8(new IntPtr(&__ret), __Instance, arg0);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QPainterPath object that is a copy of the
        /// given path, mapped into the coordinate system defined by this
        /// matrix.</para>
        /// </summary>
        public QPainterPath Map(QPainterPath p)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.Map_9(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Resets the matrix to an identity matrix, i.e. all elements are
        /// set to zero, except m11 and m22 (specifying the scale) which are set to
        /// 1.</para>
        /// <para>See also QMatrix(), isIdentity(), and Basic Matrix
        /// Operations.</para>
        /// </summary>
        public void Reset()
        {
            Internal.Reset_0(__Instance);
        }

        /// <summary>
        /// <para>Returns an inverted copy of this matrix.</para>
        /// <para>If the matrix is singular (not invertible), the returned matrix
        /// is the identity matrix. If invertible is valid (i.e. not 0), its value is
        /// set to true if the matrix is invertible, otherwise it is set to
        /// false.</para>
        /// <para>See also isInvertible().</para>
        /// </summary>
        public QMatrix Inverted(bool* invertible = null)
        {
            var arg0 = invertible;
            var __ret = new QtGui.QMatrix.Internal();
            Internal.Inverted_0(new IntPtr(&__ret), __Instance, arg0);
            return QMatrix.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if this matrix is equal to the given matrix,
        /// otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QMatrix __op, QMatrix matrix)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool matrixNull = ReferenceEquals(matrix, null);
            if (__opNull || matrixNull)
                return __opNull && matrixNull;
            var arg0 = __op.__Instance;
            var arg1 = matrix.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QMatrix;
        }

        /// <summary>
        /// <para>Returns true if this matrix is not equal to the given matrix,
        /// otherwise returns false.</para>
        /// </summary>
        public static bool operator !=(QMatrix __op, QMatrix matrix)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the result of multiplying this matrix by the given
        /// matrix.</para>
        /// <para>Note that matrix multiplication is not commutative, i.e. a*b !=
        /// b*a.</para>
        /// </summary>
        public static QMatrix operator *(QMatrix __op, QMatrix o)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(o, null) ? global::System.IntPtr.Zero : o.__Instance;
            var __ret = new QtGui.QMatrix.Internal();
            Internal.OperatorStar_0(new IntPtr(&__ret), arg0, arg1);
            return QMatrix.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QPainterPath class provides a container for painting
    /// operations, enabling graphical shapes to be constructed and reused.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A painter path is an object composed of a number of graphical
    /// building blocks, such as rectangles, ellipses, lines, and curves. Building
    /// blocks can be joined in closed subpaths, for example as a rectangle or an
    /// ellipse. A closed path has coinciding start and end points. Or they can
    /// exist independently as unclosed subpaths, such as lines and curves.</para>
    /// <para>A QPainterPath object can be used for filling, outlining, and
    /// clipping. To generate fillable outlines for a given painter path, use the
    /// QPainterPathStroker class. The main advantage of painter paths over normal
    /// drawing operations is that complex shapes only need to be created once;
    /// then they can be drawn many times using only calls to the
    /// QPainter::drawPath() function.</para>
    /// <para>QPainterPath provides a collection of functions that can be used
    /// to obtain information about the path and its elements. In addition it is
    /// possible to reverse the order of the elements using the toReversed()
    /// function. There are also several functions to convert this painter path
    /// object into a polygon representation.</para>
    /// <para></para>
    /// <para>Composing a QPainterPath</para>
    /// <para>A QPainterPath object can be constructed as an empty path, with a
    /// given start point, or as a copy of another QPainterPath object. Once
    /// created, lines and curves can be added to the path using the lineTo(),
    /// arcTo(), cubicTo() and quadTo() functions. The lines and curves stretch
    /// from the currentPosition() to the position passed as argument.</para>
    /// <para>The currentPosition() of the QPainterPath object is always the
    /// end position of the last subpath that was added (or the initial start
    /// point). Use the moveTo() function to move the currentPosition() without
    /// adding a component. The moveTo() function implicitly starts a new subpath,
    /// and closes the previous one. Another way of starting a new subpath is to
    /// call the closeSubpath() function which closes the current path by adding a
    /// line from the currentPosition() back to the path's start position. Note
    /// that the new path will have (0, 0) as its initial currentPosition().</para>
    /// <para>QPainterPath class also provides several convenience functions to
    /// add closed subpaths to a painter path: addEllipse(), addPath(), addRect(),
    /// addRegion() and addText(). The addPolygon() function adds an unclosed
    /// subpath. In fact, these functions are all collections of moveTo(), lineTo()
    /// and cubicTo() operations.</para>
    /// <para>In addition, a path can be added to the current path using the
    /// connectPath() function. But note that this function will connect the last
    /// element of the current path to the first element of given one by adding a
    /// line.</para>
    /// <para>Below is a code snippet that shows how a QPainterPath object can
    /// be used:</para>
    /// <para></para>
    /// <para> 	QPainterPath path;</para>
    /// <para>path.addRect(20, 20, 60, 60);</para>
    /// <para></para>
    /// <para>path.moveTo(0, 0);</para>
    /// <para>path.cubicTo(99, 0,  50, 50,  99, 99);</para>
    /// <para>path.cubicTo(0, 99,  50, 50,  0, 0);</para>
    /// <para></para>
    /// <para>QPainter painter(this);</para>
    /// <para>painter.fillRect(0, 0, 100, 100, Qt::white);</para>
    /// <para>painter.setPen(QPen(QColor(79, 106, 25), 1, Qt::SolidLine,</para>
    /// <para>                    Qt::FlatCap, Qt::MiterJoin));</para>
    /// <para>painter.setBrush(QColor(122, 163, 39));</para>
    /// <para></para>
    /// <para>painter.drawPath(path);</para>
    /// </remarks>
    public unsafe partial class QPainterPath : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QScopedPointer.Internal d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPathC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPathC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPathD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPath12closeSubpathEv")]
            internal static extern void CloseSubpath_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPath10addPolygonERK9QPolygonF")]
            internal static extern void AddPolygon_0(global::System.IntPtr instance, global::System.IntPtr polygon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPath7addPathERKS_")]
            internal static extern void AddPath_0(global::System.IntPtr instance, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPath9addRegionERK7QRegion")]
            internal static extern void AddRegion_0(global::System.IntPtr instance, global::System.IntPtr region);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPainterPath11connectPathERKS_")]
            internal static extern void ConnectPath_0(global::System.IntPtr instance, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath10toReversedEv")]
            internal static extern void ToReversed_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath17toSubpathPolygonsERK7QMatrix")]
            internal static extern QList.Internal ToSubpathPolygons_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath14toFillPolygonsERK7QMatrix")]
            internal static extern QList.Internal ToFillPolygons_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath13toFillPolygonERK7QMatrix")]
            internal static extern void ToFillPolygon_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath17toSubpathPolygonsERK10QTransform")]
            internal static extern QList.Internal ToSubpathPolygons_1(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath14toFillPolygonsERK10QTransform")]
            internal static extern QList.Internal ToFillPolygons_1(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath13toFillPolygonERK10QTransform")]
            internal static extern void ToFillPolygon_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath9elementAtEi")]
            internal static extern void ElementAt_0(global::System.IntPtr @return, global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath10intersectsERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Intersects_1(global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath8containsERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Contains_2(global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath6unitedERKS_")]
            internal static extern void United_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath11intersectedERKS_")]
            internal static extern void Intersected_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath10subtractedERKS_")]
            internal static extern void Subtracted_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath18subtractedInvertedERKS_")]
            internal static extern void SubtractedInverted_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPatheqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPathneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPathanERKS_")]
            internal static extern void OperatorAmp_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPathorERKS_")]
            internal static extern void OperatorPipe_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPathplERKS_")]
            internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPathmiERKS_")]
            internal static extern void OperatorMinus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZmlRK12QPainterPathRK7QMatrix")]
            internal static extern void OperatorStar_0(global::System.IntPtr @return, global::System.IntPtr p, global::System.IntPtr m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath7isEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath12elementCountEv")]
            internal static extern int ElementCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPainterPath10simplifiedEv")]
            internal static extern void Simplified_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the types of elements used to connect
        /// vertices in subpaths.</para>
        /// <para>Note that elements added as closed subpaths using the
        /// addEllipse(), addPath(), addPolygon(), addRect(), addRegion() and addText()
        /// convenience functions, is actually added to the path as a collection of
        /// separate elements using the moveTo(), lineTo() and cubicTo()
        /// functions.</para>
        /// <para>See also elementAt() and elementCount().</para>
        /// </summary>
        public enum ElementType : uint
        {
            /// <summary>A new subpath. See also moveTo().</summary>
            MoveToElement = 0,
            /// <summary>A line. See also lineTo().</summary>
            LineToElement = 1,
            /// <summary>A curve. See also cubicTo() and quadTo().</summary>
            CurveToElement = 2,
            /// <summary>The extra data required to describe a curve in a CurveToElement element.</summary>
            CurveToDataElement = 3
        }

        public unsafe partial class Element : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public double x;

                [FieldOffset(8)]
                public double y;

                [FieldOffset(16)]
                public QPainterPath.ElementType type;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN12QPainterPath7ElementC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Element __CreateInstance(global::System.IntPtr native)
            {
                return new Element((Element.Internal*) native);
            }

            public static Element __CreateInstance(Element.Internal native)
            {
                return new Element(native);
            }

            private static Element.Internal* __CopyValue(Element.Internal native)
            {
                var ret = (Element.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private Element(Element.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Element(Element.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public QPainterPath.ElementType Type
            {
                get
                {
                    return ((Internal*) __Instance)->type;
                }

                set
                {
                    ((Internal*) __Instance)->type = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPainterPath __CreateInstance(global::System.IntPtr native)
        {
            return new QPainterPath((QPainterPath.Internal*) native);
        }

        public static QPainterPath __CreateInstance(QPainterPath.Internal native)
        {
            return new QPainterPath(native);
        }

        private static QPainterPath.Internal* __CopyValue(QPainterPath.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QPainterPath.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QPainterPath.Internal*) ret;
        }

        private QPainterPath(QPainterPath.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPainterPath(QPainterPath.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QPainterPath object.</para>
        /// </summary>
        public QPainterPath()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a QPainterPath object that is a copy of the given
        /// path.</para>
        /// <para>See also operator=().</para>
        /// </summary>
        public QPainterPath(QPainterPath other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Closes the current subpath by drawing a line to the beginning of
        /// the subpath, automatically starting a new path. The current point of the
        /// new path is (0, 0).</para>
        /// <para>If the subpath does not contain any elements, this function does
        /// nothing.</para>
        /// <para>See also moveTo() and Composing a QPainterPath.</para>
        /// </summary>
        public void CloseSubpath()
        {
            Internal.CloseSubpath_0(__Instance);
        }

        /// <summary>
        /// <para>Adds the given polygon to the path as an (unclosed)
        /// subpath.</para>
        /// <para>Note that the current position after the polygon has been added,
        /// is the last point in polygon. To draw a line back to the first point, use
        /// the closeSubpath() function.</para>
        /// <para></para>
        /// <para> 	QLinearGradient myGradient;</para>
        /// <para>QPen myPen;</para>
        /// <para>QPolygonF myPolygon;</para>
        /// <para></para>
        /// <para>QPainterPath myPath;</para>
        /// <para>myPath.addPolygon(myPolygon);</para>
        /// <para></para>
        /// <para>QPainter painter(this);</para>
        /// <para>painter.setBrush(myGradient);</para>
        /// <para>painter.setPen(myPen);</para>
        /// <para>painter.drawPath(myPath);</para>
        /// </summary>
        public void AddPolygon(QPolygonF polygon)
        {
            var arg0 = ReferenceEquals(polygon, null) ? global::System.IntPtr.Zero : polygon.__Instance;
            Internal.AddPolygon_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Adds the given path to this path as a closed subpath.</para>
        /// <para>See also connectPath() and Composing a QPainterPath.</para>
        /// </summary>
        public void AddPath(QPainterPath path)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            Internal.AddPath_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Adds the given region to the path by adding each rectangle in the
        /// region as a separate closed subpath.</para>
        /// <para>See also addRect() and Composing a QPainterPath.</para>
        /// </summary>
        public void AddRegion(QRegion region)
        {
            var arg0 = ReferenceEquals(region, null) ? global::System.IntPtr.Zero : region.__Instance;
            Internal.AddRegion_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Connects the given path to this path by adding a line from the
        /// last element of this path to the first element of the given path.</para>
        /// <para>See also addPath() and Composing a QPainterPath.</para>
        /// </summary>
        public void ConnectPath(QPainterPath path)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            Internal.ConnectPath_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Creates and returns a reversed copy of the path.</para>
        /// <para>It is the order of the elements that is reversed: If a
        /// QPainterPath is composed by calling the moveTo(), lineTo() and cubicTo()
        /// functions in the specified order, the reversed copy is composed by calling
        /// cubicTo(), lineTo() and moveTo().</para>
        /// </summary>
        public QPainterPath ToReversed()
        {
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.ToReversed_0(new IntPtr(&__ret), __Instance);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public System.Collections.Generic.IList<QPolygonF> ToSubpathPolygons(QMatrix matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = Internal.ToSubpathPolygons_0(__Instance, arg0);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QPolygonF>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QPolygonF.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public System.Collections.Generic.IList<QPolygonF> ToFillPolygons(QMatrix matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = Internal.ToFillPolygons_0(__Instance, arg0);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QPolygonF>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QPolygonF.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public QPolygonF ToFillPolygon(QMatrix matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.ToFillPolygon_0(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Converts the path into a list of polygons using the QTransform
        /// matrix, and returns the list.</para>
        /// <para>This function creates one polygon for each subpath regardless of
        /// intersecting subpaths (i.e. overlapping bounding rectangles). To make sure
        /// that such overlapping subpaths are filled correctly, use the
        /// toFillPolygons() function instead.</para>
        /// <para>See also toFillPolygons(), toFillPolygon(), and QPainterPath
        /// Conversion.</para>
        /// </summary>
        public System.Collections.Generic.IList<QPolygonF> ToSubpathPolygons(QTransform matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = Internal.ToSubpathPolygons_1(__Instance, arg0);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QPolygonF>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QPolygonF.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Converts the path into a list of polygons using the QTransform
        /// matrix, and returns the list.</para>
        /// <para>The function differs from the toFillPolygon() function in that it
        /// creates several polygons. It is provided because it is usually faster to
        /// draw several small polygons than to draw one large polygon, even though the
        /// total number of points drawn is the same.</para>
        /// <para>The toFillPolygons() function differs from the
        /// toSubpathPolygons() function in that it create only polygon for subpaths
        /// that have overlapping bounding rectangles.</para>
        /// <para>Like the toFillPolygon() function, this function uses a rewinding
        /// technique to make sure that overlapping subpaths can be filled using the
        /// correct fill rule. Note that rewinding inserts addition lines in the
        /// polygons so the outline of the fill polygon does not match the outline of
        /// the path.</para>
        /// <para>See also toSubpathPolygons(), toFillPolygon(), and QPainterPath
        /// Conversion.</para>
        /// </summary>
        public System.Collections.Generic.IList<QPolygonF> ToFillPolygons(QTransform matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = Internal.ToFillPolygons_1(__Instance, arg0);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QPolygonF>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QPolygonF.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Converts the path into a polygon using the QTransform matrix, and
        /// returns the polygon.</para>
        /// <para>The polygon is created by first converting all subpaths to
        /// polygons, then using a rewinding technique to make sure that overlapping
        /// subpaths can be filled using the correct fill rule.</para>
        /// <para>Note that rewinding inserts addition lines in the polygon so the
        /// outline of the fill polygon does not match the outline of the path.</para>
        /// <para>See also toSubpathPolygons(), toFillPolygons(), and QPainterPath
        /// Conversion.</para>
        /// </summary>
        public QPolygonF ToFillPolygon(QTransform matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.ToFillPolygon_1(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the element at the given index in the painter
        /// path.</para>
        /// <para>See also ElementType, elementCount(), and isEmpty().</para>
        /// </summary>
        public QPainterPath.Element ElementAt(int i)
        {
            var __ret = new QtGui.QPainterPath.Element.Internal();
            Internal.ElementAt_0(new IntPtr(&__ret), __Instance, i);
            return QPainterPath.Element.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if the current path intersects at any point the
        /// given path p. Also returns true if the current path contains or is
        /// contained by any part of p.</para>
        /// <para>Set operations on paths will treat the paths as areas. Non-closed
        /// paths will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also contains().</para>
        /// </summary>
        public bool Intersects(QPainterPath p)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var __ret = Internal.Intersects_1(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the given path p is contained within the current
        /// path. Returns false if any edges of the current path and p
        /// intersect.</para>
        /// <para>Set operations on paths will treat the paths as areas. Non-closed
        /// paths will be treated as implicitly closed.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also intersects().</para>
        /// </summary>
        public bool Contains(QPainterPath p)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var __ret = Internal.Contains_2(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a path which is the union of this path's fill area and
        /// p's fill area.</para>
        /// <para>Set operations on paths will treat the paths as areas. Non-closed
        /// paths will be treated as implicitly closed. Bezier curves may be flattened
        /// to line segments due to numerical instability of doing bezier curve
        /// intersections.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also intersected() and subtracted().</para>
        /// </summary>
        public QPainterPath United(QPainterPath r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.United_0(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a path which is the intersection of this path's fill area
        /// and p's fill area. Bezier curves may be flattened to line segments due to
        /// numerical instability of doing bezier curve intersections.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public QPainterPath Intersected(QPainterPath r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.Intersected_0(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a path which is p's fill area subtracted from this path's
        /// fill area.</para>
        /// <para>Set operations on paths will treat the paths as areas. Non-closed
        /// paths will be treated as implicitly closed. Bezier curves may be flattened
        /// to line segments due to numerical instability of doing bezier curve
        /// intersections.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public QPainterPath Subtracted(QPainterPath r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.Subtracted_0(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Use subtracted() instead.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also subtracted().</para>
        /// </summary>
        [System.ObsoleteAttribute("Use subtracted() instead.")]
        public QPainterPath SubtractedInverted(QPainterPath r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.SubtractedInverted_0(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if this painterpath is equal to the given
        /// path.</para>
        /// <para>Note that comparing paths may involve a per element comparison
        /// which can be slow for complex paths.</para>
        /// <para>See also operator!=().</para>
        /// </summary>
        public static bool operator ==(QPainterPath __op, QPainterPath other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QPainterPath;
        }

        /// <summary>
        /// <para>Returns true if this painter path differs from the given
        /// path.</para>
        /// <para>Note that comparing paths may involve a per element comparison
        /// which can be slow for complex paths.</para>
        /// <para>See also operator==().</para>
        /// </summary>
        public static bool operator !=(QPainterPath __op, QPainterPath other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the intersection of this path and the other path.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also intersected(), operator&amp;=(), united(), and
        /// operator|().</para>
        /// </summary>
        public static QPainterPath operator &(QPainterPath __op, QPainterPath other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.OperatorAmp_0(new IntPtr(&__ret), arg0, arg1);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the union of this path and the other path.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also united(), operator|=(), intersected(), and
        /// operator&amp;().</para>
        /// </summary>
        public static QPainterPath operator |(QPainterPath __op, QPainterPath other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.OperatorPipe_0(new IntPtr(&__ret), arg0, arg1);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the union of this path and the other path. This function
        /// is equivalent to operator|().</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also united(), operator+=(), and operator-().</para>
        /// </summary>
        public static QPainterPath operator +(QPainterPath __op, QPainterPath other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.OperatorPlus_0(new IntPtr(&__ret), arg0, arg1);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Subtracts the other path from a copy of this path, and returns
        /// the copy.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also subtracted(), operator-=(), and operator+().</para>
        /// </summary>
        public static QPainterPath operator -(QPainterPath __op, QPainterPath other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.OperatorMinus_0(new IntPtr(&__ret), arg0, arg1);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public System.Collections.Generic.IList<QPolygonF> ToSubpathPolygons()
        {
            return ToSubpathPolygons(new QMatrix());
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public System.Collections.Generic.IList<QPolygonF> ToFillPolygons()
        {
            return ToFillPolygons(new QMatrix());
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public QPolygonF ToFillPolygon()
        {
            return ToFillPolygon(new QMatrix());
        }

        public static QPainterPath operator *(QPainterPath p, QMatrix m)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var arg1 = ReferenceEquals(m, null) ? global::System.IntPtr.Zero : m.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.OperatorStar_0(new IntPtr(&__ret), arg0, arg1);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if either there are no elements in this path, or if
        /// the only element is a MoveToElement; otherwise returns false.</para>
        /// <para>See also elementCount().</para>
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                var __ret = Internal.IsEmpty_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of path elements in the painter path.</para>
        /// <para>See also ElementType, elementAt(), and isEmpty().</para>
        /// </summary>
        public int ElementCount
        {
            get
            {
                var __ret = Internal.ElementCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a simplified version of this path. This implies merging
        /// all subpaths that intersect, and returning a path containing no
        /// intersecting edges. Consecutive parallel lines will also be merged. The
        /// simplified path will always use the default fill rule, Qt::OddEvenFill.
        /// Bezier curves may be flattened to line segments due to numerical
        /// instability of doing bezier curve intersections.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public QPainterPath Simplified
        {
            get
            {
                var __ret = new QtGui.QPainterPath.Internal();
                Internal.Simplified_0(new IntPtr(&__ret), __Instance);
                return QPainterPath.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QPainterPathStroker class is used to generate fillable
    /// outlines for a given painter path.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>By calling the createStroke() function, passing a given
    /// QPainterPath as argument, a new painter path representing the outline of
    /// the given path is created. The newly created painter path can then be
    /// filled to draw the original painter path's outline.</para>
    /// <para>You can control the various design aspects (width, cap styles,
    /// join styles and dash pattern) of the outlining using the following
    /// functions:</para>
    /// <para></para>
    /// <para>setWidth()</para>
    /// <para>setCapStyle()</para>
    /// <para>setJoinStyle()</para>
    /// <para>setDashPattern()</para>
    /// <para></para>
    /// <para>The setDashPattern() function accepts both a Qt::PenStyle object
    /// and a vector representation of the pattern as argument.</para>
    /// <para>In addition you can specify a curve's threshold, controlling the
    /// granularity with which a curve is drawn, using the setCurveThreshold()
    /// function. The default threshold is a well adjusted value (0.25), and
    /// normally you should not need to modify it. However, you can make the
    /// curve's appearance smoother by decreasing its value.</para>
    /// <para>You can also control the miter limit for the generated outline
    /// using the setMiterLimit() function. The miter limit describes how far from
    /// each join the miter join can extend. The limit is specified in the units of
    /// width so the pixelwise miter limit will be miterlimit * width. This value
    /// is only used if the join style is Qt::MiterJoin.</para>
    /// <para>The painter path generated by the createStroke() function should
    /// only be used for outlining the given painter path. Otherwise it may cause
    /// unexpected behavior. Generated outlines also require the Qt::WindingFill
    /// rule which is set by default.</para>
    /// <para></para>
    /// <para>See also QPen and QBrush.</para>
    /// </remarks>
    public unsafe partial class QPainterPathStroker : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QScopedPointer.Internal d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QPainterPathStrokerC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QPainterPathStrokerC2ERK4QPen")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr pen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QPainterPathStrokerC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QPainterPathStrokerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QPainterPathStroker12createStrokeERK12QPainterPath")]
            internal static extern void CreateStroke_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr path);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPainterPathStroker __CreateInstance(global::System.IntPtr native)
        {
            return new QPainterPathStroker((QPainterPathStroker.Internal*) native);
        }

        public static QPainterPathStroker __CreateInstance(QPainterPathStroker.Internal native)
        {
            return new QPainterPathStroker(native);
        }

        private static QPainterPathStroker.Internal* __CopyValue(QPainterPathStroker.Internal native)
        {
            var ret = (QPainterPathStroker.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QPainterPathStroker(QPainterPathStroker.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPainterPathStroker(QPainterPathStroker.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a new stroker.</para>
        /// </summary>
        public QPainterPathStroker()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a new stroker based on pen.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// </summary>
        public QPainterPathStroker(QPen pen)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(pen, null) ? global::System.IntPtr.Zero : pen.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Generates a new path that is a fillable area representing the
        /// outline of the given path.</para>
        /// <para>The various design aspects of the outline are based on the
        /// stroker's properties: width(), capStyle(), joinStyle(), dashPattern(),
        /// curveThreshold() and miterLimit().</para>
        /// <para>The generated path should only be used for outlining the given
        /// painter path. Otherwise it may cause unexpected behavior. Generated
        /// outlines also require the Qt::WindingFill rule which is set by
        /// default.</para>
        /// </summary>
        public QPainterPath CreateStroke(QPainterPath path)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.CreateStroke_0(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QTransform class specifies 2D transformations of a coordinate
    /// system.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A transformation specifies how to translate, scale, shear, rotate
    /// or project the coordinate system, and is typically used when rendering
    /// graphics.</para>
    /// <para>QTransform differs from QMatrix in that it is a true 3x3 matrix,
    /// allowing perspective transformations. QTransform's toAffine() method allows
    /// casting QTransform to QMatrix. If a perspective transformation has been
    /// specified on the matrix, then the conversion will cause loss of
    /// data.</para>
    /// <para>QTransform is the recommended transformation class in Qt.</para>
    /// <para>A QTransform object can be built using the setMatrix(), scale(),
    /// rotate(), translate() and shear() functions. Alternatively, it can be built
    /// by applying basic matrix operations. The matrix can also be defined when
    /// constructed, and it can be reset to the identity matrix (the default) using
    /// the reset() function.</para>
    /// <para>The QTransform class supports mapping of graphic primitives: A
    /// given point, line, polygon, region, or painter path can be mapped to the
    /// coordinate system defined by this matrix using the map() function. In case
    /// of a rectangle, its coordinates can be transformed using the mapRect()
    /// function. A rectangle can also be transformed into a polygon (mapped to the
    /// coordinate system defined by this matrix), using the mapToPolygon()
    /// function.</para>
    /// <para>QTransform provides the isIdentity() function which returns true
    /// if the matrix is the identity matrix, and the isInvertible() function which
    /// returns true if the matrix is non-singular (i.e. AB = BA = I). The
    /// inverted() function returns an inverted copy of this matrix if it is
    /// invertible (otherwise it returns the identity matrix), and adjoint()
    /// returns the matrix's classical adjoint. In addition, QTransform provides
    /// the determinant() function which returns the matrix's determinant.</para>
    /// <para>Finally, the QTransform class supports matrix multiplication,
    /// addition and subtraction, and objects of the class can be streamed as well
    /// as compared.</para>
    /// <para></para>
    /// <para>Rendering Graphics</para>
    /// <para>When rendering graphics, the matrix defines the transformations
    /// but the actual transformation is performed by the drawing routines in
    /// QPainter.</para>
    /// <para>By default, QPainter operates on the associated device's own
    /// coordinate system. The standard coordinate system of a QPaintDevice has its
    /// origin located at the top-left position. The x values increase to the
    /// right; y values increase downward. For a complete description, see the
    /// coordinate system documentation.</para>
    /// <para>QPainter has functions to translate, scale, shear and rotate the
    /// coordinate system without using a QTransform. For example:</para>
    /// <para></para>
    /// <para> 	void SimpleTransformation::paintEvent(QPaintEvent *)</para>
    /// <para>{</para>
    /// <para>    QPainter painter(this);</para>
    /// <para>    painter.setPen(QPen(Qt::blue, 1, Qt::DashLine));</para>
    /// <para>    painter.drawRect(0, 0, 100, 100);</para>
    /// <para></para>
    /// <para>    painter.rotate(45);</para>
    /// <para></para>
    /// <para>    painter.setFont(QFont(&quot;Helvetica&quot;, 24));</para>
    /// <para>    painter.setPen(QPen(Qt::black, 1));</para>
    /// <para>    painter.drawText(20, 10, &quot;QTransform&quot;);</para>
    /// <para>}</para>
    /// </remarks>
    public unsafe partial class QTransform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public QMatrix.Internal affine;

            [FieldOffset(48)]
            public double m_13;

            [FieldOffset(56)]
            public double m_23;

            [FieldOffset(64)]
            public double m_33;

            [FieldOffset(72)]
            public uint m_type;

            [FieldOffset(72)]
            public uint m_dirty;

            [FieldOffset(76)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTransformC2Ev")]
            internal static extern void ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTransformC2ERK7QMatrix")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr mtx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTransformC2ERKS_")]
            internal static extern void cctor_7(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform8invertedEPb")]
            internal static extern void Inverted_0(global::System.IntPtr @return, global::System.IntPtr instance, bool* invertible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10QTransform12squareToQuadERK9QPolygonFRS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SquareToQuad_0(global::System.IntPtr square, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10QTransform12quadToSquareERK9QPolygonFRS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool QuadToSquare_0(global::System.IntPtr quad, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10QTransform10quadToQuadERK9QPolygonFS2_RS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool QuadToQuad_0(global::System.IntPtr one, global::System.IntPtr two, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransformeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransformneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransformmlERKS_")]
            internal static extern void OperatorStar_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr o);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTransform5resetEv")]
            internal static extern void Reset_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform3mapERK9QPolygonF")]
            internal static extern void Map_4(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform3mapERK8QPolygon")]
            internal static extern void Map_5(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform3mapERK7QRegion")]
            internal static extern void Map_6(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform3mapERK12QPainterPath")]
            internal static extern void Map_7(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform3mapEiiPiS0_")]
            internal static extern void Map_8(global::System.IntPtr instance, int x, int y, int* tx, int* ty);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform8toAffineEv")]
            internal static extern global::System.IntPtr ToAffine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform4typeEv")]
            internal static extern QTransform.TransformationType Type_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform7adjointEv")]
            internal static extern void Adjoint_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTransform10transposedEv")]
            internal static extern void Transposed_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        [Flags]
        public enum TransformationType : uint
        {
            TxNone = 0x0,
            TxTranslate = 0x1,
            TxScale = 0x2,
            TxRotate = 0x4,
            TxShear = 0x8,
            TxProject = 0x10
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTransform __CreateInstance(global::System.IntPtr native)
        {
            return new QTransform((QTransform.Internal*) native);
        }

        public static QTransform __CreateInstance(QTransform.Internal native)
        {
            return new QTransform(native);
        }

        private static QTransform.Internal* __CopyValue(QTransform.Internal native)
        {
            var ret = Marshal.AllocHGlobal(80);
            QtGui.QTransform.Internal.cctor_7(ret, new global::System.IntPtr(&native));
            return (QTransform.Internal*) ret;
        }

        private QTransform(QTransform.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTransform(QTransform.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an identity matrix.</para>
        /// <para>All elements are set to zero except m11 and m22 (specifying the
        /// scale) and m33 which are set to 1.</para>
        /// <para>See also reset().</para>
        /// </summary>
        public QTransform()
        {
            __Instance = Marshal.AllocHGlobal(80);
            __ownsNativeInstance = true;
            Internal.ctor_1(__Instance);
        }

        /// <summary>
        /// <para>Constructs a matrix that is a copy of the given matrix. Note that
        /// the m13, m23, and m33 elements are set to 0, 0, and 1 respectively.</para>
        /// </summary>
        public QTransform(QMatrix mtx)
        {
            __Instance = Marshal.AllocHGlobal(80);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(mtx, null) ? global::System.IntPtr.Zero : mtx.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns an inverted copy of this matrix.</para>
        /// <para>If the matrix is singular (not invertible), the returned matrix
        /// is the identity matrix. If invertible is valid (i.e. not 0), its value is
        /// set to true if the matrix is invertible, otherwise it is set to
        /// false.</para>
        /// <para>See also isInvertible().</para>
        /// </summary>
        public QTransform Inverted(bool* invertible = null)
        {
            var arg0 = invertible;
            var __ret = new QtGui.QTransform.Internal();
            Internal.Inverted_0(new IntPtr(&__ret), __Instance, arg0);
            return QTransform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if this matrix is equal to the given matrix,
        /// otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QTransform __op, QTransform matrix)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool matrixNull = ReferenceEquals(matrix, null);
            if (__opNull || matrixNull)
                return __opNull && matrixNull;
            var arg0 = __op.__Instance;
            var arg1 = matrix.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QTransform;
        }

        /// <summary>
        /// <para>Returns true if this matrix is not equal to the given matrix,
        /// otherwise returns false.</para>
        /// </summary>
        public static bool operator !=(QTransform __op, QTransform matrix)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the result of multiplying this matrix by the given
        /// matrix.</para>
        /// <para>Note that matrix multiplication is not commutative, i.e. a*b !=
        /// b*a.</para>
        /// </summary>
        public static QTransform operator *(QTransform __op, QTransform o)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(o, null) ? global::System.IntPtr.Zero : o.__Instance;
            var __ret = new QtGui.QTransform.Internal();
            Internal.OperatorStar_0(new IntPtr(&__ret), arg0, arg1);
            return QTransform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Resets the matrix to an identity matrix, i.e. all elements are
        /// set to zero, except m11 and m22 (specifying the scale) and m33 which are
        /// set to 1.</para>
        /// <para>See also QTransform(), isIdentity(), and Basic Matrix
        /// Operations.</para>
        /// </summary>
        public void Reset()
        {
            Internal.Reset_0(__Instance);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QPolygonF object that is a copy of the
        /// given polygon, mapped into the coordinate system defined by this
        /// matrix.</para>
        /// </summary>
        public QPolygonF Map(QPolygonF a)
        {
            var arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var __ret = new QtGui.QPolygonF.Internal();
            Internal.Map_4(new IntPtr(&__ret), __Instance, arg0);
            return QPolygonF.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QPolygon object that is a copy of the given
        /// polygon, mapped into the coordinate system defined by this matrix. Note
        /// that the transformed coordinates are rounded to the nearest integer.</para>
        /// </summary>
        public QPolygon Map(QPolygon a)
        {
            var arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var __ret = new QtGui.QPolygon.Internal();
            Internal.Map_5(new IntPtr(&__ret), __Instance, arg0);
            return QPolygon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QRegion object that is a copy of the given
        /// region, mapped into the coordinate system defined by this matrix.</para>
        /// <para>Calling this method can be rather expensive if rotations or
        /// shearing are used.</para>
        /// </summary>
        public QRegion Map(QRegion r)
        {
            var arg0 = ReferenceEquals(r, null) ? global::System.IntPtr.Zero : r.__Instance;
            var __ret = new QtGui.QRegion.Internal();
            Internal.Map_6(new IntPtr(&__ret), __Instance, arg0);
            return QRegion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a QPainterPath object that is a copy of the
        /// given path, mapped into the coordinate system defined by this
        /// matrix.</para>
        /// </summary>
        public QPainterPath Map(QPainterPath p)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var __ret = new QtGui.QPainterPath.Internal();
            Internal.Map_7(new IntPtr(&__ret), __Instance, arg0);
            return QPainterPath.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Maps the given coordinates x and y into the coordinate system
        /// defined by this matrix. The resulting values are put in *tx and *ty,
        /// respectively. Note that the transformed coordinates are rounded to the
        /// nearest integer.</para>
        /// </summary>
        public void Map(int x, int y, int* tx, int* ty)
        {
            var arg2 = tx;
            var arg3 = ty;
            Internal.Map_8(__Instance, x, y, arg2, arg3);
        }

        /// <summary>
        /// <para>Returns the QTransform as an affine matrix.</para>
        /// <para>Warning: If a perspective transformation has been specified, then
        /// the conversion will cause loss of data.</para>
        /// </summary>
        public QMatrix ToAffine()
        {
            var __ret = Internal.ToAffine_0(__Instance);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QMatrix.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates a transformation matrix, trans, that maps a unit square
        /// to a four-sided polygon, quad. Returns true if the transformation is
        /// constructed or false if such a transformation does not exist.</para>
        /// <para>See also quadToSquare() and quadToQuad().</para>
        /// </summary>
        public static bool SquareToQuad(QPolygonF square, QTransform result)
        {
            var arg0 = ReferenceEquals(square, null) ? global::System.IntPtr.Zero : square.__Instance;
            var arg1 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
            var __ret = Internal.SquareToQuad_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Creates a transformation matrix, trans, that maps a four-sided
        /// polygon, quad, to a unit square. Returns true if the transformation is
        /// constructed or false if such a transformation does not exist.</para>
        /// <para>See also squareToQuad() and quadToQuad().</para>
        /// </summary>
        public static bool QuadToSquare(QPolygonF quad, QTransform result)
        {
            var arg0 = ReferenceEquals(quad, null) ? global::System.IntPtr.Zero : quad.__Instance;
            var arg1 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
            var __ret = Internal.QuadToSquare_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Creates a transformation matrix, trans, that maps a four-sided
        /// polygon, one, to another four-sided polygon, two. Returns true if the
        /// transformation is possible; otherwise returns false.</para>
        /// <para>This is a convenience method combining quadToSquare() and
        /// squareToQuad() methods. It allows the input quad to be transformed into any
        /// other quad.</para>
        /// <para>See also squareToQuad() and quadToSquare().</para>
        /// </summary>
        public static bool QuadToQuad(QPolygonF one, QPolygonF two, QTransform result)
        {
            var arg0 = ReferenceEquals(one, null) ? global::System.IntPtr.Zero : one.__Instance;
            var arg1 = ReferenceEquals(two, null) ? global::System.IntPtr.Zero : two.__Instance;
            var arg2 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
            var __ret = Internal.QuadToQuad_0(arg0, arg1, arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the transformation type of this matrix.</para>
        /// <para>The transformation type is the highest enumeration value
        /// capturing all of the matrix's transformations. For example, if the matrix
        /// both scales and shears, the type would be TxShear, because TxShear has a
        /// higher enumeration value than TxScale.</para>
        /// <para>Knowing the transformation type of a matrix is useful for
        /// optimization: you can often handle specific types more optimally than
        /// handling the generic case.</para>
        /// </summary>
        public QTransform.TransformationType Type
        {
            get
            {
                var __ret = Internal.Type_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the adjoint of this matrix.</para>
        /// </summary>
        public QTransform Adjoint
        {
            get
            {
                var __ret = new QtGui.QTransform.Internal();
                Internal.Adjoint_0(new IntPtr(&__ret), __Instance);
                return QTransform.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the transpose of this matrix.</para>
        /// </summary>
        public QTransform Transposed
        {
            get
            {
                var __ret = new QtGui.QTransform.Internal();
                Internal.Transposed_0(new IntPtr(&__ret), __Instance);
                return QTransform.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class QPixelFormat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public ulong data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPixelFormatC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        /// <summary>
        /// <para>This enum type is used to describe the color model of the
        /// pixelformat.</para>
        /// </summary>
        public enum ColorModel : uint
        {
            /// <summary>The color model is RGB.</summary>
            RGB = 0,
            /// <summary>This is logically the opposite endian version of RGB. However, for ease of use it has its own model.</summary>
            BGR = 1,
            /// <summary>The color model uses a color palette.</summary>
            Indexed = 2,
            /// <summary>The color model is Grayscale.</summary>
            Grayscale = 3,
            /// <summary>The color model is CMYK.</summary>
            CMYK = 4,
            /// <summary>The color model is HSL.</summary>
            HSL = 5,
            /// <summary>The color model is HSV.</summary>
            HSV = 6,
            /// <summary>The color model is YUV.</summary>
            YUV = 7
        }

        /// <summary>
        /// <para>This enum describes if the alpha channel is used or not.
        /// Sometimes the pixelformat will have a size for the alpha channel, but the
        /// pixel format does actually not use the alpha channel. For example RGB32 is
        /// such a format. The RGB channels are 8 bits each, and there is no alpha
        /// channel. But the complete size for each pixel is 32. Therefore the alpha
        /// channel size is 8, but the alpha channel is ignored. Its important to note
        /// that in such situations the position of the alpha channel is
        /// significant.</para>
        /// </summary>
        public enum AlphaUsage : uint
        {
            /// <summary>The alpha channel is used.</summary>
            UsesAlpha = 0,
            /// <summary>The alpha channel is not used.</summary>
            IgnoresAlpha = 1
        }

        /// <summary>
        /// <para>This enum type is used to describe the alpha channels position
        /// relative to the color channels.</para>
        /// </summary>
        public enum AlphaPosition : uint
        {
            /// <summary>The alpha channel will be put in front of the color channels . E.g. ARGB.</summary>
            AtBeginning = 0,
            /// <summary>The alpha channel will be put in the back of the color channels. E.g. RGBA.</summary>
            AtEnd = 1
        }

        /// <summary>
        /// <para>This enum type describes the boolean state if the alpha channel
        /// is multiplied into the color channels or not.</para>
        /// </summary>
        public enum AlphaPremultiplied : uint
        {
            /// <summary>The alpha channel is not multiplied into the color channels.</summary>
            NotPremultiplied = 0,
            /// <summary>The alpha channel is multiplied into the color channels.</summary>
            Premultiplied = 1
        }

        /// <summary>
        /// <para>This enum describes how each pixel is interpreted. If a pixel is
        /// read as a full 32 bit unsigned integer and then each channel is masked out,
        /// or if each byte is read as unsigned char values. Typically QImage formats
        /// interpret one pixel as an unsigned integer and then the color channels are
        /// masked out. OpenGL on the other hand typically interpreted pixels &quot;one
        /// byte after the other&quot;, Ie. unsigned byte.</para>
        /// <para>QImage also have the format Format_RGBA8888 (and its
        /// derivatives), where the pixels are interpreted as unsigned bytes. OpenGL
        /// has extensions that makes it possible to upload pixel buffers in an
        /// unsigned integer format.</para>
        /// <para>The image above shows a ARGB pixel in memory read as an unsigned
        /// integer. However, if this pixel was read byte for byte on a little endian
        /// system the first byte would be the byte containing the B-channel. The next
        /// byte would be the G-channel, then the R-channel and finally the A-channel.
        /// This shows that on little endian systems, how each pixel is interpreted is
        /// significant for integer formats. This is not the case on big endian
        /// systems.</para>
        /// </summary>
        public enum TypeInterpretation : uint
        {
            UnsignedInteger = 0,
            UnsignedShort = 1,
            UnsignedByte = 2,
            FloatingPoint = 3
        }

        /// <summary>
        /// <para>YUV is not represented by describing the size of the color
        /// channels. This is because YUV often use macro pixels, making the concept of
        /// sperate color channels invalid. Instead the different YUV layouts are
        /// described with this enum.</para>
        /// </summary>
        public enum YUVLayout : uint
        {
            YUV444 = 0,
            YUV422 = 1,
            YUV411 = 2,
            YUV420P = 3,
            YUV420SP = 4,
            YV12 = 5,
            UYVY = 6,
            YUYV = 7,
            NV12 = 8,
            NV21 = 9,
            IMC1 = 10,
            IMC2 = 11,
            IMC3 = 12,
            IMC4 = 13,
            Y8 = 14,
            Y16 = 15
        }

        /// <summary>
        /// <para>This enum describes the ByteOrder of the pixel format. This enum
        /// is mostly ignored but have some use cases for YUV formats. BGR formats have
        /// their own color model, and should not be described by using the opposite
        /// endianness on an RGB format.</para>
        /// </summary>
        public enum ByteOrder : uint
        {
            /// <summary>The byte order is little endian.</summary>
            LittleEndian = 0,
            /// <summary>The byte order is big endian.</summary>
            BigEndian = 1,
            /// <summary>This enum will not be stored, but is converted in the constructor to the endian enum that matches the enum of the current system.</summary>
            CurrentSystemEndian = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPixelFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QPixelFormat((QPixelFormat.Internal*) native);
        }

        public static QPixelFormat __CreateInstance(QPixelFormat.Internal native)
        {
            return new QPixelFormat(native);
        }

        private static QPixelFormat.Internal* __CopyValue(QPixelFormat.Internal native)
        {
            var ret = (QPixelFormat.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QPixelFormat(QPixelFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPixelFormat(QPixelFormat.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    namespace QtPrivate
    {
    }

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void QImageCleanupFunction(global::System.IntPtr _0);

    /// <summary>
    /// <para>The QImage class provides a hardware-independent image
    /// representation that allows direct access to the pixel data, and can be used
    /// as a paint device.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Qt provides four classes for handling image data: QImage,
    /// QPixmap, QBitmap and QPicture. QImage is designed and optimized for I/O,
    /// and for direct pixel access and manipulation, while QPixmap is designed and
    /// optimized for showing images on screen. QBitmap is only a convenience class
    /// that inherits QPixmap, ensuring a depth of 1. Finally, the QPicture class
    /// is a paint device that records and replays QPainter commands.</para>
    /// <para>Because QImage is a QPaintDevice subclass, QPainter can be used
    /// to draw directly onto images. When using QPainter on a QImage, the painting
    /// can be performed in another thread than the current GUI thread.</para>
    /// <para>The QImage class supports several image formats described by the
    /// Format enum. These include monochrome, 8-bit, 32-bit and alpha-blended
    /// images which are available in all versions of Qt 4.x.</para>
    /// <para>QImage provides a collection of functions that can be used to
    /// obtain a variety of information about the image. There are also several
    /// functions that enables transformation of the image.</para>
    /// <para>QImage objects can be passed around by value since the QImage
    /// class uses implicit data sharing. QImage objects can also be streamed and
    /// compared.</para>
    /// <para>Note: If you would like to load QImage objects in a static build
    /// of Qt, refer to the Plugin HowTo.Warning: Painting on a QImage with the
    /// format QImage::Format_Indexed8 is not supported.</para>
    /// <para></para>
    /// <para>Reading and Writing Image Files</para>
    /// <para>QImage provides several ways of loading an image file: The file
    /// can be loaded when constructing the QImage object, or by using the load()
    /// or loadFromData() functions later on. QImage also provides the static
    /// fromData() function, constructing a QImage from the given data. When
    /// loading an image, the file name can either refer to an actual file on disk
    /// or to one of the application's embedded resources. See The Qt Resource
    /// System overview for details on how to embed images and other resource files
    /// in the application's executable.</para>
    /// <para>Simply call the save() function to save a QImage object.</para>
    /// <para>The complete list of supported file formats are available through
    /// the QImageReader::supportedImageFormats() and
    /// QImageWriter::supportedImageFormats() functions. New file formats can be
    /// added as plugins. By default, Qt supports the following formats:</para>
    /// <para></para>
    /// <para> FormatDescriptionQt's support</para>
    /// <para>BMP	Windows Bitmap	Read/write</para>
    /// <para>GIF	Graphic Interchange Format (optional)	Read</para>
    /// <para>JPG	Joint Photographic Experts Group	Read/write</para>
    /// <para>JPEG	Joint Photographic Experts Group	Read/write</para>
    /// <para>PNG	Portable Network Graphics	Read/write</para>
    /// <para>PBM	Portable Bitmap	Read</para>
    /// <para>PGM	Portable Graymap	Read</para>
    /// <para>PPM	Portable Pixmap	Read/write</para>
    /// <para>XBM	X11 Bitmap	Read/write</para>
    /// <para>XPM	X11 Pixmap	Read/write</para>
    /// </remarks>
    public unsafe partial class QImage : QtGui.QPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            public global::System.IntPtr d;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImageC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImageC2EiiNS_6FormatE")]
            internal static extern void ctor_2(global::System.IntPtr instance, int width, int height, QImage.Format format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImageC2ERK7QStringPKc")]
            internal static extern void ctor_8(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImageC2ERKS_")]
            internal static extern void cctor_9(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImageD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImageeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImageneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage6detachEv")]
            internal static extern void Detach_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage5colorEi")]
            internal static extern uint Color_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage8setColorEij")]
            internal static extern void SetColor_0(global::System.IntPtr instance, int i, uint c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage5validEii")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Valid_0(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage10pixelIndexEii")]
            internal static extern int PixelIndex_0(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage5pixelEii")]
            internal static extern uint Pixel_0(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage4fillERK6QColor")]
            internal static extern void Fill_1(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage19createHeuristicMaskEb")]
            internal static extern void CreateHeuristicMask_0(global::System.IntPtr @return, global::System.IntPtr instance, bool clipTight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QImage10trueMatrixERK7QMatrixii")]
            internal static extern void TrueMatrix_0(global::System.IntPtr @return, global::System.IntPtr matrix, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QImage10trueMatrixERK10QTransformii")]
            internal static extern void TrueMatrix_1(global::System.IntPtr @return, global::System.IntPtr matrix, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage12invertPixelsENS_10InvertModeE")]
            internal static extern void InvertPixels_0(global::System.IntPtr instance, QImage.InvertMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage4loadERK7QStringPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Load_1(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage4saveERK7QStringPKci")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Save_0(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format, int quality);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage4textERK7QString")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage7setTextERK7QStringS2_")]
            internal static extern void SetText_0(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QImage13toPixelFormatENS_6FormatE")]
            internal static extern QPixelFormat.Internal ToPixelFormat_0(QImage.Format format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6QImage13toImageFormatE12QPixelFormat")]
            internal static extern QImage.Format ToImageFormat_0(QPixelFormat.Internal format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage15mirrored_helperEbb")]
            internal static extern void Mirrored_helper_0(global::System.IntPtr @return, global::System.IntPtr instance, bool horizontal, bool vertical);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage16mirrored_inplaceEbb")]
            internal static extern void Mirrored_inplace_0(global::System.IntPtr instance, bool horizontal, bool vertical);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage18rgbSwapped_inplaceEv")]
            internal static extern void RgbSwapped_inplace_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage10colorCountEv")]
            internal static extern int ColorCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage13setColorCountEi")]
            internal static extern void SetColorCount_0(global::System.IntPtr instance, int colorCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage12alphaChannelEv")]
            internal static extern void AlphaChannel_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage15setAlphaChannelERKS_")]
            internal static extern void SetAlphaChannel_0(global::System.IntPtr instance, global::System.IntPtr alphaChannel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage13dotsPerMeterXEv")]
            internal static extern int DotsPerMeterX_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage16setDotsPerMeterXEi")]
            internal static extern void SetDotsPerMeterX_0(global::System.IntPtr instance, int x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage13dotsPerMeterYEv")]
            internal static extern int DotsPerMeterY_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QImage16setDotsPerMeterYEi")]
            internal static extern void SetDotsPerMeterY_0(global::System.IntPtr instance, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage6isNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage10isDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage6formatEv")]
            internal static extern QImage.Format format_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage5widthEv")]
            internal static extern int Width_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage6heightEv")]
            internal static extern int Height_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage5depthEv")]
            internal static extern int Depth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage13bitPlaneCountEv")]
            internal static extern int BitPlaneCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage7allGrayEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AllGray_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage11isGrayscaleEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsGrayscale_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage9byteCountEv")]
            internal static extern int ByteCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage12bytesPerLineEv")]
            internal static extern int BytesPerLine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage15hasAlphaChannelEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasAlphaChannel_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage11pixelFormatEv")]
            internal static extern QPixelFormat.Internal PixelFormat_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QImage17rgbSwapped_helperEv")]
            internal static extern void RgbSwapped_helper_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type is used to describe how pixel values should be
        /// inverted in the invertPixels() function.</para>
        /// <para>See also invertPixels().</para>
        /// </summary>
        public enum InvertMode : uint
        {
            /// <summary>Invert only the RGB values and leave the alpha channel unchanged.</summary>
            InvertRgb = 0,
            /// <summary>Invert all channels, including the alpha channel.</summary>
            InvertRgba = 1
        }

        /// <summary>
        /// <para>The following image formats are available in Qt. Values from
        /// Format_ARGB8565_Premultiplied to Format_ARGB4444_Premultiplied were added
        /// in Qt 4.4. Values Format_RGBX8888, Format_RGBA8888 and
        /// Format_RGBA8888_Premultiplied were added in Qt 5.2. Values Format_BGR30,
        /// Format_A2BGR30_Premultiplied, Format_RGB30, Format_A2RGB30_Premultiplied
        /// were added in Qt 5.4. See the notes after the table.</para>
        /// <para>Note: Drawing into a QImage with QImage::Format_Indexed8 is not
        /// supported.Note: Do not render into ARGB32 images using QPainter. Using
        /// QImage::Format_ARGB32_Premultiplied is significantly faster.Note: Formats
        /// with more than 8 bit per color channel will only be processed by the raster
        /// engine using 8 bit per color.See also format() and
        /// convertToFormat().</para>
        /// </summary>
        public enum Format : uint
        {
            /// <summary>The image is invalid.</summary>
            Format_Invalid = 0,
            /// <summary>The image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.</summary>
            Format_Mono = 1,
            /// <summary>The image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.</summary>
            Format_MonoLSB = 2,
            /// <summary>The image is stored using 8-bit indexes into a colormap.</summary>
            Format_Indexed8 = 3,
            /// <summary>The image is stored using a 32-bit RGB format (0xffRRGGBB).</summary>
            Format_RGB32 = 4,
            /// <summary>The image is stored using a 32-bit ARGB format (0xAARRGGBB).</summary>
            Format_ARGB32 = 5,
            /// <summary>The image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.</summary>
            Format_ARGB32_Premultiplied = 6,
            /// <summary>The image is stored using a 16-bit RGB format (5-6-5).</summary>
            Format_RGB16 = 7,
            /// <summary>The image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).</summary>
            Format_ARGB8565_Premultiplied = 8,
            /// <summary>The image is stored using a 24-bit RGB format (6-6-6). The unused most significant bits is always zero.</summary>
            Format_RGB666 = 9,
            /// <summary>The image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).</summary>
            Format_ARGB6666_Premultiplied = 10,
            /// <summary>The image is stored using a 16-bit RGB format (5-5-5). The unused most significant bit is always zero.</summary>
            Format_RGB555 = 11,
            /// <summary>The image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).</summary>
            Format_ARGB8555_Premultiplied = 12,
            /// <summary>The image is stored using a 24-bit RGB format (8-8-8).</summary>
            Format_RGB888 = 13,
            /// <summary>The image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.</summary>
            Format_RGB444 = 14,
            /// <summary>The image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).</summary>
            Format_ARGB4444_Premultiplied = 15,
            /// <summary>The image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is the same as the Format_RGBA8888 except alpha must always be 255.</summary>
            Format_RGBX8888 = 16,
            /// <summary>The image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32 this is a byte-ordered format, which means the 32bit encoding differs between big endian and little endian architectures, being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA.</summary>
            Format_RGBA8888 = 17,
            /// <summary>The image is stored using a premultiplied 32-bit byte-ordered RGBA format (8-8-8-8).</summary>
            Format_RGBA8888_Premultiplied = 18,
            /// <summary>The image is stored using a 32-bit BGR format (x-10-10-10).</summary>
            Format_BGR30 = 19,
            /// <summary>The image is stored using a 32-bit premultiplied ABGR format (2-10-10-10).</summary>
            Format_A2BGR30_Premultiplied = 20,
            /// <summary>The image is stored using a 32-bit RGB format (x-10-10-10).</summary>
            Format_RGB30 = 21,
            /// <summary>The image is stored using a 32-bit premultiplied ARGB format (2-10-10-10).</summary>
            Format_A2RGB30_Premultiplied = 22,
            NImageFormats = 23
        }

        private readonly bool __ownsNativeInstance;

        public static QImage __CreateInstance(global::System.IntPtr native)
        {
            return new QImage((QImage.Internal*) native);
        }

        public static QImage __CreateInstance(QImage.Internal native)
        {
            return new QImage(native);
        }

        private static QImage.Internal* __CopyValue(QImage.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QImage.Internal.cctor_9(ret, new global::System.IntPtr(&native));
            return (QImage.Internal*) ret;
        }

        private QImage(QImage.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QImage(QImage.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDevice.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a null image.</para>
        /// <para>See also isNull().</para>
        /// </summary>
        public QImage()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an image with the given width, height and
        /// format.</para>
        /// <para>A null image will be returned if memory cannot be
        /// allocated.</para>
        /// <para>Warning: This will create a QImage with uninitialized data. Call
        /// fill() to fill the image with an appropriate pixel value before drawing
        /// onto it with QPainter.</para>
        /// </summary>
        public QImage(int width, int height, QImage.Format format)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg2 = format;
            Internal.ctor_2(__Instance, width, height, arg2);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an image and tries to load the image from the file
        /// with the given fileName.</para>
        /// <para>The loader attempts to read the image using the specified format.
        /// If the format is not specified (which is the default), the loader probes
        /// the file for a header to guess the file format.</para>
        /// <para>If the loading of the image failed, this object is a null
        /// image.</para>
        /// <para>The file name can either refer to an actual file on disk or to
        /// one of the application's embedded resources. See the Resource System
        /// overview for details on how to embed images and other resource files in the
        /// application's executable.</para>
        /// <para>See also isNull() and Reading and Writing Image Files.</para>
        /// </summary>
        public QImage(string fileName, string format = null)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            Internal.ctor_8(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Returns true if this image and the given image have the same
        /// contents; otherwise returns false.</para>
        /// <para>The comparison can be slow, unless there is some obvious
        /// difference (e.g. different size or format), in which case the function will
        /// return quickly.</para>
        /// <para>See also operator=().</para>
        /// </summary>
        public static bool operator ==(QImage __op, QImage image)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool imageNull = ReferenceEquals(image, null);
            if (__opNull || imageNull)
                return __opNull && imageNull;
            var arg0 = __op.__Instance;
            var arg1 = image.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QImage;
        }

        /// <summary>
        /// <para>Returns true if this image and the given image have different
        /// contents; otherwise returns false.</para>
        /// <para>The comparison can be slow, unless there is some obvious
        /// difference, such as different widths, in which case the function will
        /// return quickly.</para>
        /// <para>See also operator=().</para>
        /// </summary>
        public static bool operator !=(QImage __op, QImage image)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        public void Detach()
        {
            Internal.Detach_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the color in the color table at index i. The first color
        /// is at index 0.</para>
        /// <para>The colors in an image's color table are specified as ARGB
        /// quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and qBlue()
        /// functions to get the color value components.</para>
        /// <para>See also setColor(), pixelIndex(), and Pixel Manipulation.</para>
        /// </summary>
        public uint Color(int i)
        {
            var __ret = Internal.Color_0(__Instance, i);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the color at the given index in the color table, to the
        /// given to colorValue. The color value is an ARGB quadruplet.</para>
        /// <para>If index is outside the current size of the color table, it is
        /// expanded with setColorCount().</para>
        /// <para>See also color(), colorCount(), setColorTable(), and Pixel
        /// Manipulation.</para>
        /// </summary>
        public void SetColor(int i, uint c)
        {
            var arg1 = c;
            Internal.SetColor_0(__Instance, i, arg1);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns true if QPoint(x, y) is a valid coordinate pair within
        /// the image; otherwise returns false.</para>
        /// </summary>
        public bool Valid(int x, int y)
        {
            var __ret = Internal.Valid_0(__Instance, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the pixel index at (x, y).</para>
        /// </summary>
        public int PixelIndex(int x, int y)
        {
            var __ret = Internal.PixelIndex_0(__Instance, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the color of the pixel at coordinates (x, y).</para>
        /// </summary>
        public uint Pixel(int x, int y)
        {
            var __ret = Internal.Pixel_0(__Instance, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Fills the entire image with the given color.</para>
        /// <para>If the depth of the image is 1, the image will be filled with 1
        /// if color equals Qt::color1; it will otherwise be filled with 0.</para>
        /// <para>If the depth of the image is 8, the image will be filled with the
        /// index corresponding the color in the color table if present; it will
        /// otherwise be filled with 0.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// </summary>
        public void Fill(QColor color)
        {
            var arg0 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.Fill_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Creates and returns a 1-bpp heuristic mask for this image.</para>
        /// <para>The function works by selecting a color from one of the corners,
        /// then chipping away pixels of that color starting at all the edges. The four
        /// corners vote for which color is to be masked away. In case of a draw (this
        /// generally means that this function is not applicable to the image), the
        /// result is arbitrary.</para>
        /// <para>The returned image has little-endian bit order (i.e. the image's
        /// format is QImage::Format_MonoLSB), which you can convert to big-endian
        /// (QImage::Format_Mono) using the convertToFormat() function.</para>
        /// <para>If clipTight is true (the default) the mask is just large enough
        /// to cover the pixels; otherwise, the mask is larger than the data
        /// pixels.</para>
        /// <para>Note that this function disregards the alpha buffer.</para>
        /// <para>See also createAlphaMask() and Image Transformations.</para>
        /// </summary>
        public QImage CreateHeuristicMask(bool clipTight = true)
        {
            var __ret = new QtGui.QImage.Internal();
            Internal.CreateHeuristicMask_0(new IntPtr(&__ret), __Instance, clipTight);
            return QImage.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Inverts all pixel values in the image.</para>
        /// <para>The given invert mode only have a meaning when the image's depth
        /// is 32. The default mode is InvertRgb, which leaves the alpha channel
        /// unchanged. If the mode is InvertRgba, the alpha bits are also
        /// inverted.</para>
        /// <para>Inverting an 8-bit image means to replace all pixels using color
        /// index i with a pixel using color index 255 minus i. The same is the case
        /// for a 1-bit image. Note that the color table is not changed.</para>
        /// <para>If the image has a premultiplied alpha channel, the image is
        /// first converted to ARGB32 to be inverted and then converted back.</para>
        /// <para>See also Image Transformations.</para>
        /// </summary>
        public void InvertPixels(QImage.InvertMode mode = QImage.InvertMode.InvertRgb)
        {
            var arg0 = mode;
            Internal.InvertPixels_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Loads an image from the file with the given fileName. Returns
        /// true if the image was successfully loaded; otherwise invalidates the image
        /// and returns false.</para>
        /// <para>The loader attempts to read the image using the specified format,
        /// e.g., PNG or JPG. If format is not specified (which is the default), the
        /// loader probes the file for a header to guess the file format.</para>
        /// <para>The file name can either refer to an actual file on disk or to
        /// one of the application's embedded resources. See the Resource System
        /// overview for details on how to embed images and other resource files in the
        /// application's executable.</para>
        /// <para>See also Reading and Writing Image Files.</para>
        /// </summary>
        public bool Load(string fileName, string format = null)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            var __ret = Internal.Load_1(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Saves the image to the file with the given fileName, using the
        /// given image file format and quality factor. If format is 0, QImage will
        /// attempt to guess the format by looking at fileName's suffix.</para>
        /// <para>The quality factor must be in the range 0 to 100 or -1. Specify 0
        /// to obtain small compressed files, 100 for large uncompressed files, and -1
        /// (the default) to use the default settings.</para>
        /// <para>Returns true if the image was successfully saved; otherwise
        /// returns false.</para>
        /// <para>See also Reading and Writing Image Files.</para>
        /// </summary>
        public bool Save(string fileName, string format = null, int quality = -1)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            var __ret = Internal.Save_0(__Instance, arg0, arg1, quality);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the image text associated with the given key. If the
        /// specified key is an empty string, the whole image text is returned, with
        /// each key-text pair separated by a newline.</para>
        /// <para>See also setText() and textKeys().</para>
        /// </summary>
        public string Text(string key = "")
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.Text_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Sets the image text to the given text and associate it with the
        /// given key.</para>
        /// <para>If you just want to store a single text block (i.e., a
        /// &quot;comment&quot; or just a description), you can either pass an empty
        /// key, or use a generic key like &quot;Description&quot;.</para>
        /// <para>The image text is embedded into the image data when you call
        /// save() or QImageWriter::write().</para>
        /// <para>Not all image formats support embedded text. You can find out if
        /// a specific image or format supports embedding text by using
        /// QImageWriter::supportsOption(). We give an example:</para>
        /// <para>    QImageWriter writer;</para>
        /// <para>    writer.setFormat(&quot;png&quot;);</para>
        /// <para>    if
        /// (writer.supportsOption(QImageIOHandler::Description))</para>
        /// <para>        qDebug() &lt;&lt; &quot;Png supports embedded
        /// text&quot;;</para>
        /// <para>You can use QImageWriter::supportedImageFormats() to find out
        /// which image formats are available to you.</para>
        /// <para>See also text() and textKeys().</para>
        /// </summary>
        public void SetText(string key, string value)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.SetText_0(__Instance, arg0, arg1);
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        protected QImage Mirrored_helper(bool horizontal, bool vertical)
        {
            var __ret = new QtGui.QImage.Internal();
            Internal.Mirrored_helper_0(new IntPtr(&__ret), __Instance, horizontal, vertical);
            return QImage.__CreateInstance(__ret);
        }

        protected void Mirrored_inplace(bool horizontal, bool vertical)
        {
            Internal.Mirrored_inplace_0(__Instance, horizontal, vertical);
        }

        protected void RgbSwapped_inplace()
        {
            Internal.RgbSwapped_inplace_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the actual matrix used for transforming an image with the
        /// given width, height and matrix.</para>
        /// <para>When transforming an image using the transformed() function, the
        /// transformation matrix is internally adjusted to compensate for unwanted
        /// translation, i.e. transformed() returns the smallest image containing all
        /// transformed points of the original image. This function returns the
        /// modified matrix, which maps points correctly from the original image into
        /// the new image.</para>
        /// <para>See also transformed() and Image Transformations.</para>
        /// </summary>
        public static QMatrix TrueMatrix(QMatrix matrix, int w, int h)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QMatrix.Internal();
            Internal.TrueMatrix_0(new IntPtr(&__ret), arg0, w, h);
            return QMatrix.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the actual matrix used for transforming an image with the
        /// given width, height and matrix.</para>
        /// <para>When transforming an image using the transformed() function, the
        /// transformation matrix is internally adjusted to compensate for unwanted
        /// translation, i.e. transformed() returns the smallest image containing all
        /// transformed points of the original image. This function returns the
        /// modified matrix, which maps points correctly from the original image into
        /// the new image.</para>
        /// <para>Unlike the other overload, this function creates transformation
        /// matrices that can be used to perform perspective transformations on
        /// images.</para>
        /// <para>See also transformed() and Image Transformations.</para>
        /// </summary>
        public static QTransform TrueMatrix(QTransform matrix, int w, int h)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QTransform.Internal();
            Internal.TrueMatrix_1(new IntPtr(&__ret), arg0, w, h);
            return QTransform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Converts format into a QPixelFormat</para>
        /// </summary>
        public static QPixelFormat ToPixelFormat(QImage.Format format)
        {
            var arg0 = format;
            var __ret = Internal.ToPixelFormat_0(arg0);
            return QPixelFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Converts format into a QImage::Format</para>
        /// </summary>
        public static QImage.Format ToImageFormat(QPixelFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? new QPixelFormat.Internal() : *(QPixelFormat.Internal*) (format.__Instance);
            var __ret = Internal.ToImageFormat_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the size of the color table for the image.</para>
        /// <para>Notice that colorCount() returns 0 for 32-bpp images because
        /// these images do not use color tables, but instead encode pixel values as
        /// ARGB quadruplets.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also setColorCount() and Image Information.</para>
        /// <para></para>
        /// <para>Resizes the color table to contain colorCount entries.</para>
        /// <para>If the color table is expanded, all the extra colors will be set
        /// to transparent (i.e qRgba(0, 0, 0, 0)).</para>
        /// <para>When the image is used, the color table must be large enough to
        /// have entries for all the pixel/index values present in the image, otherwise
        /// the results are undefined.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also colorCount(), colorTable(), setColor(), and Image
        /// Transformations.</para>
        /// </summary>
        public int ColorCount
        {
            get
            {
                var __ret = Internal.ColorCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetColorCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the alpha channel of the image as a new grayscale QImage
        /// in which each pixel's red, green, and blue values are given the alpha value
        /// of the original image. The color depth of the returned image is
        /// 8-bit.</para>
        /// <para>You can see an example of use of this function in QPixmap's
        /// alphaChannel(), which works in the same way as this function on
        /// QPixmaps.</para>
        /// <para>Most usecases for this function can be replaced with QPainter and
        /// using composition modes.</para>
        /// <para>Warning: This is an expensive function.</para>
        /// <para>See also setAlphaChannel(), hasAlphaChannel(), Pixmap, and Image
        /// Transformations.</para>
        /// <para></para>
        /// <para>Sets the alpha channel of this image to the given
        /// alphaChannel.</para>
        /// <para>If alphaChannel is an 8 bit grayscale image, the intensity values
        /// are written into this buffer directly. Otherwise, alphaChannel is converted
        /// to 32 bit and the intensity of the RGB pixel values is used.</para>
        /// <para>Note that the image will be converted to the
        /// Format_ARGB32_Premultiplied format if the function succeeds.</para>
        /// <para>Use one of the composition modes in QPainter::CompositionMode
        /// instead.</para>
        /// <para>Warning: This function is expensive.</para>
        /// <para>See also alphaChannel(), Image Transformations, and Image
        /// Formats.</para>
        /// </summary>
        public QImage AlphaChannel
        {
            get
            {
                var __ret = new QtGui.QImage.Internal();
                Internal.AlphaChannel_0(new IntPtr(&__ret), __Instance);
                return QImage.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetAlphaChannel_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the number of pixels that fit horizontally in a physical
        /// meter. Together with dotsPerMeterY(), this number defines the intended
        /// scale and aspect ratio of the image.</para>
        /// <para>See also setDotsPerMeterX() and Image Information.</para>
        /// <para></para>
        /// <para>Sets the number of pixels that fit horizontally in a physical
        /// meter, to x.</para>
        /// <para>Together with dotsPerMeterY(), this number defines the intended
        /// scale and aspect ratio of the image, and determines the scale at which
        /// QPainter will draw graphics on the image. It does not change the scale or
        /// aspect ratio of the image when it is rendered on other paint
        /// devices.</para>
        /// <para>See also dotsPerMeterX() and Image Information.</para>
        /// </summary>
        public int DotsPerMeterX
        {
            get
            {
                var __ret = Internal.DotsPerMeterX_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetDotsPerMeterX_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of pixels that fit vertically in a physical
        /// meter. Together with dotsPerMeterX(), this number defines the intended
        /// scale and aspect ratio of the image.</para>
        /// <para>See also setDotsPerMeterY() and Image Information.</para>
        /// <para></para>
        /// <para>Sets the number of pixels that fit vertically in a physical
        /// meter, to y.</para>
        /// <para>Together with dotsPerMeterX(), this number defines the intended
        /// scale and aspect ratio of the image, and determines the scale at which
        /// QPainter will draw graphics on the image. It does not change the scale or
        /// aspect ratio of the image when it is rendered on other paint
        /// devices.</para>
        /// <para>See also dotsPerMeterY() and Image Information.</para>
        /// </summary>
        public int DotsPerMeterY
        {
            get
            {
                var __ret = Internal.DotsPerMeterY_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetDotsPerMeterY_0(__Instance, value);
            }
        }

        public override QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if it is a null image, otherwise returns
        /// false.</para>
        /// <para>A null image has all parameters set to zero and no allocated
        /// data.</para>
        /// </summary>
        public bool IsNull
        {
            get
            {
                var __ret = Internal.IsNull_0(__Instance);
                return __ret;
            }
        }

        public bool IsDetached
        {
            get
            {
                var __ret = Internal.IsDetached_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the format of the image.</para>
        /// <para>See also Image Formats.</para>
        /// </summary>
        public QImage.Format format
        {
            get
            {
                var __ret = Internal.format_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the width of the image.</para>
        /// <para>See also Image Information.</para>
        /// </summary>
        public int Width
        {
            get
            {
                var __ret = Internal.Width_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the height of the image.</para>
        /// <para>See also Image Information.</para>
        /// </summary>
        public int Height
        {
            get
            {
                var __ret = Internal.Height_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the depth of the image.</para>
        /// <para>The image depth is the number of bits used to store a single
        /// pixel, also called bits per pixel (bpp).</para>
        /// <para>The supported depths are 1, 8, 16, 24 and 32.</para>
        /// <para>See also bitPlaneCount(), convertToFormat(), Image Formats, and
        /// Image Information.</para>
        /// </summary>
        public int Depth
        {
            get
            {
                var __ret = Internal.Depth_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of bit planes in the image.</para>
        /// <para>The number of bit planes is the number of bits of color and
        /// transparency information for each pixel. This is different from (i.e.
        /// smaller than) the depth when the image format contains unused bits.</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also depth(), format(), and Image Formats.</para>
        /// </summary>
        public int BitPlaneCount
        {
            get
            {
                var __ret = Internal.BitPlaneCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if all the colors in the image are shades of gray
        /// (i.e. their red, green and blue components are equal); otherwise
        /// false.</para>
        /// <para>Note that this function is slow for images without color
        /// table.</para>
        /// <para>See also isGrayscale().</para>
        /// </summary>
        public bool AllGray
        {
            get
            {
                var __ret = Internal.AllGray_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For 32-bit images, this function is equivalent to
        /// allGray().</para>
        /// <para>For 8-bpp images, this function returns true if color(i) is
        /// QRgb(i, i, i) for all indexes of the color table; otherwise returns
        /// false.</para>
        /// <para>See also allGray() and Image Formats.</para>
        /// </summary>
        public bool IsGrayscale
        {
            get
            {
                var __ret = Internal.IsGrayscale_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of bytes occupied by the image data.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also bytesPerLine(), bits(), and Image Information.</para>
        /// </summary>
        public int ByteCount
        {
            get
            {
                var __ret = Internal.ByteCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of bytes per image scanline.</para>
        /// <para>This is equivalent to byteCount() / height().</para>
        /// <para>See also scanLine().</para>
        /// </summary>
        public int BytesPerLine
        {
            get
            {
                var __ret = Internal.BytesPerLine_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the image has a format that respects the alpha
        /// channel, otherwise returns false.</para>
        /// <para>See also Image Information.</para>
        /// </summary>
        public bool HasAlphaChannel
        {
            get
            {
                var __ret = Internal.HasAlphaChannel_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the QImage::Format as a QPixelFormat</para>
        /// </summary>
        public QPixelFormat PixelFormat
        {
            get
            {
                var __ret = Internal.PixelFormat_0(__Instance);
                return QPixelFormat.__CreateInstance(__ret);
            }
        }

        public QImage RgbSwapped_helper
        {
            get
            {
                var __ret = new QtGui.QImage.Internal();
                Internal.RgbSwapped_helper_0(new IntPtr(&__ret), __Instance);
                return QImage.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QImage()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImage) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImage) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImage) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImage) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImage) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QPixmap class is an off-screen image representation that can
    /// be used as a paint device.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Qt provides four classes for handling image data: QImage,
    /// QPixmap, QBitmap and QPicture. QImage is designed and optimized for I/O,
    /// and for direct pixel access and manipulation, while QPixmap is designed and
    /// optimized for showing images on screen. QBitmap is only a convenience class
    /// that inherits QPixmap, ensuring a depth of 1. The isQBitmap() function
    /// returns true if a QPixmap object is really a bitmap, otherwise returns
    /// false. Finally, the QPicture class is a paint device that records and
    /// replays QPainter commands.</para>
    /// <para>A QPixmap can easily be displayed on the screen using QLabel or
    /// one of QAbstractButton's subclasses (such as QPushButton and QToolButton).
    /// QLabel has a pixmap property, whereas QAbstractButton has an icon
    /// property.</para>
    /// <para>QPixmap objects can be passed around by value since the QPixmap
    /// class uses implicit data sharing. For more information, see the Implicit
    /// Data Sharing documentation. QPixmap objects can also be streamed.</para>
    /// <para>Note that the pixel data in a pixmap is internal and is managed
    /// by the underlying window system. Because QPixmap is a QPaintDevice
    /// subclass, QPainter can be used to draw directly onto pixmaps. Pixels can
    /// only be accessed through QPainter functions or by converting the QPixmap to
    /// a QImage. However, the fill() function is available for initializing the
    /// entire pixmap with a given color.</para>
    /// <para>There are functions to convert between QImage and QPixmap.
    /// Typically, the QImage class is used to load an image file, optionally
    /// manipulating the image data, before the QImage object is converted into a
    /// QPixmap to be shown on screen. Alternatively, if no manipulation is
    /// desired, the image file can be loaded directly into a QPixmap.</para>
    /// <para>QPixmap provides a collection of functions that can be used to
    /// obtain a variety of information about the pixmap. In addition, there are
    /// several functions that enables transformation of the pixmap.</para>
    /// <para></para>
    /// <para>Reading and Writing Image Files</para>
    /// <para>QPixmap provides several ways of reading an image file: The file
    /// can be loaded when constructing the QPixmap object, or by using the load()
    /// or loadFromData() functions later on. When loading an image, the file name
    /// can either refer to an actual file on disk or to one of the application's
    /// embedded resources. See The Qt Resource System overview for details on how
    /// to embed images and other resource files in the application's
    /// executable.</para>
    /// <para>Simply call the save() function to save a QPixmap object.</para>
    /// <para>The complete list of supported file formats are available through
    /// the QImageReader::supportedImageFormats() and
    /// QImageWriter::supportedImageFormats() functions. New file formats can be
    /// added as plugins. By default, Qt supports the following formats:</para>
    /// <para></para>
    /// <para> FormatDescriptionQt's support</para>
    /// <para>BMP	Windows Bitmap	Read/write</para>
    /// <para>GIF	Graphic Interchange Format (optional)	Read</para>
    /// <para>JPG	Joint Photographic Experts Group	Read/write</para>
    /// <para>JPEG	Joint Photographic Experts Group	Read/write</para>
    /// <para>PNG	Portable Network Graphics	Read/write</para>
    /// <para>PBM	Portable Bitmap	Read</para>
    /// <para>PGM	Portable Graymap	Read</para>
    /// <para>PPM	Portable Pixmap	Read/write</para>
    /// <para>XBM	X11 Bitmap	Read/write</para>
    /// <para>XPM	X11 Pixmap	Read/write</para>
    /// </remarks>
    public unsafe partial class QPixmap : QtGui.QPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            internal QExplicitlySharedDataPointer.Internal data;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmapC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmapC2Eii")]
            internal static extern void ctor_2(global::System.IntPtr instance, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmapC2ERKS_")]
            internal static extern void cctor_6(global::System.IntPtr instance, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmapD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmap4fillERK6QColor")]
            internal static extern void Fill_0(global::System.IntPtr instance, global::System.IntPtr fillColor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric _204);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap19createHeuristicMaskEb")]
            internal static extern void CreateHeuristicMask_0(global::System.IntPtr @return, global::System.IntPtr instance, bool clipTight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7QPixmap10trueMatrixERK7QMatrixii")]
            internal static extern void TrueMatrix_0(global::System.IntPtr @return, global::System.IntPtr m, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7QPixmap10trueMatrixERK10QTransformii")]
            internal static extern void TrueMatrix_1(global::System.IntPtr @return, global::System.IntPtr m, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap7toImageEv")]
            internal static extern void ToImage_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap4saveERK7QStringPKci")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Save_0(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format, int quality);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmap6detachEv")]
            internal static extern void Detach_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap4maskEv")]
            internal static extern void Mask_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QPixmap7setMaskERK7QBitmap")]
            internal static extern void SetMask_0(global::System.IntPtr instance, global::System.IntPtr mask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap6isNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap5widthEv")]
            internal static extern int Width_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap6heightEv")]
            internal static extern int Height_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap5depthEv")]
            internal static extern int Depth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7QPixmap12defaultDepthEv")]
            internal static extern int DefaultDepth_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap8hasAlphaEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasAlpha_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap15hasAlphaChannelEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasAlphaChannel_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap10isDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QPixmap9isQBitmapEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsQBitmap_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static QPixmap __CreateInstance(global::System.IntPtr native)
        {
            return new QPixmap((QPixmap.Internal*) native);
        }

        public static QPixmap __CreateInstance(QPixmap.Internal native)
        {
            return new QPixmap(native);
        }

        private static QPixmap.Internal* __CopyValue(QPixmap.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QPixmap.Internal.cctor_6(ret, new global::System.IntPtr(&native));
            return (QPixmap.Internal*) ret;
        }

        private QPixmap(QPixmap.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPixmap(QPixmap.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDevice.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a null pixmap.</para>
        /// <para>See also isNull().</para>
        /// </summary>
        public QPixmap()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a pixmap with the given width and height. If either
        /// width or height is zero, a null pixmap is constructed.</para>
        /// <para>Warning: This will create a QPixmap with uninitialized data. Call
        /// fill() to fill the pixmap with an appropriate color before drawing onto it
        /// with QPainter.</para>
        /// <para>See also isNull().</para>
        /// </summary>
        public QPixmap(int w, int h)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_2(__Instance, w, h);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Fills the pixmap with the given color.</para>
        /// <para>The effect of this function is undefined when the pixmap is being
        /// painted on.</para>
        /// <para>See also Pixmap Transformations.</para>
        /// </summary>
        public void Fill(QColor fillColor)
        {
            var arg0 = ReferenceEquals(fillColor, null) ? global::System.IntPtr.Zero : fillColor.__Instance;
            Internal.Fill_0(__Instance, arg0);
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric _204)
        {
            var arg0 = _204;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Creates and returns a heuristic mask for this pixmap.</para>
        /// <para>The function works by selecting a color from one of the corners
        /// and then chipping away pixels of that color, starting at all the edges. If
        /// clipTight is true (the default) the mask is just large enough to cover the
        /// pixels; otherwise, the mask is larger than the data pixels.</para>
        /// <para>The mask may not be perfect but it should be reasonable, so you
        /// can do things such as the following:</para>
        /// <para>QPixmap myPixmap;</para>
        /// <para>myPixmap-&gt;setMask(myPixmap-&gt;createHeuristicMask());</para>
        /// <para>This function is slow because it involves converting to/from a
        /// QImage, and non-trivial computations.</para>
        /// <para>See also QImage::createHeuristicMask() and
        /// createMaskFromColor().</para>
        /// </summary>
        public QBitmap CreateHeuristicMask(bool clipTight = true)
        {
            var __ret = new QtGui.QBitmap.Internal();
            Internal.CreateHeuristicMask_0(new IntPtr(&__ret), __Instance, clipTight);
            return QBitmap.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Converts the pixmap to a QImage. Returns a null image if the
        /// conversion fails.</para>
        /// <para>If the pixmap has 1-bit depth, the returned image will also be 1
        /// bit deep. Images with more bits will be returned in a format closely
        /// represents the underlying system. Usually this will be
        /// QImage::Format_ARGB32_Premultiplied for pixmaps with an alpha and
        /// QImage::Format_RGB32 or QImage::Format_RGB16 for pixmaps without
        /// alpha.</para>
        /// <para>Note that for the moment, alpha masks on monochrome images are
        /// ignored.</para>
        /// <para>See also fromImage() and Image Formats.</para>
        /// </summary>
        public QImage ToImage()
        {
            var __ret = new QtGui.QImage.Internal();
            Internal.ToImage_0(new IntPtr(&__ret), __Instance);
            return QImage.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Saves the pixmap to the file with the given fileName using the
        /// specified image file format and quality factor. Returns true if successful;
        /// otherwise returns false.</para>
        /// <para>The quality factor must be in the range [0,100] or -1. Specify 0
        /// to obtain small compressed files, 100 for large uncompressed files, and -1
        /// to use the default settings.</para>
        /// <para>If format is 0, an image format will be chosen from fileName's
        /// suffix.</para>
        /// <para>See also Reading and Writing Image Files.</para>
        /// </summary>
        public bool Save(string fileName, string format = null, int quality = -1)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            var __ret = Internal.Save_0(__Instance, arg0, arg1, quality);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Detaches the pixmap from shared pixmap data.</para>
        /// <para>A pixmap is automatically detached by Qt whenever its contents
        /// are about to change. This is done in almost all QPixmap member functions
        /// that modify the pixmap (fill(), fromImage(), load(), etc.), and in
        /// QPainter::begin() on a pixmap.</para>
        /// <para>There are two exceptions in which detach() must be called
        /// explicitly, that is when calling the handle() or the x11PictureHandle()
        /// function (only available on X11). Otherwise, any modifications done using
        /// system calls, will be performed on the shared data.</para>
        /// <para>The detach() function returns immediately if there is just a
        /// single reference or if the pixmap has not been initialized yet.</para>
        /// </summary>
        public void Detach()
        {
            Internal.Detach_0(__Instance);
        }

        /// <summary>
        /// <para>Fills the pixmap with the given color.</para>
        /// <para>The effect of this function is undefined when the pixmap is being
        /// painted on.</para>
        /// <para>See also Pixmap Transformations.</para>
        /// </summary>
        public void Fill()
        {
            Fill(Qt.GlobalColor.white);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>This convenience function loads the matrix m into a QTransform
        /// and calls the overloaded function with the QTransform and the width w and
        /// the height h.</para>
        /// </summary>
        public static QMatrix TrueMatrix(QMatrix m, int w, int h)
        {
            var arg0 = ReferenceEquals(m, null) ? global::System.IntPtr.Zero : m.__Instance;
            var __ret = new QtGui.QMatrix.Internal();
            Internal.TrueMatrix_0(new IntPtr(&__ret), arg0, w, h);
            return QMatrix.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the actual matrix used for transforming a pixmap with the
        /// given width, height and matrix.</para>
        /// <para>When transforming a pixmap using the transformed() function, the
        /// transformation matrix is internally adjusted to compensate for unwanted
        /// translation, i.e. transformed() returns the smallest pixmap containing all
        /// transformed points of the original pixmap. This function returns the
        /// modified matrix, which maps points correctly from the original pixmap into
        /// the new pixmap.</para>
        /// <para>See also transformed() and Pixmap Transformations.</para>
        /// </summary>
        public static QTransform TrueMatrix(QTransform m, int w, int h)
        {
            var arg0 = ReferenceEquals(m, null) ? global::System.IntPtr.Zero : m.__Instance;
            var __ret = new QtGui.QTransform.Internal();
            Internal.TrueMatrix_1(new IntPtr(&__ret), arg0, w, h);
            return QTransform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Extracts a bitmap mask from the pixmap's alpha channel.</para>
        /// <para>Warning: This is potentially an expensive operation. The mask of
        /// the pixmap is extracted dynamically from the pixeldata.</para>
        /// <para>See also setMask() and Pixmap Information.</para>
        /// <para></para>
        /// <para>Sets a mask bitmap.</para>
        /// <para>This function merges the mask with the pixmap's alpha channel. A
        /// pixel value of 1 on the mask means the pixmap's pixel is unchanged; a value
        /// of 0 means the pixel is transparent. The mask must have the same size as
        /// this pixmap.</para>
        /// <para>Setting a null mask resets the mask, leaving the previously
        /// transparent pixels black. The effect of this function is undefined when the
        /// pixmap is being painted on.</para>
        /// <para>Warning: This is potentially an expensive operation.</para>
        /// <para>See also mask(), Pixmap Transformations, and QBitmap.</para>
        /// </summary>
        public QBitmap Mask
        {
            get
            {
                var __ret = new QtGui.QBitmap.Internal();
                Internal.Mask_0(new IntPtr(&__ret), __Instance);
                return QBitmap.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetMask_0(__Instance, arg0);
            }
        }

        public override QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if this is a null pixmap; otherwise returns
        /// false.</para>
        /// <para>A null pixmap has zero width, zero height and no contents. You
        /// cannot draw in a null pixmap.</para>
        /// </summary>
        public bool IsNull
        {
            get
            {
                var __ret = Internal.IsNull_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the width of the pixmap.</para>
        /// <para>See also size() and Pixmap Information.</para>
        /// </summary>
        public int Width
        {
            get
            {
                var __ret = Internal.Width_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the height of the pixmap.</para>
        /// <para>See also size() and Pixmap Information.</para>
        /// </summary>
        public int Height
        {
            get
            {
                var __ret = Internal.Height_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the depth of the pixmap.</para>
        /// <para>The pixmap depth is also called bits per pixel (bpp) or bit
        /// planes of a pixmap. A null pixmap has depth 0.</para>
        /// <para>See also defaultDepth() and Pixmap Information.</para>
        /// </summary>
        public int Depth
        {
            get
            {
                var __ret = Internal.Depth_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the default pixmap depth used by the application.</para>
        /// <para>On all platforms the depth of the primary screen will be
        /// returned.</para>
        /// <para>See also depth(), QColormap::depth(), and Pixmap
        /// Information.</para>
        /// </summary>
        public static int DefaultDepth
        {
            get
            {
                var __ret = Internal.DefaultDepth_0();
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this pixmap has an alpha channel, or has a mask,
        /// otherwise returns false.</para>
        /// <para>See also hasAlphaChannel() and mask().</para>
        /// </summary>
        public bool HasAlpha
        {
            get
            {
                var __ret = Internal.HasAlpha_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the pixmap has a format that respects the alpha
        /// channel, otherwise returns false.</para>
        /// <para>See also hasAlpha().</para>
        /// </summary>
        public bool HasAlphaChannel
        {
            get
            {
                var __ret = Internal.HasAlphaChannel_0(__Instance);
                return __ret;
            }
        }

        public bool IsDetached
        {
            get
            {
                var __ret = Internal.IsDetached_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this is a QBitmap; otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsQBitmap
        {
            get
            {
                var __ret = Internal.IsQBitmap_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QPixmap()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPixmap) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPixmap) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric _204);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric _204)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPixmap) _References[instance].Target;
            var _ret = target.Metric(_204);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPixmap) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPixmap) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QBitmap class provides monochrome (1-bit depth)
    /// pixmaps.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QBitmap class is a monochrome off-screen paint device used
    /// mainly for creating custom QCursor and QBrush objects, constructing QRegion
    /// objects, and for setting masks for pixmaps and widgets.</para>
    /// <para>QBitmap is a QPixmap subclass ensuring a depth of 1, except for
    /// null objects which have a depth of 0. If a pixmap with a depth greater than
    /// 1 is assigned to a bitmap, the bitmap will be dithered
    /// automatically.</para>
    /// <para>Use the QColor objects Qt::color0 and Qt::color1 when drawing on
    /// a QBitmap object (or a QPixmap object with depth 1).</para>
    /// <para>Painting with Qt::color0 sets the bitmap bits to 0, and painting
    /// with Qt::color1 sets the bits to 1. For a bitmap, 0-bits indicate
    /// background (or transparent pixels) and 1-bits indicate foreground (or
    /// opaque pixels). Use the clear() function to set all the bits to Qt::color0.
    /// Note that using the Qt::black and Qt::white colors make no sense because
    /// the QColor::pixel() value is not necessarily 0 for black and 1 for
    /// white.</para>
    /// <para>The QBitmap class provides the transformed() function returning a
    /// transformed copy of the bitmap; use the QTransform argument to translate,
    /// scale, shear, and rotate the bitmap. In addition, QBitmap provides the
    /// static fromData() function which returns a bitmap constructed from the
    /// given uchar data, and the static fromImage() function returning a converted
    /// copy of a QImage object.</para>
    /// <para>Just like the QPixmap class, QBitmap is optimized by the use of
    /// implicit data sharing. For more information, see the Implicit Data Sharing
    /// documentation.</para>
    /// <para></para>
    /// <para>See also QPixmap, QImage, QImageReader, and QImageWriter.</para>
    /// </remarks>
    public unsafe partial class QBitmap : QtGui.QPixmap, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            internal QExplicitlySharedDataPointer.Internal data;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QBitmapC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QBitmapC2ERK7QPixmap")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QBitmapC2Eii")]
            internal static extern void ctor_2(global::System.IntPtr instance, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QBitmapC2ERK7QStringPKc")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QBitmapC2ERKS_")]
            internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QBitmapD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QBitmap11transformedERK7QMatrix")]
            internal static extern void Transformed_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QBitmap11transformedERK10QTransform")]
            internal static extern void Transformed_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr matrix);
        }

        private readonly bool __ownsNativeInstance;

        public static new QBitmap __CreateInstance(global::System.IntPtr native)
        {
            return new QBitmap((QBitmap.Internal*) native);
        }

        public static QBitmap __CreateInstance(QBitmap.Internal native)
        {
            return new QBitmap(native);
        }

        private static QBitmap.Internal* __CopyValue(QBitmap.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QBitmap.Internal.cctor_5(ret, new global::System.IntPtr(&native));
            return (QBitmap.Internal*) ret;
        }

        private QBitmap(QBitmap.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QBitmap(QBitmap.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPixmap.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a null bitmap.</para>
        /// <para>See also QPixmap::isNull().</para>
        /// </summary>
        public QBitmap()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a bitmap that is a copy of the given pixmap.</para>
        /// <para>If the pixmap has a depth greater than 1, the resulting bitmap
        /// will be dithered automatically.</para>
        /// <para>See also QPixmap::depth(), fromImage(), and fromData().</para>
        /// </summary>
        public QBitmap(QPixmap pixmap)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            Internal.ctor_1(__Instance, arg0);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a bitmap with the given width and height. The pixels
        /// inside are uninitialized.</para>
        /// <para>See also clear().</para>
        /// </summary>
        public QBitmap(int w, int h)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_2(__Instance, w, h);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a bitmap from the file specified by the given
        /// fileName. If the file does not exist, or has an unknown format, the bitmap
        /// becomes a null bitmap.</para>
        /// <para>The fileName and format parameters are passed on to the
        /// QPixmap::load() function. If the file format uses more than 1 bit per
        /// pixel, the resulting bitmap will be dithered automatically.</para>
        /// <para>See also QPixmap::isNull() and
        /// QImageReader::imageFormat().</para>
        /// </summary>
        public QBitmap(string fileName, string format = null)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            Internal.ctor_4(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>This convenience function converts the matrix to a QTransform and
        /// calls the overloaded function.</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public QBitmap Transformed(QMatrix matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QBitmap.Internal();
            Internal.Transformed_0(new IntPtr(&__ret), __Instance, arg0);
            return QBitmap.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a copy of this bitmap, transformed according to the given
        /// matrix.</para>
        /// <para>See also QPixmap::transformed().</para>
        /// </summary>
        public QBitmap Transformed(QTransform matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QBitmap.Internal();
            Internal.Transformed_1(new IntPtr(&__ret), __Instance, arg0);
            return QBitmap.__CreateInstance(__ret);
        }

        #region Virtual table interop

        // ~QBitmap()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QBitmap) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QBitmap) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric _204);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric _204)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QBitmap) _References[instance].Target;
            var _ret = target.Metric(_204);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QBitmap) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QBitmap) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QIcon class provides scalable icons in different modes and
    /// states.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A QIcon can generate smaller, larger, active, and disabled
    /// pixmaps from the set of pixmaps it is given. Such pixmaps are used by Qt
    /// widgets to show an icon representing a particular action.</para>
    /// <para>The simplest use of QIcon is to create one from a QPixmap file or
    /// resource, and then use it, allowing Qt to work out all the required icon
    /// styles and sizes. For example:</para>
    /// <para>QToolButton *button = new QToolButton;</para>
    /// <para>button-&gt;setIcon(QIcon(&quot;open.xpm&quot;));</para>
    /// <para>To undo a QIcon, simply set a null icon in its place:</para>
    /// <para>button-&gt;setIcon(QIcon());</para>
    /// <para>Use the QImageReader::supportedImageFormats() and
    /// QImageWriter::supportedImageFormats() functions to retrieve a complete list
    /// of the supported file formats.</para>
    /// <para>When you retrieve a pixmap using pixmap(QSize, Mode, State), and
    /// no pixmap for this given size, mode and state has been added with addFile()
    /// or addPixmap(), then QIcon will generate one on the fly. This pixmap
    /// generation happens in a QIconEngineV2. The default engine scales pixmaps
    /// down if required, but never up, and it uses the current style to calculate
    /// a disabled appearance. By using custom icon engines, you can customize
    /// every aspect of generated icons. With QIconEnginePluginV2 it is possible to
    /// register different icon engines for different file suffixes, making it
    /// possible for third parties to provide additional icon engines to those
    /// included with Qt.</para>
    /// <para>Note: Since Qt 4.2, an icon engine that supports SVG is
    /// included.</para>
    /// <para>Making Classes that Use QIcon</para>
    /// <para>If you write your own widgets that have an option to set a small
    /// pixmap, consider allowing a QIcon to be set for that pixmap. The Qt class
    /// QToolButton is an example of such a widget.</para>
    /// <para>Provide a method to set a QIcon, and when you draw the icon,
    /// choose whichever pixmap is appropriate for the current state of your
    /// widget. For example:</para>
    /// <para>void MyWidget::drawIcon(QPainter *painter, QPoint pos)</para>
    /// <para>{</para>
    /// <para>    QPixmap pixmap = icon.pixmap(QSize(22, 22),</para>
    /// <para>                                   isEnabled() ?
    /// QIcon::Normal</para>
    /// <para>                                               :
    /// QIcon::Disabled,</para>
    /// <para>                                   isChecked() ? QIcon::On</para>
    /// <para>                                               :
    /// QIcon::Off);</para>
    /// <para>    painter-&gt;drawPixmap(pos, pixmap);</para>
    /// <para>}</para>
    /// <para>You might also make use of the Active mode, perhaps making your
    /// widget Active when the mouse is over the widget (see
    /// QWidget::enterEvent()), while the mouse is pressed pending the release that
    /// will activate the function, or when it is the currently selected item. If
    /// the widget can be toggled, the &quot;On&quot; mode might be used to draw a
    /// different icon.</para>
    /// <para></para>
    /// <para>See also GUI Design Handbook: Iconic Label and Icons
    /// Example.</para>
    /// </remarks>
    public unsafe partial class QIcon : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIconC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIconC2ERK7QPixmap")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIconC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIconC2ERK7QString")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIconC2EP11QIconEngine")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr engine);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIconD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIcon6detachEv")]
            internal static extern void Detach_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QIcon9addPixmapERK7QPixmapNS_4ModeENS_5StateE")]
            internal static extern void AddPixmap_0(global::System.IntPtr instance, global::System.IntPtr pixmap, QIcon.Mode mode, QIcon.State state);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QIcon9fromThemeERK7QStringRKS_")]
            internal static extern void FromTheme_0(global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr fallback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QIcon12hasThemeIconERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasThemeIcon_0(global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QIcon9themeNameEv")]
            internal static extern void ThemeName_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QIcon12setThemeNameERK7QString")]
            internal static extern void SetThemeName_0(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QIcon4nameEv")]
            internal static extern void Name_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QIcon6isNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QIcon10isDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type describes the mode for which a pixmap is intended
        /// to be used. The currently defined modes are:</para>
        /// </summary>
        public enum Mode : uint
        {
            /// <summary>Display the pixmap when the user is not interacting with the icon, but the functionality represented by the icon is available.</summary>
            Normal = 0,
            /// <summary>Display the pixmap when the functionality represented by the icon is not available.</summary>
            Disabled = 1,
            /// <summary>Display the pixmap when the functionality represented by the icon is available and the user is interacting with the icon, for example, moving the mouse over it or clicking it.</summary>
            Active = 2,
            /// <summary>Display the pixmap when the item represented by the icon is selected.</summary>
            Selected = 3
        }

        /// <summary>
        /// <para>This enum describes the state for which a pixmap is intended to
        /// be used. The state can be:</para>
        /// </summary>
        public enum State : uint
        {
            /// <summary>Display the pixmap when the widget is in an "on" state</summary>
            On = 0,
            /// <summary>Display the pixmap when the widget is in an "off" state</summary>
            Off = 1
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QIcon __CreateInstance(global::System.IntPtr native)
        {
            return new QIcon((QIcon.Internal*) native);
        }

        public static QIcon __CreateInstance(QIcon.Internal native)
        {
            return new QIcon(native);
        }

        private static QIcon.Internal* __CopyValue(QIcon.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QIcon.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QIcon.Internal*) ret;
        }

        private QIcon(QIcon.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QIcon(QIcon.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a null icon.</para>
        /// </summary>
        public QIcon()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs an icon from a pixmap.</para>
        /// </summary>
        public QIcon(QPixmap pixmap)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a copy of other. This is very fast.</para>
        /// </summary>
        public QIcon(QIcon other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs an icon from the file with the given fileName. The
        /// file will be loaded on demand.</para>
        /// <para>If fileName contains a relative path (e.g. the filename only) the
        /// relevant file must be found relative to the runtime working
        /// directory.</para>
        /// <para>The file name can be either refer to an actual file on disk or to
        /// one of the application's embedded resources. See the Resource System
        /// overview for details on how to embed images and other resource files in the
        /// application's executable.</para>
        /// <para>Use the QImageReader::supportedImageFormats() and
        /// QImageWriter::supportedImageFormats() functions to retrieve a complete list
        /// of the supported file formats.</para>
        /// </summary>
        public QIcon(string fileName)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Creates an icon with a specific icon engine. The icon takes
        /// ownership of the engine.</para>
        /// </summary>
        public QIcon(QIconEngine engine)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(engine, null) ? global::System.IntPtr.Zero : engine.__Instance;
            Internal.ctor_5(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public void Detach()
        {
            Internal.Detach_0(__Instance);
        }

        /// <summary>
        /// <para>Adds pixmap to the icon, as a specialization for mode and
        /// state.</para>
        /// <para>Custom icon engines are free to ignore additionally added
        /// pixmaps.</para>
        /// <para>See also addFile().</para>
        /// </summary>
        public void AddPixmap(QPixmap pixmap, QIcon.Mode mode = QIcon.Mode.Normal, QIcon.State state = QIcon.State.Off)
        {
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var arg1 = mode;
            var arg2 = state;
            Internal.AddPixmap_0(__Instance, arg0, arg1, arg2);
        }

        /// <summary>
        /// <para>Returns the QIcon corresponding to name in the current icon
        /// theme. If no such icon is found in the current theme fallback is returned
        /// instead.</para>
        /// <para>The latest version of the freedesktop icon specification and
        /// naming specification can be obtained here:</para>
        /// <para></para>
        ///
        /// <para>http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-late
        /// st.html</para>
        ///
        /// <para>http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-la
        /// test.html</para>
        /// <para></para>
        /// <para>To fetch an icon from the current icon theme:</para>
        /// <para>    QIcon undoicon =
        /// QIcon::fromTheme(&quot;edit-undo&quot;);</para>
        /// <para>Or if you want to provide a guaranteed fallback for platforms
        /// that do not support theme icons, you can use the second argument:</para>
        /// <para>    QIcon undoicon = QIcon::fromTheme(&quot;edit-undo&quot;,
        /// QIcon(&quot;:/undo.png&quot;));</para>
        /// <para>Note: By default, only X11 will support themed icons. In order to
        /// use themed icons on Mac and Windows, you will have to bundle a compliant
        /// theme in one of your themeSearchPaths() and set the appropriate
        /// themeName().This function was introduced in  Qt 4.6.</para>
        /// <para>See also themeName(), setThemeName(), and
        /// themeSearchPaths().</para>
        /// </summary>
        public static QIcon FromTheme(string name, QIcon fallback)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(fallback, null) ? global::System.IntPtr.Zero : fallback.__Instance;
            var __ret = new QtGui.QIcon.Internal();
            Internal.FromTheme_0(new IntPtr(&__ret), arg0, arg1);
            return QIcon.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if there is an icon available for name in the
        /// current icon theme, otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also themeSearchPaths(), fromTheme(), and
        /// setThemeName().</para>
        /// </summary>
        public static bool HasThemeIcon(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.HasThemeIcon_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the QIcon corresponding to name in the current icon
        /// theme. If no such icon is found in the current theme fallback is returned
        /// instead.</para>
        /// <para>The latest version of the freedesktop icon specification and
        /// naming specification can be obtained here:</para>
        /// <para></para>
        ///
        /// <para>http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-late
        /// st.html</para>
        ///
        /// <para>http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-la
        /// test.html</para>
        /// <para></para>
        /// <para>To fetch an icon from the current icon theme:</para>
        /// <para>    QIcon undoicon =
        /// QIcon::fromTheme(&quot;edit-undo&quot;);</para>
        /// <para>Or if you want to provide a guaranteed fallback for platforms
        /// that do not support theme icons, you can use the second argument:</para>
        /// <para>    QIcon undoicon = QIcon::fromTheme(&quot;edit-undo&quot;,
        /// QIcon(&quot;:/undo.png&quot;));</para>
        /// <para>Note: By default, only X11 will support themed icons. In order to
        /// use themed icons on Mac and Windows, you will have to bundle a compliant
        /// theme in one of your themeSearchPaths() and set the appropriate
        /// themeName().This function was introduced in  Qt 4.6.</para>
        /// <para>See also themeName(), setThemeName(), and
        /// themeSearchPaths().</para>
        /// </summary>
        public static QIcon FromTheme(string name)
        {
            return FromTheme(name, new QIcon());
        }

        /// <summary>
        /// <para>Returns the name of the current icon theme.</para>
        /// <para>On X11, the current icon theme depends on your desktop settings.
        /// On other platforms it is not set by default.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also setThemeName(), themeSearchPaths(), fromTheme(), and
        /// hasThemeIcon().</para>
        /// <para></para>
        /// <para>Sets the current icon theme to name.</para>
        /// <para>The name should correspond to a directory name in the
        /// themeSearchPath() containing an index.theme file describing it's
        /// contents.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also themeSearchPaths() and themeName().</para>
        /// </summary>
        public static string ThemeName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.ThemeName_0(new IntPtr(&__ret));
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetThemeName_0(arg0);
            }
        }

        /// <summary>
        /// <para>Returns the name used to create the icon, if available.</para>
        /// <para>Depending on the way the icon was created, it may have an
        /// associated name. This is the case for icons created with fromTheme() or
        /// icons using a QIconEngine which supports the
        /// QIconEngineV2::IconNameHook.</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also fromTheme() and QIconEngine.</para>
        /// </summary>
        public string Name
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Name_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns true if the icon is empty; otherwise returns
        /// false.</para>
        /// <para>An icon is empty if it has neither a pixmap nor a
        /// filename.</para>
        /// <para>Note: Even a non-null icon might not be able to create valid
        /// pixmaps, eg. if the file does not exist or cannot be read.</para>
        /// </summary>
        public bool IsNull
        {
            get
            {
                var __ret = Internal.IsNull_0(__Instance);
                return __ret;
            }
        }

        public bool IsDetached
        {
            get
            {
                var __ret = Internal.IsDetached_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QIconEngine class provides an abstract base class for QIcon
    /// renderers.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>An icon engine provides the rendering functions for a QIcon. Each
    /// icon has a corresponding icon engine that is responsible for drawing the
    /// icon with a requested size, mode and state.</para>
    /// <para>The icon is rendered by the paint() function, and the icon can
    /// additionally be obtained as a pixmap with the pixmap() function (the
    /// default implementation simply uses paint() to achieve this). The
    /// addPixmap() function can be used to add new pixmaps to the icon engine, and
    /// is used by QIcon to add specialized custom pixmaps.</para>
    /// <para>The paint(), pixmap(), and addPixmap() functions are all virtual,
    /// and can therefore be reimplemented in subclasses of QIconEngine.</para>
    /// <para></para>
    /// <para>See also QIconEnginePlugin.</para>
    /// </remarks>
    public unsafe abstract partial class QIconEngine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QIconEngineC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QIconEngineD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QIconEngine9addPixmapERK7QPixmapN5QIcon4ModeENS3_5StateE")]
            internal static extern void AddPixmap_0(global::System.IntPtr instance, global::System.IntPtr pixmap, QIcon.Mode mode, QIcon.State state);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QIconEngine12virtual_hookEiPv")]
            internal static extern void Virtual_hook_0(global::System.IntPtr instance, int id, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QIconEngine3keyEv")]
            internal static extern void Key_0(global::System.IntPtr _return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QIconEngine8iconNameEv")]
            internal static extern void IconName_0(global::System.IntPtr _return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>These enum values are used for virtual_hook() to allow additional
        /// queries to icon engine without breaking binary compatibility.</para>
        /// <para>This enum was introduced or modified in  Qt 4.5.</para>
        /// <para>See also virtual_hook().</para>
        /// </summary>
        public enum IconEngineHook : uint
        {
            /// <summary>Allows to query the sizes of the contained pixmaps for pixmap-based engines. The data argument of the virtual_hook() function is a AvailableSizesArgument pointer that should be filled with icon sizes. Engines that work in terms of a scalable, vectorial format normally return an empty list.</summary>
            AvailableSizesHook = 1,
            /// <summary>Allows to query the name used to create the icon, for example when instantiating an icon using QIcon::fromTheme().</summary>
            IconNameHook = 2
        }

        public unsafe partial class AvailableSizesArgument : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public QIcon.Mode mode;

                [FieldOffset(4)]
                public QIcon.State state;

                [FieldOffset(8)]
                internal QList.Internal sizes;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QIconEngine22AvailableSizesArgumentC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QIconEngine22AvailableSizesArgumentD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static AvailableSizesArgument __CreateInstance(global::System.IntPtr native)
            {
                return new AvailableSizesArgument((AvailableSizesArgument.Internal*) native);
            }

            public static AvailableSizesArgument __CreateInstance(AvailableSizesArgument.Internal native)
            {
                return new AvailableSizesArgument(native);
            }

            private static AvailableSizesArgument.Internal* __CopyValue(AvailableSizesArgument.Internal native)
            {
                var ret = Marshal.AllocHGlobal(12);
                QtGui.QIconEngine.AvailableSizesArgument.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                return (AvailableSizesArgument.Internal*) ret;
            }

            private AvailableSizesArgument(AvailableSizesArgument.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected AvailableSizesArgument(AvailableSizesArgument.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public QIcon.Mode Mode
            {
                get
                {
                    return ((Internal*) __Instance)->mode;
                }

                set
                {
                    ((Internal*) __Instance)->mode = value;
                }
            }

            public QIcon.State State
            {
                get
                {
                    return ((Internal*) __Instance)->state;
                }

                set
                {
                    ((Internal*) __Instance)->state = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QIconEngine(QIconEngine.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Called by QIcon::addPixmap(). Adds a specialized pixmap for the
        /// given mode and state. The default pixmap-based engine stores any supplied
        /// pixmaps, and it uses them instead of scaled pixmaps if the size of a pixmap
        /// matches the size of icon requested. Custom icon engines that implement
        /// scalable vector formats are free to ignores any extra pixmaps.</para>
        /// </summary>
        public virtual void AddPixmap(QPixmap pixmap, QIcon.Mode mode, QIcon.State state)
        {
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var arg1 = mode;
            var arg2 = state;
            Internal.AddPixmap_0(__Instance, arg0, arg1, arg2);
        }

        /// <summary>
        /// <para>Reimplement this method to return a clone of this icon
        /// engine.</para>
        /// </summary>
        public abstract QIconEngine Clone();

        /// <summary>
        /// <para>Additional method to allow extending QIconEngine without adding
        /// new virtual methods (and without breaking binary compatibility). The actual
        /// action and format of data depends on id argument which is in fact a
        /// constant from IconEngineHook enum.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also IconEngineHook.</para>
        /// </summary>
        public virtual void Virtual_hook(int id, global::System.IntPtr data)
        {
            var arg1 = data;
            Internal.Virtual_hook_0(__Instance, id, arg1);
        }

        /// <summary>
        /// <para>Returns a key that identifies this icon engine.</para>
        /// </summary>
        public virtual string Key
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Key_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the name used to create the engine, if available.</para>
        /// <para>Note: This is a helper method and the actual work is done by
        /// virtual_hook() method, hence this method depends on icon engine support and
        /// may not work with all icon engines.This function was introduced in  Qt
        /// 4.7.</para>
        /// </summary>
        public virtual string IconName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.IconName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        #region Virtual table interop

        // virtual ~QIconEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEngine) _References[instance].Target;
            target.Dispose();
        }

        // void addPixmap(const QPixmap &pixmap, QIcon::Mode mode, QIcon::State state)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _AddPixmap_0Delegate(global::System.IntPtr instance, global::System.IntPtr pixmap, QIcon.Mode mode, QIcon.State state);
        private static _AddPixmap_0Delegate _AddPixmap_0DelegateInstance;

        private static void _AddPixmap_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr pixmap, QIcon.Mode mode, QIcon.State state)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEngine) _References[instance].Target;
            target.AddPixmap((pixmap == IntPtr.Zero) ? null : QPixmap.__CreateInstance(pixmap), mode, state);
        }

        // QString key()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _Key_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Key_0Delegate _Key_0DelegateInstance;

        private static QString.Internal _Key_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEngine) _References[instance].Target;
            var _ret = target.Key;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // QIconEngine *clone()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Clone_0Delegate(global::System.IntPtr instance);
        private static _Clone_0Delegate _Clone_0DelegateInstance;

        private static global::System.IntPtr _Clone_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEngine) _References[instance].Target;
            var _ret = target.Clone();
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // QString iconName()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QString.Internal _IconName_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _IconName_0Delegate _IconName_0DelegateInstance;

        private static QString.Internal _IconName_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEngine) _References[instance].Target;
            var _ret = target.IconName;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_ret).ToPointer(), _ret.Length);
            return ReferenceEquals(__qstring0, null) ? new QtCore.QString.Internal() : *(QtCore.QString.Internal*) (__qstring0.__Instance);
        }

        // void virtual_hook(int id, void *data)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Virtual_hook_0Delegate(global::System.IntPtr instance, int id, global::System.IntPtr data);
        private static _Virtual_hook_0Delegate _Virtual_hook_0DelegateInstance;

        private static void _Virtual_hook_0DelegateHook(global::System.IntPtr instance, int id, global::System.IntPtr data)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEngine) _References[instance].Target;
            target.Virtual_hook(id, data);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _AddPixmap_0DelegateInstance += _AddPixmap_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddPixmap_0DelegateInstance).ToPointer();
                _Key_0DelegateInstance += _Key_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Key_0DelegateInstance).ToPointer();
                _Clone_0DelegateInstance += _Clone_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_Clone_0DelegateInstance).ToPointer();
                _IconName_0DelegateInstance += _IconName_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IconName_0DelegateInstance).ToPointer();
                _Virtual_hook_0DelegateInstance += _Virtual_hook_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Virtual_hook_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 20) = _Thunks[1];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[2];
                *(void**)(vfptr0 + 32) = _Thunks[3];
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[4];
                *(void**)(vfptr0 + 52) = _Thunks[5];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QIconEngineInternal : QtGui.QIconEngine, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QIconEngineInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QIconEngineInternal((QIconEngine.Internal*) native);
        }

        public static QIconEngine __CreateInstance(QIconEngine.Internal native)
        {
            return new QIconEngineInternal(native);
        }

        private static QIconEngine.Internal* __CopyValue(QIconEngine.Internal native)
        {
            var ret = (QIconEngine.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QIconEngineInternal(QIconEngine.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QIconEngineInternal(QIconEngine.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QIconEngine.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QIconEngine Clone()
        {
            void* slot = *(void**) (((QIconEngine.Internal*) __Instance)->vfptr0 + 8 * 4);
            var ___Clone_0Delegate = (_Clone_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Clone_0Delegate));
            var __ret = ___Clone_0Delegate(__Instance);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QIconEngineInternal.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QIconEnginePlugin class provides an abstract base for custom
    /// QIconEngine plugins.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The icon engine plugin is a simple plugin interface that makes it
    /// easy to create custom icon engines that can be loaded dynamically into
    /// applications through QIcon. QIcon uses the file or resource name's suffix
    /// to determine what icon engine to use.</para>
    /// <para>Writing a icon engine plugin is achieved by subclassing this base
    /// class, reimplementing the pure virtual function create(), and exporting the
    /// class with the Q_PLUGIN_METADATA() macro.</para>
    /// <para>The json metadata should contain a list of icon engine keys that
    /// this plugin supports. The keys correspond to the suffix of the file or
    /// resource name used when the plugin was created. Keys are case
    /// insensitive.</para>
    /// <para>{ &quot;Keys&quot;: [ &quot;myiconengine&quot; ] }</para>
    /// <para></para>
    /// <para>See also How to Create Qt Plugins.</para>
    /// </remarks>
    public unsafe abstract partial class QIconEnginePlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QIconEnginePluginC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QIconEnginePluginD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QIconEnginePlugin(QIconEnginePlugin.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Creates and returns a QIconEngine object for the icon with the
        /// given filename.</para>
        /// </summary>
        public abstract QIconEngine Create(string filename = "");

        #region Virtual table interop

        // ~QIconEnginePlugin()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEnginePlugin) _References[instance].Target;
            target.Dispose();
        }

        // QIconEngine *create(const QString &filename = QString())
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Create_0Delegate(global::System.IntPtr instance, global::System.IntPtr filename);
        private static _Create_0Delegate _Create_0DelegateInstance;

        private static global::System.IntPtr _Create_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIconEnginePlugin) _References[instance].Target;
            var _ret = target.Create(Marshal.PtrToStringUni(new IntPtr(new QString(filename).Utf16)));
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Create_0DelegateInstance += _Create_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Create_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(12 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QIconEnginePluginInternal : QtGui.QIconEnginePlugin, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QIconEnginePluginInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QIconEnginePluginInternal((QIconEnginePlugin.Internal*) native);
        }

        public static QIconEnginePlugin __CreateInstance(QIconEnginePlugin.Internal native)
        {
            return new QIconEnginePluginInternal(native);
        }

        private static QIconEnginePlugin.Internal* __CopyValue(QIconEnginePlugin.Internal native)
        {
            var ret = (QIconEnginePlugin.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QIconEnginePluginInternal(QIconEnginePlugin.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QIconEnginePluginInternal(QIconEnginePlugin.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QIconEnginePlugin.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QIconEngine Create(string filename = "")
        {
            void* slot = *(void**) (((QIconEnginePlugin.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___Create_0Delegate = (_Create_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Create_0Delegate));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(filename).ToPointer(), filename.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = ___Create_0Delegate(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QIconEngineInternal.__CreateInstance(__ret);
        }
    }

    /// <summary>
    /// <para>The QImageIOHandler class defines the common image I/O interface
    /// for all image formats in Qt.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Qt uses QImageIOHandler for reading and writing images through
    /// QImageReader and QImageWriter. You can also derive from this class to write
    /// your own image format handler using Qt's plugin mechanism.</para>
    /// <para>Call setDevice() to assign a device to the handler, and
    /// setFormat() to assign a format to it. One QImageIOHandler may support more
    /// than one image format. canRead() returns true if an image can be read from
    /// the device, and read() and write() return true if reading or writing an
    /// image was completed successfully.</para>
    /// <para>QImageIOHandler also has support for animations formats, through
    /// the functions loopCount(), imageCount(), nextImageDelay() and
    /// currentImageNumber().</para>
    /// <para>In order to determine what options an image handler supports, Qt
    /// will call supportsOption() and setOption(). Make sure to reimplement these
    /// functions if you can provide support for any of the options in the
    /// ImageOption enum.</para>
    /// <para>To write your own image handler, you must at least reimplement
    /// canRead() and read(). Then create a QImageIOPlugin that can create the
    /// handler. Finally, install your plugin, and QImageReader and QImageWriter
    /// will then automatically load the plugin, and start using it.</para>
    /// <para></para>
    /// <para>See also QImageIOPlugin, QImageReader, and QImageWriter.</para>
    /// </remarks>
    public unsafe abstract partial class QImageIOHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            internal QScopedPointer.Internal d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QImageIOHandlerC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QImageIOHandlerC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QImageIOHandlerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QImageIOHandler5writeERK6QImage")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Write_0(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QImageIOHandler14supportsOptionENS_11ImageOptionE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsOption_0(global::System.IntPtr instance, QImageIOHandler.ImageOption option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QImageIOHandler15jumpToNextImageEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool JumpToNextImage_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QImageIOHandler11jumpToImageEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool JumpToImage_0(global::System.IntPtr instance, int imageNumber);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QImageIOHandler9loopCountEv")]
            internal static extern int LoopCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QImageIOHandler10imageCountEv")]
            internal static extern int ImageCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QImageIOHandler14nextImageDelayEv")]
            internal static extern int NextImageDelay_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QImageIOHandler18currentImageNumberEv")]
            internal static extern int CurrentImageNumber_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the different options supported by
        /// QImageIOHandler. Some options are used to query an image for properties,
        /// and others are used to toggle the way in which an image should be
        /// written.</para>
        /// </summary>
        public enum ImageOption : uint
        {
            /// <summary>The original size of an image. A handler that supports this option is expected to read the size of the image from the image metadata, and return this size from option() as a QSize.</summary>
            Size = 0,
            /// <summary>The clip rect, or ROI (Region Of Interest). A handler that supports this option is expected to only read the provided QRect area from the original image in read(), before any other transformation is applied.</summary>
            ClipRect = 1,
            /// <summary>The image description. Some image formats, such as GIF and PNG, allow embedding of text or comments into the image data (e.g., for storing copyright information). It's common that the text is stored in key-value pairs, but some formats store all text in one continuous block. QImageIOHandler returns the text as one QString, where keys and values are separated by a ':', and keys-value pairs are separated by two newlines (\n\n). For example, "Title: Sunset\n\nAuthor: Jim Smith\nSarah Jones\n\n". Formats that store text in a single block can use "Description" as the key.</summary>
            Description = 2,
            /// <summary>The scaled clip rect (or ROI, Region Of Interest) of the image. A handler that supports this option is expected to apply the provided clip rect (a QRect), after applying any scaling (ScaleSize) or regular clipping (ClipRect). If the handler does not support this option, QImageReader will apply the scaled clip rect after the image has been read.</summary>
            ScaledClipRect = 3,
            /// <summary>The scaled size of the image. A handler that supports this option is expected to scale the image to the provided size (a QSize), after applying any clip rect transformation (ClipRect). If the handler does not support this option, QImageReader will perform the scaling after the image has been read.</summary>
            ScaledSize = 4,
            /// <summary>The compression ratio of the image data. A handler that supports this option is expected to set its compression rate depending on the value of this option (an int) when writing.</summary>
            CompressionRatio = 5,
            /// <summary>The gamma level of the image. A handler that supports this option is expected to set the image gamma level depending on the value of this option (a float) when writing.</summary>
            Gamma = 6,
            /// <summary>The quality level of the image. A handler that supports this option is expected to set the image quality level depending on the value of this option (an int) when writing.</summary>
            Quality = 7,
            /// <summary>The name of the image. A handler that supports this option is expected to read the name from the image metadata and return this as a QString, or when writing an image it is expected to store the name in the image metadata.</summary>
            Name = 8,
            /// <summary>The subtype of the image. A handler that supports this option can use the subtype value to help when reading and writing images. For example, a PPM handler may have a subtype value of "ppm" or "ppmraw".</summary>
            SubType = 9,
            /// <summary>A handler that supports this option is expected to read the image in several passes, as if it was an animation. QImageReader will treat the image as an animation.</summary>
            IncrementalReading = 10,
            /// <summary>The endianness of the image. Certain image formats can be stored as BigEndian or LittleEndian. A handler that supports Endianness uses the value of this option to determine how the image should be stored.</summary>
            Endianness = 11,
            /// <summary>Image formats that support animation return true for this value in supportsOption(); otherwise, false is returned.</summary>
            Animation = 12,
            /// <summary>Certain image formats allow the background color to be specified. A handler that supports BackgroundColor initializes the background color to this option (a QColor) when reading an image.</summary>
            BackgroundColor = 13,
            /// <summary>The image's data format returned by the handler. This can be any of the formats listed in QImage::Format.</summary>
            ImageFormat = 14,
            /// <summary>Image formats that support different saving variants should return a list of supported variant names (QList<QByteArray>) in this option.</summary>
            SupportedSubTypes = 15
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QImageIOHandler(QImageIOHandler.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QImageIOHandler object.</para>
        /// </summary>
        protected QImageIOHandler()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if an image can be read from the device (i.e., the
        /// image format is supported, the device can be read from and the initial
        /// header information suggests that the image can be read); otherwise returns
        /// false.</para>
        /// <para>When reimplementing canRead(), make sure that the I/O device
        /// (device()) is left in its original state (e.g., by using peek() rather than
        /// read()).</para>
        /// <para>See also read() and QIODevice::peek().</para>
        /// </summary>
        public abstract bool CanRead();

        /// <summary>
        /// <para>Read an image from the device, and stores it in image. Returns
        /// true if the image is successfully read; otherwise returns false.</para>
        /// <para>For image formats that support incremental loading, and for
        /// animation formats, the image handler can assume that image points to the
        /// previous frame.</para>
        /// <para>See also canRead().</para>
        /// </summary>
        public abstract bool Read(QImage image);

        /// <summary>
        /// <para>Writes the image image to the assigned device. Returns true on
        /// success; otherwise returns false.</para>
        /// <para>The default implementation does nothing, and simply returns
        /// false.</para>
        /// </summary>
        public virtual bool Write(QImage image)
        {
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = Internal.Write_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the QImageIOHandler supports the option option;
        /// otherwise returns false. For example, if the QImageIOHandler supports the
        /// Size option, supportsOption(Size) must return true.</para>
        /// <para>See also setOption() and option().</para>
        /// </summary>
        public virtual bool SupportsOption(QImageIOHandler.ImageOption option)
        {
            var arg0 = option;
            var __ret = Internal.SupportsOption_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>For image formats that support animation, this function jumps to
        /// the next image.</para>
        /// <para>The default implementation does nothing, and returns
        /// false.</para>
        /// </summary>
        public virtual bool JumpToNextImage()
        {
            var __ret = Internal.JumpToNextImage_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>For image formats that support animation, this function jumps to
        /// the image whose sequence number is imageNumber. The next call to read()
        /// will attempt to read this image.</para>
        /// <para>The default implementation does nothing, and returns
        /// false.</para>
        /// </summary>
        public virtual bool JumpToImage(int imageNumber)
        {
            var __ret = Internal.JumpToImage_0(__Instance, imageNumber);
            return __ret;
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the number of times the animation should loop. If the image format does not
        /// support animation, 0 is returned.</para>
        /// </summary>
        public virtual int LoopCount
        {
            get
            {
                var __ret = Internal.LoopCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the number of images in the animation. If the image format does not support
        /// animation, or if it is unable to determine the number of images, 0 is
        /// returned.</para>
        /// <para>The default implementation returns 1 if canRead() returns true;
        /// otherwise 0 is returned.</para>
        /// </summary>
        public virtual int ImageCount
        {
            get
            {
                var __ret = Internal.ImageCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the number of milliseconds to wait until reading the next image. If the
        /// image format does not support animation, 0 is returned.</para>
        /// </summary>
        public virtual int NextImageDelay
        {
            get
            {
                var __ret = Internal.NextImageDelay_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the sequence number of the current image in the animation. If this function
        /// is called before any image is read(), -1 is returned. The number of the
        /// first image in the sequence is 0.</para>
        /// <para>If the image format does not support animation, 0 is
        /// returned.</para>
        /// <para>See also read().</para>
        /// </summary>
        public virtual int CurrentImageNumber
        {
            get
            {
                var __ret = Internal.CurrentImageNumber_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QImageIOHandler()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            target.Dispose();
        }

        // bool canRead()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _CanRead_0Delegate(global::System.IntPtr instance);
        private static _CanRead_0Delegate _CanRead_0DelegateInstance;

        private static bool _CanRead_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.CanRead();
            return _ret;
        }

        // bool read(QImage *image)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _Read_0Delegate(global::System.IntPtr instance, global::System.IntPtr image);
        private static _Read_0Delegate _Read_0DelegateInstance;

        private static bool _Read_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr image)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.Read((image == IntPtr.Zero) ? null : QImage.__CreateInstance(image));
            return _ret;
        }

        // bool write(const QImage &image)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _Write_0Delegate(global::System.IntPtr instance, global::System.IntPtr image);
        private static _Write_0Delegate _Write_0DelegateInstance;

        private static bool _Write_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr image)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.Write((image == IntPtr.Zero) ? null : QImage.__CreateInstance(image));
            return _ret;
        }

        // bool supportsOption(ImageOption option)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _SupportsOption_0Delegate(global::System.IntPtr instance, QImageIOHandler.ImageOption option);
        private static _SupportsOption_0Delegate _SupportsOption_0DelegateInstance;

        private static bool _SupportsOption_0DelegateHook(global::System.IntPtr instance, QImageIOHandler.ImageOption option)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.SupportsOption(option);
            return _ret;
        }

        // bool jumpToNextImage()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _JumpToNextImage_0Delegate(global::System.IntPtr instance);
        private static _JumpToNextImage_0Delegate _JumpToNextImage_0DelegateInstance;

        private static bool _JumpToNextImage_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.JumpToNextImage();
            return _ret;
        }

        // bool jumpToImage(int imageNumber)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _JumpToImage_0Delegate(global::System.IntPtr instance, int imageNumber);
        private static _JumpToImage_0Delegate _JumpToImage_0DelegateInstance;

        private static bool _JumpToImage_0DelegateHook(global::System.IntPtr instance, int imageNumber)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.JumpToImage(imageNumber);
            return _ret;
        }

        // int loopCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _LoopCount_0Delegate(global::System.IntPtr instance);
        private static _LoopCount_0Delegate _LoopCount_0DelegateInstance;

        private static int _LoopCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.LoopCount;
            return _ret;
        }

        // int imageCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _ImageCount_0Delegate(global::System.IntPtr instance);
        private static _ImageCount_0Delegate _ImageCount_0DelegateInstance;

        private static int _ImageCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.ImageCount;
            return _ret;
        }

        // int nextImageDelay()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _NextImageDelay_0Delegate(global::System.IntPtr instance);
        private static _NextImageDelay_0Delegate _NextImageDelay_0DelegateInstance;

        private static int _NextImageDelay_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.NextImageDelay;
            return _ret;
        }

        // int currentImageNumber()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _CurrentImageNumber_0Delegate(global::System.IntPtr instance);
        private static _CurrentImageNumber_0Delegate _CurrentImageNumber_0DelegateInstance;

        private static int _CurrentImageNumber_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOHandler) _References[instance].Target;
            var _ret = target.CurrentImageNumber;
            return _ret;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[11];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CanRead_0DelegateInstance += _CanRead_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CanRead_0DelegateInstance).ToPointer();
                _Read_0DelegateInstance += _Read_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Read_0DelegateInstance).ToPointer();
                _Write_0DelegateInstance += _Write_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_Write_0DelegateInstance).ToPointer();
                _SupportsOption_0DelegateInstance += _SupportsOption_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SupportsOption_0DelegateInstance).ToPointer();
                _JumpToNextImage_0DelegateInstance += _JumpToNextImage_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_JumpToNextImage_0DelegateInstance).ToPointer();
                _JumpToImage_0DelegateInstance += _JumpToImage_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_JumpToImage_0DelegateInstance).ToPointer();
                _LoopCount_0DelegateInstance += _LoopCount_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_LoopCount_0DelegateInstance).ToPointer();
                _ImageCount_0DelegateInstance += _ImageCount_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ImageCount_0DelegateInstance).ToPointer();
                _NextImageDelay_0DelegateInstance += _NextImageDelay_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_NextImageDelay_0DelegateInstance).ToPointer();
                _CurrentImageNumber_0DelegateInstance += _CurrentImageNumber_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_CurrentImageNumber_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(15 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = _Thunks[4];
                *(void**)(vfptr0 + 36) = _Thunks[5];
                *(void**)(vfptr0 + 40) = _Thunks[6];
                *(void**)(vfptr0 + 44) = _Thunks[7];
                *(void**)(vfptr0 + 48) = _Thunks[8];
                *(void**)(vfptr0 + 52) = _Thunks[9];
                *(void**)(vfptr0 + 56) = _Thunks[10];
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QImageIOPlugin class defines an interface for writing an
    /// image format plugin.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QImageIOPlugin is a factory for creating QImageIOHandler objects,
    /// which are used internally by QImageReader and QImageWriter to add support
    /// for different image formats to Qt.</para>
    /// <para>Writing an image I/O plugin is achieved by subclassing this base
    /// class, reimplementing the pure virtual functions capabilities() and
    /// create(), and exporting the class with the Q_PLUGIN_METADATA() macro. See
    /// How to Create Qt Plugins for details.</para>
    /// <para>An image format plugin can support three capabilities: reading
    /// (CanRead), writing (CanWrite) and incremental reading (CanReadIncremental).
    /// Reimplement capabilities() in you subclass to expose the capabilities of
    /// your image format.</para>
    /// <para>create() should create an instance of your QImageIOHandler
    /// subclass, with the provided device and format properly set, and return this
    /// handler.</para>
    /// <para>The json metadata file for the plugin needs to contain
    /// information about the image formats the plugins supports, together with the
    /// corresponding MIME types (one for each format). For a jpeg plugin, this
    /// could, for example, look as follows:</para>
    /// <para>{</para>
    /// <para>  &quot;Keys&quot;: [ &quot;jpg&quot;, &quot;jpeg&quot; ],</para>
    /// <para>  &quot;MimeTypes&quot;: [ &quot;image/jpeg&quot;,
    /// &quot;image/jpeg&quot; ]</para>
    /// <para>}</para>
    /// <para>Different plugins can support different capabilities. For
    /// example, you may have one plugin that supports reading the GIF format, and
    /// another that supports writing. Qt will select the correct plugin for the
    /// job, depending on the return value of capabilities(). If several plugins
    /// support the same capability, Qt will select one arbitrarily.</para>
    /// <para></para>
    /// <para>See also QImageIOHandler and How to Create Qt Plugins.</para>
    /// </remarks>
    public unsafe abstract partial class QImageIOPlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QImageIOPluginC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QImageIOPluginD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the capabilities of a QImageIOPlugin.</para>
        /// </summary>
        [Flags]
        public enum Capability : uint
        {
            /// <summary>The plugin can read images.</summary>
            CanRead = 0x1,
            /// <summary>The plugin can write images.</summary>
            CanWrite = 0x2,
            /// <summary>The plugin can read images incrementally.</summary>
            CanReadIncremental = 0x4
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QImageIOPlugin(QImageIOPlugin.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // virtual ~QImageIOPlugin()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QImageIOPlugin) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
                *(void**)(vfptr0 + 52) = *(void**)(native->vfptr0 + 52);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QImageIOHandlerInternal : QtGui.QImageIOHandler, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QImageIOHandlerInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QImageIOHandlerInternal((QImageIOHandler.Internal*) native);
        }

        public static QImageIOHandler __CreateInstance(QImageIOHandler.Internal native)
        {
            return new QImageIOHandlerInternal(native);
        }

        private static QImageIOHandler.Internal* __CopyValue(QImageIOHandler.Internal native)
        {
            var ret = (QImageIOHandler.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QImageIOHandlerInternal(QImageIOHandler.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QImageIOHandlerInternal(QImageIOHandler.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QImageIOHandler.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override bool CanRead()
        {
            void* slot = *(void**) (((QImageIOHandler.Internal*) __Instance)->vfptr0 + 3 * 4);
            var ___CanRead_0Delegate = (_CanRead_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_CanRead_0Delegate));
            var __ret = ___CanRead_0Delegate(__Instance);
            return __ret;
        }

        public override bool Read(QImage image)
        {
            void* slot = *(void**) (((QImageIOHandler.Internal*) __Instance)->vfptr0 + 4 * 4);
            var ___Read_0Delegate = (_Read_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Read_0Delegate));
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = ___Read_0Delegate(__Instance, arg0);
            return __ret;
        }
    }

    internal unsafe partial class QImageIOPluginInternal : QtGui.QImageIOPlugin, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QImageIOPluginInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QImageIOPluginInternal((QImageIOPlugin.Internal*) native);
        }

        public static QImageIOPlugin __CreateInstance(QImageIOPlugin.Internal native)
        {
            return new QImageIOPluginInternal(native);
        }

        private static QImageIOPlugin.Internal* __CopyValue(QImageIOPlugin.Internal native)
        {
            var ret = (QImageIOPlugin.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QImageIOPluginInternal(QImageIOPlugin.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QImageIOPluginInternal(QImageIOPlugin.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QImageIOPlugin.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QImageReader class provides a format independent interface
    /// for reading images from files or other devices.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The most common way to read images is through QImage and
    /// QPixmap's constructors, or by calling QImage::load() and QPixmap::load().
    /// QImageReader is a specialized class which gives you more control when
    /// reading images. For example, you can read an image into a specific size by
    /// calling setScaledSize(), and you can select a clip rect, effectively
    /// loading only parts of an image, by calling setClipRect(). Depending on the
    /// underlying support in the image format, this can save memory and speed up
    /// loading of images.</para>
    /// <para>To read an image, you start by constructing a QImageReader
    /// object. Pass either a file name or a device pointer, and the image format
    /// to QImageReader's constructor. You can then set several options, such as
    /// the clip rect (by calling setClipRect()) and scaled size (by calling
    /// setScaledSize()). canRead() returns the image if the QImageReader can read
    /// the image (i.e., the image format is supported and the device is open for
    /// reading). Call read() to read the image.</para>
    /// <para>If any error occurs when reading the image, read() will return a
    /// null QImage. You can then call error() to find the type of error that
    /// occurred, or errorString() to get a human readable description of what went
    /// wrong.</para>
    /// <para></para>
    /// <para>Formats</para>
    /// <para>Call supportedImageFormats() for a list of formats that
    /// QImageReader can read. QImageReader supports all built-in image formats, in
    /// addition to any image format plugins that support reading. Call
    /// supportedMimeTypes() to obtain a list of supported MIME types, which for
    /// example can be passed to QFileDialog::setMimeTypeFilters().</para>
    /// <para>QImageReader autodetects the image format by default, by looking
    /// at the provided (optional) format string, the file name suffix, and the
    /// data stream contents. You can enable or disable this feature, by calling
    /// setAutoDetectImageFormat().</para>
    /// <para></para>
    /// <para>High Resolution Versions of Images</para>
    /// <para>It is possible to provide high resolution versions of images
    /// should a scaling between device pixels and device independent pixels be in
    /// effect.</para>
    /// <para>The high resolution version is marked by the suffix @2x on the
    /// base name. The image read will have its device pixel ratio set to a value
    /// of 2.</para>
    /// <para>This can be disabled by setting the environment variable
    /// QT_HIGHDPI_DISABLE_2X_IMAGE_LOADING.</para>
    /// <para></para>
    /// <para>See also QImageWriter, QImageIOHandler, QImageIOPlugin,
    /// QMimeDatabase, QImage::devicePixelRatio(), QPixmap::devicePixelRatio(),
    /// QIcon, QPainter::drawPixmap(), QPainter::drawImage(), and
    /// Qt::AA_UseHighDpiPixmaps.</para>
    /// </remarks>
    public unsafe partial class QImageReader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReaderC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReaderC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReaderD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader11imageFormatEv")]
            internal static extern QImage.Format ImageFormat_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader4textERK7QString")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader7canReadEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CanRead_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader4readEv")]
            internal static extern void Read_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader4readEP6QImage")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Read_1(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader15jumpToNextImageEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool JumpToNextImage_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader11jumpToImageEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool JumpToImage_0(global::System.IntPtr instance, int imageNumber);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader14supportsOptionEN15QImageIOHandler11ImageOptionE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsOption_0(global::System.IntPtr instance, QImageIOHandler.ImageOption option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader21autoDetectImageFormatEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AutoDetectImageFormat_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader24setAutoDetectImageFormatEb")]
            internal static extern void SetAutoDetectImageFormat_0(global::System.IntPtr instance, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader23decideFormatFromContentEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DecideFormatFromContent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader26setDecideFormatFromContentEb")]
            internal static extern void SetDecideFormatFromContent_0(global::System.IntPtr instance, bool ignored);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader8fileNameEv")]
            internal static extern void FileName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader11setFileNameERK7QString")]
            internal static extern void SetFileName_0(global::System.IntPtr instance, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader7qualityEv")]
            internal static extern int Quality_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader10setQualityEi")]
            internal static extern void SetQuality_0(global::System.IntPtr instance, int quality);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader15backgroundColorEv")]
            internal static extern void BackgroundColor_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageReader18setBackgroundColorERK6QColor")]
            internal static extern void SetBackgroundColor_0(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader17supportsAnimationEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsAnimation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader9loopCountEv")]
            internal static extern int LoopCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader10imageCountEv")]
            internal static extern int ImageCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader14nextImageDelayEv")]
            internal static extern int NextImageDelay_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader18currentImageNumberEv")]
            internal static extern int CurrentImageNumber_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader5errorEv")]
            internal static extern QImageReader.ImageReaderError Error_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageReader11errorStringEv")]
            internal static extern void ErrorString_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the different types of errors that can occur
        /// when reading images with QImageReader.</para>
        /// </summary>
        public enum ImageReaderError : uint
        {
            /// <summary>An unknown error occurred. If you get this value after calling read(), it is most likely caused by a bug in QImageReader.</summary>
            UnknownError = 0,
            /// <summary>QImageReader was used with a file name, but not file was found with that name. This can also happen if the file name contained no extension, and the file with the correct extension is not supported by Qt.</summary>
            FileNotFoundError = 1,
            /// <summary>QImageReader encountered a device error when reading the image. You can consult your particular device for more details on what went wrong.</summary>
            DeviceError = 2,
            /// <summary>Qt does not support the requested image format.</summary>
            UnsupportedFormatError = 3,
            /// <summary>The image data was invalid, and QImageReader was unable to read an image from it. The can happen if the image file is damaged.</summary>
            InvalidDataError = 4
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QImageReader __CreateInstance(global::System.IntPtr native)
        {
            return new QImageReader((QImageReader.Internal*) native);
        }

        public static QImageReader __CreateInstance(QImageReader.Internal native)
        {
            return new QImageReader(native);
        }

        private static QImageReader.Internal* __CopyValue(QImageReader.Internal native)
        {
            var ret = (QImageReader.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QImageReader(QImageReader.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QImageReader(QImageReader.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QImageReader object. Before reading an image,
        /// call setDevice() or setFileName().</para>
        /// </summary>
        public QImageReader()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the format of the image, without actually reading the
        /// image contents. The format describes the image format QImageReader::read()
        /// returns, not the format of the actual image.</para>
        /// <para>If the image format does not support this feature, this function
        /// returns an invalid format.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also QImageIOHandler::ImageOption, QImageIOHandler::option(),
        /// and QImageIOHandler::supportsOption().</para>
        /// </summary>
        public QImage.Format ImageFormat()
        {
            var __ret = Internal.ImageFormat_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the image text associated with key.</para>
        /// <para>Support for this option is implemented through
        /// QImageIOHandler::Description.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also textKeys() and QImageWriter::setText().</para>
        /// </summary>
        public string Text(string key)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.Text_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns true if an image can be read for the device (i.e., the
        /// image format is supported, and the device seems to contain valid data);
        /// otherwise returns false.</para>
        /// <para>canRead() is a lightweight function that only does a quick test
        /// to see if the image data is valid. read() may still return false after
        /// canRead() returns true, if the image data is corrupt.</para>
        /// <para>For images that support animation, canRead() returns false when
        /// all frames have been read.</para>
        /// <para>See also read() and supportedImageFormats().</para>
        /// </summary>
        public bool CanRead()
        {
            var __ret = Internal.CanRead_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Reads an image from the device. On success, the image that was
        /// read is returned; otherwise, a null QImage is returned. You can then call
        /// error() to find the type of error that occurred, or errorString() to get a
        /// human readable description of the error.</para>
        /// <para>For image formats that support animation, calling read()
        /// repeatedly will return the next frame. When all frames have been read, a
        /// null image will be returned.</para>
        /// <para>See also canRead(), supportedImageFormats(), supportsAnimation(),
        /// and QMovie.</para>
        /// </summary>
        public QImage Read()
        {
            var __ret = new QtGui.QImage.Internal();
            Internal.Read_0(new IntPtr(&__ret), __Instance);
            return QImage.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Reads an image from the device into image, which must point to a
        /// QImage. Returns true on success; otherwise, returns false.</para>
        /// <para>If image has same format and size as the image data that is about
        /// to be read, this function may not need to allocate a new image before
        /// reading. Because of this, it can be faster than the other read() overload,
        /// which always constructs a new image; especially when reading several images
        /// with the same format and size.</para>
        /// <para>QImage icon(64, 64, QImage::Format_RGB32);</para>
        /// <para>QImageReader reader(&quot;icon_64x64.bmp&quot;);</para>
        /// <para>if (reader.read(&amp;icon)) {</para>
        /// <para>    // Display icon</para>
        /// <para>}</para>
        /// <para>For image formats that support animation, calling read()
        /// repeatedly will return the next frame. When all frames have been read, a
        /// null image will be returned.</para>
        /// <para>See also canRead(), supportedImageFormats(), supportsAnimation(),
        /// and QMovie.</para>
        /// </summary>
        public bool Read(QImage image)
        {
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = Internal.Read_1(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>For image formats that support animation, this function steps
        /// over the current image, returning true if successful or false if there is
        /// no following image in the animation.</para>
        /// <para>The default implementation calls read(), then discards the
        /// resulting image, but the image handler may have a more efficient way of
        /// implementing this operation.</para>
        /// <para>See also jumpToImage() and
        /// QImageIOHandler::jumpToNextImage().</para>
        /// </summary>
        public bool JumpToNextImage()
        {
            var __ret = Internal.JumpToNextImage_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>For image formats that support animation, this function skips to
        /// the image whose sequence number is imageNumber, returning true if
        /// successful or false if the corresponding image cannot be found.</para>
        /// <para>The next call to read() will attempt to read this image.</para>
        /// <para>See also jumpToNextImage() and
        /// QImageIOHandler::jumpToImage().</para>
        /// </summary>
        public bool JumpToImage(int imageNumber)
        {
            var __ret = Internal.JumpToImage_0(__Instance, imageNumber);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the reader supports option; otherwise returns
        /// false.</para>
        /// <para>Different image formats support different options. Call this
        /// function to determine whether a certain option is supported by the current
        /// format. For example, the PNG format allows you to embed text into the
        /// image's metadata (see text()), and the BMP format allows you to determine
        /// the image's size without loading the whole image into memory (see
        /// size()).</para>
        /// <para>QImageReader reader(&quot;:/image.png&quot;);</para>
        /// <para>if (reader.supportsOption(QImageIOHandler::Size))</para>
        /// <para>    qDebug() &lt;&lt; &quot;Size:&quot; &lt;&lt;
        /// reader.size();</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also QImageWriter::supportsOption().</para>
        /// </summary>
        public bool SupportsOption(QImageIOHandler.ImageOption option)
        {
            var arg0 = option;
            var __ret = Internal.SupportsOption_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if image format autodetection is enabled on this
        /// image reader; otherwise returns false. By default, autodetection is
        /// enabled.</para>
        /// <para>See also setAutoDetectImageFormat().</para>
        /// <para></para>
        /// <para>If enabled is true, image format autodetection is enabled;
        /// otherwise, it is disabled. By default, autodetection is enabled.</para>
        /// <para>QImageReader uses an extensive approach to detecting the image
        /// format; firstly, if you pass a file name to QImageReader, it will attempt
        /// to detect the file extension if the given file name does not point to an
        /// existing file, by appending supported default extensions to the given file
        /// name, one at a time. It then uses the following approach to detect the
        /// image format:</para>
        /// <para></para>
        /// <para>Image plugins are queried first, based on either the optional
        /// format string, or the file name suffix (if the source device is a file). No
        /// content detection is done at this stage. QImageReader will choose the first
        /// plugin that supports reading for this format.</para>
        /// <para>If no plugin supports the image format, Qt's built-in handlers
        /// are checked based on either the optional format string, or the file name
        /// suffix.</para>
        /// <para>If no capable plugins or built-in handlers are found, each plugin
        /// is tested by inspecting the content of the data stream.</para>
        /// <para>If no plugins could detect the image format based on data
        /// contents, each built-in image handler is tested by inspecting the
        /// contents.</para>
        /// <para>Finally, if all above approaches fail, QImageReader will report
        /// failure when trying to read the image.</para>
        /// <para></para>
        /// <para>By disabling image format autodetection, QImageReader will only
        /// query the plugins and built-in handlers based on the format string (i.e.,
        /// no file name extensions are tested).</para>
        /// <para>See also autoDetectImageFormat(), QImageIOHandler::canRead(), and
        /// QImageIOPlugin::capabilities().</para>
        /// </summary>
        public bool AutoDetectImageFormat
        {
            get
            {
                var __ret = Internal.AutoDetectImageFormat_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetAutoDetectImageFormat_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns whether the image reader should decide which plugin to
        /// use only based on the contents of the datastream rather than on the file
        /// extension.</para>
        /// <para>See also setDecideFormatFromContent().</para>
        /// <para></para>
        /// <para>If ignored is set to true, then the image reader will ignore
        /// specified formats or file extensions and decide which plugin to use only
        /// based on the contents in the datastream.</para>
        /// <para>Setting this flag means that all image plugins gets loaded. Each
        /// plugin will read the first bytes in the image data and decide if the plugin
        /// is compatible or not.</para>
        /// <para>This also disables auto detecting the image format.</para>
        /// <para>See also decideFormatFromContent().</para>
        /// </summary>
        public bool DecideFormatFromContent
        {
            get
            {
                var __ret = Internal.DecideFormatFromContent_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetDecideFormatFromContent_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>If the currently assigned device is a QFile, or if setFileName()
        /// has been called, this function returns the name of the file QImageReader
        /// reads from. Otherwise (i.e., if no device has been assigned or the device
        /// is not a QFile), an empty QString is returned.</para>
        /// <para>See also setFileName() and setDevice().</para>
        /// <para></para>
        /// <para>Sets the file name of QImageReader to fileName. Internally,
        /// QImageReader will create a QFile object and open it in QIODevice::ReadOnly
        /// mode, and use this when reading images.</para>
        /// <para>If fileName does not include a file extension (e.g., .png or
        /// .bmp), QImageReader will cycle through all supported extensions until it
        /// finds a matching file.</para>
        /// <para>See also fileName(), setDevice(), and
        /// supportedImageFormats().</para>
        /// </summary>
        public string FileName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FileName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFileName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the quality setting of the image format.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setQuality().</para>
        /// <para></para>
        /// <para>Sets the quality setting of the image format to quality.</para>
        /// <para>Some image formats, in particular lossy ones, entail a tradeoff
        /// between a) visual quality of the resulting image, and b) decoding execution
        /// time. This function sets the level of that tradeoff for image formats that
        /// support it.</para>
        /// <para>In case of scaled image reading, the quality setting may also
        /// influence the tradeoff level between visual quality and execution speed of
        /// the scaling algorithm.</para>
        /// <para>The value range of quality depends on the image format. For
        /// example, the &quot;jpeg&quot; format supports a quality range from 0 (low
        /// visual quality) to 100 (high visual quality).</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also quality() and setScaledSize().</para>
        /// </summary>
        public int Quality
        {
            get
            {
                var __ret = Internal.Quality_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetQuality_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the background color that's used when reading an image.
        /// If the image format does not support setting the background color an
        /// invalid color is returned.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also setBackgroundColor() and read().</para>
        /// <para></para>
        /// <para>Sets the background color to color. Image formats that support
        /// this operation are expected to initialize the background to color before
        /// reading an image.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also backgroundColor() and read().</para>
        /// </summary>
        public QColor BackgroundColor
        {
            get
            {
                var __ret = new QtGui.QColor.Internal();
                Internal.BackgroundColor_0(new IntPtr(&__ret), __Instance);
                return QColor.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBackgroundColor_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if the image format supports animation; otherwise,
        /// false is returned.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also QMovie::supportedFormats().</para>
        /// </summary>
        public bool SupportsAnimation
        {
            get
            {
                var __ret = Internal.SupportsAnimation_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the number of times the animation should loop. If this function returns -1,
        /// it can either mean the animation should loop forever, or that an error
        /// occurred. If an error occurred, canRead() will return false.</para>
        /// <para>See also supportsAnimation(), QImageIOHandler::loopCount(), and
        /// canRead().</para>
        /// </summary>
        public int LoopCount
        {
            get
            {
                var __ret = Internal.LoopCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the total number of images in the animation. If the format does not support
        /// animation, 0 is returned.</para>
        /// <para>This function returns -1 if an error occurred.</para>
        /// <para>See also supportsAnimation(), QImageIOHandler::imageCount(), and
        /// canRead().</para>
        /// </summary>
        public int ImageCount
        {
            get
            {
                var __ret = Internal.ImageCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the number of milliseconds to wait until displaying the next frame in the
        /// animation. If the image format doesn't support animation, 0 is
        /// returned.</para>
        /// <para>This function returns -1 if an error occurred.</para>
        /// <para>See also supportsAnimation(), QImageIOHandler::nextImageDelay(),
        /// and canRead().</para>
        /// </summary>
        public int NextImageDelay
        {
            get
            {
                var __ret = Internal.NextImageDelay_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>For image formats that support animation, this function returns
        /// the sequence number of the current frame. If the image format doesn't
        /// support animation, 0 is returned.</para>
        /// <para>This function returns -1 if an error occurred.</para>
        /// <para>See also supportsAnimation(),
        /// QImageIOHandler::currentImageNumber(), and canRead().</para>
        /// </summary>
        public int CurrentImageNumber
        {
            get
            {
                var __ret = Internal.CurrentImageNumber_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the type of error that occurred last.</para>
        /// <para>See also ImageReaderError and errorString().</para>
        /// </summary>
        public QImageReader.ImageReaderError Error
        {
            get
            {
                var __ret = Internal.Error_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a human readable description of the last error that
        /// occurred.</para>
        /// <para>See also error().</para>
        /// </summary>
        public string ErrorString
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.ErrorString_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    /// <summary>
    /// <para>The QImageWriter class provides a format independent interface
    /// for writing images to files or other devices.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QImageWriter supports setting format specific options, such as
    /// the gamma level, compression level and quality, prior to storing the image.
    /// If you do not need such options, you can use QImage::save() or
    /// QPixmap::save() instead.</para>
    /// <para>To store an image, you start by constructing a QImageWriter
    /// object. Pass either a file name or a device pointer, and the image format
    /// to QImageWriter's constructor. You can then set several options, such as
    /// the gamma level (by calling setGamma()) and quality (by calling
    /// setQuality()). canWrite() returns true if QImageWriter can write the image
    /// (i.e., the image format is supported and the device is open for writing).
    /// Call write() to write the image to the device.</para>
    /// <para>If any error occurs when writing the image, write() will return
    /// false. You can then call error() to find the type of error that occurred,
    /// or errorString() to get a human readable description of what went
    /// wrong.</para>
    /// <para>Call supportedImageFormats() for a list of formats that
    /// QImageWriter can write. QImageWriter supports all built-in image formats,
    /// in addition to any image format plugins that support writing.</para>
    /// <para></para>
    /// <para>See also QImageReader, QImageIOHandler, and
    /// QImageIOPlugin.</para>
    /// </remarks>
    public unsafe partial class QImageWriter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriterC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriterC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriterD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter7setTextERK7QStringS2_")]
            internal static extern void SetText_0(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter8canWriteEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CanWrite_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter5writeERK6QImage")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Write_0(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter14supportsOptionEN15QImageIOHandler11ImageOptionE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsOption_0(global::System.IntPtr instance, QImageIOHandler.ImageOption option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter8fileNameEv")]
            internal static extern void FileName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter11setFileNameERK7QString")]
            internal static extern void SetFileName_0(global::System.IntPtr instance, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter7qualityEv")]
            internal static extern int Quality_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter10setQualityEi")]
            internal static extern void SetQuality_0(global::System.IntPtr instance, int quality);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter11compressionEv")]
            internal static extern int Compression_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter14setCompressionEi")]
            internal static extern void SetCompression_0(global::System.IntPtr instance, int compression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter5gammaEv")]
            internal static extern float Gamma_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter8setGammaEf")]
            internal static extern void SetGamma_0(global::System.IntPtr instance, float gamma);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter11descriptionEv")]
            internal static extern void Description_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QImageWriter14setDescriptionERK7QString")]
            internal static extern void SetDescription_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter5errorEv")]
            internal static extern QImageWriter.ImageWriterError Error_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QImageWriter11errorStringEv")]
            internal static extern void ErrorString_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes errors that can occur when writing images
        /// with QImageWriter.</para>
        /// </summary>
        public enum ImageWriterError : uint
        {
            /// <summary>An unknown error occurred. If you get this value after calling write(), it is most likely caused by a bug in QImageWriter.</summary>
            UnknownError = 0,
            /// <summary>QImageWriter encountered a device error when writing the image data. Consult your device for more details on what went wrong.</summary>
            DeviceError = 1,
            /// <summary>Qt does not support the requested image format.</summary>
            UnsupportedFormatError = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QImageWriter __CreateInstance(global::System.IntPtr native)
        {
            return new QImageWriter((QImageWriter.Internal*) native);
        }

        public static QImageWriter __CreateInstance(QImageWriter.Internal native)
        {
            return new QImageWriter(native);
        }

        private static QImageWriter.Internal* __CopyValue(QImageWriter.Internal native)
        {
            var ret = (QImageWriter.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QImageWriter(QImageWriter.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QImageWriter(QImageWriter.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QImageWriter object. Before writing, you must
        /// call setFormat() to set an image format, then setDevice() or
        /// setFileName().</para>
        /// </summary>
        public QImageWriter()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the image text associated with the key key to text. This is
        /// useful for storing copyright information or other information about the
        /// image. Example:</para>
        /// <para>QImage image(&quot;some/image.jpeg&quot;);</para>
        /// <para>QImageWriter writer(&quot;images/outimage.png&quot;,
        /// &quot;png&quot;);</para>
        /// <para>writer.setText(&quot;Author&quot;, &quot;John
        /// Smith&quot;);</para>
        /// <para>writer.write(image);</para>
        /// <para>If you want to store a single block of data (e.g., a comment),
        /// you can pass an empty key, or use a generic key like
        /// &quot;Description&quot;.</para>
        /// <para>The key and text will be embedded into the image data after
        /// calling write().</para>
        /// <para>Support for this option is implemented through
        /// QImageIOHandler::Description.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also QImage::setText() and QImageReader::text().</para>
        /// </summary>
        public void SetText(string key, string text)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.SetText_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Returns true if QImageWriter can write the image; i.e., the image
        /// format is supported and the assigned device is open for reading.</para>
        /// <para>See also write(), setDevice(), and setFormat().</para>
        /// </summary>
        public bool CanWrite()
        {
            var __ret = Internal.CanWrite_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Writes the image image to the assigned device or file name.
        /// Returns true on success; otherwise returns false. If the operation fails,
        /// you can call error() to find the type of error that occurred, or
        /// errorString() to get a human readable description of the error.</para>
        /// <para>See also canWrite(), error(), and errorString().</para>
        /// </summary>
        public bool Write(QImage image)
        {
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = Internal.Write_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the writer supports option; otherwise returns
        /// false.</para>
        /// <para>Different image formats support different options. Call this
        /// function to determine whether a certain option is supported by the current
        /// format. For example, the PNG format allows you to embed text into the
        /// image's metadata (see text()).</para>
        /// <para>QImageWriter writer(fileName);</para>
        /// <para>if (writer.supportsOption(QImageIOHandler::Description))</para>
        /// <para>    writer.setText(&quot;Author&quot;, &quot;John
        /// Smith&quot;);</para>
        /// <para>Options can be tested after the writer has been associated with a
        /// format.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also QImageReader::supportsOption() and setFormat().</para>
        /// </summary>
        public bool SupportsOption(QImageIOHandler.ImageOption option)
        {
            var arg0 = option;
            var __ret = Internal.SupportsOption_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>If the currently assigned device is a QFile, or if setFileName()
        /// has been called, this function returns the name of the file QImageWriter
        /// writes to. Otherwise (i.e., if no device has been assigned or the device is
        /// not a QFile), an empty QString is returned.</para>
        /// <para>See also setFileName() and setDevice().</para>
        /// <para></para>
        /// <para>Sets the file name of QImageWriter to fileName. Internally,
        /// QImageWriter will create a QFile and open it in QIODevice::WriteOnly mode,
        /// and use this file when writing images.</para>
        /// <para>See also fileName() and setDevice().</para>
        /// </summary>
        public string FileName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FileName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFileName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the quality setting of the image format.</para>
        /// <para>See also setQuality().</para>
        /// <para></para>
        /// <para>Sets the quality setting of the image format to quality.</para>
        /// <para>Some image formats, in particular lossy ones, entail a tradeoff
        /// between a) visual quality of the resulting image, and b) encoding execution
        /// time and compression level. This function sets the level of that tradeoff
        /// for image formats that support it. For other formats, this value is
        /// ignored.</para>
        /// <para>The value range of quality depends on the image format. For
        /// example, the &quot;jpeg&quot; format supports a quality range from 0 (low
        /// visual quality, high compression) to 100 (high visual quality, low
        /// compression).</para>
        /// <para>See also quality().</para>
        /// </summary>
        public int Quality
        {
            get
            {
                var __ret = Internal.Quality_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetQuality_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the compression of the image.</para>
        /// <para>See also setCompression().</para>
        /// <para></para>
        /// <para>This is an image format specific function that set the
        /// compression of an image. For image formats that do not support setting the
        /// compression, this value is ignored.</para>
        /// <para>The value range of compression depends on the image format. For
        /// example, the &quot;tiff&quot; format supports two values, 0(no compression)
        /// and 1(LZW-compression).</para>
        /// <para>See also compression().</para>
        /// </summary>
        public int Compression
        {
            get
            {
                var __ret = Internal.Compression_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetCompression_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the gamma level of the image.</para>
        /// <para>See also setGamma().</para>
        /// <para></para>
        /// <para>This is an image format specific function that sets the gamma
        /// level of the image to gamma. For image formats that do not support setting
        /// the gamma level, this value is ignored.</para>
        /// <para>The value range of gamma depends on the image format. For
        /// example, the &quot;png&quot; format supports a gamma range from 0.0 to
        /// 1.0.</para>
        /// <para>See also gamma() and quality().</para>
        /// </summary>
        public float Gamma
        {
            get
            {
                var __ret = Internal.Gamma_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetGamma_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Use QImageReader::text() instead.</para>
        /// <para>Returns the description of the image.</para>
        /// <para>See also setDescription().</para>
        /// <para></para>
        /// <para>Use setText() instead.</para>
        /// <para>This is an image format specific function that sets the
        /// description of the image to description. For image formats that do not
        /// support setting the description, this value is ignored.</para>
        /// <para>The contents of description depends on the image format.</para>
        /// <para>See also description().</para>
        /// </summary>
        public string Description
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Description_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetDescription_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the type of error that last occurred.</para>
        /// <para>See also ImageWriterError and errorString().</para>
        /// </summary>
        public QImageWriter.ImageWriterError Error
        {
            get
            {
                var __ret = Internal.Error_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a human readable description of the last error that
        /// occurred.</para>
        /// <para>See also error().</para>
        /// </summary>
        public string ErrorString
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.ErrorString_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    /// <summary>
    /// <para>The QMovie class is a convenience class for playing movies with
    /// QImageReader.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is used to show simple animations without sound. If
    /// you want to display video and media content, use the Qt Multimedia
    /// multimedia framework instead.</para>
    /// <para>First, create a QMovie object by passing either the name of a
    /// file or a pointer to a QIODevice containing an animated image format to
    /// QMovie's constructor. You can call isValid() to check if the image data is
    /// valid, before starting the movie. To start the movie, call start(). QMovie
    /// will enter Running state, and emit started() and stateChanged(). To get the
    /// current state of the movie, call state().</para>
    /// <para>To display the movie in your application, you can pass your
    /// QMovie object to QLabel::setMovie(). Example:</para>
    /// <para>QLabel label;</para>
    /// <para>QMovie *movie = new
    /// QMovie(&quot;animations/fire.gif&quot;);</para>
    /// <para></para>
    /// <para>label.setMovie(movie);</para>
    /// <para>movie-&gt;start();</para>
    /// <para>Whenever a new frame is available in the movie, QMovie will emit
    /// updated(). If the size of the frame changes, resized() is emitted. You can
    /// call currentImage() or currentPixmap() to get a copy of the current frame.
    /// When the movie is done, QMovie emits finished(). If any error occurs during
    /// playback (i.e, the image file is corrupt), QMovie will emit error().</para>
    /// <para>You can control the speed of the movie playback by calling
    /// setSpeed(), which takes the percentage of the original speed as an
    /// argument. Pause the movie by calling setPaused(true). QMovie will then
    /// enter Paused state and emit stateChanged(). If you call setPaused(false),
    /// QMovie will reenter Running state and start the movie again. To stop the
    /// movie, call stop().</para>
    /// <para>Certain animation formats allow you to set the background color.
    /// You can call setBackgroundColor() to set the color, or backgroundColor() to
    /// retrieve the current background color.</para>
    /// <para>currentFrameNumber() returns the sequence number of the current
    /// frame. The first frame in the animation has the sequence number 0.
    /// frameCount() returns the total number of frames in the animation, if the
    /// image format supports this. You can call loopCount() to get the number of
    /// times the movie should loop before finishing. nextFrameDelay() returns the
    /// number of milliseconds the current frame should be displayed.</para>
    /// <para>QMovie can be instructed to cache frames of an animation by
    /// calling setCacheMode().</para>
    /// <para>Call supportedFormats() for a list of formats that QMovie
    /// supports.</para>
    /// <para></para>
    /// <para>See also QLabel, QImageReader, and Movie Example.</para>
    /// </remarks>
    public unsafe partial class QMovie : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovieC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovieD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie11jumpToFrameEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool JumpToFrame_0(global::System.IntPtr instance, int frameNumber);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie5startEv")]
            internal static extern void Start_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie15jumpToNextFrameEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool JumpToNextFrame_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie9setPausedEb")]
            internal static extern void SetPaused_0(global::System.IntPtr instance, bool paused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie4stopEv")]
            internal static extern void Stop_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie8fileNameEv")]
            internal static extern void FileName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie11setFileNameERK7QString")]
            internal static extern void SetFileName_0(global::System.IntPtr instance, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie15backgroundColorEv")]
            internal static extern void BackgroundColor_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie18setBackgroundColorERK6QColor")]
            internal static extern void SetBackgroundColor_0(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie9cacheModeEv")]
            internal static extern QMovie.CacheMode cacheMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie12setCacheModeENS_9CacheModeE")]
            internal static extern void SetCacheMode_0(global::System.IntPtr instance, QMovie.CacheMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie5speedEv")]
            internal static extern int Speed_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QMovie8setSpeedEi")]
            internal static extern void SetSpeed_0(global::System.IntPtr instance, int percentSpeed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie5stateEv")]
            internal static extern QMovie.MovieState State_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie12currentImageEv")]
            internal static extern void CurrentImage_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie13currentPixmapEv")]
            internal static extern void CurrentPixmap_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie9loopCountEv")]
            internal static extern int LoopCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie10frameCountEv")]
            internal static extern int FrameCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie14nextFrameDelayEv")]
            internal static extern int NextFrameDelay_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QMovie18currentFrameNumberEv")]
            internal static extern int CurrentFrameNumber_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the different states of QMovie.</para>
        /// </summary>
        public enum MovieState : uint
        {
            /// <summary>The movie is not running. This is QMovie's initial state, and the state it enters after stop() has been called or the movie is finished.</summary>
            NotRunning = 0,
            /// <summary>The movie is paused, and QMovie stops emitting updated() or resized(). This state is entered after calling pause() or setPaused(true). The current frame number it kept, and the movie will continue with the next frame when unpause() or setPaused(false) is called.</summary>
            Paused = 1,
            /// <summary>The movie is running.</summary>
            Running = 2
        }

        /// <summary>
        /// <para>This enum describes the different cache modes of QMovie.</para>
        /// </summary>
        public enum CacheMode : uint
        {
            /// <summary>No frames are cached (the default).</summary>
            CacheNone = 0,
            /// <summary>All frames are cached.</summary>
            CacheAll = 1
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted after QMovie::start() has been called, and QMovie has entered QMovie::Running state.</para>
        /// </summary>
        public event Action Started
        {
        	add
        	{
                ConnectDynamicSlot(this, "started()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "started()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted every time the state of the movie changes. The new state is specified by state.</para>
        /// <para>See also QMovie::state().</para>
        /// </summary>
        public event Action<QMovie.MovieState> StateChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "stateChanged(QMovie.MovieState)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "stateChanged(QMovie.MovieState)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted by QMovie when the error error occurred during playback. QMovie will stop the movie, and enter QMovie::NotRunning state.</para>
        /// </summary>
        public event Action<QImageReader.ImageReaderError> Error
        {
        	add
        	{
                ConnectDynamicSlot(this, "error(QImageReader.ImageReaderError)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "error(QImageReader.ImageReaderError)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the movie has finished.</para>
        /// <para>See also QMovie::stop().</para>
        /// </summary>
        public event Action Finished
        {
        	add
        	{
                ConnectDynamicSlot(this, "finished()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "finished()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the frame number has changed to frameNumber. You can call currentImage() or currentPixmap() to get a copy of the frame.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// </summary>
        public event Action<int> FrameChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "frameChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "frameChanged(int)", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QMovie __CreateInstance(global::System.IntPtr native)
        {
            return new QMovie((QMovie.Internal*) native);
        }

        public static QMovie __CreateInstance(QMovie.Internal native)
        {
            return new QMovie(native);
        }

        private static QMovie.Internal* __CopyValue(QMovie.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QMovie.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QMovie.Internal*) ret;
        }

        private QMovie(QMovie.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QMovie(QMovie.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Jumps to frame number frameNumber. Returns true on success;
        /// otherwise returns false.</para>
        /// </summary>
        public bool JumpToFrame(int frameNumber)
        {
            var __ret = Internal.JumpToFrame_0(__Instance, frameNumber);
            return __ret;
        }

        /// <summary>
        /// <para>Starts the movie. QMovie will enter Running state, and start
        /// emitting updated() and resized() as the movie progresses.</para>
        /// <para>If QMovie is in the Paused state, this function is equivalent to
        /// calling setPaused(false). If QMovie is already in the Running state, this
        /// function does nothing.</para>
        /// <para>See also stop() and setPaused().</para>
        /// </summary>
        public void Start()
        {
            Internal.Start_0(__Instance);
        }

        /// <summary>
        /// <para>Jumps to the next frame. Returns true on success; otherwise
        /// returns false.</para>
        /// </summary>
        public bool JumpToNextFrame()
        {
            var __ret = Internal.JumpToNextFrame_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>If paused is true, QMovie will enter Paused state and emit
        /// stateChanged(Paused); otherwise it will enter Running state and emit
        /// stateChanged(Running).</para>
        /// <para>See also state().</para>
        /// </summary>
        public void SetPaused(bool paused)
        {
            Internal.SetPaused_0(__Instance, paused);
        }

        /// <summary>
        /// <para>Stops the movie. QMovie enters NotRunning state, and stops
        /// emitting updated() and resized(). If start() is called again, the movie
        /// will restart from the beginning.</para>
        /// <para>If QMovie is already in the NotRunning state, this function does
        /// nothing.</para>
        /// <para>See also start() and setPaused().</para>
        /// </summary>
        public void Stop()
        {
            Internal.Stop_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the name of the file that QMovie reads image data from.
        /// If no file name has been assigned, or if the assigned device is not a file,
        /// an empty QString is returned.</para>
        /// <para>See also setFileName() and device().</para>
        /// <para></para>
        /// <para>Sets the name of the file that QMovie reads image data from, to
        /// fileName.</para>
        /// <para>See also fileName(), setDevice(), and setFormat().</para>
        /// </summary>
        public string FileName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FileName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFileName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the background color of the movie. If no background color
        /// has been assigned, an invalid QColor is returned.</para>
        /// <para>See also setBackgroundColor().</para>
        /// <para></para>
        /// <para>For image formats that support it, this function sets the
        /// background color to color.</para>
        /// <para>See also backgroundColor().</para>
        /// </summary>
        public QColor BackgroundColor
        {
            get
            {
                var __ret = new QtGui.QColor.Internal();
                Internal.BackgroundColor_0(new IntPtr(&__ret), __Instance);
                return QColor.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBackgroundColor_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds the movie's cache mode.</para>
        /// <para>Caching frames can be useful when the underlying animation format
        /// handler that QMovie relies on to decode the animation data does not support
        /// jumping to particular frames in the animation, or even
        /// &quot;rewinding&quot; the animation to the beginning (for looping).
        /// Furthermore, if the image data comes from a sequential device, it is not
        /// possible for the underlying animation handler to seek back to frames whose
        /// data has already been read (making looping altogether impossible).</para>
        /// <para>To aid in such situations, a QMovie object can be instructed to
        /// cache the frames, at the added memory cost of keeping the frames in memory
        /// for the lifetime of the object.</para>
        /// <para>By default, this property is set to CacheNone.</para>
        /// </summary>
        public QMovie.CacheMode cacheMode
        {
            get
            {
                var __ret = Internal.cacheMode_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetCacheMode_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds the movie's speed.</para>
        /// <para>The speed is measured in percentage of the original movie speed.
        /// The default speed is 100%. Example:</para>
        /// <para>QMovie movie(&quot;racecar.gif&quot;);</para>
        /// <para>movie.setSpeed(200); // 2x speed</para>
        /// </summary>
        public int Speed
        {
            get
            {
                var __ret = Internal.Speed_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSpeed_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the current state of QMovie.</para>
        /// <para>See also MovieState and stateChanged().</para>
        /// </summary>
        public QMovie.MovieState State
        {
            get
            {
                var __ret = Internal.State_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the current frame as a QImage.</para>
        /// <para>See also currentPixmap() and updated().</para>
        /// </summary>
        public QImage CurrentImage
        {
            get
            {
                var __ret = new QtGui.QImage.Internal();
                Internal.CurrentImage_0(new IntPtr(&__ret), __Instance);
                return QImage.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the current frame as a QPixmap.</para>
        /// <para>See also currentImage() and updated().</para>
        /// </summary>
        public QPixmap CurrentPixmap
        {
            get
            {
                var __ret = new QtGui.QPixmap.Internal();
                Internal.CurrentPixmap_0(new IntPtr(&__ret), __Instance);
                return QPixmap.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the movie is valid (e.g., the image data is
        /// readable and the image format is supported); otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of times the movie will loop before it
        /// finishes. If the movie will only play once (no looping), loopCount returns
        /// 0. If the movie loops forever, loopCount returns -1.</para>
        /// <para>Note that, if the image data comes from a sequential device (e.g.
        /// a socket), QMovie can only loop the movie if the cacheMode is set to
        /// QMovie::CacheAll.</para>
        /// </summary>
        public int LoopCount
        {
            get
            {
                var __ret = Internal.LoopCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of frames in the movie.</para>
        /// <para>Certain animation formats do not support this feature, in which
        /// case 0 is returned.</para>
        /// </summary>
        public int FrameCount
        {
            get
            {
                var __ret = Internal.FrameCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of milliseconds QMovie will wait before
        /// updating the next frame in the animation.</para>
        /// </summary>
        public int NextFrameDelay
        {
            get
            {
                var __ret = Internal.NextFrameDelay_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the sequence number of the current frame. The number of
        /// the first frame in the movie is 0.</para>
        /// </summary>
        public int CurrentFrameNumber
        {
            get
            {
                var __ret = Internal.CurrentFrameNumber_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QMovie()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QMovie) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void Picture_io_handler(global::System.IntPtr _0);

    /// <summary>
    /// <para>The QPicture class is a paint device that records and replays
    /// QPainter commands.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A picture serializes painter commands to an IO device in a
    /// platform-independent format. They are sometimes referred to as
    /// meta-files.</para>
    /// <para>Qt pictures use a proprietary binary format. Unlike native
    /// picture (meta-file) formats on many window systems, Qt pictures have no
    /// limitations regarding their contents. Everything that can be painted on a
    /// widget or pixmap (e.g., fonts, pixmaps, regions, transformed graphics,
    /// etc.) can also be stored in a picture.</para>
    /// <para>QPicture is resolution independent, i.e. a QPicture can be
    /// displayed on different devices (for example svg, pdf, ps, printer and
    /// screen) looking the same. This is, for instance, needed for WYSIWYG print
    /// preview. QPicture runs in the default system dpi, and scales the painter to
    /// match differences in resolution depending on the window system.</para>
    /// <para>Example of how to record a picture:</para>
    /// <para>        QPicture picture;</para>
    /// <para>        QPainter painter;</para>
    /// <para>        painter.begin(&amp;picture);           // paint in
    /// picture</para>
    /// <para>        painter.drawEllipse(10,20, 80,70); // draw an
    /// ellipse</para>
    /// <para>        painter.end();                     // painting
    /// done</para>
    /// <para>        picture.save(&quot;drawing.pic&quot;);       // save
    /// picture</para>
    /// <para>Note that the list of painter commands is reset on each call to
    /// the QPainter::begin() function.</para>
    /// <para>Example of how to replay a picture:</para>
    /// <para>        QPicture picture;</para>
    /// <para>        picture.load(&quot;drawing.pic&quot;);           // load
    /// picture</para>
    /// <para>        QPainter painter;</para>
    /// <para>        painter.begin(&amp;myImage);               // paint in
    /// myImage</para>
    /// <para>        painter.drawPicture(0, 0, picture);    // draw the
    /// picture at (0,0)</para>
    /// <para>        painter.end();                         // painting
    /// done</para>
    /// <para>Pictures can also be drawn using play(). Some basic data about a
    /// picture is available, for example, size(), isNull() and
    /// boundingRect().</para>
    /// <para></para>
    /// <para>See also QMovie.</para>
    /// </remarks>
    public unsafe partial class QPicture : QtGui.QPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            internal QExplicitlySharedDataPointer.Internal d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPictureC2Ei")]
            internal static extern void ctor_0(global::System.IntPtr instance, int formatVersion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPictureC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr pic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPictureD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPicture4playEP8QPainter")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Play_0(global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPicture4loadERK7QStringPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Load_1(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPicture4saveERK7QStringPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Save_1(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPicture6detachEv")]
            internal static extern void Detach_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8QPicture13pictureFormatERK7QString")]
            internal static extern global::System.IntPtr PictureFormat_0(global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPicture6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPicture11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPicture6isNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPicture4dataEv")]
            internal static extern global::System.IntPtr Data_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPicture10isDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static QPicture __CreateInstance(global::System.IntPtr native)
        {
            return new QPicture((QPicture.Internal*) native);
        }

        public static QPicture __CreateInstance(QPicture.Internal native)
        {
            return new QPicture(native);
        }

        private static QPicture.Internal* __CopyValue(QPicture.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QPicture.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QPicture.Internal*) ret;
        }

        private QPicture(QPicture.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPicture(QPicture.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDevice.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs an empty picture.</para>
        /// <para>The formatVersion parameter may be used to create a QPicture that
        /// can be read by applications that are compiled with earlier versions of
        /// Qt.</para>
        /// <para>Note that the default formatVersion is -1 which signifies the
        /// current release, i.e. for Qt 4.0 a formatVersion of 7 is the same as the
        /// default formatVersion of -1.</para>
        /// <para>Reading pictures generated by earlier versions of Qt is not
        /// supported in Qt 4.0.</para>
        /// </summary>
        public QPicture(int formatVersion = -1)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance, formatVersion);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Replays the picture using painter, and returns true if
        /// successful; otherwise returns false.</para>
        /// <para>This function does exactly the same as QPainter::drawPicture()
        /// with (x, y) = (0, 0).</para>
        /// </summary>
        public bool Play(QPainter p)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var __ret = Internal.Play_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Loads a picture from the file specified by fileName and returns
        /// true if successful; otherwise invalidates the picture and returns
        /// false.</para>
        /// <para>Please note that the format parameter has been deprecated and
        /// will have no effect.</para>
        /// <para>See also save().</para>
        /// </summary>
        public bool Load(string fileName, string format = null)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            var __ret = Internal.Load_1(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Saves a picture to the file specified by fileName and returns
        /// true if successful; otherwise returns false.</para>
        /// <para>Please note that the format parameter has been deprecated and
        /// will have no effect.</para>
        /// <para>See also load().</para>
        /// </summary>
        public bool Save(string fileName, string format = null)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            var __ret = Internal.Save_1(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        public void Detach()
        {
            Internal.Detach_0(__Instance);
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric m)
        {
            var arg0 = m;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a string that specifies the picture format of the file
        /// fileName, or 0 if the file cannot be read or if the format is not
        /// recognized.</para>
        /// <para>See also load() and save().</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public static string PictureFormat(string fileName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.PictureFormat_0(arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return Marshal.PtrToStringAnsi(__ret);
        }

        public override QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the picture contains no data; otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsNull
        {
            get
            {
                var __ret = Internal.IsNull_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the picture data. The pointer is only valid
        /// until the next non-const function is called on this picture. The returned
        /// pointer is 0 if the picture contains no data.</para>
        /// <para>See also setData(), size(), and isNull().</para>
        /// </summary>
        public string Data
        {
            get
            {
                var __ret = Internal.Data_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public bool IsDetached
        {
            get
            {
                var __ret = Internal.IsDetached_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QPicture()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPicture) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPicture) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric m)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric m);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric m)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPicture) _References[instance].Target;
            var _ret = target.Metric(m);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPicture) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPicture) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QPictureIO class contains parameters for loading and saving
    /// pictures.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QPictureIO contains a QIODevice object that is used for picture
    /// data I/O. The programmer can install new picture file formats in addition
    /// to those that Qt provides.</para>
    /// <para>You don't normally need to use this class; QPicture::load(),
    /// QPicture::save().</para>
    /// <para></para>
    /// <para>See also QPicture, QPixmap, and QFile.</para>
    /// </remarks>
    public unsafe partial class QPictureIO : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIOC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIOC2ERK7QStringPKc")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr fileName, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIOC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIOD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO4readEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Read_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO5writeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Write_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10QPictureIO15defineIOHandlerEPKcS1_S1_PFvPS_ES4_")]
            internal static extern void DefineIOHandler_0(global::System.IntPtr format, global::System.IntPtr header, global::System.IntPtr flags, global::System.IntPtr read_picture, global::System.IntPtr write_picture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO7pictureEv")]
            internal static extern global::System.IntPtr Picture_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO10setPictureERK8QPicture")]
            internal static extern void SetPicture_0(global::System.IntPtr instance, global::System.IntPtr picture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO6statusEv")]
            internal static extern int Status_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO9setStatusEi")]
            internal static extern void SetStatus_0(global::System.IntPtr instance, int status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO6formatEv")]
            internal static extern global::System.IntPtr Format_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO9setFormatEPKc")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO8fileNameEv")]
            internal static extern void FileName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO11setFileNameERK7QString")]
            internal static extern void SetFileName_0(global::System.IntPtr instance, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO7qualityEv")]
            internal static extern int Quality_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO10setQualityEi")]
            internal static extern void SetQuality_0(global::System.IntPtr instance, int q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO11descriptionEv")]
            internal static extern void Description_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO14setDescriptionERK7QString")]
            internal static extern void SetDescription_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO10parametersEv")]
            internal static extern global::System.IntPtr Parameters_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO13setParametersEPKc")]
            internal static extern void SetParameters_0(global::System.IntPtr instance, global::System.IntPtr parameters);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPictureIO5gammaEv")]
            internal static extern float Gamma_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPictureIO8setGammaEf")]
            internal static extern void SetGamma_0(global::System.IntPtr instance, float gamma);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPictureIO __CreateInstance(global::System.IntPtr native)
        {
            return new QPictureIO((QPictureIO.Internal*) native);
        }

        public static QPictureIO __CreateInstance(QPictureIO.Internal native)
        {
            return new QPictureIO(native);
        }

        private static QPictureIO.Internal* __CopyValue(QPictureIO.Internal native)
        {
            var ret = (QPictureIO.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QPictureIO(QPictureIO.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPictureIO(QPictureIO.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a QPictureIO object with all parameters set to
        /// zero.</para>
        /// </summary>
        public QPictureIO()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QPictureIO object with the file name fileName and a
        /// format tag.</para>
        /// </summary>
        public QPictureIO(string fileName, string format)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(format);
            Internal.ctor_2(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Reads an picture into memory and returns true if the picture was
        /// successfully read; otherwise returns false.</para>
        /// <para>Before reading an picture you must set an IO device or a file
        /// name. If both an IO device and a file name have been set, the IO device
        /// will be used.</para>
        /// <para>Setting the picture file format string is optional.</para>
        /// <para>Note that this function does not set the format used to read the
        /// picture. If you need that information, use the pictureFormat() static
        /// functions.</para>
        /// <para>Example:</para>
        /// <para>        QPictureIO iio;</para>
        /// <para>        QPixmap  pixmap;</para>
        /// <para>        iio.setFileName(&quot;vegeburger.pic&quot;);</para>
        /// <para>        if (iio.read()) {        // OK</para>
        /// <para>            QPicture picture = iio.picture();</para>
        /// <para>            QPainter painter(&amp;pixmap);</para>
        /// <para>            painter.drawPicture(0, 0, picture);</para>
        /// <para>        }</para>
        /// <para>See also setIODevice(), setFileName(), setFormat(), write(), and
        /// QPixmap::load().</para>
        /// </summary>
        public bool Read()
        {
            var __ret = Internal.Read_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Writes an picture to an IO device and returns true if the picture
        /// was successfully written; otherwise returns false.</para>
        /// <para>Before writing an picture you must set an IO device or a file
        /// name. If both an IO device and a file name have been set, the IO device
        /// will be used.</para>
        /// <para>The picture will be written using the specified picture
        /// format.</para>
        /// <para>Example:</para>
        /// <para>        QPictureIO iio;</para>
        /// <para>        QPicture   picture;</para>
        /// <para>        QPainter painter(&amp;picture);</para>
        /// <para>        painter.drawPixmap(0, 0, pixmap);</para>
        /// <para>        iio.setPicture(picture);</para>
        /// <para>        iio.setFileName(&quot;vegeburger.pic&quot;);</para>
        /// <para>        iio.setFormat(&quot;PIC&quot;);</para>
        /// <para>        if (iio.write())</para>
        /// <para>            return true; // returned true if written
        /// successfully</para>
        /// <para>See also setIODevice(), setFileName(), setFormat(), read(), and
        /// QPixmap::save().</para>
        /// </summary>
        public bool Write()
        {
            var __ret = Internal.Write_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Defines a picture I/O handler for the picture format called
        /// format, which is recognized using the regular expression defined in header,
        /// read using readPicture and written using writePicture.</para>
        /// <para>flags is a string of single-character flags for this format. The
        /// only flag defined currently is T (upper case), so the only legal value for
        /// flags are &quot;T&quot; and the empty string. The &quot;T&quot; flag means
        /// that the picture file is a text file, and Qt should treat all newline
        /// conventions as equivalent. (XPM files and some PPM files are text files for
        /// example.)</para>
        /// <para>format is used to select a handler to write a QPicture; header is
        /// used to select a handler to read an picture file.</para>
        /// <para>If readPicture is a null pointer, the QPictureIO will not be able
        /// to read pictures in format. If writePicture is a null pointer, the
        /// QPictureIO will not be able to write pictures in format. If both are null,
        /// the QPictureIO object is valid but useless.</para>
        /// <para>Example:</para>
        /// <para>void readSVG(QPictureIO *picture)</para>
        /// <para>{</para>
        /// <para>    // read the picture using the picture-&gt;ioDevice()</para>
        /// <para>}</para>
        /// <para></para>
        /// <para>void writeSVG(QPictureIO *picture)</para>
        /// <para>{</para>
        /// <para>    // write the picture using the picture-&gt;ioDevice()</para>
        /// <para>}</para>
        /// <para></para>
        /// <para>    // add the SVG picture handler</para>
        /// <para>    // ...</para>
        /// <para>Before the regular expression test, all the 0 bytes in the file
        /// header are converted to 1 bytes. This is done because when Qt was
        /// ASCII-based, QRegExp could not handle 0 bytes in strings.</para>
        /// <para>The regexp is only applied on the first 14 bytes of the
        /// file.</para>
        /// <para>(Note that if one handlerIO supports writing a format and another
        /// supports reading it, Qt supports both reading and writing. If two handlers
        /// support the same operation, Qt chooses one arbitrarily.)</para>
        /// </summary>
        public static void DefineIOHandler(string format, string header, string flags, Picture_io_handler read_picture, Picture_io_handler write_picture)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(format);
            var arg1 = Marshal.StringToHGlobalAnsi(header);
            var arg2 = Marshal.StringToHGlobalAnsi(flags);
            var arg3 = Marshal.GetFunctionPointerForDelegate(read_picture);
            var arg4 = Marshal.GetFunctionPointerForDelegate(write_picture);
            Internal.DefineIOHandler_0(arg0, arg1, arg2, arg3, arg4);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
        }

        /// <summary>
        /// <para>Returns the picture currently set.</para>
        /// <para>See also setPicture().</para>
        /// <para></para>
        /// <para>Sets the picture to picture.</para>
        /// <para>See also picture().</para>
        /// </summary>
        public QPicture Picture
        {
            get
            {
                var __ret = Internal.Picture_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPicture.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetPicture_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the picture's IO status. A non-zero value indicates an
        /// error, whereas 0 means that the IO operation was successful.</para>
        /// <para>See also setStatus().</para>
        /// <para></para>
        /// <para>Sets the picture IO status to status. A non-zero value indicates
        /// an error, whereas 0 means that the IO operation was successful.</para>
        /// <para>See also status().</para>
        /// </summary>
        public int Status
        {
            get
            {
                var __ret = Internal.Status_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStatus_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the picture format string or 0 if no format has been
        /// explicitly set.</para>
        /// <para>See also setFormat().</para>
        /// <para></para>
        /// <para>Sets the picture format to format for the picture to be read or
        /// written.</para>
        /// <para>It is necessary to specify a format before writing an picture,
        /// but it is not necessary to specify a format before reading an
        /// picture.</para>
        /// <para>If no format has been set, Qt guesses the picture format before
        /// reading it. If a format is set the picture will only be read if it has that
        /// format.</para>
        /// <para>See also read(), write(), and format().</para>
        /// </summary>
        public string Format
        {
            get
            {
                var __ret = Internal.Format_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringAnsi(__ret);
            }

            set
            {
                var arg0 = Marshal.StringToHGlobalAnsi(value);
                Internal.SetFormat_0(__Instance, arg0);
                Marshal.FreeHGlobal(arg0);
            }
        }

        /// <summary>
        /// <para>Returns the file name currently set.</para>
        /// <para>See also setFileName().</para>
        /// <para></para>
        /// <para>Sets the name of the file to read or write an picture from to
        /// fileName.</para>
        /// <para>See also fileName() and setIODevice().</para>
        /// </summary>
        public string FileName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FileName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFileName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the quality of the written picture, related to the
        /// compression ratio.</para>
        /// <para>See also setQuality() and QPicture::save().</para>
        /// <para></para>
        /// <para>Sets the quality of the written picture to q, related to the
        /// compression ratio.</para>
        /// <para>q must be in the range -1..100. Specify 0 to obtain small
        /// compressed files, 100 for large uncompressed files. (-1 signifies the
        /// default compression.)</para>
        /// <para>See also quality() and QPicture::save().</para>
        /// </summary>
        public int Quality
        {
            get
            {
                var __ret = Internal.Quality_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetQuality_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the picture description string.</para>
        /// <para>See also setDescription().</para>
        /// <para></para>
        /// <para>Sets the picture description string for picture handlers that
        /// support picture descriptions to description.</para>
        /// <para>Currently, no picture format supported by Qt uses the description
        /// string.</para>
        /// <para>See also description().</para>
        /// </summary>
        public string Description
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Description_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetDescription_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the picture's parameters string.</para>
        /// <para>See also setParameters().</para>
        /// <para></para>
        /// <para>Sets the picture's parameter string to parameters. This is for
        /// picture handlers that require special parameters.</para>
        /// <para>Although the current picture formats supported by Qt ignore the
        /// parameters string, it may be used in future extensions or by contributions
        /// (for example, JPEG).</para>
        /// <para>See also parameters().</para>
        /// </summary>
        public string Parameters
        {
            get
            {
                var __ret = Internal.Parameters_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return Marshal.PtrToStringAnsi(__ret);
            }

            set
            {
                var arg0 = Marshal.StringToHGlobalAnsi(value);
                Internal.SetParameters_0(__Instance, arg0);
                Marshal.FreeHGlobal(arg0);
            }
        }

        /// <summary>
        /// <para>Returns the gamma value at which the picture will be
        /// viewed.</para>
        /// <para>See also setGamma().</para>
        /// <para></para>
        /// <para>Sets the gamma value at which the picture will be viewed to
        /// gamma. If the picture format stores a gamma value for which the picture is
        /// intended to be used, then this setting will be used to modify the picture.
        /// Setting to 0.0 will disable gamma correction (i.e. any specification in the
        /// file will be ignored).</para>
        /// <para>The default value is 0.0.</para>
        /// <para>See also gamma().</para>
        /// </summary>
        public float Gamma
        {
            get
            {
                var __ret = Internal.Gamma_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetGamma_0(__Instance, value);
            }
        }
    }

    /// <summary>
    /// <para>The QPictureFormatPlugin class provides an abstract base for
    /// custom picture format plugins.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The picture format plugin is a simple plugin interface that makes
    /// it easy to create custom picture formats that can be used transparently by
    /// applications.</para>
    /// <para>Writing an picture format plugin is achieved by subclassing this
    /// base class, reimplementing the pure virtual functions loadPicture(),
    /// savePicture(), and installIOHandler(), and exporting the class with the
    /// Q_PLUGIN_METADATA() macro.</para>
    /// <para>The json file containing the metadata should contain one entry
    /// with the list of picture formats supported by the plugin:</para>
    /// <para>{ &quot;Keys&quot;: [ &quot;mypictureformat&quot; ] }</para>
    /// <para></para>
    /// <para>See also How to Create Qt Plugins.</para>
    /// </remarks>
    public unsafe abstract partial class QPictureFormatPlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QPictureFormatPluginC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QPictureFormatPluginD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QPictureFormatPlugin11loadPictureERK7QStringS2_P8QPicture")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool LoadPicture_0(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr filename, global::System.IntPtr pic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QPictureFormatPlugin11savePictureERK7QStringS2_RK8QPicture")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SavePicture_0(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr filename, global::System.IntPtr pic);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QPictureFormatPlugin(QPictureFormatPlugin.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Loads the picture stored in the file called fileName, with the
        /// given format, into *picture. Returns true on success; otherwise returns
        /// false.</para>
        /// <para>See also savePicture().</para>
        /// </summary>
        public virtual bool LoadPicture(string format, string filename, QPicture pic)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(format).ToPointer(), format.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(filename).ToPointer(), filename.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var arg2 = ReferenceEquals(pic, null) ? global::System.IntPtr.Zero : pic.__Instance;
            var __ret = Internal.LoadPicture_0(__Instance, arg0, arg1, arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Saves the given picture into the file called fileName, using the
        /// specified format. Returns true on success; otherwise returns false.</para>
        /// <para>See also loadPicture().</para>
        /// </summary>
        public virtual bool SavePicture(string format, string filename, QPicture pic)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(format).ToPointer(), format.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(filename).ToPointer(), filename.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var arg2 = ReferenceEquals(pic, null) ? global::System.IntPtr.Zero : pic.__Instance;
            var __ret = Internal.SavePicture_0(__Instance, arg0, arg1, arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Installs a QPictureIO picture I/O handler for the picture format
        /// format. Returns true on success.</para>
        /// </summary>
        public abstract bool InstallIOHandler(string format);

        #region Virtual table interop

        // ~QPictureFormatPlugin()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPictureFormatPlugin) _References[instance].Target;
            target.Dispose();
        }

        // bool loadPicture(const QString &format, const QString &filename, QPicture *pic)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _LoadPicture_0Delegate(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr filename, global::System.IntPtr pic);
        private static _LoadPicture_0Delegate _LoadPicture_0DelegateInstance;

        private static bool _LoadPicture_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr filename, global::System.IntPtr pic)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPictureFormatPlugin) _References[instance].Target;
            var _ret = target.LoadPicture(Marshal.PtrToStringUni(new IntPtr(new QString(format).Utf16)), Marshal.PtrToStringUni(new IntPtr(new QString(filename).Utf16)), (pic == IntPtr.Zero) ? null : QPicture.__CreateInstance(pic));
            return _ret;
        }

        // bool savePicture(const QString &format, const QString &filename, const QPicture &pic)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _SavePicture_0Delegate(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr filename, global::System.IntPtr pic);
        private static _SavePicture_0Delegate _SavePicture_0DelegateInstance;

        private static bool _SavePicture_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr filename, global::System.IntPtr pic)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPictureFormatPlugin) _References[instance].Target;
            var _ret = target.SavePicture(Marshal.PtrToStringUni(new IntPtr(new QString(format).Utf16)), Marshal.PtrToStringUni(new IntPtr(new QString(filename).Utf16)), (pic == IntPtr.Zero) ? null : QPicture.__CreateInstance(pic));
            return _ret;
        }

        // bool installIOHandler(const QString &format)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _InstallIOHandler_0Delegate(global::System.IntPtr instance, global::System.IntPtr format);
        private static _InstallIOHandler_0Delegate _InstallIOHandler_0DelegateInstance;

        private static bool _InstallIOHandler_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr format)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPictureFormatPlugin) _References[instance].Target;
            var _ret = target.InstallIOHandler(Marshal.PtrToStringUni(new IntPtr(new QString(format).Utf16)));
            return _ret;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _LoadPicture_0DelegateInstance += _LoadPicture_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadPicture_0DelegateInstance).ToPointer();
                _SavePicture_0DelegateInstance += _SavePicture_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SavePicture_0DelegateInstance).ToPointer();
                _InstallIOHandler_0DelegateInstance += _InstallIOHandler_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InstallIOHandler_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(14 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = _Thunks[3];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QPictureFormatPluginInternal : QtGui.QPictureFormatPlugin, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QPictureFormatPluginInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QPictureFormatPluginInternal((QPictureFormatPlugin.Internal*) native);
        }

        public static QPictureFormatPlugin __CreateInstance(QPictureFormatPlugin.Internal native)
        {
            return new QPictureFormatPluginInternal(native);
        }

        private static QPictureFormatPlugin.Internal* __CopyValue(QPictureFormatPlugin.Internal native)
        {
            var ret = (QPictureFormatPlugin.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QPictureFormatPluginInternal(QPictureFormatPlugin.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPictureFormatPluginInternal(QPictureFormatPlugin.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPictureFormatPlugin.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override bool InstallIOHandler(string format)
        {
            void* slot = *(void**) (((QPictureFormatPlugin.Internal*) __Instance)->vfptr0 + 14 * 4);
            var ___InstallIOHandler_0Delegate = (_InstallIOHandler_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_InstallIOHandler_0Delegate));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(format).ToPointer(), format.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = ___InstallIOHandler_0Delegate(__Instance, arg0);
            return __ret;
        }
    }

    /// <summary>
    /// <para>The QPixmapCache class provides an application-wide cache for
    /// pixmaps.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is a tool for optimized drawing with QPixmap. You can
    /// use it to store temporary pixmaps that are expensive to generate without
    /// using more storage space than cacheLimit(). Use insert() to insert pixmaps,
    /// find() to find them, and clear() to empty the cache.</para>
    /// <para>QPixmapCache contains no member data, only static functions to
    /// access the global pixmap cache. It creates an internal QCache object for
    /// caching the pixmaps.</para>
    /// <para>The cache associates a pixmap with a user-provided string as a
    /// key, or with a QPixmapCache::Key that the cache generates. Using
    /// QPixmapCache::Key for keys is faster than using strings. The string API is
    /// very convenient for complex keys but the QPixmapCache::Key API will be very
    /// efficient and convenient for a one-to-one object-to-pixmap mapping - in
    /// this case, you can store the keys as members of an object.</para>
    /// <para>If two pixmaps are inserted into the cache using equal keys then
    /// the last pixmap will replace the first pixmap in the cache. This follows
    /// the behavior of the QHash and QCache classes.</para>
    /// <para>The cache becomes full when the total size of all pixmaps in the
    /// cache exceeds cacheLimit(). The initial cache limit is 10240 KB (10 MB);
    /// you can change this by calling setCacheLimit() with the required value. A
    /// pixmap takes roughly (width * height * depth)/8 bytes of memory.</para>
    /// <para>The Qt Quarterly article Optimizing with QPixmapCache explains
    /// how to use QPixmapCache to speed up applications by caching the results of
    /// painting.</para>
    /// <para></para>
    /// <para>See also QCache and QPixmap.</para>
    /// </remarks>
    public unsafe partial class QPixmapCache : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPixmapCacheC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache4findERK7QString")]
            internal static extern global::System.IntPtr Find_0(global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache4findERK7QStringR7QPixmap")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Find_1(global::System.IntPtr key, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache4findERK7QStringP7QPixmap")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Find1_0(global::System.IntPtr key, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache4findERKNS_3KeyEP7QPixmap")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Find_2(global::System.IntPtr key, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache6insertERK7QStringRK7QPixmap")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Insert_0(global::System.IntPtr key, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache6insertERK7QPixmap")]
            internal static extern void Insert_1(global::System.IntPtr @return, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache7replaceERKNS_3KeyERK7QPixmap")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Replace_0(global::System.IntPtr key, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache6removeERK7QString")]
            internal static extern void Remove_0(global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache6removeERKNS_3KeyE")]
            internal static extern void Remove_1(global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache5clearEv")]
            internal static extern void Clear_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache10cacheLimitEv")]
            internal static extern int CacheLimit_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12QPixmapCache13setCacheLimitEi")]
            internal static extern void SetCacheLimit_0(int n);
        }

        public unsafe partial class Key : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr d;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN12QPixmapCache3KeyC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN12QPixmapCache3KeyC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN12QPixmapCache3KeyD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK12QPixmapCache3KeyeqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr key);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Key __CreateInstance(global::System.IntPtr native)
            {
                return new Key((Key.Internal*) native);
            }

            public static Key __CreateInstance(Key.Internal native)
            {
                return new Key(native);
            }

            private static Key.Internal* __CopyValue(Key.Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                QtGui.QPixmapCache.Key.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                return (Key.Internal*) ret;
            }

            private Key(Key.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Key(Key.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Constructs an empty Key object.</para>
            /// </summary>
            public Key()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                Internal.ctor_0(__Instance);
            }

            public Key(QPixmapCache.Key other)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
                Internal.cctor_1(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public static bool operator !=(QPixmapCache.Key __op, QPixmapCache.Key key)
            {
                return !(__op == key);
            }

            public static bool operator ==(QPixmapCache.Key __op, QPixmapCache.Key key)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool keyNull = ReferenceEquals(key, null);
                if (__opNull || keyNull)
                    return __opNull && keyNull;
                var arg0 = __op.__Instance;
                var arg1 = key.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as Key;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPixmapCache __CreateInstance(global::System.IntPtr native)
        {
            return new QPixmapCache((QPixmapCache.Internal*) native);
        }

        public static QPixmapCache __CreateInstance(QPixmapCache.Internal native)
        {
            return new QPixmapCache(native);
        }

        private static QPixmapCache.Internal* __CopyValue(QPixmapCache.Internal native)
        {
            var ret = (QPixmapCache.Internal*) Marshal.AllocHGlobal(1);
            *ret = native;
            return ret;
        }

        private QPixmapCache(QPixmapCache.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPixmapCache(QPixmapCache.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the pixmap associated with the key in the cache, or null
        /// if there is no such pixmap.</para>
        /// <para>Warning: If valid, you should copy the pixmap immediately (this
        /// is fast). Subsequent insertions into the cache could cause the pointer to
        /// become invalid. For this reason, we recommend you use bool find(const
        /// QString&amp;, QPixmap*) instead.</para>
        /// <para>Example:</para>
        /// <para>QPixmap* pp;</para>
        /// <para>QPixmap p;</para>
        /// <para>if ((pp=QPixmapCache::find(&quot;my_big_image&quot;, pm)))
        /// {</para>
        /// <para>    p = *pp;</para>
        /// <para>} else {</para>
        /// <para>    p.load(&quot;bigimage.png&quot;);</para>
        /// <para>    QPixmapCache::insert(&quot;my_big_image&quot;, new
        /// QPixmap(p));</para>
        /// <para>}</para>
        /// <para>painter-&gt;drawPixmap(0, 0, p);</para>
        /// </summary>
        [System.ObsoleteAttribute("Warning: If valid, you should copy the pixmap immediately (this is fast). Subsequent insertions into the cache could cause the pointer to become invalid. For this reason, we recommend you use bool find(const QString&, QPixmap*) instead.")]
        public static QPixmap Find(string key)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.Find_0(arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QPixmap.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Use bool find(const QString&amp;, QPixmap*) instead.</para>
        /// </summary>
        [System.ObsoleteAttribute("Use bool find(const QString&, QPixmap*) instead.")]
        public static bool Find(string key, QPixmap pixmap)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var __ret = Internal.Find_1(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Looks for a cached pixmap associated with the given key in the
        /// cache. If the pixmap is found, the function sets pixmap to that pixmap and
        /// returns true; otherwise it leaves pixmap alone and returns false.</para>
        /// <para>Example:</para>
        /// <para>QPixmap pm;</para>
        /// <para>if (!QPixmapCache::find(&quot;my_big_image&quot;, &amp;pm))
        /// {</para>
        /// <para>    pm.load(&quot;bigimage.png&quot;);</para>
        /// <para>    QPixmapCache::insert(&quot;my_big_image&quot;, pm);</para>
        /// <para>}</para>
        /// <para>painter-&gt;drawPixmap(0, 0, pm);</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// </summary>
        public static bool Find1(string key, QPixmap pixmap)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var __ret = Internal.Find1_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Looks for a cached pixmap associated with the given key in the
        /// cache. If the pixmap is found, the function sets pixmap to that pixmap and
        /// returns true; otherwise it leaves pixmap alone and returns false. If the
        /// pixmap is not found, it means that the key is no longer valid, so it will
        /// be released for the next insertion.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// </summary>
        public static bool Find(QPixmapCache.Key key, QPixmap pixmap)
        {
            var arg0 = ReferenceEquals(key, null) ? global::System.IntPtr.Zero : key.__Instance;
            var arg1 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var __ret = Internal.Find_2(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Inserts a copy of the pixmap pixmap associated with the key into
        /// the cache.</para>
        /// <para>All pixmaps inserted by the Qt library have a key starting with
        /// &quot;$qt&quot;, so your own pixmap keys should never begin
        /// &quot;$qt&quot;.</para>
        /// <para>When a pixmap is inserted and the cache is about to exceed its
        /// limit, it removes pixmaps until there is enough room for the pixmap to be
        /// inserted.</para>
        /// <para>The oldest pixmaps (least recently accessed in the cache) are
        /// deleted when more space is needed.</para>
        /// <para>The function returns true if the object was inserted into the
        /// cache; otherwise it returns false.</para>
        /// <para>See also setCacheLimit().</para>
        /// </summary>
        public static bool Insert(string key, QPixmap pixmap)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var __ret = Internal.Insert_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Inserts a copy of the given pixmap into the cache and returns a
        /// key that can be used to retrieve it.</para>
        /// <para>When a pixmap is inserted and the cache is about to exceed its
        /// limit, it removes pixmaps until there is enough room for the pixmap to be
        /// inserted.</para>
        /// <para>The oldest pixmaps (least recently accessed in the cache) are
        /// deleted when more space is needed.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also setCacheLimit() and replace().</para>
        /// </summary>
        public static QPixmapCache.Key Insert(QPixmap pixmap)
        {
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var __ret = new QtGui.QPixmapCache.Key.Internal();
            Internal.Insert_1(new IntPtr(&__ret), arg0);
            return QPixmapCache.Key.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Replaces the pixmap associated with the given key with the pixmap
        /// specified. Returns true if the pixmap has been correctly inserted into the
        /// cache; otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also setCacheLimit() and insert().</para>
        /// </summary>
        public static bool Replace(QPixmapCache.Key key, QPixmap pixmap)
        {
            var arg0 = ReferenceEquals(key, null) ? global::System.IntPtr.Zero : key.__Instance;
            var arg1 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var __ret = Internal.Replace_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Removes the pixmap associated with key from the cache.</para>
        /// </summary>
        public static void Remove(string key)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(key).ToPointer(), key.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.Remove_0(arg0);
        }

        /// <summary>
        /// <para>Removes the pixmap associated with key from the cache and
        /// releases the key for a future insertion.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// </summary>
        public static void Remove(QPixmapCache.Key key)
        {
            var arg0 = ReferenceEquals(key, null) ? global::System.IntPtr.Zero : key.__Instance;
            Internal.Remove_1(arg0);
        }

        /// <summary>
        /// <para>Removes all pixmaps from the cache.</para>
        /// </summary>
        public static void Clear()
        {
            Internal.Clear_0();
        }

        /// <summary>
        /// <para>Returns the cache limit (in kilobytes).</para>
        /// <para>The default cache limit is 10240 KB.</para>
        /// <para>See also setCacheLimit().</para>
        /// <para></para>
        /// <para>Sets the cache limit to n kilobytes.</para>
        /// <para>The default setting is 10240 KB.</para>
        /// <para>See also cacheLimit().</para>
        /// </summary>
        public static int CacheLimit
        {
            get
            {
                var __ret = Internal.CacheLimit_0();
                return __ret;
            }

            set
            {
                Internal.SetCacheLimit_0(value);
            }
        }
    }

    /// <summary>
    /// <para>The QBrush class defines the fill pattern of shapes drawn by
    /// QPainter.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A brush has a style, a color, a gradient and a texture.</para>
    /// <para>The brush style() defines the fill pattern using the
    /// Qt::BrushStyle enum. The default brush style is Qt::NoBrush (depending on
    /// how you construct a brush). This style tells the painter to not fill
    /// shapes. The standard style for filling is Qt::SolidPattern. The style can
    /// be set when the brush is created using the appropriate constructor, and in
    /// addition the setStyle() function provides means for altering the style once
    /// the brush is constructed.</para>
    /// <para>The brush color() defines the color of the fill pattern. The
    /// color can either be one of Qt's predefined colors, Qt::GlobalColor, or any
    /// other custom QColor. The currently set color can be retrieved and altered
    /// using the color() and setColor() functions, respectively.</para>
    /// <para>The gradient() defines the gradient fill used when the current
    /// style is either Qt::LinearGradientPattern, Qt::RadialGradientPattern or
    /// Qt::ConicalGradientPattern. Gradient brushes are created by giving a
    /// QGradient as a constructor argument when creating the QBrush. Qt provides
    /// three different gradients: QLinearGradient, QConicalGradient, and
    /// QRadialGradient - all of which inherit QGradient.</para>
    /// <para>    QRadialGradient gradient(50, 50, 50, 50, 50);</para>
    /// <para>    gradient.setColorAt(0, QColor::fromRgbF(0, 1, 0, 1));</para>
    /// <para>    gradient.setColorAt(1, QColor::fromRgbF(0, 0, 0, 0));</para>
    /// <para></para>
    /// <para>    QBrush brush(gradient);</para>
    /// <para>The texture() defines the pixmap used when the current style is
    /// Qt::TexturePattern. You can create a brush with a texture by providing the
    /// pixmap when the brush is created or by using setTexture().</para>
    /// <para>Note that applying setTexture() makes style() ==
    /// Qt::TexturePattern, regardless of previous style settings. Also, calling
    /// setColor() will not make a difference if the style is a gradient. The same
    /// is the case if the style is Qt::TexturePattern style unless the current
    /// texture is a QBitmap.</para>
    /// <para>The isOpaque() function returns true if the brush is fully opaque
    /// otherwise false. A brush is considered opaque if:</para>
    /// <para></para>
    /// <para>The alpha component of the color() is 255.</para>
    /// <para>Its texture() does not have an alpha channel and is not a
    /// QBitmap.</para>
    /// <para>The colors in the gradient() all have an alpha component that is
    /// 255.</para>
    /// </remarks>
    public unsafe partial class QBrush : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QScopedPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushC2ERK6QColorRK7QPixmap")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr color, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushC2ERK7QPixmap")]
            internal static extern void ctor_6(global::System.IntPtr instance, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushC2ERK6QImage")]
            internal static extern void ctor_7(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushC2ERKS_")]
            internal static extern void cctor_8(global::System.IntPtr instance, global::System.IntPtr brush);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushC2ERK9QGradient")]
            internal static extern void ctor_9(global::System.IntPtr instance, global::System.IntPtr gradient);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrushD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrush9setMatrixERK7QMatrix")]
            internal static extern void SetMatrix_0(global::System.IntPtr instance, global::System.IntPtr mat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrush12setTransformERK10QTransform")]
            internal static extern void SetTransform_0(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrush8setColorERK6QColor")]
            internal static extern void SetColor_0(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QBrusheqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z17qHasPixmapTextureRK6QBrush")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool QHasPixmapTexture_0(global::System.IntPtr brush);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QBrush7textureEv")]
            internal static extern void Texture_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrush10setTextureERK7QPixmap")]
            internal static extern void SetTexture_0(global::System.IntPtr instance, global::System.IntPtr pixmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QBrush12textureImageEv")]
            internal static extern void TextureImage_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN6QBrush15setTextureImageERK6QImage")]
            internal static extern void SetTextureImage_0(global::System.IntPtr instance, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QBrush8gradientEv")]
            internal static extern global::System.IntPtr Gradient_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK6QBrush8isOpaqueEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOpaque_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QBrush __CreateInstance(global::System.IntPtr native)
        {
            return new QBrush((QBrush.Internal*) native);
        }

        public static QBrush __CreateInstance(QBrush.Internal native)
        {
            return new QBrush(native);
        }

        private static QBrush.Internal* __CopyValue(QBrush.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QBrush.Internal.cctor_8(ret, new global::System.IntPtr(&native));
            return (QBrush.Internal*) ret;
        }

        private QBrush(QBrush.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QBrush(QBrush.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a default black brush with the style Qt::NoBrush (i.e.
        /// this brush will not fill shapes).</para>
        /// </summary>
        public QBrush()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a brush with the given color and the custom pattern
        /// stored in pixmap.</para>
        /// <para>The style is set to Qt::TexturePattern. The color will only have
        /// an effect for QBitmaps.</para>
        /// <para>See also setColor() and setTexture().</para>
        /// </summary>
        public QBrush(QColor color, QPixmap pixmap)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            var arg1 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            Internal.ctor_4(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a brush with a black color and a texture set to the
        /// given pixmap. The style is set to Qt::TexturePattern.</para>
        /// <para>See also setTexture().</para>
        /// </summary>
        public QBrush(QPixmap pixmap)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            Internal.ctor_6(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a brush with a black color and a texture set to the
        /// given image. The style is set to Qt::TexturePattern.</para>
        /// <para>See also setTextureImage().</para>
        /// </summary>
        public QBrush(QImage image)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            Internal.ctor_7(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a copy of other.</para>
        /// </summary>
        public QBrush(QBrush brush)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(brush, null) ? global::System.IntPtr.Zero : brush.__Instance;
            Internal.cctor_8(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a brush based on the given gradient.</para>
        /// <para>The brush style is set to the corresponding gradient style
        /// (either Qt::LinearGradientPattern, Qt::RadialGradientPattern or
        /// Qt::ConicalGradientPattern).</para>
        /// </summary>
        public QBrush(QGradient gradient)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(gradient, null) ? global::System.IntPtr.Zero : gradient.__Instance;
            Internal.ctor_9(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets matrix as an explicit transformation matrix on the current
        /// brush. The brush transformation matrix is merged with QPainter
        /// transformation matrix to produce the final result.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also matrix().</para>
        /// </summary>
        public void SetMatrix(QMatrix mat)
        {
            var arg0 = ReferenceEquals(mat, null) ? global::System.IntPtr.Zero : mat.__Instance;
            Internal.SetMatrix_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Sets matrix as an explicit transformation matrix on the current
        /// brush. The brush transformation matrix is merged with QPainter
        /// transformation matrix to produce the final result.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also transform().</para>
        /// </summary>
        public void SetTransform(QTransform matrix)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            Internal.SetTransform_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Sets the brush color to the given color.</para>
        /// <para>Note that calling setColor() will not make a difference if the
        /// style is a gradient. The same is the case if the style is
        /// Qt::TexturePattern style unless the current texture is a QBitmap.</para>
        /// <para>See also color().</para>
        /// </summary>
        public void SetColor(QColor color)
        {
            var arg0 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.SetColor_0(__Instance, arg0);
        }

        public static bool operator !=(QBrush __op, QBrush b)
        {
            return !(__op == b);
        }

        /// <summary>
        /// <para>Returns true if the brush is equal to the given brush; otherwise
        /// returns false.</para>
        /// <para>Two brushes are equal if they have equal styles, colors and
        /// transforms and equal pixmaps or gradients depending on the style.</para>
        /// <para>See also operator!=().</para>
        /// </summary>
        public static bool operator ==(QBrush __op, QBrush b)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool bNull = ReferenceEquals(b, null);
            if (__opNull || bNull)
                return __opNull && bNull;
            var arg0 = __op.__Instance;
            var arg1 = b.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QBrush;
        }

        public static bool QHasPixmapTexture(QBrush brush)
        {
            var arg0 = ReferenceEquals(brush, null) ? global::System.IntPtr.Zero : brush.__Instance;
            var __ret = Internal.QHasPixmapTexture_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the custom brush pattern, or a null pixmap if no custom
        /// brush pattern has been set.</para>
        /// <para>See also setTexture().</para>
        /// <para></para>
        /// <para>Sets the brush pixmap to pixmap. The style is set to
        /// Qt::TexturePattern.</para>
        /// <para>The current brush color will only have an effect for monochrome
        /// pixmaps, i.e. for QPixmap::depth() == 1 (QBitmaps).</para>
        /// <para>See also texture().</para>
        /// </summary>
        public QPixmap Texture
        {
            get
            {
                var __ret = new QtGui.QPixmap.Internal();
                Internal.Texture_0(new IntPtr(&__ret), __Instance);
                return QPixmap.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetTexture_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the custom brush pattern, or a null image if no custom
        /// brush pattern has been set.</para>
        /// <para>If the texture was set as a QPixmap it will be converted to a
        /// QImage.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setTextureImage().</para>
        /// <para></para>
        /// <para>Sets the brush image to image. The style is set to
        /// Qt::TexturePattern.</para>
        /// <para>Note the current brush color will not have any affect on
        /// monochrome images, as opposed to calling setTexture() with a QBitmap. If
        /// you want to change the color of monochrome image brushes, either convert
        /// the image to QBitmap with QBitmap::fromImage() and set the resulting
        /// QBitmap as a texture, or change the entries in the color table for the
        /// image.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also textureImage() and setTexture().</para>
        /// </summary>
        public QImage TextureImage
        {
            get
            {
                var __ret = new QtGui.QImage.Internal();
                Internal.TextureImage_0(new IntPtr(&__ret), __Instance);
                return QImage.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetTextureImage_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the gradient describing this brush.</para>
        /// </summary>
        public QGradient Gradient
        {
            get
            {
                var __ret = Internal.Gradient_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QGradient.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the brush is fully opaque otherwise false. A
        /// brush is considered opaque if:</para>
        /// <para></para>
        /// <para>The alpha component of the color() is 255.</para>
        /// <para>Its texture() does not have an alpha channel and is not a
        /// QBitmap.</para>
        /// <para>The colors in the gradient() all have an alpha component that is
        /// 255.</para>
        /// <para>It is an extended radial gradient.</para>
        /// </summary>
        public bool IsOpaque
        {
            get
            {
                var __ret = Internal.IsOpaque_0(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class QBrushData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QtCore.QAtomicInt.Internal @ref;

            [FieldOffset(4)]
            public QtCore.Qt.BrushStyle style;

            [FieldOffset(8)]
            public QColor.Internal color;

            [FieldOffset(24)]
            public QTransform.Internal transform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QBrushDataC2ERKS_")]
            internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QBrushData __CreateInstance(global::System.IntPtr native)
        {
            return new QBrushData((QBrushData.Internal*) native);
        }

        public static QBrushData __CreateInstance(QBrushData.Internal native)
        {
            return new QBrushData(native);
        }

        private static QBrushData.Internal* __CopyValue(QBrushData.Internal native)
        {
            var ret = Marshal.AllocHGlobal(104);
            QtGui.QBrushData.Internal.cctor_0(ret, new global::System.IntPtr(&native));
            return (QBrushData.Internal*) ret;
        }

        private QBrushData(QBrushData.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QBrushData(QBrushData.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public QColor Color
        {
            get
            {
                return QColor.__CreateInstance(((Internal*) __Instance)->color);
            }

            set
            {
                ((Internal*) __Instance)->color = ReferenceEquals(value, null) ? new QColor.Internal() : *(QColor.Internal*) (value.__Instance);
            }
        }

        public QTransform Transform
        {
            get
            {
                return QTransform.__CreateInstance(((Internal*) __Instance)->transform);
            }

            set
            {
                ((Internal*) __Instance)->transform = ReferenceEquals(value, null) ? new QTransform.Internal() : *(QTransform.Internal*) (value.__Instance);
            }
        }
    }

    /// <summary>
    /// <para>The QGradient class is used in combination with QBrush to specify
    /// gradient fills.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Qt currently supports three types of gradient fills:</para>
    /// <para></para>
    /// <para>Linear gradients interpolate colors between start and end
    /// points.</para>
    /// <para>Simple radial gradients interpolate colors between a focal point
    /// and end points on a circle surrounding it.</para>
    /// <para>Extended radial gradients interpolate colors between a center and
    /// a focal circle.</para>
    /// <para>Conical gradients interpolate colors around a center
    /// point.</para>
    /// <para></para>
    /// <para>A gradient's type can be retrieved using the type() function.
    /// Each of the types is represented by a subclass of QGradient:</para>
    /// <para></para>
    /// <para> QLinearGradientQRadialGradientQConicalGradient</para>
    /// <para>	</para>
    /// <para></para>
    /// <para>The colors in a gradient are defined using stop points of the
    /// QGradientStop type; i.e., a position and a color. Use the setColorAt()
    /// function to define a single stop point. Alternatively, use the setStops()
    /// function to define several stop points in one go. Note that the latter
    /// function replaces the current set of stop points.</para>
    /// <para>It is the gradient's complete set of stop points (accessible
    /// through the stops() function) that describes how the gradient area should
    /// be filled. If no stop points have been specified, a gradient of black at 0
    /// to white at 1 is used.</para>
    /// <para>A diagonal linear gradient from black at (100, 100) to white at
    /// (200, 200) could be specified like this:</para>
    /// <para>    QLinearGradient linearGrad(QPointF(100, 100), QPointF(200,
    /// 200));</para>
    /// <para>    linearGrad.setColorAt(0, Qt::black);</para>
    /// <para>    linearGrad.setColorAt(1, Qt::white);</para>
    /// <para>A gradient can have an arbitrary number of stop points. The
    /// following would create a radial gradient starting with red in the center,
    /// blue and then green on the edges:</para>
    /// <para>    QRadialGradient radialGrad(QPointF(100, 100), 100);</para>
    /// <para>    radialGrad.setColorAt(0, Qt::red);</para>
    /// <para>    radialGrad.setColorAt(0.5, Qt::blue);</para>
    /// <para>    radialGrad.setColorAt(1, Qt::green);</para>
    /// <para>It is possible to repeat or reflect the gradient outside its area
    /// by specifiying the spread method using the setSpread() function. The
    /// default is to pad the outside area with the color at the closest stop
    /// point. The currently set spread method can be retrieved using the spread()
    /// function. The QGradient::Spread enum defines three different
    /// methods:</para>
    /// <para></para>
    /// <para> 	</para>
    /// <para>PadSpread	RepeatSpread	ReflectSpread</para>
    /// <para></para>
    /// <para>Note that the setSpread() function only has effect for linear and
    /// radial gradients. The reason is that the conical gradient is closed by
    /// definition, i.e. the conical gradient fills the entire circle from 0 - 360
    /// degrees, while the boundary of a radial or a linear gradient can be
    /// specified through its radius or final stop points, respectively.</para>
    /// <para>The gradient coordinates can be specified in logical coordinates,
    /// relative to device coordinates, or relative to object bounding box
    /// coordinates. The coordinate mode can be set using the setCoordinateMode()
    /// function. The default is LogicalMode, where the gradient coordinates are
    /// specified in the same way as the object coordinates. To retrieve the
    /// currently set coordinate mode use coordinateMode().</para>
    /// <para></para>
    /// <para>See also The Gradients Example and QBrush.</para>
    /// </remarks>
    public unsafe partial class QGradient : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public QGradient.Type m_type;

            [FieldOffset(4)]
            public QGradient.Spread m_spread;

            [FieldOffset(8)]
            internal QVector.Internal m_stops;

            [FieldOffset(16)]
            internal QGradient._.Internal m_data;

            [FieldOffset(56)]
            public global::System.IntPtr dummy;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGradientC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGradientC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGradientD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGradienteqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr gradient);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGradient14coordinateModeEv")]
            internal static extern QGradient.CoordinateMode coordinateMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGradient17setCoordinateModeENS_14CoordinateModeE")]
            internal static extern void SetCoordinateMode_0(global::System.IntPtr instance, QGradient.CoordinateMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGradient17interpolationModeEv")]
            internal static extern QGradient.InterpolationMode interpolationMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGradient20setInterpolationModeENS_17InterpolationModeE")]
            internal static extern void SetInterpolationMode_0(global::System.IntPtr instance, QGradient.InterpolationMode mode);
        }

        /// <summary>
        /// <para>Specifies the type of gradient.</para>
        /// <para>See also type().</para>
        /// </summary>
        public enum Type : uint
        {
            /// <summary>Interpolates colors between start and end points (QLinearGradient).</summary>
            LinearGradient = 0,
            /// <summary>Interpolate colors between a focal point and end points on a circle surrounding it (QRadialGradient).</summary>
            RadialGradient = 1,
            /// <summary>Interpolate colors around a center point (QConicalGradient).</summary>
            ConicalGradient = 2,
            /// <summary>No gradient is used.</summary>
            NoGradient = 3
        }

        /// <summary>
        /// <para>Specifies how the area outside the gradient area should be
        /// filled.</para>
        /// <para>See also spread() and setSpread().</para>
        /// </summary>
        public enum Spread : uint
        {
            /// <summary>The area is filled with the closest stop color. This is the default.</summary>
            PadSpread = 0,
            /// <summary>The gradient is reflected outside the gradient area.</summary>
            ReflectSpread = 1,
            /// <summary>The gradient is repeated outside the gradient area.</summary>
            RepeatSpread = 2
        }

        /// <summary>
        /// <para>This enum specifies how gradient coordinates map to the paint
        /// device on which the gradient is used.</para>
        /// <para>This enum was introduced or modified in  Qt 4.4.</para>
        /// </summary>
        public enum CoordinateMode : uint
        {
            /// <summary>This is the default mode. The gradient coordinates are specified logical space just like the object coordinates.</summary>
            LogicalMode = 0,
            /// <summary>In this mode the gradient coordinates are relative to the bounding rectangle of the paint device, with (0,0) in the top left corner, and (1,1) in the bottom right corner of the paint device.</summary>
            StretchToDeviceMode = 1,
            /// <summary>In this mode the gradient coordinates are relative to the bounding rectangle of the object being drawn, with (0,0) in the top left corner, and (1,1) in the bottom right corner of the object's bounding rectangle.</summary>
            ObjectBoundingMode = 2
        }

        public enum InterpolationMode : uint
        {
            ColorInterpolation = 0,
            ComponentInterpolation = 1
        }

        internal unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal QGradient._.__.Internal linear;

                [FieldOffset(0)]
                internal QGradient._.__.Internal radial;

                [FieldOffset(0)]
                internal QGradient._.__.Internal conical;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public double x1;

                    [FieldOffset(8)]
                    public double y1;

                    [FieldOffset(16)]
                    public double x2;

                    [FieldOffset(24)]
                    public double y2;
                }
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public double cx;

                    [FieldOffset(8)]
                    public double cy;

                    [FieldOffset(16)]
                    public double fx;

                    [FieldOffset(24)]
                    public double fy;

                    [FieldOffset(32)]
                    public double cradius;
                }
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public double cx;

                    [FieldOffset(8)]
                    public double cy;

                    [FieldOffset(16)]
                    public double angle;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QGradient __CreateInstance(global::System.IntPtr native)
        {
            return new QGradient((QGradient.Internal*) native);
        }

        public static QGradient __CreateInstance(QGradient.Internal native)
        {
            return new QGradient(native);
        }

        private static QGradient.Internal* __CopyValue(QGradient.Internal native)
        {
            var ret = Marshal.AllocHGlobal(64);
            QtGui.QGradient.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QGradient.Internal*) ret;
        }

        private QGradient(QGradient.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QGradient(QGradient.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public QGradient()
        {
            __Instance = Marshal.AllocHGlobal(64);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public static bool operator !=(QGradient __op, QGradient gradient)
        {
            return !(__op == gradient);
        }

        /// <summary>
        /// <para>Returns true if the gradient is the same as the other gradient
        /// specified; otherwise returns false.</para>
        /// <para>See also operator!=().</para>
        /// </summary>
        public static bool operator ==(QGradient __op, QGradient gradient)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool gradientNull = ReferenceEquals(gradient, null);
            if (__opNull || gradientNull)
                return __opNull && gradientNull;
            var arg0 = __op.__Instance;
            var arg1 = gradient.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QGradient;
        }

        /// <summary>
        /// <para>Returns the coordinate mode of this gradient. The default mode is
        /// LogicalMode.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setCoordinateMode().</para>
        /// <para></para>
        /// <para>Sets the coordinate mode of this gradient to mode. The default
        /// mode is LogicalMode.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also coordinateMode().</para>
        /// </summary>
        public QGradient.CoordinateMode coordinateMode
        {
            get
            {
                var __ret = Internal.coordinateMode_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetCoordinateMode_0(__Instance, arg0);
            }
        }

        public QGradient.InterpolationMode interpolationMode
        {
            get
            {
                var __ret = Internal.interpolationMode_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetInterpolationMode_0(__Instance, arg0);
            }
        }
    }

    /// <summary>
    /// <para>The QLinearGradient class is used in combination with QBrush to
    /// specify a linear gradient brush.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Linear gradients interpolate colors between start and end points.
    /// Outside these points the gradient is either padded, reflected or repeated
    /// depending on the currently set spread method:</para>
    /// <para></para>
    /// <para> 	</para>
    /// <para>PadSpread (default)	ReflectSpread	RepeatSpread</para>
    /// <para></para>
    /// <para>The colors in a gradient is defined using stop points of the
    /// QGradientStop type, i.e. a position and a color. Use the
    /// QGradient::setColorAt() or the QGradient::setStops() function to define the
    /// stop points. It is the gradient's complete set of stop points that
    /// describes how the gradient area should be filled. If no stop points have
    /// been specified, a gradient of black at 0 to white at 1 is used.</para>
    /// <para>In addition to the functions inherited from QGradient, the
    /// QLinearGradient class provides the finalStop() function which returns the
    /// final stop point of the gradient, and the start() function returning the
    /// start point of the gradient.</para>
    /// <para></para>
    /// <para>See also QRadialGradient, QConicalGradient, and The Gradients
    /// Example.</para>
    /// </remarks>
    public unsafe partial class QLinearGradient : QtGui.QGradient, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public QGradient.Type m_type;

            [FieldOffset(4)]
            public QGradient.Spread m_spread;

            [FieldOffset(8)]
            internal QVector.Internal m_stops;

            [FieldOffset(16)]
            internal QGradient._.Internal m_data;

            [FieldOffset(56)]
            public global::System.IntPtr dummy;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QLinearGradientC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QLinearGradientC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QLinearGradientD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QLinearGradient __CreateInstance(global::System.IntPtr native)
        {
            return new QLinearGradient((QLinearGradient.Internal*) native);
        }

        public static QLinearGradient __CreateInstance(QLinearGradient.Internal native)
        {
            return new QLinearGradient(native);
        }

        private static QLinearGradient.Internal* __CopyValue(QLinearGradient.Internal native)
        {
            var ret = Marshal.AllocHGlobal(64);
            QtGui.QLinearGradient.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QLinearGradient.Internal*) ret;
        }

        private QLinearGradient(QLinearGradient.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QLinearGradient(QLinearGradient.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QGradient.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a default linear gradient with interpolation area
        /// between (0, 0) and (1, 1).</para>
        /// <para>See also QGradient::setColorAt(), setStart(), and
        /// setFinalStop().</para>
        /// </summary>
        public QLinearGradient()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(64);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QRadialGradient class is used in combination with QBrush to
    /// specify a radial gradient brush.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Qt supports both simple and extended radial gradients.</para>
    /// <para>Simple radial gradients interpolate colors between a focal point
    /// and end points on a circle surrounding it. Extended radial gradients
    /// interpolate colors between a focal circle and a center circle. Points
    /// outside the cone defined by the two circles will be transparent. For simple
    /// radial gradients the focal point is adjusted to lie inside the center
    /// circle, whereas the focal point can have any position in an extended radial
    /// gradient.</para>
    /// <para>Outside the end points the gradient is either padded, reflected
    /// or repeated depending on the currently set spread method:</para>
    /// <para></para>
    /// <para> 	</para>
    /// <para>PadSpread (default)	ReflectSpread	RepeatSpread</para>
    /// <para></para>
    /// <para>The colors in a gradient is defined using stop points of the
    /// QGradientStop type, i.e. a position and a color. Use the
    /// QGradient::setColorAt() or the QGradient::setStops() function to define the
    /// stop points. It is the gradient's complete set of stop points that
    /// describes how the gradient area should be filled. If no stop points have
    /// been specified, a gradient of black at 0 to white at 1 is used.</para>
    /// <para>In addition to the functions inherited from QGradient, the
    /// QRadialGradient class provides the center(), focalPoint() and radius()
    /// functions returning the gradient's center, focal point and radius
    /// respectively.</para>
    /// <para></para>
    /// <para>See also QLinearGradient, QConicalGradient, and The Gradients
    /// Example.</para>
    /// </remarks>
    public unsafe partial class QRadialGradient : QtGui.QGradient, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public QGradient.Type m_type;

            [FieldOffset(4)]
            public QGradient.Spread m_spread;

            [FieldOffset(8)]
            internal QVector.Internal m_stops;

            [FieldOffset(16)]
            internal QGradient._.Internal m_data;

            [FieldOffset(56)]
            public global::System.IntPtr dummy;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QRadialGradientC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QRadialGradientC2ERKS_")]
            internal static extern void cctor_7(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QRadialGradientD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QRadialGradient __CreateInstance(global::System.IntPtr native)
        {
            return new QRadialGradient((QRadialGradient.Internal*) native);
        }

        public static QRadialGradient __CreateInstance(QRadialGradient.Internal native)
        {
            return new QRadialGradient(native);
        }

        private static QRadialGradient.Internal* __CopyValue(QRadialGradient.Internal native)
        {
            var ret = Marshal.AllocHGlobal(64);
            QtGui.QRadialGradient.Internal.cctor_7(ret, new global::System.IntPtr(&native));
            return (QRadialGradient.Internal*) ret;
        }

        private QRadialGradient(QRadialGradient.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QRadialGradient(QRadialGradient.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QGradient.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a simple radial gradient with the center and focal
        /// point at (0, 0) with a radius of 1.</para>
        /// </summary>
        public QRadialGradient()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(64);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QConicalGradient class is used in combination with QBrush to
    /// specify a conical gradient brush.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Conical gradients interpolate interpolate colors
    /// counter-clockwise around a center point.</para>
    /// <para>The colors in a gradient is defined using stop points of the
    /// QGradientStop type, i.e. a position and a color. Use the
    /// QGradient::setColorAt() or the QGradient::setStops() function to define the
    /// stop points. It is the gradient's complete set of stop points that
    /// describes how the gradient area should be filled. If no stop points have
    /// been specified, a gradient of black at 0 to white at 1 is used.</para>
    /// <para>In addition to the functions inherited from QGradient, the
    /// QConicalGradient class provides the angle() and center() functions
    /// returning the start angle and center of the gradient.</para>
    /// <para>Note that the setSpread() function has no effect for conical
    /// gradients. The reason is that the conical gradient is closed by definition,
    /// i.e. the conical gradient fills the entire circle from 0 - 360 degrees,
    /// while the boundary of a radial or a linear gradient can be specified
    /// through its radius or final stop points, respectively.</para>
    /// <para></para>
    /// <para>See also QLinearGradient, QRadialGradient, and The Gradients
    /// Example.</para>
    /// </remarks>
    public unsafe partial class QConicalGradient : QtGui.QGradient, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public QGradient.Type m_type;

            [FieldOffset(4)]
            public QGradient.Spread m_spread;

            [FieldOffset(8)]
            internal QVector.Internal m_stops;

            [FieldOffset(16)]
            internal QGradient._.Internal m_data;

            [FieldOffset(56)]
            public global::System.IntPtr dummy;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QConicalGradientC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QConicalGradientC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QConicalGradientD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QConicalGradient __CreateInstance(global::System.IntPtr native)
        {
            return new QConicalGradient((QConicalGradient.Internal*) native);
        }

        public static QConicalGradient __CreateInstance(QConicalGradient.Internal native)
        {
            return new QConicalGradient(native);
        }

        private static QConicalGradient.Internal* __CopyValue(QConicalGradient.Internal native)
        {
            var ret = Marshal.AllocHGlobal(64);
            QtGui.QConicalGradient.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QConicalGradient.Internal*) ret;
        }

        private QConicalGradient(QConicalGradient.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QConicalGradient(QConicalGradient.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QGradient.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a conical with center at (0, 0) starting the
        /// interpolation at angle 0.</para>
        /// <para>See also QGradient::setColorAt(), setCenter(), and
        /// setAngle().</para>
        /// </summary>
        public QConicalGradient()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(64);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QFont class specifies a font used for drawing text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>When you create a QFont object you specify various attributes
    /// that you want the font to have. Qt will use the font with the specified
    /// attributes, or if no matching font exists, Qt will use the closest matching
    /// installed font. The attributes of the font that is actually used are
    /// retrievable from a QFontInfo object. If the window system provides an exact
    /// match exactMatch() returns true. Use QFontMetrics to get measurements, e.g.
    /// the pixel length of a string using QFontMetrics::width().</para>
    /// <para>Note that a QGuiApplication instance must exist before a QFont
    /// can be used. You can set the application's default font with
    /// QGuiApplication::setFont().</para>
    /// <para>If a chosen font does not include all the characters that need to
    /// be displayed, QFont will try to find the characters in the nearest
    /// equivalent fonts. When a QPainter draws a character from a font the QFont
    /// will report whether or not it has the character; if it does not, QPainter
    /// will draw an unfilled square.</para>
    /// <para>Create QFonts like this:</para>
    /// <para>QFont serifFont(&quot;Times&quot;, 10, QFont::Bold);</para>
    /// <para>QFont sansFont(&quot;Helvetica [Cronyx]&quot;, 12);</para>
    /// <para>The attributes set in the constructor can also be set later, e.g.
    /// setFamily(), setPointSize(), setPointSizeF(), setWeight() and setItalic().
    /// The remaining attributes must be set after contstruction, e.g. setBold(),
    /// setUnderline(), setOverline(), setStrikeOut() and setFixedPitch().
    /// QFontInfo objects should be created after the font's attributes have been
    /// set. A QFontInfo object will not change, even if you change the font's
    /// attributes. The corresponding &quot;get&quot; functions, e.g. family(),
    /// pointSize(), etc., return the values that were set, even though the values
    /// used may differ. The actual values are available from a QFontInfo
    /// object.</para>
    /// <para>If the requested font family is unavailable you can influence the
    /// font matching algorithm by choosing a particular QFont::StyleHint and
    /// QFont::StyleStrategy with setStyleHint(). The default family (corresponding
    /// to the current style hint) is returned by defaultFamily().</para>
    /// <para>The font-matching algorithm has a lastResortFamily() and
    /// lastResortFont() in cases where a suitable match cannot be found. You can
    /// provide substitutions for font family names using insertSubstitution() and
    /// insertSubstitutions(). Substitutions can be removed with
    /// removeSubstitutions(). Use substitute() to retrieve a family's first
    /// substitute, or the family name itself if it has no substitutes. Use
    /// substitutes() to retrieve a list of a family's substitutes (which may be
    /// empty).</para>
    /// <para>Every QFont has a key() which you can use, for example, as the
    /// key in a cache or dictionary. If you want to store a user's font
    /// preferences you could use QSettings, writing the font information with
    /// toString() and reading it back with fromString(). The operator&lt;&lt;()
    /// and operator&gt;&gt;() functions are also available, but they work on a
    /// data stream.</para>
    /// <para>It is possible to set the height of characters shown on the
    /// screen to a specified number of pixels with setPixelSize(); however using
    /// setPointSize() has a similar effect and provides device
    /// independence.</para>
    /// <para>In X11 you can set a font using its system specific name with
    /// setRawName().</para>
    /// <para>Loading fonts can be expensive, especially on X11. QFont contains
    /// extensive optimizations to make the copying of QFont objects fast, and to
    /// cache the results of the slow window system functions it depends
    /// upon.</para>
    /// <para>The font matching algorithm works as follows:</para>
    /// <para></para>
    /// <para>The specified font family is searched for.</para>
    /// <para>If not found, the styleHint() is used to select a replacement
    /// family.</para>
    /// <para>Each replacement font family is searched for.</para>
    /// <para>If none of these are found or there was no styleHint(),
    /// &quot;helvetica&quot; will be searched for.</para>
    /// <para>If &quot;helvetica&quot; isn't found Qt will try the
    /// lastResortFamily().</para>
    /// <para>If the lastResortFamily() isn't found Qt will try the
    /// lastResortFont() which will always return a name of some kind.</para>
    /// <para></para>
    /// <para>Note that the actual font matching algorithm varies from platform
    /// to platform.</para>
    /// <para>In Windows a request for the &quot;Courier&quot; font is
    /// automatically changed to &quot;Courier New&quot;, an improved version of
    /// Courier that allows for smooth scaling. The older &quot;Courier&quot;
    /// bitmap font can be selected by setting the PreferBitmap style strategy (see
    /// setStyleStrategy()).</para>
    /// <para>Once a font is found, the remaining attributes are matched in
    /// order of priority:</para>
    /// <para></para>
    /// <para>fixedPitch()</para>
    /// <para>pointSize() (see below)</para>
    /// <para>weight()</para>
    /// <para>style()</para>
    /// <para></para>
    /// <para>If you have a font which matches on family, even if none of the
    /// other attributes match, this font will be chosen in preference to a font
    /// which doesn't match on family but which does match on the other attributes.
    /// This is because font family is the dominant search criteria.</para>
    /// <para>The point size is defined to match if it is within 20% of the
    /// requested point size. When several fonts match and are only distinguished
    /// by point size, the font with the closest point size to the one requested
    /// will be chosen.</para>
    /// <para>The actual family, font size, weight and other font attributes
    /// used for drawing text will depend on what's available for the chosen family
    /// under the window system. A QFontInfo object can be used to determine the
    /// actual values used for drawing the text.</para>
    /// <para>Examples:</para>
    /// <para>QFont f(&quot;Helvetica&quot;);</para>
    /// <para>If you had both an Adobe and a Cronyx Helvetica, you might get
    /// either.</para>
    /// <para>QFont f(&quot;Helvetica [Cronyx]&quot;);</para>
    /// <para>You can specify the foundry you want in the family name. The font
    /// f in the above example will be set to &quot;Helvetica
    /// [Cronyx]&quot;.</para>
    /// <para>To determine the attributes of the font actually used in the
    /// window system, use a QFontInfo object, e.g.</para>
    /// <para>QFontInfo info(f1);</para>
    /// <para>QString family = info.family();</para>
    /// <para>To find out font metrics use a QFontMetrics object, e.g.</para>
    /// <para>QFontMetrics fm(f1);</para>
    /// <para>int textWidthInPixels = fm.width(&quot;How many pixels wide is
    /// this text?&quot;);</para>
    /// <para>int textHeightInPixels = fm.height();</para>
    /// <para>For more general information on fonts, see the comp.fonts FAQ.
    /// Information on encodings can be found from Roman Czyborra's page.</para>
    /// <para></para>
    /// <para>See also QFontMetrics, QFontInfo, QFontDatabase, and Character
    /// Map Example.</para>
    /// </remarks>
    public unsafe partial class QFont : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [FieldOffset(4)]
            public uint resolve_mask;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFontC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFontC2ERK7QStringiib")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr family, int pointSize, int weight, bool italic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFontC2ERKS_P12QPaintDevice")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr font, global::System.IntPtr pd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFontC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFontD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont12setStyleHintENS_9StyleHintENS_13StyleStrategyE")]
            internal static extern void SetStyleHint_0(global::System.IntPtr instance, QFont.StyleHint hint, QFont.StyleStrategy strategy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont10exactMatchEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool ExactMatch_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFonteqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFontneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFontltERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont8isCopyOfERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCopyOf_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont8toStringEv")]
            internal static extern void ToString_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont10fromStringERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool FromString_0(global::System.IntPtr instance, global::System.IntPtr descrip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QFont10substituteERK7QString")]
            internal static extern void Substitute_0(global::System.IntPtr @return, global::System.IntPtr familyName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QFont18insertSubstitutionERK7QStringS2_")]
            internal static extern void InsertSubstitution_0(global::System.IntPtr familyName, global::System.IntPtr substituteName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QFont19removeSubstitutionsERK7QString")]
            internal static extern void RemoveSubstitutions_0(global::System.IntPtr familyName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QFont10initializeEv")]
            internal static extern void Initialize_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QFont7cleanupEv")]
            internal static extern void Cleanup_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5QFont15cacheStatisticsEv")]
            internal static extern void CacheStatistics_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont7resolveERKS_")]
            internal static extern void Resolve_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont6familyEv")]
            internal static extern void Family_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont9setFamilyERK7QString")]
            internal static extern void SetFamily_0(global::System.IntPtr instance, global::System.IntPtr family);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont9styleNameEv")]
            internal static extern void StyleName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont12setStyleNameERK7QString")]
            internal static extern void SetStyleName_0(global::System.IntPtr instance, global::System.IntPtr styleName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont9pointSizeEv")]
            internal static extern int PointSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont12setPointSizeEi")]
            internal static extern void SetPointSize_0(global::System.IntPtr instance, int pointSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont9pixelSizeEv")]
            internal static extern int PixelSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont12setPixelSizeEi")]
            internal static extern void SetPixelSize_0(global::System.IntPtr instance, int pixelSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont6weightEv")]
            internal static extern int weight_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont9setWeightEi")]
            internal static extern void SetWeight_0(global::System.IntPtr instance, int weight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont5styleEv")]
            internal static extern QFont.Style style_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont8setStyleENS_5StyleE")]
            internal static extern void SetStyle_0(global::System.IntPtr instance, QFont.Style style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont9underlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Underline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont12setUnderlineEb")]
            internal static extern void SetUnderline_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont8overlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Overline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont11setOverlineEb")]
            internal static extern void SetOverline_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont9strikeOutEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool StrikeOut_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont12setStrikeOutEb")]
            internal static extern void SetStrikeOut_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont10fixedPitchEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool FixedPitch_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont13setFixedPitchEb")]
            internal static extern void SetFixedPitch_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont7kerningEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Kerning_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont10setKerningEb")]
            internal static extern void SetKerning_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont13styleStrategyEv")]
            internal static extern QFont.StyleStrategy styleStrategy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont16setStyleStrategyENS_13StyleStrategyE")]
            internal static extern void SetStyleStrategy_0(global::System.IntPtr instance, QFont.StyleStrategy s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont7stretchEv")]
            internal static extern int stretch_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont10setStretchEi")]
            internal static extern void SetStretch_0(global::System.IntPtr instance, int factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont14capitalizationEv")]
            internal static extern QFont.Capitalization capitalization_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont17setCapitalizationENS_14CapitalizationE")]
            internal static extern void SetCapitalization_0(global::System.IntPtr instance, QFont.Capitalization caps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont17hintingPreferenceEv")]
            internal static extern QFont.HintingPreference hintingPreference_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont20setHintingPreferenceENS_17HintingPreferenceE")]
            internal static extern void SetHintingPreference_0(global::System.IntPtr instance, QFont.HintingPreference hintingPreference);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont7rawModeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RawMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont10setRawModeEb")]
            internal static extern void SetRawMode_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont7rawNameEv")]
            internal static extern void RawName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QFont10setRawNameERK7QString")]
            internal static extern void SetRawName_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont9styleHintEv")]
            internal static extern QFont.StyleHint styleHint_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont17letterSpacingTypeEv")]
            internal static extern QFont.SpacingType LetterSpacingType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont3keyEv")]
            internal static extern void Key_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont13defaultFamilyEv")]
            internal static extern void DefaultFamily_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont16lastResortFamilyEv")]
            internal static extern void LastResortFamily_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QFont14lastResortFontEv")]
            internal static extern void LastResortFont_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Style hints are used by the font matching algorithm to find an
        /// appropriate default family if a selected font family is not
        /// available.</para>
        /// </summary>
        public enum StyleHint : uint
        {
            /// <summary>is a synonym for SansSerif.</summary>
            Helvetica = 0,
            /// <summary>the font matcher prefer sans serif fonts.</summary>
            SansSerif = 0,
            /// <summary>is a synonym for Serif.</summary>
            Times = 1,
            /// <summary>the font matcher prefers serif fonts.</summary>
            Serif = 1,
            /// <summary>a synonym for TypeWriter.</summary>
            Courier = 2,
            /// <summary>the font matcher prefers fixed pitch fonts.</summary>
            TypeWriter = 2,
            /// <summary>the font matcher prefers decorative fonts.</summary>
            OldEnglish = 3,
            /// <summary>is a synonym for OldEnglish.</summary>
            Decorative = 3,
            /// <summary>the font matcher prefers system fonts.</summary>
            System = 4,
            /// <summary>leaves the font matching algorithm to choose the family. This is the default.</summary>
            AnyStyle = 5,
            /// <summary>the font matcher prefers fonts that map to the CSS generic font-family 'cursive'.</summary>
            Cursive = 6,
            /// <summary>the font matcher prefers fonts that map to the CSS generic font-family 'monospace'.</summary>
            Monospace = 7,
            /// <summary>the font matcher prefers fonts that map to the CSS generic font-family 'fantasy'.</summary>
            Fantasy = 8
        }

        /// <summary>
        /// <para>The style strategy tells the font matching algorithm what type of
        /// fonts should be used to find an appropriate default family.</para>
        /// <para>The following strategies are available:</para>
        /// <para>Any of these may be OR-ed with one of these flags:</para>
        /// </summary>
        [Flags]
        public enum StyleStrategy : uint
        {
            /// <summary>the default style strategy. It does not prefer any type of font.</summary>
            PreferDefault = 0x1,
            /// <summary>prefers bitmap fonts (as opposed to outline fonts).</summary>
            PreferBitmap = 0x2,
            /// <summary>prefers device fonts.</summary>
            PreferDevice = 0x4,
            /// <summary>prefers outline fonts (as opposed to bitmap fonts).</summary>
            PreferOutline = 0x8,
            /// <summary>forces the use of outline fonts.</summary>
            ForceOutline = 0x10,
            /// <summary>prefer an exact match. The font matcher will try to use the exact font size that has been specified.</summary>
            PreferMatch = 0x20,
            /// <summary>prefer the best quality font. The font matcher will use the nearest standard point size that the font supports.</summary>
            PreferQuality = 0x40,
            /// <summary>antialias if possible.</summary>
            PreferAntialias = 0x80,
            /// <summary>don't antialias the fonts.</summary>
            NoAntialias = 0x100,
            /// <summary>forces the use of OpenGL compatible fonts.</summary>
            OpenGLCompatible = 0x200,
            /// <summary>forces the use of integer values in font engines that support fractional font metrics.</summary>
            ForceIntegerMetrics = 0x400,
            /// <summary>avoid subpixel antialiasing on the fonts if possible.</summary>
            NoSubpixelAntialias = 0x800,
            /// <summary>If the font selected for a certain writing system does not contain a character requested to draw, then Qt automatically chooses a similar looking font that contains the character. The NoFontMerging flag disables this feature. Please note that enabling this flag will not prevent Qt from automatically picking a suitable font when the selected font does not support the writing system of the text.</summary>
            NoFontMerging = 0x8000
        }

        /// <summary>
        /// <para>This enum describes the different levels of hinting that can be
        /// applied to glyphs to improve legibility on displays where it might be
        /// warranted by the density of pixels.</para>
        /// <para>Please note that this enum only describes a preference, as the
        /// full range of hinting levels are not supported on all of Qt's supported
        /// platforms. The following table details the effect of a given hinting
        /// preference on a selected set of target platforms.</para>
        /// <para></para>
        /// <para>
        /// PreferDefaultHintingPreferNoHintingPreferVerticalHintingPreferFullHinting</
        /// para>
        /// <para>Windows Vista (w/o Platform Update) and earlier	Full hinting	Full
        /// hinting	Full hinting	Full hinting</para>
        /// <para>Windows 7 and Windows Vista (w/Platform Update) and DirectWrite
        /// enabled in Qt	Full hinting	Vertical hinting	Vertical hinting	Full
        /// hinting</para>
        /// <para>FreeType	Operating System setting	No hinting	Vertical hinting
        /// (light)	Full hinting</para>
        /// <para>Cocoa on Mac OS X	No hinting	No hinting	No hinting	No
        /// hinting</para>
        /// <para></para>
        /// <para>Note: Please be aware that altering the hinting preference on
        /// Windows is available through the DirectWrite font engine. This is available
        /// on Windows Vista after installing the platform update, and on Windows 7. In
        /// order to use this extension, configure Qt using -directwrite. The target
        /// application will then depend on the availability of DirectWrite on the
        /// target system.This enum was introduced or modified in  Qt 4.8.</para>
        /// </summary>
        public enum HintingPreference : uint
        {
            /// <summary>Use the default hinting level for the target platform.</summary>
            PreferDefaultHinting = 0,
            /// <summary>If possible, render text without hinting the outlines of the glyphs. The text layout will be typographically accurate and scalable, using the same metrics as are used e.g. when printing.</summary>
            PreferNoHinting = 1,
            /// <summary>If possible, render text with no horizontal hinting, but align glyphs to the pixel grid in the vertical direction. The text will appear crisper on displays where the density is too low to give an accurate rendering of the glyphs. But since the horizontal metrics of the glyphs are unhinted, the text's layout will be scalable to higher density devices (such as printers) without impacting details such as line breaks.</summary>
            PreferVerticalHinting = 2,
            /// <summary>If possible, render text with hinting in both horizontal and vertical directions. The text will be altered to optimize legibility on the target device, but since the metrics will depend on the target size of the text, the positions of glyphs, line breaks, and other typographical detail will not scale, meaning that a text layout may look different on devices with different pixel densities.</summary>
            PreferFullHinting = 3
        }

        /// <summary>
        /// <para>Qt uses a weighting scale from 0 to 99 similar to, but not the
        /// same as, the scales used in Windows or CSS. A weight of 0 will be thin,
        /// whilst 99 will be extremely black.</para>
        /// <para>This enum contains the predefined font weights:</para>
        /// </summary>
        public enum Weight : uint
        {
            /// <summary>25</summary>
            Light = 25,
            /// <summary>50</summary>
            Normal = 50,
            /// <summary>63</summary>
            DemiBold = 63,
            /// <summary>75</summary>
            Bold = 75,
            /// <summary>87</summary>
            Black = 87
        }

        /// <summary>
        /// <para>This enum describes the different styles of glyphs that are used
        /// to display text.</para>
        /// <para>See also Weight.</para>
        /// </summary>
        public enum Style : uint
        {
            /// <summary>Normal glyphs used in unstyled text.</summary>
            StyleNormal = 0,
            /// <summary>Italic glyphs that are specifically designed for the purpose of representing italicized text.</summary>
            StyleItalic = 1,
            /// <summary>Glyphs with an italic appearance that are typically based on the unstyled glyphs, but are not fine-tuned for the purpose of representing italicized text.</summary>
            StyleOblique = 2
        }

        /// <summary>
        /// <para>Predefined stretch values that follow the CSS naming convention.
        /// The higher the value, the more stretched the text is.</para>
        /// <para>See also setStretch() and stretch().</para>
        /// </summary>
        public enum Stretch : uint
        {
            /// <summary>50</summary>
            UltraCondensed = 50,
            /// <summary>62</summary>
            ExtraCondensed = 62,
            /// <summary>75</summary>
            Condensed = 75,
            /// <summary>87</summary>
            SemiCondensed = 87,
            /// <summary>100</summary>
            Unstretched = 100,
            /// <summary>112</summary>
            SemiExpanded = 112,
            /// <summary>125</summary>
            Expanded = 125,
            /// <summary>150</summary>
            ExtraExpanded = 150,
            /// <summary>200</summary>
            UltraExpanded = 200
        }

        /// <summary>
        /// <para>Rendering option for text this font applies to.</para>
        /// <para>This enum was introduced or modified in  Qt 4.4.</para>
        /// </summary>
        public enum Capitalization : uint
        {
            /// <summary>This is the normal text rendering option where no capitalization change is applied.</summary>
            MixedCase = 0,
            /// <summary>This alters the text to be rendered in all uppercase type.</summary>
            AllUppercase = 1,
            /// <summary>This alters the text to be rendered in all lowercase type.</summary>
            AllLowercase = 2,
            /// <summary>This alters the text to be rendered in small-caps type.</summary>
            SmallCaps = 3,
            /// <summary>This alters the text to be rendered with the first character of each word as an uppercase character.</summary>
            Capitalize = 4
        }

        /// <summary>
        /// <para>This enum was introduced or modified in  Qt 4.4.</para>
        /// </summary>
        public enum SpacingType : uint
        {
            /// <summary>A value of 100 will keep the spacing unchanged; a value of 200 will enlarge the spacing after a character by the width of the character itself.</summary>
            PercentageSpacing = 0,
            /// <summary>A positive value increases the letter spacing by the corresponding pixels; a negative value decreases the spacing.</summary>
            AbsoluteSpacing = 1
        }

        public enum ResolveProperties : uint
        {
            FamilyResolved = 0x1,
            SizeResolved = 0x2,
            StyleHintResolved = 0x4,
            StyleStrategyResolved = 0x8,
            WeightResolved = 0x10,
            StyleResolved = 0x20,
            UnderlineResolved = 0x40,
            OverlineResolved = 0x80,
            StrikeOutResolved = 0x100,
            FixedPitchResolved = 0x200,
            StretchResolved = 0x400,
            KerningResolved = 0x800,
            CapitalizationResolved = 0x1000,
            LetterSpacingResolved = 0x2000,
            WordSpacingResolved = 0x4000,
            HintingPreferenceResolved = 0x8000,
            StyleNameResolved = 0x10000,
            AllPropertiesResolved = 0x1ffff
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFont __CreateInstance(global::System.IntPtr native)
        {
            return new QFont((QFont.Internal*) native);
        }

        public static QFont __CreateInstance(QFont.Internal native)
        {
            return new QFont(native);
        }

        private static QFont.Internal* __CopyValue(QFont.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QFont.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QFont.Internal*) ret;
        }

        private QFont(QFont.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFont(QFont.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a font object that uses the application's default
        /// font.</para>
        /// <para>See also QGuiApplication::setFont() and
        /// QGuiApplication::font().</para>
        /// </summary>
        public QFont()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a font object with the specified family, pointSize,
        /// weight and italic settings.</para>
        /// <para>If pointSize is zero or negative, the point size of the font is
        /// set to a system-dependent default value. Generally, this is 12
        /// points.</para>
        /// <para>The family name may optionally also include a foundry name, e.g.
        /// &quot;Helvetica [Cronyx]&quot;. If the family is available from more than
        /// one foundry and the foundry isn't specified, an arbitrary foundry is
        /// chosen. If the family isn't available a family will be set using the font
        /// matching algorithm.</para>
        /// <para>See also Weight, setFamily(), setPointSize(), setWeight(),
        /// setItalic(), setStyleHint(), and QGuiApplication::font().</para>
        /// </summary>
        public QFont(string family, int pointSize = -1, int weight = -1, bool italic = false)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_1(__Instance, arg0, pointSize, weight, italic);
        }

        /// <summary>
        /// <para>Constructs a font from font for use on the paint device
        /// pd.</para>
        /// </summary>
        public QFont(QFont font, QPaintDevice pd)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var arg1 = ReferenceEquals(pd, null) ? global::System.IntPtr.Zero : pd.__Instance;
            Internal.ctor_2(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a font that is a copy of font.</para>
        /// </summary>
        public QFont(QFont font)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            Internal.cctor_3(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the style hint and strategy to hint and strategy,
        /// respectively.</para>
        /// <para>If these aren't set explicitly the style hint will default to
        /// AnyStyle and the style strategy to PreferDefault.</para>
        /// <para>Qt does not support style hints on X11 since this information is
        /// not provided by the window system.</para>
        /// <para>See also StyleHint, styleHint(), StyleStrategy, styleStrategy(),
        /// and QFontInfo.</para>
        /// </summary>
        public void SetStyleHint(QFont.StyleHint hint, QFont.StyleStrategy strategy = QFont.StyleStrategy.PreferDefault)
        {
            var arg0 = hint;
            var arg1 = strategy;
            Internal.SetStyleHint_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Returns true if a window system font exactly matching the
        /// settings of this font is available.</para>
        /// <para>See also QFontInfo.</para>
        /// </summary>
        public bool ExactMatch()
        {
            var __ret = Internal.ExactMatch_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if this font is equal to f; otherwise returns
        /// false.</para>
        /// <para>Two QFonts are considered equal if their font attributes are
        /// equal. If rawMode() is enabled for both fonts, only the family fields are
        /// compared.</para>
        /// <para>See also operator!=() and isCopyOf().</para>
        /// </summary>
        public static bool operator ==(QFont __op, QFont f)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool fNull = ReferenceEquals(f, null);
            if (__opNull || fNull)
                return __opNull && fNull;
            var arg0 = __op.__Instance;
            var arg1 = f.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QFont;
        }

        /// <summary>
        /// <para>Returns true if this font is different from f; otherwise returns
        /// false.</para>
        /// <para>Two QFonts are considered to be different if their font
        /// attributes are different. If rawMode() is enabled for both fonts, only the
        /// family fields are compared.</para>
        /// <para>See also operator==().</para>
        /// </summary>
        public static bool operator !=(QFont __op, QFont f)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        public static bool operator >(QFont __op, QFont f)
        {
            return !(__op < f);
        }

        /// <summary>
        /// <para>Provides an arbitrary comparison of this font and font f. All
        /// that is guaranteed is that the operator returns false if both fonts are
        /// equal and that (f1 &lt; f2) == !(f2 &lt; f1) if the fonts are not
        /// equal.</para>
        /// <para>This function is useful in some circumstances, for example if you
        /// want to use QFont objects as keys in a QMap.</para>
        /// <para>See also operator==(), operator!=(), and isCopyOf().</para>
        /// </summary>
        public static bool operator <(QFont __op, QFont f)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
            var __ret = Internal.OperatorLess_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if this font and f are copies of each other, i.e.
        /// one of them was created as a copy of the other and neither has been
        /// modified since. This is much stricter than equality.</para>
        /// <para>See also operator=() and operator==().</para>
        /// </summary>
        public bool IsCopyOf(QFont f)
        {
            var arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
            var __ret = Internal.IsCopyOf_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a description of the font. The description is a
        /// comma-separated list of the attributes, perfectly suited for use in
        /// QSettings.</para>
        /// <para>See also fromString().</para>
        /// </summary>
        public string ToString()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.ToString_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Sets this font to match the description descrip. The description
        /// is a comma-separated list of the font attributes, as returned by
        /// toString().</para>
        /// <para>See also toString().</para>
        /// </summary>
        public bool FromString(string descrip)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(descrip).ToPointer(), descrip.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.FromString_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a new QFont that has attributes copied from other that
        /// have not been previously set on this font.</para>
        /// </summary>
        public QFont Resolve(QFont other)
        {
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = new QtGui.QFont.Internal();
            Internal.Resolve_0(new IntPtr(&__ret), __Instance, arg0);
            return QFont.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the first family name to be used whenever familyName is
        /// specified. The lookup is case insensitive.</para>
        /// <para>If there is no substitution for familyName, familyName is
        /// returned.</para>
        /// <para>To obtain a list of substitutions use substitutes().</para>
        /// <para>See also setFamily(), insertSubstitutions(),
        /// insertSubstitution(), and removeSubstitutions().</para>
        /// </summary>
        public static string Substitute(string familyName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(familyName).ToPointer(), familyName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.Substitute_0(new IntPtr(&__ret), arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Inserts substituteName into the substitution table for the family
        /// familyName.</para>
        /// <para>See also insertSubstitutions(), removeSubstitutions(),
        /// substitutions(), substitute(), and substitutes().</para>
        /// </summary>
        public static void InsertSubstitution(string familyName, string substituteName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(familyName).ToPointer(), familyName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(substituteName).ToPointer(), substituteName.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.InsertSubstitution_0(arg0, arg1);
        }

        /// <summary>
        /// <para>Removes all the substitutions for familyName.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also insertSubstitutions(), insertSubstitution(),
        /// substitutions(), and substitute().</para>
        /// </summary>
        public static void RemoveSubstitutions(string familyName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(familyName).ToPointer(), familyName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.RemoveSubstitutions_0(arg0);
        }

        public static void Initialize()
        {
            Internal.Initialize_0();
        }

        public static void Cleanup()
        {
            Internal.Cleanup_0();
        }

        public static void CacheStatistics()
        {
            Internal.CacheStatistics_0();
        }

        /// <summary>
        /// <para>Returns the requested font family name, i.e. the name set in the
        /// constructor or the last setFont() call.</para>
        /// <para>See also setFamily(), substitutes(), and substitute().</para>
        /// <para></para>
        /// <para>Sets the family name of the font. The name is case insensitive
        /// and may include a foundry name.</para>
        /// <para>The family name may optionally also include a foundry name, e.g.
        /// &quot;Helvetica [Cronyx]&quot;. If the family is available from more than
        /// one foundry and the foundry isn't specified, an arbitrary foundry is
        /// chosen. If the family isn't available a family will be set using the font
        /// matching algorithm.</para>
        /// <para>See also family(), setStyleHint(), and QFontInfo.</para>
        /// </summary>
        public string Family
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Family_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFamily_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the requested font style name, it will be used to match
        /// the font with irregular styles (that can't be normalized in other style
        /// properties). It depends on system font support, thus only works for Mac OS
        /// X and X11 so far. On Windows irregular styles will be added as separate
        /// font families so there is no need for this.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// <para>See also setStyleName(), setFamily(), and setStyle().</para>
        /// <para></para>
        /// <para>Sets the style name of the font to styleName. When set, other
        /// style properties like style() and weight() will be ignored for font
        /// matching.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// <para>See also styleName().</para>
        /// </summary>
        public string StyleName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.StyleName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetStyleName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the point size of the font. Returns -1 if the font size
        /// was specified in pixels.</para>
        /// <para>See also setPointSize() and pointSizeF().</para>
        /// <para></para>
        /// <para>Sets the point size to pointSize. The point size must be greater
        /// than zero.</para>
        /// <para>See also pointSize() and setPointSizeF().</para>
        /// </summary>
        public int PointSize
        {
            get
            {
                var __ret = Internal.PointSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetPointSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the pixel size of the font if it was set with
        /// setPixelSize(). Returns -1 if the size was set with setPointSize() or
        /// setPointSizeF().</para>
        /// <para>See also setPixelSize(), pointSize(), QFontInfo::pointSize(), and
        /// QFontInfo::pixelSize().</para>
        /// <para></para>
        /// <para>Sets the font size to pixelSize pixels.</para>
        /// <para>Using this function makes the font device dependent. Use
        /// setPointSize() or setPointSizeF() to set the size of the font in a device
        /// independent manner.</para>
        /// <para>See also pixelSize().</para>
        /// </summary>
        public int PixelSize
        {
            get
            {
                var __ret = Internal.PixelSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetPixelSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the weight of the font, using the same scale as the
        /// QFont::Weight enumeration.</para>
        /// <para>See also setWeight(), Weight, and QFontInfo.</para>
        /// <para></para>
        /// <para>Sets the weight of the font to weight, using the scale defined by
        /// QFont::Weight enumeration.</para>
        /// <para>See also weight() and QFontInfo.</para>
        /// </summary>
        public int weight
        {
            get
            {
                var __ret = Internal.weight_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetWeight_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the style of the font.</para>
        /// <para>See also setStyle().</para>
        /// <para></para>
        /// <para>Sets the style of the font to style.</para>
        /// <para>See also style(), italic(), and QFontInfo.</para>
        /// </summary>
        public QFont.Style style
        {
            get
            {
                var __ret = Internal.style_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetStyle_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if underline has been set; otherwise returns
        /// false.</para>
        /// <para>See also setUnderline().</para>
        /// <para></para>
        /// <para>If enable is true, sets underline on; otherwise sets underline
        /// off.</para>
        /// <para>See also underline() and QFontInfo.</para>
        /// </summary>
        public bool Underline
        {
            get
            {
                var __ret = Internal.Underline_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetUnderline_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if overline has been set; otherwise returns
        /// false.</para>
        /// <para>See also setOverline().</para>
        /// <para></para>
        /// <para>If enable is true, sets overline on; otherwise sets overline
        /// off.</para>
        /// <para>See also overline() and QFontInfo.</para>
        /// </summary>
        public bool Overline
        {
            get
            {
                var __ret = Internal.Overline_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetOverline_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if strikeout has been set; otherwise returns
        /// false.</para>
        /// <para>See also setStrikeOut().</para>
        /// <para></para>
        /// <para>If enable is true, sets strikeout on; otherwise sets strikeout
        /// off.</para>
        /// <para>See also strikeOut() and QFontInfo.</para>
        /// </summary>
        public bool StrikeOut
        {
            get
            {
                var __ret = Internal.StrikeOut_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStrikeOut_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if fixed pitch has been set; otherwise returns
        /// false.</para>
        /// <para>See also setFixedPitch() and QFontInfo::fixedPitch().</para>
        /// <para></para>
        /// <para>If enable is true, sets fixed pitch on; otherwise sets fixed
        /// pitch off.</para>
        /// <para>See also fixedPitch() and QFontInfo.</para>
        /// </summary>
        public bool FixedPitch
        {
            get
            {
                var __ret = Internal.FixedPitch_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetFixedPitch_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if kerning should be used when drawing text with
        /// this font.</para>
        /// <para>See also setKerning().</para>
        /// <para></para>
        /// <para>Enables kerning for this font if enable is true; otherwise
        /// disables it. By default, kerning is enabled.</para>
        /// <para>When kerning is enabled, glyph metrics do not add up anymore,
        /// even for Latin text. In other words, the assumption that width('a') +
        /// width('b') is equal to width(&quot;ab&quot;) is not necessarily
        /// true.</para>
        /// <para>See also kerning() and QFontMetrics.</para>
        /// </summary>
        public bool Kerning
        {
            get
            {
                var __ret = Internal.Kerning_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetKerning_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the StyleStrategy.</para>
        /// <para>The style strategy affects the font matching algorithm. See
        /// QFont::StyleStrategy for the list of available strategies.</para>
        /// <para>See also setStyleStrategy(), setStyleHint(), and
        /// QFont::StyleHint.</para>
        /// <para></para>
        /// <para>Sets the style strategy for the font to s.</para>
        /// <para>See also styleStrategy() and QFont::StyleStrategy.</para>
        /// </summary>
        public QFont.StyleStrategy styleStrategy
        {
            get
            {
                var __ret = Internal.styleStrategy_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetStyleStrategy_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the stretch factor for the font.</para>
        /// <para>See also setStretch().</para>
        /// <para></para>
        /// <para>Sets the stretch factor for the font.</para>
        /// <para>The stretch factor changes the width of all characters in the
        /// font by factor percent. For example, setting factor to 150 results in all
        /// characters in the font being 1.5 times (ie. 150%) wider. The default
        /// stretch factor is 100. The minimum stretch factor is 1, and the maximum
        /// stretch factor is 4000.</para>
        /// <para>The stretch factor is only applied to outline fonts. The stretch
        /// factor is ignored for bitmap fonts.</para>
        /// <para>See also stretch() and QFont::Stretch.</para>
        /// </summary>
        public int stretch
        {
            get
            {
                var __ret = Internal.stretch_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStretch_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the current capitalization type of the font.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setCapitalization().</para>
        /// <para></para>
        /// <para>Sets the capitalization of the text in this font to caps.</para>
        /// <para>A font's capitalization makes the text appear in the selected
        /// capitalization mode.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also capitalization().</para>
        /// </summary>
        public QFont.Capitalization capitalization
        {
            get
            {
                var __ret = Internal.capitalization_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetCapitalization_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the currently preferred hinting level for glyphs rendered
        /// with this font.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// <para>See also setHintingPreference().</para>
        /// <para></para>
        /// <para>Set the preference for the hinting level of the glyphs to
        /// hintingPreference. This is a hint to the underlying font rendering system
        /// to use a certain level of hinting, and has varying support across
        /// platforms. See the table in the documentation for QFont::HintingPreference
        /// for more details.</para>
        /// <para>The default hinting preference is
        /// QFont::PreferDefaultHinting.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// <para>See also hintingPreference().</para>
        /// </summary>
        public QFont.HintingPreference hintingPreference
        {
            get
            {
                var __ret = Internal.hintingPreference_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetHintingPreference_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if raw mode is used for font name matching;
        /// otherwise returns false.</para>
        /// <para>See also setRawMode() and rawName().</para>
        /// <para></para>
        /// <para>If enable is true, turns raw mode on; otherwise turns raw mode
        /// off. This function only has an effect under X11.</para>
        /// <para>If raw mode is enabled, Qt will search for an X font with a
        /// complete font name matching the family name, ignoring all other values set
        /// for the QFont. If the font name matches several fonts, Qt will use the
        /// first font returned by X. QFontInfo cannot be used to fetch information
        /// about a QFont using raw mode (it will return the values set in the QFont
        /// for all parameters, including the family name).</para>
        /// <para>Warning: Do not use raw mode unless you really, really need it!
        /// In most (if not all) cases, setRawName() is a much better choice.</para>
        /// <para>See also rawMode() and setRawName().</para>
        /// </summary>
        public bool RawMode
        {
            get
            {
                var __ret = Internal.RawMode_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRawMode_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the name of the font within the underlying window
        /// system.</para>
        /// <para>On X11, this function will return an empty string.</para>
        /// <para>Using the return value of this function is usually not
        /// portable.</para>
        /// <para>See also setRawName().</para>
        /// <para></para>
        /// <para>Sets a font by its system specific name.</para>
        /// <para>A font set with setRawName() is still a full-featured QFont. It
        /// can be queried (for example with italic()) or modified (for example with
        /// setItalic()) and is therefore also suitable for rendering rich text.</para>
        /// <para>If Qt's internal font database cannot resolve the raw name, the
        /// font becomes a raw font with name as its family.</para>
        /// <para>See also rawName(), setRawMode(), and setFamily().</para>
        /// </summary>
        public string RawName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.RawName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetRawName_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the StyleHint.</para>
        /// <para>The style hint affects the font matching algorithm. See
        /// QFont::StyleHint for the list of available hints.</para>
        /// <para>See also setStyleHint(), QFont::StyleStrategy, and
        /// QFontInfo::styleHint().</para>
        /// </summary>
        public QFont.StyleHint styleHint
        {
            get
            {
                var __ret = Internal.styleHint_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the spacing type used for letter spacing.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also letterSpacing(), setLetterSpacing(), and
        /// setWordSpacing().</para>
        /// </summary>
        public QFont.SpacingType LetterSpacingType
        {
            get
            {
                var __ret = Internal.LetterSpacingType_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the font's key, a textual representation of a font. It is
        /// typically used as the key for a cache or dictionary of fonts.</para>
        /// <para>See also QMap.</para>
        /// </summary>
        public string Key
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Key_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the family name that corresponds to the current style
        /// hint.</para>
        /// <para>See also StyleHint, styleHint(), and setStyleHint().</para>
        /// </summary>
        public string DefaultFamily
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.DefaultFamily_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the &quot;last resort&quot; font family name.</para>
        /// <para>The current implementation tries a wide variety of common fonts,
        /// returning the first one it finds. Is is possible that no family is found in
        /// which case an empty string is returned.</para>
        /// <para>See also lastResortFont().</para>
        /// </summary>
        public string LastResortFamily
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.LastResortFamily_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns a &quot;last resort&quot; font name for the font matching
        /// algorithm. This is used if the last resort family is not available. It will
        /// always return a name, if necessary returning something like
        /// &quot;fixed&quot; or &quot;system&quot;.</para>
        /// <para>The current implementation tries a wide variety of common fonts,
        /// returning the first one it finds. The implementation may change at any
        /// time, but this function will always return a string containing
        /// something.</para>
        /// <para>It is theoretically possible that there really isn't a
        /// lastResortFont() in which case Qt will abort with an error message. We have
        /// not been able to identify a case where this happens. Please report it as a
        /// bug if it does, preferably with a list of the fonts you have
        /// installed.</para>
        /// <para>See also lastResortFamily() and rawName().</para>
        /// </summary>
        public string LastResortFont
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.LastResortFont_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    /// <summary>
    /// <para>The QStandardItem class provides an item for use with the
    /// QStandardItemModel class.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Items usually contain text, icons, or checkboxes.</para>
    /// <para>Each item can have its own background brush which is set with the
    /// setBackground() function. The current background brush can be found with
    /// background(). The text label for each item can be rendered with its own
    /// font and brush. These are specified with the setFont() and setForeground()
    /// functions, and read with font() and foreground().</para>
    /// <para>By default, items are enabled, editable, selectable, checkable,
    /// and can be used both as the source of a drag and drop operation and as a
    /// drop target. Each item's flags can be changed by calling setFlags().
    /// Checkable items can be checked and unchecked with the setCheckState()
    /// function. The corresponding checkState() function indicates whether the
    /// item is currently checked.</para>
    /// <para>You can store application-specific data in an item by calling
    /// setData().</para>
    /// <para>Each item can have a two-dimensional table of child items. This
    /// makes it possible to build hierarchies of items. The typical hierarchy is
    /// the tree, in which case the child table is a table with a single column (a
    /// list).</para>
    /// <para>The dimensions of the child table can be set with setRowCount()
    /// and setColumnCount(). Items can be positioned in the child table with
    /// setChild(). Get a pointer to a child item with child(). New rows and
    /// columns of children can also be inserted with insertRow() and
    /// insertColumn(), or appended with appendRow() and appendColumn(). When using
    /// the append and insert functions, the dimensions of the child table will
    /// grow as needed.</para>
    /// <para>An existing row of children can be removed with removeRow() or
    /// takeRow(); correspondingly, a column can be removed with removeColumn() or
    /// takeColumn().</para>
    /// <para>An item's children can be sorted by calling
    /// sortChildren().</para>
    /// <para></para>
    /// <para>Subclassing</para>
    /// <para>When subclassing QStandardItem to provide custom items, it is
    /// possible to define new types for them so that they can be distinguished
    /// from the base class. The type() function should be reimplemented to return
    /// a new type value equal to or greater than UserType.</para>
    /// <para>Reimplement data() and setData() if you want to perform custom
    /// handling of data queries and/or control how an item's data is
    /// represented.</para>
    /// <para>Reimplement clone() if you want QStandardItemModel to be able to
    /// create instances of your custom item class on demand (see
    /// QStandardItemModel::setItemPrototype()).</para>
    /// <para>Reimplement read() and write() if you want to control how items
    /// are represented in their serialized form.</para>
    /// <para>Reimplement operator&lt;() if you want to control the semantics
    /// of item comparison. operator&lt;() determines the sorted order when sorting
    /// items with sortChildren() or with QStandardItemModel::sort().</para>
    /// <para></para>
    /// <para>See also QStandardItemModel, Item View Convenience Classes, and
    /// Model/View Programming.</para>
    /// </remarks>
    public unsafe partial class QStandardItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            internal QScopedPointer.Internal d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItemC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItemC2ERK7QString")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItemC2ERK5QIconRK7QString")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr icon, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItemC2Eii")]
            internal static extern void ctor_3(global::System.IntPtr instance, int rows, int columns);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItemC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItemD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem10setEnabledEb")]
            internal static extern void SetEnabled_0(global::System.IntPtr instance, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem11setEditableEb")]
            internal static extern void SetEditable_0(global::System.IntPtr instance, bool editable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem13setSelectableEb")]
            internal static extern void SetSelectable_0(global::System.IntPtr instance, bool selectable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem12setCheckableEb")]
            internal static extern void SetCheckable_0(global::System.IntPtr instance, bool checkable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem11setTristateEb")]
            internal static extern void SetTristate_0(global::System.IntPtr instance, bool tristate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem14setDragEnabledEb")]
            internal static extern void SetDragEnabled_0(global::System.IntPtr instance, bool dragEnabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem14setDropEnabledEb")]
            internal static extern void SetDropEnabled_0(global::System.IntPtr instance, bool dropEnabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem5childEii")]
            internal static extern global::System.IntPtr Child_0(global::System.IntPtr instance, int row, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem8setChildEiiPS_")]
            internal static extern void SetChild_0(global::System.IntPtr instance, int row, int column, global::System.IntPtr item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem9insertRowEiRK5QListIPS_E")]
            internal static extern void InsertRow_0(global::System.IntPtr instance, int row, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem12insertColumnEiRK5QListIPS_E")]
            internal static extern void InsertColumn_0(global::System.IntPtr instance, int column, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem10insertRowsEiRK5QListIPS_E")]
            internal static extern void InsertRows_0(global::System.IntPtr instance, int row, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem10insertRowsEii")]
            internal static extern void InsertRows_1(global::System.IntPtr instance, int row, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem13insertColumnsEii")]
            internal static extern void InsertColumns_0(global::System.IntPtr instance, int column, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem9removeRowEi")]
            internal static extern void RemoveRow_0(global::System.IntPtr instance, int row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem12removeColumnEi")]
            internal static extern void RemoveColumn_0(global::System.IntPtr instance, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem10removeRowsEii")]
            internal static extern void RemoveRows_0(global::System.IntPtr instance, int row, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem13removeColumnsEii")]
            internal static extern void RemoveColumns_0(global::System.IntPtr instance, int column, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem9takeChildEii")]
            internal static extern global::System.IntPtr TakeChild_0(global::System.IntPtr instance, int row, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem7takeRowEi")]
            internal static extern QList.Internal TakeRow_0(global::System.IntPtr instance, int row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem10takeColumnEi")]
            internal static extern QList.Internal TakeColumn_0(global::System.IntPtr instance, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem5cloneEv")]
            internal static extern global::System.IntPtr Clone_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItemltERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem15emitDataChangedEv")]
            internal static extern void EmitDataChanged_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem8rowCountEv")]
            internal static extern int RowCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem11setRowCountEi")]
            internal static extern void SetRowCount_0(global::System.IntPtr instance, int rows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem11columnCountEv")]
            internal static extern int ColumnCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QStandardItem14setColumnCountEi")]
            internal static extern void SetColumnCount_0(global::System.IntPtr instance, int columns);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem6parentEv")]
            internal static extern global::System.IntPtr Parent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem3rowEv")]
            internal static extern int Row_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem6columnEv")]
            internal static extern int Column_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem5modelEv")]
            internal static extern global::System.IntPtr Model_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem11hasChildrenEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasChildren_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QStandardItem4typeEv")]
            internal static extern int Type_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the types that are used to describe standard
        /// items.</para>
        /// <para>You can define new user types in QStandardItem subclasses to
        /// ensure that custom items are treated specially; for example, when items are
        /// sorted.</para>
        /// <para>See also type().</para>
        /// </summary>
        public enum ItemType : uint
        {
            /// <summary>The default type for standard items.</summary>
            Type = 0,
            /// <summary>The minimum value for custom types. Values below UserType are reserved by Qt.</summary>
            UserType = 1000
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QStandardItem __CreateInstance(global::System.IntPtr native)
        {
            return new QStandardItem((QStandardItem.Internal*) native);
        }

        public static QStandardItem __CreateInstance(QStandardItem.Internal native)
        {
            return new QStandardItem(native);
        }

        private static QStandardItem.Internal* __CopyValue(QStandardItem.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QStandardItem.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QStandardItem.Internal*) ret;
        }

        private QStandardItem(QStandardItem.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QStandardItem(QStandardItem.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an item.</para>
        /// </summary>
        public QStandardItem()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an item with the given text.</para>
        /// </summary>
        public QStandardItem(string text)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_1(__Instance, arg0);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an item with the given icon and text.</para>
        /// </summary>
        public QStandardItem(QIcon icon, string text)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(icon, null) ? global::System.IntPtr.Zero : icon.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.ctor_2(__Instance, arg0, arg1);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs an item with rows rows and columns columns of child
        /// items.</para>
        /// </summary>
        public QStandardItem(int rows, int columns = 1)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_3(__Instance, rows, columns);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a copy of other. Note that model() is not
        /// copied.</para>
        /// <para>This function is useful when reimplementing clone().</para>
        /// </summary>
        protected QStandardItem(QStandardItem other)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_4(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets whether the item is enabled. If enabled is true, the item is
        /// enabled, meaning that the user can interact with the item; if enabled is
        /// false, the user cannot interact with the item.</para>
        /// <para>This flag takes precedence over the other item flags; e.g. if an
        /// item is not enabled, it cannot be selected by the user, even if the
        /// Qt::ItemIsSelectable flag has been set.</para>
        /// <para>See also isEnabled(), Qt::ItemIsEnabled, and setFlags().</para>
        /// </summary>
        public void SetEnabled(bool enabled)
        {
            Internal.SetEnabled_0(__Instance, enabled);
        }

        /// <summary>
        /// <para>Sets whether the item is editable. If editable is true, the item
        /// can be edited by the user; otherwise, the user cannot edit the item.</para>
        /// <para>How the user can edit items in a view is determined by the view's
        /// edit triggers; see QAbstractItemView::editTriggers.</para>
        /// <para>See also isEditable() and setFlags().</para>
        /// </summary>
        public void SetEditable(bool editable)
        {
            Internal.SetEditable_0(__Instance, editable);
        }

        /// <summary>
        /// <para>Sets whether the item is selectable. If selectable is true, the
        /// item can be selected by the user; otherwise, the user cannot select the
        /// item.</para>
        /// <para>You can control the selection behavior and mode by manipulating
        /// their view properties; see QAbstractItemView::selectionMode and
        /// QAbstractItemView::selectionBehavior.</para>
        /// <para>See also isSelectable() and setFlags().</para>
        /// </summary>
        public void SetSelectable(bool selectable)
        {
            Internal.SetSelectable_0(__Instance, selectable);
        }

        /// <summary>
        /// <para>Sets whether the item is user-checkable. If checkable is true,
        /// the item can be checked by the user; otherwise, the user cannot check the
        /// item.</para>
        /// <para>The item delegate will render a checkable item with a check box
        /// next to the item's text.</para>
        /// <para>See also isCheckable(), setCheckState(), and
        /// setTristate().</para>
        /// </summary>
        public void SetCheckable(bool checkable)
        {
            Internal.SetCheckable_0(__Instance, checkable);
        }

        /// <summary>
        /// <para>Sets whether the item is tristate. If tristate is true, the item
        /// is checkable with three separate states; otherwise, the item is checkable
        /// with two states. (Note that this also requires that the item is checkable;
        /// see isCheckable().)</para>
        /// <para>See also isTristate(), setCheckable(), and
        /// setCheckState().</para>
        /// </summary>
        public void SetTristate(bool tristate)
        {
            Internal.SetTristate_0(__Instance, tristate);
        }

        /// <summary>
        /// <para>Sets whether the item is drag enabled. If dragEnabled is true,
        /// the item can be dragged by the user; otherwise, the user cannot drag the
        /// item.</para>
        /// <para>Note that you also need to ensure that item dragging is enabled
        /// in the view; see QAbstractItemView::dragEnabled.</para>
        /// <para>See also isDragEnabled(), setDropEnabled(), and
        /// setFlags().</para>
        /// </summary>
        public void SetDragEnabled(bool dragEnabled)
        {
            Internal.SetDragEnabled_0(__Instance, dragEnabled);
        }

        /// <summary>
        /// <para>Sets whether the item is drop enabled. If dropEnabled is true,
        /// the item can be used as a drop target; otherwise, it cannot.</para>
        /// <para>Note that you also need to ensure that drops are enabled in the
        /// view; see QWidget::acceptDrops(); and that the model supports the desired
        /// drop actions; see QAbstractItemModel::supportedDropActions().</para>
        /// <para>See also isDropEnabled(), setDragEnabled(), and
        /// setFlags().</para>
        /// </summary>
        public void SetDropEnabled(bool dropEnabled)
        {
            Internal.SetDropEnabled_0(__Instance, dropEnabled);
        }

        /// <summary>
        /// <para>Returns the child item at (row, column) if one has been set;
        /// otherwise returns 0.</para>
        /// <para>See also setChild(), takeChild(), and parent().</para>
        /// </summary>
        public QStandardItem Child(int row, int column = 0)
        {
            var __ret = Internal.Child_0(__Instance, row, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Sets the child item at (row, column) to item. This item (the
        /// parent item) takes ownership of item. If necessary, the row count and
        /// column count are increased to fit the item.</para>
        /// <para>See also child().</para>
        /// </summary>
        public void SetChild(int row, int column, QStandardItem item)
        {
            var arg2 = ReferenceEquals(item, null) ? global::System.IntPtr.Zero : item.__Instance;
            Internal.SetChild_0(__Instance, row, column, arg2);
        }

        /// <summary>
        /// <para>Inserts a row at row containing items. If necessary, the column
        /// count is increased to the size of items.</para>
        /// <para>See also insertRows() and insertColumn().</para>
        /// </summary>
        public void InsertRow(int row, System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList1 = new QtCore.QList.Internal();
            var __qlistDataData1 = (QListData.Data.Internal*) __qList1._0.d;
            __qlistDataData1->alloc = items.Count;
            __qlistDataData1->begin = 0;
            __qlistDataData1->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData1->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData1->array[i] = (void*) items[i].__Instance;
            }
            var arg1 = new global::System.IntPtr(&__qList1);
            Internal.InsertRow_0(__Instance, row, arg1);
        }

        /// <summary>
        /// <para>Inserts a column at column containing items. If necessary, the
        /// row count is increased to the size of items.</para>
        /// <para>See also insertColumns() and insertRow().</para>
        /// </summary>
        public void InsertColumn(int column, System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList1 = new QtCore.QList.Internal();
            var __qlistDataData1 = (QListData.Data.Internal*) __qList1._0.d;
            __qlistDataData1->alloc = items.Count;
            __qlistDataData1->begin = 0;
            __qlistDataData1->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData1->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData1->array[i] = (void*) items[i].__Instance;
            }
            var arg1 = new global::System.IntPtr(&__qList1);
            Internal.InsertColumn_0(__Instance, column, arg1);
        }

        /// <summary>
        /// <para>Inserts items at row. The column count won't be changed.</para>
        /// <para>See also insertRow() and insertColumn().</para>
        /// </summary>
        public void InsertRows(int row, System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList1 = new QtCore.QList.Internal();
            var __qlistDataData1 = (QListData.Data.Internal*) __qList1._0.d;
            __qlistDataData1->alloc = items.Count;
            __qlistDataData1->begin = 0;
            __qlistDataData1->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData1->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData1->array[i] = (void*) items[i].__Instance;
            }
            var arg1 = new global::System.IntPtr(&__qList1);
            Internal.InsertRows_0(__Instance, row, arg1);
        }

        /// <summary>
        /// <para>Inserts count rows of child items at row row.</para>
        /// <para>See also insertRow() and insertColumns().</para>
        /// </summary>
        public void InsertRows(int row, int count)
        {
            Internal.InsertRows_1(__Instance, row, count);
        }

        /// <summary>
        /// <para>Inserts count columns of child items at column column.</para>
        /// <para>See also insertColumn() and insertRows().</para>
        /// </summary>
        public void InsertColumns(int column, int count)
        {
            Internal.InsertColumns_0(__Instance, column, count);
        }

        /// <summary>
        /// <para>Removes the given row. The items that were in the row are
        /// deleted.</para>
        /// <para>See also takeRow(), removeRows(), and removeColumn().</para>
        /// </summary>
        public void RemoveRow(int row)
        {
            Internal.RemoveRow_0(__Instance, row);
        }

        /// <summary>
        /// <para>Removes the given column. The items that were in the column are
        /// deleted.</para>
        /// <para>See also takeColumn(), removeColumns(), and removeRow().</para>
        /// </summary>
        public void RemoveColumn(int column)
        {
            Internal.RemoveColumn_0(__Instance, column);
        }

        /// <summary>
        /// <para>Removes count rows at row row. The items that were in those rows
        /// are deleted.</para>
        /// <para>See also removeRow() and removeColumn().</para>
        /// </summary>
        public void RemoveRows(int row, int count)
        {
            Internal.RemoveRows_0(__Instance, row, count);
        }

        /// <summary>
        /// <para>Removes count columns at column column. The items that were in
        /// those columns are deleted.</para>
        /// <para>See also removeColumn() and removeRows().</para>
        /// </summary>
        public void RemoveColumns(int column, int count)
        {
            Internal.RemoveColumns_0(__Instance, column, count);
        }

        /// <summary>
        /// <para>Removes the child item at (row, column) without deleting it, and
        /// returns a pointer to the item. If there was no child at the given location,
        /// then this function returns 0.</para>
        /// <para>Note that this function, unlike takeRow() and takeColumn(), does
        /// not affect the dimensions of the child table.</para>
        /// <para>See also child(), takeRow(), and takeColumn().</para>
        /// </summary>
        public QStandardItem TakeChild(int row, int column = 0)
        {
            var __ret = Internal.TakeChild_0(__Instance, row, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Removes row without deleting the row items, and returns a list of
        /// pointers to the removed items. For items in the row that have not been set,
        /// the corresponding pointers in the list will be 0.</para>
        /// <para>See also removeRow(), insertRow(), and takeColumn().</para>
        /// </summary>
        public System.Collections.Generic.IList<QStandardItem> TakeRow(int row)
        {
            var __ret = Internal.TakeRow_0(__Instance, row);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QStandardItem>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QStandardItem.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Removes column without deleting the column items, and returns a
        /// list of pointers to the removed items. For items in the column that have
        /// not been set, the corresponding pointers in the list will be 0.</para>
        /// <para>See also removeColumn(), insertColumn(), and takeRow().</para>
        /// </summary>
        public System.Collections.Generic.IList<QStandardItem> TakeColumn(int column)
        {
            var __ret = Internal.TakeColumn_0(__Instance, column);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QStandardItem>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QStandardItem.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns a copy of this item. The item's children are not
        /// copied.</para>
        /// <para>When subclassing QStandardItem, you can reimplement this function
        /// to provide QStandardItemModel with a factory that it can use to create new
        /// items on demand.</para>
        /// <para>See also QStandardItemModel::setItemPrototype() and
        /// operator=().</para>
        /// </summary>
        public virtual QStandardItem Clone()
        {
            var __ret = Internal.Clone_0(__Instance);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        public static bool operator >(QStandardItem __op, QStandardItem other)
        {
            return !(__op < other);
        }

        /// <summary>
        /// <para>Returns true if this item is less than other; otherwise returns
        /// false.</para>
        /// <para>The default implementation uses the data for the item's sort role
        /// (see QStandardItemModel::sortRole) to perform the comparison if the item
        /// belongs to a model; otherwise, the data for the item's Qt::DisplayRole
        /// (text()) is used to perform the comparison.</para>
        /// <para>sortChildren() and QStandardItemModel::sort() use this function
        /// when sorting items. If you want custom sorting, you can subclass
        /// QStandardItem and reimplement this function.</para>
        /// </summary>
        public static bool operator <(QStandardItem __op, QStandardItem other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.OperatorLess_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Causes the model associated with this item to emit a
        /// dataChanged() signal for this item.</para>
        /// <para>You normally only need to call this function if you have
        /// subclassed QStandardItem and reimplemented data() and/or setData().</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setData().</para>
        /// </summary>
        protected void EmitDataChanged()
        {
            Internal.EmitDataChanged_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the number of child item rows that the item has.</para>
        /// <para>See also setRowCount() and columnCount().</para>
        /// <para></para>
        /// <para>Sets the number of child item rows to rows. If this is less than
        /// rowCount(), the data in the unwanted rows is discarded.</para>
        /// <para>See also rowCount() and setColumnCount().</para>
        /// </summary>
        public int RowCount
        {
            get
            {
                var __ret = Internal.RowCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRowCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of child item columns that the item
        /// has.</para>
        /// <para>See also setColumnCount() and rowCount().</para>
        /// <para></para>
        /// <para>Sets the number of child item columns to columns. If this is less
        /// than columnCount(), the data in the unwanted columns is discarded.</para>
        /// <para>See also columnCount() and setRowCount().</para>
        /// </summary>
        public int ColumnCount
        {
            get
            {
                var __ret = Internal.ColumnCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetColumnCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the item's parent item, or 0 if the item has no
        /// parent.</para>
        /// <para>Note: For toplevel items parent() returns 0. To receive toplevel
        /// item's parent use QStandardItemModel::invisibleRootItem() instead.See also
        /// child() and QStandardItemModel::invisibleRootItem().</para>
        /// </summary>
        public QStandardItem Parent
        {
            get
            {
                var __ret = Internal.Parent_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the row where the item is located in its parent's child
        /// table, or -1 if the item has no parent.</para>
        /// <para>See also column() and parent().</para>
        /// </summary>
        public int Row
        {
            get
            {
                var __ret = Internal.Row_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the column where the item is located in its parent's
        /// child table, or -1 if the item has no parent.</para>
        /// <para>See also row() and parent().</para>
        /// </summary>
        public int Column
        {
            get
            {
                var __ret = Internal.Column_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the QStandardItemModel that this item belongs to.</para>
        /// <para>If the item is not a child of another item that belongs to the
        /// model, this function returns 0.</para>
        /// <para>See also index().</para>
        /// </summary>
        public QStandardItemModel Model
        {
            get
            {
                var __ret = Internal.Model_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QStandardItemModel.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if this item has any children; otherwise returns
        /// false.</para>
        /// <para>See also rowCount(), columnCount(), and child().</para>
        /// </summary>
        public bool HasChildren
        {
            get
            {
                var __ret = Internal.HasChildren_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the type of this item. The type is used to distinguish
        /// custom items from the base class. When subclassing QStandardItem, you
        /// should reimplement this function and return a new value greater than or
        /// equal to UserType.</para>
        /// <para>See also QStandardItem::Type.</para>
        /// </summary>
        public virtual int Type
        {
            get
            {
                var __ret = Internal.Type_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QStandardItem()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QStandardItem) _References[instance].Target;
            target.Dispose();
        }

        // QStandardItem *clone()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _Clone_0Delegate(global::System.IntPtr instance);
        private static _Clone_0Delegate _Clone_0DelegateInstance;

        private static global::System.IntPtr _Clone_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QStandardItem) _References[instance].Target;
            var _ret = target.Clone();
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int type()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Type_0Delegate(global::System.IntPtr instance);
        private static _Type_0Delegate _Type_0DelegateInstance;

        private static int _Type_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QStandardItem) _References[instance].Target;
            var _ret = target.Type;
            return _ret;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Clone_0DelegateInstance += _Clone_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Clone_0DelegateInstance).ToPointer();
                _Type_0DelegateInstance += _Type_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Type_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = _Thunks[1];
                *(void**)(vfptr0 + 20) = _Thunks[2];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = _Thunks[-1];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QStandardItemModel class provides a generic model for storing
    /// custom data.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QStandardItemModel can be used as a repository for standard Qt
    /// data types. It is one of the Model/View Classes and is part of Qt's
    /// model/view framework.</para>
    /// <para>QStandardItemModel provides a classic item-based approach to
    /// working with the model. The items in a QStandardItemModel are provided by
    /// QStandardItem.</para>
    /// <para>QStandardItemModel implements the QAbstractItemModel interface,
    /// which means that the model can be used to provide data in any view that
    /// supports that interface (such as QListView, QTableView and QTreeView, and
    /// your own custom views). For performance and flexibility, you may want to
    /// subclass QAbstractItemModel to provide support for different kinds of data
    /// repositories. For example, the QDirModel provides a model interface to the
    /// underlying file system.</para>
    /// <para>When you want a list or tree, you typically create an empty
    /// QStandardItemModel and use appendRow() to add items to the model, and
    /// item() to access an item. If your model represents a table, you typically
    /// pass the dimensions of the table to the QStandardItemModel constructor and
    /// use setItem() to position items into the table. You can also use
    /// setRowCount() and setColumnCount() to alter the dimensions of the model. To
    /// insert items, use insertRow() or insertColumn(), and to remove items, use
    /// removeRow() or removeColumn().</para>
    /// <para>You can set the header labels of your model with
    /// setHorizontalHeaderLabels() and setVerticalHeaderLabels().</para>
    /// <para>You can search for items in the model with findItems(), and sort
    /// the model by calling sort().</para>
    /// <para>Call clear() to remove all items from the model.</para>
    /// <para>An example usage of QStandardItemModel to create a table:</para>
    /// <para>QStandardItemModel model(4, 4);</para>
    /// <para>for (int row = 0; row &lt; 4; ++row) {</para>
    /// <para>    for (int column = 0; column &lt; 4; ++column) {</para>
    /// <para>        QStandardItem *item = new QStandardItem(QString(&quot;row
    /// %0, column %1&quot;).arg(row).arg(column));</para>
    /// <para>        model.setItem(row, column, item);</para>
    /// <para>    }</para>
    /// <para>}</para>
    /// <para>An example usage of QStandardItemModel to create a tree:</para>
    /// <para>QStandardItemModel model;</para>
    /// <para>QStandardItem *parentItem = model.invisibleRootItem();</para>
    /// <para>for (int i = 0; i &lt; 4; ++i) {</para>
    /// <para>    QStandardItem *item = new QStandardItem(QString(&quot;item
    /// %0&quot;).arg(i));</para>
    /// <para>    parentItem-&gt;appendRow(item);</para>
    /// <para>    parentItem = item;</para>
    /// <para>}</para>
    /// <para>After setting the model on a view, you typically want to react to
    /// user actions, such as an item being clicked. Since a QAbstractItemView
    /// provides QModelIndex-based signals and functions, you need a way to obtain
    /// the QStandardItem that corresponds to a given QModelIndex, and vice versa.
    /// itemFromIndex() and indexFromItem() provide this mapping. Typical usage of
    /// itemFromIndex() includes obtaining the item at the current index in a view,
    /// and obtaining the item that corresponds to an index carried by a
    /// QAbstractItemView signal, such as QAbstractItemView::clicked(). First you
    /// connect the view's signal to a slot in your class:</para>
    /// <para>QTreeView *treeView = new QTreeView(this);</para>
    /// <para>treeView-&gt;setModel(myStandardItemModel);</para>
    /// <para>connect(treeView, SIGNAL(clicked(QModelIndex)),</para>
    /// <para>        this, SLOT(clicked(QModelIndex)));</para>
    /// <para>When you receive the signal, you call itemFromIndex() on the
    /// given model index to get a pointer to the item:</para>
    /// <para>void MyWidget::clicked(const QModelIndex &amp;index)</para>
    /// <para>{</para>
    /// <para>    QStandardItem *item =
    /// myStandardItemModel-&gt;itemFromIndex(index);</para>
    /// <para>    // Do stuff with the item ...</para>
    /// <para>}</para>
    /// <para>Conversely, you must obtain the QModelIndex of an item when you
    /// want to invoke a model/view function that takes an index as argument. You
    /// can obtain the index either by using the model's indexFromItem() function,
    /// or, equivalently, by calling QStandardItem::index():</para>
    /// <para>treeView-&gt;scrollTo(item-&gt;index());</para>
    /// <para>You are, of course, not required to use the item-based approach;
    /// you could instead rely entirely on the QAbstractItemModel interface when
    /// working with the model, or use a combination of the two as
    /// appropriate.</para>
    /// <para></para>
    /// <para>See also QStandardItem, Model/View Programming,
    /// QAbstractItemModel, Simple Tree Model example, and Item View Convenience
    /// Classes.</para>
    /// </remarks>
    public unsafe partial class QStandardItemModel : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModelC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModelD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel5clearEv")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QStandardItemModel4itemEii")]
            internal static extern global::System.IntPtr Item_0(global::System.IntPtr instance, int row, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel7setItemEiiP13QStandardItem")]
            internal static extern void SetItem_0(global::System.IntPtr instance, int row, int column, global::System.IntPtr item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QStandardItemModel20horizontalHeaderItemEi")]
            internal static extern global::System.IntPtr HorizontalHeaderItem_0(global::System.IntPtr instance, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel23setHorizontalHeaderItemEiP13QStandardItem")]
            internal static extern void SetHorizontalHeaderItem_0(global::System.IntPtr instance, int column, global::System.IntPtr item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QStandardItemModel18verticalHeaderItemEi")]
            internal static extern global::System.IntPtr VerticalHeaderItem_0(global::System.IntPtr instance, int row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel21setVerticalHeaderItemEiP13QStandardItem")]
            internal static extern void SetVerticalHeaderItem_0(global::System.IntPtr instance, int row, global::System.IntPtr item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel11setRowCountEi")]
            internal static extern void SetRowCount_0(global::System.IntPtr instance, int rows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel14setColumnCountEi")]
            internal static extern void SetColumnCount_0(global::System.IntPtr instance, int columns);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel9appendRowERK5QListIP13QStandardItemE")]
            internal static extern void AppendRow_0(global::System.IntPtr instance, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel12appendColumnERK5QListIP13QStandardItemE")]
            internal static extern void AppendColumn_0(global::System.IntPtr instance, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel9insertRowEiRK5QListIP13QStandardItemE")]
            internal static extern void InsertRow_0(global::System.IntPtr instance, int row, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel12insertColumnEiRK5QListIP13QStandardItemE")]
            internal static extern void InsertColumn_0(global::System.IntPtr instance, int column, global::System.IntPtr items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel8takeItemEii")]
            internal static extern global::System.IntPtr TakeItem_0(global::System.IntPtr instance, int row, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel7takeRowEi")]
            internal static extern QList.Internal TakeRow_0(global::System.IntPtr instance, int row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel10takeColumnEi")]
            internal static extern QList.Internal TakeColumn_0(global::System.IntPtr instance, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel24takeHorizontalHeaderItemEi")]
            internal static extern global::System.IntPtr TakeHorizontalHeaderItem_0(global::System.IntPtr instance, int column);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel22takeVerticalHeaderItemEi")]
            internal static extern global::System.IntPtr TakeVerticalHeaderItem_0(global::System.IntPtr instance, int row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QStandardItemModel13itemPrototypeEv")]
            internal static extern global::System.IntPtr ItemPrototype_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel16setItemPrototypeEPK13QStandardItem")]
            internal static extern void SetItemPrototype_0(global::System.IntPtr instance, global::System.IntPtr item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QStandardItemModel8sortRoleEv")]
            internal static extern int SortRole_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QStandardItemModel11setSortRoleEi")]
            internal static extern void SetSortRole_0(global::System.IntPtr instance, int role);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QStandardItemModel17invisibleRootItemEv")]
            internal static extern global::System.IntPtr InvisibleRootItem_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted whenever the data of item has changed.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public event Action<QStandardItem> ItemChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "itemChanged(QStandardItem)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "itemChanged(QStandardItem)", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QStandardItemModel __CreateInstance(global::System.IntPtr native)
        {
            return new QStandardItemModel((QStandardItemModel.Internal*) native);
        }

        public static QStandardItemModel __CreateInstance(QStandardItemModel.Internal native)
        {
            return new QStandardItemModel(native);
        }

        private static QStandardItemModel.Internal* __CopyValue(QStandardItemModel.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QStandardItemModel.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QStandardItemModel.Internal*) ret;
        }

        private QStandardItemModel(QStandardItemModel.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QStandardItemModel(QStandardItemModel.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Removes all items (including header items) from the model and
        /// sets the number of rows and columns to zero.</para>
        /// <para>See also removeColumns() and removeRows().</para>
        /// </summary>
        public void Clear()
        {
            Internal.Clear_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the item for the given row and column if one has been
        /// set; otherwise returns 0.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setItem(), takeItem(), and itemFromIndex().</para>
        /// </summary>
        public QStandardItem Item(int row, int column = 0)
        {
            var __ret = Internal.Item_0(__Instance, row, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Sets the item for the given row and column to item. The model
        /// takes ownership of the item. If necessary, the row count and column count
        /// are increased to fit the item. The previous item at the given location (if
        /// there was one) is deleted.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also item().</para>
        /// </summary>
        public void SetItem(int row, int column, QStandardItem item)
        {
            var arg2 = ReferenceEquals(item, null) ? global::System.IntPtr.Zero : item.__Instance;
            Internal.SetItem_0(__Instance, row, column, arg2);
        }

        /// <summary>
        /// <para>Returns the horizontal header item for column if one has been
        /// set; otherwise returns 0.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setHorizontalHeaderItem() and
        /// verticalHeaderItem().</para>
        /// </summary>
        public QStandardItem HorizontalHeaderItem(int column)
        {
            var __ret = Internal.HorizontalHeaderItem_0(__Instance, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Sets the horizontal header item for column to item. The model
        /// takes ownership of the item. If necessary, the column count is increased to
        /// fit the item. The previous header item (if there was one) is
        /// deleted.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also horizontalHeaderItem(), setHorizontalHeaderLabels(), and
        /// setVerticalHeaderItem().</para>
        /// </summary>
        public void SetHorizontalHeaderItem(int column, QStandardItem item)
        {
            var arg1 = ReferenceEquals(item, null) ? global::System.IntPtr.Zero : item.__Instance;
            Internal.SetHorizontalHeaderItem_0(__Instance, column, arg1);
        }

        /// <summary>
        /// <para>Returns the vertical header item for row row if one has been set;
        /// otherwise returns 0.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setVerticalHeaderItem() and
        /// horizontalHeaderItem().</para>
        /// </summary>
        public QStandardItem VerticalHeaderItem(int row)
        {
            var __ret = Internal.VerticalHeaderItem_0(__Instance, row);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Sets the vertical header item for row to item. The model takes
        /// ownership of the item. If necessary, the row count is increased to fit the
        /// item. The previous header item (if there was one) is deleted.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also verticalHeaderItem(), setVerticalHeaderLabels(), and
        /// setHorizontalHeaderItem().</para>
        /// </summary>
        public void SetVerticalHeaderItem(int row, QStandardItem item)
        {
            var arg1 = ReferenceEquals(item, null) ? global::System.IntPtr.Zero : item.__Instance;
            Internal.SetVerticalHeaderItem_0(__Instance, row, arg1);
        }

        /// <summary>
        /// <para>Sets the number of rows in this model to rows. If this is less
        /// than rowCount(), the data in the unwanted rows is discarded.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also rowCount() and setColumnCount().</para>
        /// </summary>
        public void SetRowCount(int rows)
        {
            Internal.SetRowCount_0(__Instance, rows);
        }

        /// <summary>
        /// <para>Sets the number of columns in this model to columns. If this is
        /// less than columnCount(), the data in the unwanted columns is
        /// discarded.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also columnCount() and setRowCount().</para>
        /// </summary>
        public void SetColumnCount(int columns)
        {
            Internal.SetColumnCount_0(__Instance, columns);
        }

        /// <summary>
        /// <para>Appends a row containing items. If necessary, the column count is
        /// increased to the size of items.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also insertRow() and appendColumn().</para>
        /// </summary>
        public void AppendRow(System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = items.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData->array[i] = (void*) items[i].__Instance;
            }
            var arg0 = new global::System.IntPtr(&__qList);
            Internal.AppendRow_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Appends a column containing items. If necessary, the row count is
        /// increased to the size of items.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also insertColumn() and appendRow().</para>
        /// </summary>
        public void AppendColumn(System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList = new QtCore.QList.Internal();
            var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
            __qlistDataData->alloc = items.Count;
            __qlistDataData->begin = 0;
            __qlistDataData->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData->array[i] = (void*) items[i].__Instance;
            }
            var arg0 = new global::System.IntPtr(&__qList);
            Internal.AppendColumn_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Inserts a row at row containing items. If necessary, the column
        /// count is increased to the size of items.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also takeRow(), appendRow(), and insertColumn().</para>
        /// </summary>
        public void InsertRow(int row, System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList1 = new QtCore.QList.Internal();
            var __qlistDataData1 = (QListData.Data.Internal*) __qList1._0.d;
            __qlistDataData1->alloc = items.Count;
            __qlistDataData1->begin = 0;
            __qlistDataData1->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData1->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData1->array[i] = (void*) items[i].__Instance;
            }
            var arg1 = new global::System.IntPtr(&__qList1);
            Internal.InsertRow_0(__Instance, row, arg1);
        }

        /// <summary>
        /// <para>Inserts a column at column containing items. If necessary, the
        /// row count is increased to the size of items.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also takeColumn(), appendColumn(), and insertRow().</para>
        /// </summary>
        public void InsertColumn(int column, System.Collections.Generic.IList<QStandardItem> items)
        {
            var __qList1 = new QtCore.QList.Internal();
            var __qlistDataData1 = (QListData.Data.Internal*) __qList1._0.d;
            __qlistDataData1->alloc = items.Count;
            __qlistDataData1->begin = 0;
            __qlistDataData1->end = items.Count;
            fixed (void** __v = new void*[items.Count])
            {
                __qlistDataData1->array = __v;
            }

            for (int i = 0; i < items.Count; i++)
            {
                __qlistDataData1->array[i] = (void*) items[i].__Instance;
            }
            var arg1 = new global::System.IntPtr(&__qList1);
            Internal.InsertColumn_0(__Instance, column, arg1);
        }

        /// <summary>
        /// <para>Removes the item at (row, column) without deleting it. The model
        /// releases ownership of the item.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also item(), takeRow(), and takeColumn().</para>
        /// </summary>
        public QStandardItem TakeItem(int row, int column = 0)
        {
            var __ret = Internal.TakeItem_0(__Instance, row, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Removes the given row without deleting the row items, and returns
        /// a list of pointers to the removed items. The model releases ownership of
        /// the items. For items in the row that have not been set, the corresponding
        /// pointers in the list will be 0.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also takeColumn().</para>
        /// </summary>
        public System.Collections.Generic.IList<QStandardItem> TakeRow(int row)
        {
            var __ret = Internal.TakeRow_0(__Instance, row);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QStandardItem>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QStandardItem.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Removes the given column without deleting the column items, and
        /// returns a list of pointers to the removed items. The model releases
        /// ownership of the items. For items in the column that have not been set, the
        /// corresponding pointers in the list will be 0.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also takeRow().</para>
        /// </summary>
        public System.Collections.Generic.IList<QStandardItem> TakeColumn(int column)
        {
            var __ret = Internal.TakeColumn_0(__Instance, column);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QStandardItem>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QStandardItem.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Removes the horizontal header item at column from the header
        /// without deleting it, and returns a pointer to the item. The model releases
        /// ownership of the item.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also horizontalHeaderItem() and
        /// takeVerticalHeaderItem().</para>
        /// </summary>
        public QStandardItem TakeHorizontalHeaderItem(int column)
        {
            var __ret = Internal.TakeHorizontalHeaderItem_0(__Instance, column);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Removes the vertical header item at row from the header without
        /// deleting it, and returns a pointer to the item. The model releases
        /// ownership of the item.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also verticalHeaderItem() and
        /// takeHorizontalHeaderItem().</para>
        /// </summary>
        public QStandardItem TakeVerticalHeaderItem(int row)
        {
            var __ret = Internal.TakeVerticalHeaderItem_0(__Instance, row);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the item prototype used by the model. The model uses the
        /// item prototype as an item factory when it needs to construct new items on
        /// demand (for instance, when a view or item delegate calls setData()).</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setItemPrototype().</para>
        /// <para></para>
        /// <para>Sets the item prototype for the model to the specified item. The
        /// model takes ownership of the prototype.</para>
        /// <para>The item prototype acts as a QStandardItem factory, by relying on
        /// the QStandardItem::clone() function. To provide your own prototype,
        /// subclass QStandardItem, reimplement QStandardItem::clone() and set the
        /// prototype to be an instance of your custom class. Whenever
        /// QStandardItemModel needs to create an item on demand (for instance, when a
        /// view or item delegate calls setData())), the new items will be instances of
        /// your custom class.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also itemPrototype() and QStandardItem::clone().</para>
        /// </summary>
        public QStandardItem ItemPrototype
        {
            get
            {
                var __ret = Internal.ItemPrototype_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetItemPrototype_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds the item role that is used to query the
        /// model's data when sorting items.</para>
        /// <para>The default value is Qt::DisplayRole.</para>
        /// <para>This property was introduced in  Qt 4.2.</para>
        /// </summary>
        public int SortRole
        {
            get
            {
                var __ret = Internal.SortRole_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSortRole_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the model's invisible root item.</para>
        /// <para>The invisible root item provides access to the model's top-level
        /// items through the QStandardItem API, making it possible to write functions
        /// that can treat top-level items and their children in a uniform way; for
        /// example, recursive functions involving a tree model.</para>
        /// <para>Note: Calling index() on the QStandardItem object retrieved from
        /// this function is not valid.This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public QStandardItem InvisibleRootItem
        {
            get
            {
                var __ret = Internal.InvisibleRootItem_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QStandardItem.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QStandardItemModel()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QStandardItemModel) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(45 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
                *(void**)(vfptr0 + 52) = *(void**)(native->vfptr0 + 52);
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = *(void**)(native->vfptr0 + 68);
                *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                *(void**)(vfptr0 + 76) = *(void**)(native->vfptr0 + 76);
                *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                *(void**)(vfptr0 + 84) = *(void**)(native->vfptr0 + 84);
                *(void**)(vfptr0 + 88) = *(void**)(native->vfptr0 + 88);
                *(void**)(vfptr0 + 92) = *(void**)(native->vfptr0 + 92);
                *(void**)(vfptr0 + 96) = *(void**)(native->vfptr0 + 96);
                *(void**)(vfptr0 + 100) = *(void**)(native->vfptr0 + 100);
                *(void**)(vfptr0 + 104) = *(void**)(native->vfptr0 + 104);
                *(void**)(vfptr0 + 108) = *(void**)(native->vfptr0 + 108);
                *(void**)(vfptr0 + 112) = *(void**)(native->vfptr0 + 112);
                *(void**)(vfptr0 + 116) = *(void**)(native->vfptr0 + 116);
                *(void**)(vfptr0 + 120) = *(void**)(native->vfptr0 + 120);
                *(void**)(vfptr0 + 124) = *(void**)(native->vfptr0 + 124);
                *(void**)(vfptr0 + 128) = *(void**)(native->vfptr0 + 128);
                *(void**)(vfptr0 + 132) = *(void**)(native->vfptr0 + 132);
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 140) = *(void**)(native->vfptr0 + 140);
                *(void**)(vfptr0 + 144) = *(void**)(native->vfptr0 + 144);
                *(void**)(vfptr0 + 148) = *(void**)(native->vfptr0 + 148);
                *(void**)(vfptr0 + 152) = *(void**)(native->vfptr0 + 152);
                *(void**)(vfptr0 + 156) = *(void**)(native->vfptr0 + 156);
                *(void**)(vfptr0 + 160) = *(void**)(native->vfptr0 + 160);
                *(void**)(vfptr0 + 164) = *(void**)(native->vfptr0 + 164);
                *(void**)(vfptr0 + 168) = *(void**)(native->vfptr0 + 168);
                *(void**)(vfptr0 + 172) = *(void**)(native->vfptr0 + 172);
                *(void**)(vfptr0 + 176) = *(void**)(native->vfptr0 + 176);
                *(void**)(vfptr0 + 180) = *(void**)(native->vfptr0 + 180);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QClipboard class provides access to the window system
    /// clipboard.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The clipboard offers a simple mechanism to copy and paste data
    /// between applications.</para>
    /// <para>QClipboard supports the same data types that QDrag does, and uses
    /// similar mechanisms. For advanced clipboard usage read Drag and Drop.</para>
    /// <para>There is a single QClipboard object in an application, accessible
    /// as QApplication::clipboard().</para>
    /// <para>Example:</para>
    /// <para>QClipboard *clipboard = QApplication::clipboard();</para>
    /// <para>QString originalText = clipboard-&gt;text();</para>
    /// <para>...</para>
    /// <para>clipboard-&gt;setText(newText);</para>
    /// <para>QClipboard features some convenience functions to access common
    /// data types: setText() allows the exchange of Unicode text and setPixmap()
    /// and setImage() allows the exchange of QPixmaps and QImages between
    /// applications. The setMimeData() function is the ultimate in flexibility: it
    /// allows you to add any QMimeData into the clipboard. There are corresponding
    /// getters for each of these, e.g. text(), image() and pixmap(). You can clear
    /// the clipboard by calling clear().</para>
    /// <para>A typical example of the use of these functions follows:</para>
    /// <para>void DropArea::paste()</para>
    /// <para>{</para>
    /// <para>    const QClipboard *clipboard =
    /// QApplication::clipboard();</para>
    /// <para>    const QMimeData *mimeData = clipboard-&gt;mimeData();</para>
    /// <para></para>
    /// <para>    if (mimeData-&gt;hasImage()) {</para>
    /// <para>
    /// setPixmap(qvariant_cast&lt;QPixmap&gt;(mimeData-&gt;imageData()));</para>
    /// <para>    } else if (mimeData-&gt;hasHtml()) {</para>
    /// <para>        setText(mimeData-&gt;html());</para>
    /// <para>        setTextFormat(Qt::RichText);</para>
    /// <para>    } else if (mimeData-&gt;hasText()) {</para>
    /// <para>        setText(mimeData-&gt;text());</para>
    /// <para>        setTextFormat(Qt::PlainText);</para>
    /// <para>    } else {</para>
    /// <para>        setText(tr(&quot;Cannot display data&quot;));</para>
    /// <para>    }</para>
    /// <para></para>
    /// <para>Notes for X11 Users</para>
    /// <para></para>
    /// <para>The X11 Window System has the concept of a separate selection and
    /// clipboard. When text is selected, it is immediately available as the global
    /// mouse selection. The global mouse selection may later be copied to the
    /// clipboard. By convention, the middle mouse button is used to paste the
    /// global mouse selection.</para>
    /// <para>X11 also has the concept of ownership; if you change the
    /// selection within a window, X11 will only notify the owner and the previous
    /// owner of the change, i.e. it will not notify all applications that the
    /// selection or clipboard data changed.</para>
    /// <para>Lastly, the X11 clipboard is event driven, i.e. the clipboard
    /// will not function properly if the event loop is not running. Similarly, it
    /// is recommended that the contents of the clipboard are stored or retrieved
    /// in direct response to user-input events, e.g. mouse button or key presses
    /// and releases. You should not store or retrieve the clipboard contents in
    /// response to timer or non-user-input events.</para>
    /// <para>Since there is no standard way to copy and paste files between
    /// applications on X11, various MIME types and conventions are currently in
    /// use. For instance, Nautilus expects files to be supplied with a
    /// x-special/gnome-copied-files MIME type with data beginning with the
    /// cut/copy action, a newline character, and the URL of the file.</para>
    /// </remarks>
    public unsafe partial class QClipboard : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QClipboardC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QClipboardD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QClipboard5clearENS_4ModeE")]
            internal static extern void Clear_0(global::System.IntPtr instance, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard4textENS_4ModeE")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard4textER7QStringNS_4ModeE")]
            internal static extern void Text_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr subtype, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QClipboard7setTextERK7QStringNS_4ModeE")]
            internal static extern void SetText_0(global::System.IntPtr instance, global::System.IntPtr text, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard5imageENS_4ModeE")]
            internal static extern void Image_0(global::System.IntPtr @return, global::System.IntPtr instance, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard6pixmapENS_4ModeE")]
            internal static extern void Pixmap_0(global::System.IntPtr @return, global::System.IntPtr instance, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QClipboard8setImageERK6QImageNS_4ModeE")]
            internal static extern void SetImage_0(global::System.IntPtr instance, global::System.IntPtr image, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QClipboard9setPixmapERK7QPixmapNS_4ModeE")]
            internal static extern void SetPixmap_0(global::System.IntPtr instance, global::System.IntPtr pixmap, QClipboard.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard17supportsSelectionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsSelection_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard18supportsFindBufferEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsFindBuffer_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard13ownsSelectionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OwnsSelection_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard13ownsClipboardEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OwnsClipboard_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QClipboard14ownsFindBufferEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OwnsFindBuffer_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type is used to control which part of the system
        /// clipboard is used by QClipboard::mimeData(), QClipboard::setMimeData() and
        /// related functions.</para>
        /// <para>See also QClipboard::supportsSelection().</para>
        /// </summary>
        public enum Mode : uint
        {
            /// <summary>indicates that data should be stored and retrieved from the global clipboard.</summary>
            Clipboard = 0,
            /// <summary>indicates that data should be stored and retrieved from the global mouse selection. Support for Selection is provided only on systems with a global mouse selection (e.g. X11).</summary>
            Selection = 1,
            /// <summary>indicates that data should be stored and retrieved from the Find buffer. This mode is used for holding search strings on Mac OS X.</summary>
            FindBuffer = 2,
            LastMode = 2
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted when the data for the given clipboard mode is changed.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also dataChanged(), selectionChanged(), and findBufferChanged().</para>
        /// </summary>
        public event Action<QClipboard.Mode> Changed
        {
        	add
        	{
                ConnectDynamicSlot(this, "changed(QClipboard.Mode)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "changed(QClipboard.Mode)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the selection is changed. This only applies to windowing systems that support selections, e.g. X11. Windows and Mac OS X don't support selections.</para>
        /// <para>See also dataChanged(), findBufferChanged(), and changed().</para>
        /// </summary>
        public event Action SelectionChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "selectionChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "selectionChanged()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the find buffer is changed. This only applies to Mac OS X.</para>
        /// <para>With Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also dataChanged(), selectionChanged(), and changed().</para>
        /// </summary>
        public event Action FindBufferChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "findBufferChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "findBufferChanged()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the clipboard data is changed.</para>
        /// <para>On Mac OS X and with Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</para>
        /// <para>See also findBufferChanged(), selectionChanged(), and changed().</para>
        /// </summary>
        public event Action DataChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "dataChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "dataChanged()", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QClipboard __CreateInstance(global::System.IntPtr native)
        {
            return new QClipboard((QClipboard.Internal*) native);
        }

        public static QClipboard __CreateInstance(QClipboard.Internal native)
        {
            return new QClipboard(native);
        }

        private static QClipboard.Internal* __CopyValue(QClipboard.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QClipboard.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QClipboard.Internal*) ret;
        }

        private QClipboard(QClipboard.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QClipboard(QClipboard.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Clear the clipboard contents.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, this function clears
        /// the global clipboard contents. If mode is QClipboard::Selection, this
        /// function clears the global mouse selection contents. If mode is
        /// QClipboard::FindBuffer, this function clears the search string
        /// buffer.</para>
        /// <para>See also QClipboard::Mode and supportsSelection().</para>
        /// </summary>
        public void Clear(QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var arg0 = mode;
            Internal.Clear_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns the clipboard text as plain text, or an empty string if
        /// the clipboard does not contain any text.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the text is retrieved
        /// from the global clipboard. If mode is QClipboard::Selection, the text is
        /// retrieved from the global mouse selection. If mode is
        /// QClipboard::FindBuffer, the text is retrieved from the search string
        /// buffer.</para>
        /// <para>See also setText() and mimeData().</para>
        /// </summary>
        public string Text(QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var arg0 = mode;
            var __ret = new QtCore.QString.Internal();
            Internal.Text_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the clipboard text in subtype subtype, or an empty string
        /// if the clipboard does not contain any text. If subtype is null, any subtype
        /// is acceptable, and subtype is set to the chosen subtype.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the text is retrieved
        /// from the global clipboard. If mode is QClipboard::Selection, the text is
        /// retrieved from the global mouse selection.</para>
        /// <para>Common values for subtype are &quot;plain&quot; and
        /// &quot;html&quot;.</para>
        /// <para>Note that calling this function repeatedly, for instance from a
        /// key event handler, may be slow. In such cases, you should use the
        /// dataChanged() signal instead.</para>
        /// <para>See also setText() and mimeData().</para>
        /// </summary>
        public string Text(string subtype, QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(subtype).ToPointer(), subtype.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = mode;
            var __ret = new QtCore.QString.Internal();
            Internal.Text_1(new IntPtr(&__ret), __Instance, arg0, arg1);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Copies text into the clipboard as plain text.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the text is stored in
        /// the global clipboard. If mode is QClipboard::Selection, the text is stored
        /// in the global mouse selection. If mode is QClipboard::FindBuffer, the text
        /// is stored in the search string buffer.</para>
        /// <para>See also text() and setMimeData().</para>
        /// </summary>
        public void SetText(string text, QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = mode;
            Internal.SetText_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Returns the clipboard image, or returns a null image if the
        /// clipboard does not contain an image or if it contains an image in an
        /// unsupported image format.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the image is retrieved
        /// from the global clipboard. If mode is QClipboard::Selection, the image is
        /// retrieved from the global mouse selection.</para>
        /// <para>See also setImage(), pixmap(), mimeData(), and
        /// QImage::isNull().</para>
        /// </summary>
        public QImage Image(QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var arg0 = mode;
            var __ret = new QtGui.QImage.Internal();
            Internal.Image_0(new IntPtr(&__ret), __Instance, arg0);
            return QImage.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the clipboard pixmap, or null if the clipboard does not
        /// contain a pixmap. Note that this can lose information. For example, if the
        /// image is 24-bit and the display is 8-bit, the result is converted to 8
        /// bits, and if the image has an alpha channel, the result just has a
        /// mask.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the pixmap is
        /// retrieved from the global clipboard. If mode is QClipboard::Selection, the
        /// pixmap is retrieved from the global mouse selection.</para>
        /// <para>See also setPixmap(), image(), mimeData(), and
        /// QPixmap::convertFromImage().</para>
        /// </summary>
        public QPixmap Pixmap(QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var arg0 = mode;
            var __ret = new QtGui.QPixmap.Internal();
            Internal.Pixmap_0(new IntPtr(&__ret), __Instance, arg0);
            return QPixmap.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Copies the image into the clipboard.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the image is stored in
        /// the global clipboard. If mode is QClipboard::Selection, the data is stored
        /// in the global mouse selection.</para>
        /// <para>This is shorthand for:</para>
        /// <para>QMimeData *data = new QMimeData;</para>
        /// <para>data-&gt;setImageData(image);</para>
        /// <para>clipboard-&gt;setMimeData(data, mode);</para>
        /// <para>See also image(), setPixmap(), and setMimeData().</para>
        /// </summary>
        public void SetImage(QImage image, QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var arg1 = mode;
            Internal.SetImage_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Copies pixmap into the clipboard. Note that this is slower than
        /// setImage() because it needs to convert the QPixmap to a QImage
        /// first.</para>
        /// <para>The mode argument is used to control which part of the system
        /// clipboard is used. If mode is QClipboard::Clipboard, the pixmap is stored
        /// in the global clipboard. If mode is QClipboard::Selection, the pixmap is
        /// stored in the global mouse selection.</para>
        /// <para>See also pixmap(), setImage(), and setMimeData().</para>
        /// </summary>
        public void SetPixmap(QPixmap pixmap, QClipboard.Mode mode = QClipboard.Mode.Clipboard)
        {
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var arg1 = mode;
            Internal.SetPixmap_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Returns true if the clipboard supports mouse selection; otherwise
        /// returns false.</para>
        /// </summary>
        public bool SupportsSelection
        {
            get
            {
                var __ret = Internal.SupportsSelection_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the clipboard supports a separate search buffer;
        /// otherwise returns false.</para>
        /// </summary>
        public bool SupportsFindBuffer
        {
            get
            {
                var __ret = Internal.SupportsFindBuffer_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this clipboard object owns the mouse selection
        /// data; otherwise returns false.</para>
        /// </summary>
        public bool OwnsSelection
        {
            get
            {
                var __ret = Internal.OwnsSelection_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this clipboard object owns the clipboard data;
        /// otherwise returns false.</para>
        /// </summary>
        public bool OwnsClipboard
        {
            get
            {
                var __ret = Internal.OwnsClipboard_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this clipboard object owns the find buffer data;
        /// otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public bool OwnsFindBuffer
        {
            get
            {
                var __ret = Internal.OwnsFindBuffer_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QClipboard()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QClipboard) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QCursor class provides a mouse cursor with an arbitrary
    /// shape.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class is mainly used to create mouse cursors that are
    /// associated with particular widgets and to get and set the position of the
    /// mouse cursor.</para>
    /// <para>Qt has a number of standard cursor shapes, but you can also make
    /// custom cursor shapes based on a QBitmap, a mask and a hotspot.</para>
    /// <para>To associate a cursor with a widget, use QWidget::setCursor(). To
    /// associate a cursor with all widgets (normally for a short period of time),
    /// use QGuiApplication::setOverrideCursor().</para>
    /// <para>To set a cursor shape use QCursor::setShape() or use the QCursor
    /// constructor which takes the shape as argument, or you can use one of the
    /// predefined cursors defined in the Qt::CursorShape enum.</para>
    /// <para>If you want to create a cursor with your own bitmap, either use
    /// the QCursor constructor which takes a bitmap and a mask or the constructor
    /// which takes a pixmap as arguments.</para>
    /// <para>To set or get the position of the mouse cursor use the static
    /// methods QCursor::pos() and QCursor::setPos().</para>
    /// <para>Note: It is possible to create a QCursor before QGuiApplication,
    /// but it is not useful except as a place-holder for a real QCursor created
    /// after QGuiApplication. Attempting to use a QCursor that was created before
    /// QGuiApplication will result in a crash.</para>
    /// <para></para>
    /// <para>A Note for X11 Users</para>
    /// <para>On X11, Qt supports the Xcursor library, which allows for full
    /// color icon themes. The table below shows the cursor name used for each
    /// Qt::CursorShape value. If a cursor cannot be found using the name shown
    /// below, a standard X11 cursor will be used instead. Note: X11 does not
    /// provide appropriate cursors for all possible Qt::CursorShape values. It is
    /// possible that some cursors will be taken from the Xcursor theme, while
    /// others will use an internal bitmap cursor.</para>
    /// <para></para>
    /// <para> ShapeQt::CursorShape ValueCursor NameShapeQt::CursorShape
    /// ValueCursor Name</para>
    /// <para>	Qt::ArrowCursor	left_ptr	Qt::SizeVerCursor	size_ver</para>
    /// <para>	Qt::UpArrowCursor	up_arrow	Qt::SizeHorCursor	size_hor</para>
    /// <para>	Qt::CrossCursor	cross	Qt::SizeBDiagCursor	size_bdiag</para>
    /// <para>	Qt::IBeamCursor	ibeam	Qt::SizeFDiagCursor	size_fdiag</para>
    /// <para>	Qt::WaitCursor	wait	Qt::SizeAllCursor	size_all</para>
    /// <para>	Qt::BusyCursor	left_ptr_watch	Qt::SplitVCursor	split_v</para>
    /// <para>	Qt::ForbiddenCursor	forbidden	Qt::SplitHCursor	split_h</para>
    /// <para>	Qt::PointingHandCursor	pointing_hand	Qt::OpenHandCursor
    /// openhand</para>
    /// <para>	Qt::WhatsThisCursor	whats_this	Qt::ClosedHandCursor
    /// closedhand</para>
    /// <para>	Qt::DragMoveCursor	dnd-move or move	Qt::DragCopyCursor	dnd-copy
    /// or copy</para>
    /// <para>	Qt::DragLinkCursor	dnd-link or link</para>
    /// </remarks>
    public unsafe partial class QCursor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QCursorC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QCursorC2ERK7QBitmapS2_ii")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr bitmap, global::System.IntPtr mask, int hotX, int hotY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QCursorC2ERK7QPixmapii")]
            internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr pixmap, int hotX, int hotY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QCursorC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QCursorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7QCursor6setPosEii")]
            internal static extern void SetPos_0(int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7QCursor6setPosEP7QScreenii")]
            internal static extern void SetPos_1(global::System.IntPtr screen, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QCursor6bitmapEv")]
            internal static extern global::System.IntPtr Bitmap_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QCursor4maskEv")]
            internal static extern global::System.IntPtr Mask_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QCursor6pixmapEv")]
            internal static extern void Pixmap_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QCursor __CreateInstance(global::System.IntPtr native)
        {
            return new QCursor((QCursor.Internal*) native);
        }

        public static QCursor __CreateInstance(QCursor.Internal native)
        {
            return new QCursor(native);
        }

        private static QCursor.Internal* __CopyValue(QCursor.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QCursor.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QCursor.Internal*) ret;
        }

        private QCursor(QCursor.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QCursor(QCursor.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a cursor with the default arrow shape.</para>
        /// </summary>
        public QCursor()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a custom bitmap cursor.</para>
        /// <para>bitmap and mask make up the bitmap. hotX and hotY define the
        /// cursor's hot spot.</para>
        /// <para>If hotX is negative, it is set to the bitmap().width()/2. If hotY
        /// is negative, it is set to the bitmap().height()/2.</para>
        /// <para>The cursor bitmap (B) and mask (M) bits are combined like
        /// this:</para>
        /// <para></para>
        /// <para>B=1 and M=1 gives black.</para>
        /// <para>B=0 and M=1 gives white.</para>
        /// <para>B=0 and M=0 gives transparent.</para>
        /// <para>B=1 and M=0 gives an XOR'd result under Windows, undefined
        /// results on all other platforms.</para>
        /// <para></para>
        /// <para>Use the global Qt color Qt::color0 to draw 0-pixels and
        /// Qt::color1 to draw 1-pixels in the bitmaps.</para>
        /// <para>Valid cursor sizes depend on the display hardware (or the
        /// underlying window system). We recommend using 32 x 32 cursors, because this
        /// size is supported on all platforms. Some platforms also support 16 x 16, 48
        /// x 48, and 64 x 64 cursors.</para>
        /// <para>Note: On Windows CE, the cursor size is fixed. If the pixmap is
        /// bigger than the system size, it will be scaled.See also QBitmap::QBitmap()
        /// and QBitmap::setMask().</para>
        /// </summary>
        public QCursor(QBitmap bitmap, QBitmap mask, int hotX = -1, int hotY = -1)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var arg1 = ReferenceEquals(mask, null) ? global::System.IntPtr.Zero : mask.__Instance;
            Internal.ctor_2(__Instance, arg0, arg1, hotX, hotY);
        }

        /// <summary>
        /// <para>Constructs a custom pixmap cursor.</para>
        /// <para>pixmap is the image. It is usual to give it a mask (set using
        /// QPixmap::setMask()). hotX and hotY define the cursor's hot spot.</para>
        /// <para>If hotX is negative, it is set to the pixmap().width()/2. If hotY
        /// is negative, it is set to the pixmap().height()/2.</para>
        /// <para>Valid cursor sizes depend on the display hardware (or the
        /// underlying window system). We recommend using 32 x 32 cursors, because this
        /// size is supported on all platforms. Some platforms also support 16 x 16, 48
        /// x 48, and 64 x 64 cursors.</para>
        /// <para>Note: On Windows CE, the cursor size is fixed. If the pixmap is
        /// bigger than the system size, it will be scaled.See also QPixmap::QPixmap()
        /// and QPixmap::setMask().</para>
        /// </summary>
        public QCursor(QPixmap pixmap, int hotX = -1, int hotY = -1)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            Internal.ctor_3(__Instance, arg0, hotX, hotY);
        }

        /// <summary>
        /// <para>Constructs a copy of the cursor c.</para>
        /// </summary>
        public QCursor(QCursor cursor)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            Internal.cctor_4(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Moves the cursor (hot spot) of the primary screen to the global
        /// screen position (x, y).</para>
        /// <para>You can call QWidget::mapToGlobal() to translate widget
        /// coordinates to global screen coordinates.</para>
        /// <para>See also pos(), QWidget::mapFromGlobal(), QWidget::mapToGlobal(),
        /// and QGuiApplication::primaryScreen().</para>
        /// </summary>
        public static void SetPos(int x, int y)
        {
            Internal.SetPos_0(x, y);
        }

        /// <summary>
        /// <para>Moves the cursor (hot spot) of the screen to the global screen
        /// position (x, y).</para>
        /// <para>You can call QWidget::mapToGlobal() to translate widget
        /// coordinates to global screen coordinates.</para>
        /// <para>Note: Calling this function results in changing the cursor
        /// position through the windowing system. The windowing system will typically
        /// respond by sending mouse events to the application's window. This means
        /// that the usage of this function should be avoided in unit tests and
        /// everywhere where fake mouse events are being injected via
        /// QWindowSystemInterface because the windowing system's mouse state (with
        /// regards to buttons for example) may not match the state in the
        /// application-generated events.Note: On platforms where there is no windowing
        /// system or cursors are not available, this function may do nothing.See also
        /// pos(), QWidget::mapFromGlobal(), and QWidget::mapToGlobal().</para>
        /// </summary>
        public static void SetPos(QScreen screen, int x, int y)
        {
            var arg0 = ReferenceEquals(screen, null) ? global::System.IntPtr.Zero : screen.__Instance;
            Internal.SetPos_1(arg0, x, y);
        }

        /// <summary>
        /// <para>Returns the cursor bitmap, or 0 if it is one of the standard
        /// cursors.</para>
        /// </summary>
        public QBitmap Bitmap
        {
            get
            {
                var __ret = Internal.Bitmap_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QBitmap.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the cursor bitmap mask, or 0 if it is one of the standard
        /// cursors.</para>
        /// </summary>
        public QBitmap Mask
        {
            get
            {
                var __ret = Internal.Mask_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QBitmap.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the cursor pixmap. This is only valid if the cursor is a
        /// pixmap cursor.</para>
        /// </summary>
        public QPixmap Pixmap
        {
            get
            {
                var __ret = new QtGui.QPixmap.Internal();
                Internal.Pixmap_0(new IntPtr(&__ret), __Instance);
                return QPixmap.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QDrag class provides support for MIME-based drag and drop
    /// data transfer.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Drag and drop is an intuitive way for users to copy or move data
    /// around in an application, and is used in many desktop environments as a
    /// mechanism for copying data between applications. Drag and drop support in
    /// Qt is centered around the QDrag class that handles most of the details of a
    /// drag and drop operation.</para>
    /// <para>The data to be transferred by the drag and drop operation is
    /// contained in a QMimeData object. This is specified with the setMimeData()
    /// function in the following way:</para>
    /// <para>        QDrag *drag = new QDrag(this);</para>
    /// <para>        QMimeData *mimeData = new QMimeData;</para>
    /// <para></para>
    /// <para>
    /// mimeData-&gt;setText(commentEdit-&gt;toPlainText());</para>
    /// <para>        drag-&gt;setMimeData(mimeData);</para>
    /// <para>Note that setMimeData() assigns ownership of the QMimeData object
    /// to the QDrag object. The QDrag must be constructed on the heap with a
    /// parent QObject to ensure that Qt can clean up after the drag and drop
    /// operation has been completed.</para>
    /// <para>A pixmap can be used to represent the data while the drag is in
    /// progress, and will move with the cursor to the drop target. This pixmap
    /// typically shows an icon that represents the MIME type of the data being
    /// transferred, but any pixmap can be set with setPixmap(). The cursor's hot
    /// spot can be given a position relative to the top-left corner of the pixmap
    /// with the setHotSpot() function. The following code positions the pixmap so
    /// that the cursor's hot spot points to the center of its bottom edge:</para>
    /// <para>
    /// drag-&gt;setHotSpot(QPoint(drag-&gt;pixmap().width()/2,</para>
    /// <para>                            drag-&gt;pixmap().height()));</para>
    /// <para>Note: On X11, the pixmap may not be able to keep up with the
    /// mouse movements if the hot spot causes the pixmap to be displayed directly
    /// under the cursor.The source and target widgets can be found with source()
    /// and target(). These functions are often used to determine whether drag and
    /// drop operations started and finished at the same widget, so that special
    /// behavior can be implemented.</para>
    /// <para>QDrag only deals with the drag and drop operation itself. It is
    /// up to the developer to decide when a drag operation begins, and how a QDrag
    /// object should be constructed and used. For a given widget, it is often
    /// necessary to reimplement mousePressEvent() to determine whether the user
    /// has pressed a mouse button, and reimplement mouseMoveEvent() to check
    /// whether a QDrag is required.</para>
    /// <para></para>
    /// <para>See also Drag and Drop, QClipboard, QMimeData,
    /// QMacPasteboardMime, Draggable Icons Example, Draggable Text Example, Drop
    /// Site Example, and Fridge Magnets Example.</para>
    /// </remarks>
    public unsafe partial class QDrag : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QDragC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QDragD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK5QDrag6pixmapEv")]
            internal static extern void Pixmap_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN5QDrag9setPixmapERK7QPixmap")]
            internal static extern void SetPixmap_0(global::System.IntPtr instance, global::System.IntPtr pixmap);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QDrag __CreateInstance(global::System.IntPtr native)
        {
            return new QDrag((QDrag.Internal*) native);
        }

        public static QDrag __CreateInstance(QDrag.Internal native)
        {
            return new QDrag(native);
        }

        private static QDrag.Internal* __CopyValue(QDrag.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QDrag.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QDrag.Internal*) ret;
        }

        private QDrag(QDrag.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDrag(QDrag.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the pixmap used to represent the data in a drag and drop
        /// operation.</para>
        /// <para>See also setPixmap().</para>
        /// <para></para>
        /// <para>Sets pixmap as the pixmap used to represent the data in a drag
        /// and drop operation. You can only set a pixmap before the drag is
        /// started.</para>
        /// <para>See also pixmap().</para>
        /// </summary>
        public QPixmap Pixmap
        {
            get
            {
                var __ret = new QtGui.QPixmap.Internal();
                Internal.Pixmap_0(new IntPtr(&__ret), __Instance);
                return QPixmap.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetPixmap_0(__Instance, arg0);
            }
        }

        #region Virtual table interop

        // ~QDrag()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDrag) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QGenericPlugin class is an abstract base class for
    /// plugins.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A mouse plugin can be created by subclassing QGenericPlugin and
    /// reimplementing the pure virtual create() function. By exporting the derived
    /// class using the Q_PLUGIN_METADATA() macro, The default implementation of
    /// the QGenericPluginFactory class will automatically detect the plugin and
    /// load the driver into the server application at run-time. See How to Create
    /// Qt Plugins for details.</para>
    /// <para>The json metadata file should contain a list of keys supported by
    /// this plugin.</para>
    /// <para></para>
    /// <para>See also QGenericPluginFactory.</para>
    /// </remarks>
    public unsafe abstract partial class QGenericPlugin : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QGenericPluginC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QGenericPluginD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QGenericPlugin(QGenericPlugin.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // ~QGenericPlugin()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QGenericPlugin) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(12 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QGenericPluginInternal : QtGui.QGenericPlugin, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QGenericPluginInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QGenericPluginInternal((QGenericPlugin.Internal*) native);
        }

        public static QGenericPlugin __CreateInstance(QGenericPlugin.Internal native)
        {
            return new QGenericPluginInternal(native);
        }

        private static QGenericPlugin.Internal* __CopyValue(QGenericPlugin.Internal native)
        {
            var ret = (QGenericPlugin.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QGenericPluginInternal(QGenericPlugin.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QGenericPluginInternal(QGenericPlugin.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QGenericPlugin.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QGenericPluginFactory class creates plugin drivers.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para></para>
    /// <para>See also QGenericPlugin.</para>
    /// </remarks>
    public unsafe partial class QGenericPluginFactory : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QGenericPluginFactoryC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QGenericPluginFactory __CreateInstance(global::System.IntPtr native)
        {
            return new QGenericPluginFactory((QGenericPluginFactory.Internal*) native);
        }

        public static QGenericPluginFactory __CreateInstance(QGenericPluginFactory.Internal native)
        {
            return new QGenericPluginFactory(native);
        }

        private static QGenericPluginFactory.Internal* __CopyValue(QGenericPluginFactory.Internal native)
        {
            var ret = (QGenericPluginFactory.Internal*) Marshal.AllocHGlobal(1);
            *ret = native;
            return ret;
        }

        private QGenericPluginFactory(QGenericPluginFactory.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QGenericPluginFactory(QGenericPluginFactory.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    /// <summary>
    /// <para>The QInputMethod class provides access to the active text input
    /// method.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QInputMethod is used by the text editors for integrating to the
    /// platform text input methods and more commonly by application views for
    /// querying various text input method-related information like virtual
    /// keyboard visibility and keyboard dimensions.</para>
    /// <para>Qt Quick also provides access to QInputMethod in QML through Qt
    /// global object as Qt.inputMethod property.</para>
    /// </remarks>
    public unsafe partial class QInputMethod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethodC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethodD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod4showEv")]
            internal static extern void Show_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod4hideEv")]
            internal static extern void Hide_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod5resetEv")]
            internal static extern void Reset_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod6commitEv")]
            internal static extern void Commit_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod12invokeActionENS_6ActionEi")]
            internal static extern void InvokeAction_0(global::System.IntPtr instance, QInputMethod.Action a, int cursorPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QInputMethod18inputItemTransformEv")]
            internal static extern void InputItemTransform_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod21setInputItemTransformERK10QTransform")]
            internal static extern void SetInputItemTransform_0(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QInputMethod9isVisibleEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Visible_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QInputMethod10setVisibleEb")]
            internal static extern void SetVisible_0(global::System.IntPtr instance, bool visible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QInputMethod11isAnimatingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsAnimating_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Indicates the kind of action performed by the user.</para>
        /// <para>See also invokeAction().</para>
        /// </summary>
        public enum Action : uint
        {
            /// <summary>A normal click/tap</summary>
            Click = 0,
            /// <summary>A context menu click/tap (e.g. right-button or tap-and-hold)</summary>
            ContextMenu = 1
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public event Action CursorRectangleChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "cursorRectangleChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "cursorRectangleChanged()", value);
        	}
        }

        public event Action KeyboardRectangleChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "keyboardRectangleChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "keyboardRectangleChanged()", value);
        	}
        }

        public event Action VisibleChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "visibleChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "visibleChanged()", value);
        	}
        }

        public event Action AnimatingChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "animatingChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "animatingChanged()", value);
        	}
        }

        public event Action LocaleChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "localeChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "localeChanged()", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QInputMethod __CreateInstance(global::System.IntPtr native)
        {
            return new QInputMethod((QInputMethod.Internal*) native);
        }

        public static QInputMethod __CreateInstance(QInputMethod.Internal native)
        {
            return new QInputMethod(native);
        }

        private static QInputMethod.Internal* __CopyValue(QInputMethod.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QInputMethod.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QInputMethod.Internal*) ret;
        }

        private QInputMethod(QInputMethod.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QInputMethod(QInputMethod.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Requests virtual keyboard to open. If the platform doesn't
        /// provide virtual keyboard the visibility remains false.</para>
        /// <para>Normally applications should not need to call this function,
        /// keyboard should automatically open when the text editor gains focus.</para>
        /// </summary>
        public void Show()
        {
            Internal.Show_0(__Instance);
        }

        /// <summary>
        /// <para>Requests virtual keyboard to close.</para>
        /// <para>Normally applications should not need to call this function,
        /// keyboard should automatically close when the text editor loses focus, for
        /// example when the parent view is closed.</para>
        /// </summary>
        public void Hide()
        {
            Internal.Hide_0(__Instance);
        }

        /// <summary>
        /// <para>Resets the input method state. For example, a text editor
        /// normally calls this method before inserting a text to make widget ready to
        /// accept a text.</para>
        /// <para>Input method resets automatically when the focused editor
        /// changes.</para>
        /// </summary>
        public void Reset()
        {
            Internal.Reset_0(__Instance);
        }

        /// <summary>
        /// <para>Commits the word user is currently composing to the editor. The
        /// function is mostly needed by the input methods with text prediction
        /// features and by the methods where the script used for typing characters is
        /// different from the script that actually gets appended to the editor. Any
        /// kind of action that interrupts the text composing needs to flush the
        /// composing state by calling the commit() function, for example when the
        /// cursor is moved elsewhere.</para>
        /// </summary>
        public void Commit()
        {
            Internal.Commit_0(__Instance);
        }

        /// <summary>
        /// <para>Called by the input item when the word currently being composed
        /// is tapped by the user, as indicated by the action a and the given
        /// cursorPosition. Input methods often use this information to offer more word
        /// suggestions to the user.</para>
        /// </summary>
        public void InvokeAction(QInputMethod.Action a, int cursorPosition)
        {
            var arg0 = a;
            Internal.InvokeAction_0(__Instance, arg0, cursorPosition);
        }

        /// <summary>
        /// <para>Returns the transformation from input item coordinates to the
        /// window coordinates.</para>
        /// <para>See also setInputItemTransform().</para>
        /// <para></para>
        /// <para>Sets the transformation from input item coordinates to window
        /// coordinates to be transform. Item transform needs to be updated by the
        /// focused window like QQuickCanvas whenever item is moved inside the
        /// scene.</para>
        /// <para>See also inputItemTransform().</para>
        /// </summary>
        public QTransform InputItemTransform
        {
            get
            {
                var __ret = new QtGui.QTransform.Internal();
                Internal.InputItemTransform_0(new IntPtr(&__ret), __Instance);
                return QTransform.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetInputItemTransform_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds virtual keyboard's visibility on the
        /// screen.</para>
        /// <para>Input method visibility remains false for devices with no virtual
        /// keyboards.</para>
        /// </summary>
        public bool Visible
        {
            get
            {
                var __ret = Internal.Visible_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetVisible_0(__Instance, value);
            }
        }

        public bool IsAnimating
        {
            get
            {
                var __ret = Internal.IsAnimating_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QInputMethod()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QInputMethod) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QGuiApplication class manages the GUI application's control
    /// flow and main settings.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QGuiApplication contains the main event loop, where all events
    /// from the window system and other sources are processed and dispatched. It
    /// also handles the application's initialization and finalization, and
    /// provides session management. In addition, QGuiApplication handles most of
    /// the system-wide and application-wide settings.</para>
    /// <para>For any GUI application using Qt, there is precisely one
    /// QGuiApplication object no matter whether the application has 0, 1, 2 or
    /// more windows at any given time. For non-GUI Qt applications, use
    /// QCoreApplication instead, as it does not depend on the Qt GUI module. For
    /// QWidget based Qt applications, use QApplication instead, as it provides
    /// some functionality needed for creating QWidget instances.</para>
    /// <para>The QGuiApplication object is accessible through the instance()
    /// function, which returns a pointer equivalent to the global qApp
    /// pointer.</para>
    /// <para>QGuiApplication's main areas of responsibility are:</para>
    /// <para></para>
    /// <para>It initializes the application with the user's desktop settings,
    /// such as palette(), font() and styleHints(). It keeps track of these
    /// properties in case the user changes the desktop globally, for example,
    /// through some kind of control panel.</para>
    /// <para>It performs event handling, meaning that it receives events from
    /// the underlying window system and dispatches them to the relevant widgets.
    /// You can send your own events to windows by using sendEvent() and
    /// postEvent().</para>
    /// <para>It parses common command line arguments and sets its internal
    /// state accordingly. See the constructor documentation below for more
    /// details.</para>
    /// <para>It provides localization of strings that are visible to the user
    /// via translate().</para>
    /// <para>It provides some magical objects like the clipboard().</para>
    /// <para>It knows about the application's windows. You can ask which
    /// window is at a certain position using topLevelAt(), get a list of
    /// topLevelWindows(), etc.</para>
    /// <para>It manages the application's mouse cursor handling, see
    /// setOverrideCursor()</para>
    /// <para>It provides support for sophisticated session management. This
    /// makes it possible for applications to terminate gracefully when the user
    /// logs out, to cancel a shutdown process if termination isn't possible and
    /// even to preserve the entire application's state for a future session. See
    /// isSessionRestored(), sessionId() and commitDataRequest() and
    /// saveStateRequest() for details.</para>
    /// <para></para>
    /// <para>Since the QGuiApplication object does so much initialization, it
    /// must be created before any other objects related to the user interface are
    /// created. QGuiApplication also deals with common command line arguments.
    /// Hence, it is usually a good idea to create it before any interpretation or
    /// modification of argv is done in the application itself.</para>
    /// <para></para>
    /// <para> Groups of functions</para>
    /// <para>System settings	desktopSettingsAware(),
    /// setDesktopSettingsAware(), styleHints(), palette(), setPalette(), font(),
    /// setFont().</para>
    /// <para>Event handling	exec(), processEvents(), exit(), quit().
    /// sendEvent(), postEvent(), sendPostedEvents(), removePostedEvents(),
    /// hasPendingEvents(), notify().</para>
    /// <para>Windows	allWindows(), topLevelWindows(), focusWindow(),
    /// clipboard(), topLevelAt().</para>
    /// <para>Advanced cursor handling	overrideCursor(), setOverrideCursor(),
    /// restoreOverrideCursor().</para>
    /// <para>Session management	isSessionRestored(), sessionId(),
    /// commitDataRequest(), saveStateRequest().</para>
    /// <para>Miscellaneous	startingUp(), closingDown(), type().</para>
    /// </remarks>
    public unsafe partial class QGuiApplication : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QGuiApplicationC2ERiPPci")]
            internal static extern void ctor_0(global::System.IntPtr instance, int* argc, char** argv, int _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QGuiApplicationC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QGuiApplicationD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication11focusWindowEv")]
            internal static extern global::System.IntPtr FocusWindow_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication20changeOverrideCursorERK7QCursor")]
            internal static extern void ChangeOverrideCursor_0(global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication21restoreOverrideCursorEv")]
            internal static extern void RestoreOverrideCursor_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication4execEv")]
            internal static extern int Exec_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication4syncEv")]
            internal static extern void Sync_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication22applicationDisplayNameEv")]
            internal static extern void ApplicationDisplayName_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication25setApplicationDisplayNameERK7QString")]
            internal static extern void SetApplicationDisplayName_0(global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication10windowIconEv")]
            internal static extern void WindowIcon_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication13setWindowIconERK5QIcon")]
            internal static extern void SetWindowIcon_0(global::System.IntPtr icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication14overrideCursorEv")]
            internal static extern global::System.IntPtr OverrideCursor_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication17setOverrideCursorERK7QCursor")]
            internal static extern void SetOverrideCursor_0(global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication4fontEv")]
            internal static extern void Font_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication7setFontERK5QFont")]
            internal static extern void SetFont_0(global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication7paletteEv")]
            internal static extern void Palette_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication10setPaletteERK8QPalette")]
            internal static extern void SetPalette_0(global::System.IntPtr pal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication20desktopSettingsAwareEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DesktopSettingsAware_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication23setDesktopSettingsAwareEb")]
            internal static extern void SetDesktopSettingsAware_0(bool on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication22quitOnLastWindowClosedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool QuitOnLastWindowClosed_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication25setQuitOnLastWindowClosedEb")]
            internal static extern void SetQuitOnLastWindowClosed_0(bool quit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication10allWindowsEv")]
            internal static extern QList.Internal AllWindows_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication15topLevelWindowsEv")]
            internal static extern QList.Internal TopLevelWindows_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication12platformNameEv")]
            internal static extern void PlatformName_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication11modalWindowEv")]
            internal static extern global::System.IntPtr ModalWindow_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication13primaryScreenEv")]
            internal static extern global::System.IntPtr PrimaryScreen_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication7screensEv")]
            internal static extern QList.Internal Screens_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication9clipboardEv")]
            internal static extern global::System.IntPtr Clipboard_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication10styleHintsEv")]
            internal static extern global::System.IntPtr StyleHints_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15QGuiApplication11inputMethodEv")]
            internal static extern global::System.IntPtr InputMethod_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QGuiApplication17isSessionRestoredEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSessionRestored_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QGuiApplication9sessionIdEv")]
            internal static extern void SessionId_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QGuiApplication10sessionKeyEv")]
            internal static extern void SessionKey_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QGuiApplication15isSavingSessionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSavingSession_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted when application fonts are loaded or removed.</para>
        /// <para>See also QFontDatabase::addApplicationFont(), QFontDatabase::addApplicationFontFromData(), QFontDatabase::removeAllApplicationFonts(), and QFontDatabase::removeApplicationFont().</para>
        /// </summary>
        public event Action FontDatabaseChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "fontDatabaseChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "fontDatabaseChanged()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever a new screen screen has been added to the system.</para>
        /// <para>See also screens(), primaryScreen(), and screenRemoved().</para>
        /// </summary>
        public event Action<QScreen> ScreenAdded
        {
        	add
        	{
                ConnectDynamicSlot(this, "screenAdded(QScreen)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "screenAdded(QScreen)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever a screen is removed from the system. It provides an opportunity to manage the windows on the screen before Qt falls back to moving them to the primary screen.</para>
        /// <para>This function was introduced in  Qt 5.4.</para>
        /// <para>See also screens(), screenAdded(), QObject::destroyed(), and QWindow::setScreen().</para>
        /// </summary>
        public event Action<QScreen> ScreenRemoved
        {
        	add
        	{
                ConnectDynamicSlot(this, "screenRemoved(QScreen)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "screenRemoved(QScreen)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted from exec() when the last visible primary window (i.e. window with no parent) is closed.</para>
        /// <para>By default, QGuiApplication quits after this signal is emitted. This feature can be turned off by setting quitOnLastWindowClosed to false.</para>
        /// <para>See also QWindow::close() and QWindow::isTopLevel().</para>
        /// </summary>
        public event Action LastWindowClosed
        {
        	add
        	{
                ConnectDynamicSlot(this, "lastWindowClosed()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "lastWindowClosed()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the focused window changes. focusWindow is the new focused window.</para>
        /// <para>See also focusWindow().</para>
        /// </summary>
        public event Action<QWindow> FocusWindowChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "focusWindowChanged(QWindow)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "focusWindowChanged(QWindow)", value);
        	}
        }

        /// <summary>
        /// <para>This signal deals with session management. It is emitted when the QSessionManager wants the application to commit all its data.</para>
        /// <para>Usually this means saving all open files, after getting permission from the user. Furthermore you may want to provide a means by which the user can cancel the shutdown.</para>
        /// <para>You should not exit the application within this signal. Instead, the session manager may or may not do this afterwards, depending on the context.</para>
        /// <para>Warning: Within this signal, no user interaction is possible, unless you ask the manager for explicit permission. See QSessionManager::allowsInteraction() and QSessionManager::allowsErrorInteraction() for details and example usage.</para>
        /// <para>Note: You should use Qt::DirectConnection when connecting to this signal.This function was introduced in  Qt 4.2.</para>
        /// <para>See also isSessionRestored(), sessionId(), saveStateRequest(), and Session Management.</para>
        /// </summary>
        public event Action<QSessionManager> CommitDataRequest
        {
        	add
        	{
                ConnectDynamicSlot(this, "commitDataRequest(QSessionManager)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "commitDataRequest(QSessionManager)", value);
        	}
        }

        /// <summary>
        /// <para>This signal deals with session management. It is invoked when the session manager wants the application to preserve its state for a future session.</para>
        /// <para>For example, a text editor would create a temporary file that includes the current contents of its edit buffers, the location of the cursor and other aspects of the current editing session.</para>
        /// <para>You should never exit the application within this signal. Instead, the session manager may or may not do this afterwards, depending on the context. Futhermore, most session managers will very likely request a saved state immediately after the application has been started. This permits the session manager to learn about the application's restart policy.</para>
        /// <para>Warning: Within this signal, no user interaction is possible, unless you ask the manager for explicit permission. See QSessionManager::allowsInteraction() and QSessionManager::allowsErrorInteraction() for details.</para>
        /// <para>Note: You should use Qt::DirectConnection when connecting to this signal.This function was introduced in  Qt 4.2.</para>
        /// <para>See also isSessionRestored(), sessionId(), commitDataRequest(), and Session Management.</para>
        /// </summary>
        public event Action<QSessionManager> SaveStateRequest
        {
        	add
        	{
                ConnectDynamicSlot(this, "saveStateRequest(QSessionManager)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "saveStateRequest(QSessionManager)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the palette of the application changes.</para>
        /// <para>This function was introduced in  Qt 5.4.</para>
        /// <para>See also palette().</para>
        /// </summary>
        public event Action<QPalette> PaletteChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "paletteChanged(QPalette)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "paletteChanged(QPalette)", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QGuiApplication __CreateInstance(global::System.IntPtr native)
        {
            return new QGuiApplication((QGuiApplication.Internal*) native);
        }

        public static QGuiApplication __CreateInstance(QGuiApplication.Internal native)
        {
            return new QGuiApplication(native);
        }

        private static QGuiApplication.Internal* __CopyValue(QGuiApplication.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QGuiApplication.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QGuiApplication.Internal*) ret;
        }

        private QGuiApplication(QGuiApplication.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QGuiApplication(QGuiApplication.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public QGuiApplication(int* argc, char** argv, int _0 = (int) QCoreApplication.ApplicationFlags.ApplicationFlags)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = argc;
            var arg1 = argv;
            Internal.ctor_0(__Instance, arg0, arg1, _0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the QWindow that receives events tied to focus, such as
        /// key events.</para>
        /// </summary>
        public static QWindow FocusWindow()
        {
            var __ret = Internal.FocusWindow_0();
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Changes the currently active application override cursor to
        /// cursor.</para>
        /// <para>This function has no effect if setOverrideCursor() was not
        /// called.</para>
        /// <para>See also setOverrideCursor(), overrideCursor(),
        /// restoreOverrideCursor(), and QWidget::setCursor().</para>
        /// </summary>
        public static void ChangeOverrideCursor(QCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            Internal.ChangeOverrideCursor_0(arg0);
        }

        /// <summary>
        /// <para>Undoes the last setOverrideCursor().</para>
        /// <para>If setOverrideCursor() has been called twice, calling
        /// restoreOverrideCursor() will activate the first cursor set. Calling this
        /// function a second time restores the original widgets' cursors.</para>
        /// <para>See also setOverrideCursor() and overrideCursor().</para>
        /// </summary>
        public static void RestoreOverrideCursor()
        {
            Internal.RestoreOverrideCursor_0();
        }

        /// <summary>
        /// <para>Enters the main event loop and waits until exit() is called, and
        /// then returns the value that was set to exit() (which is 0 if exit() is
        /// called via quit()).</para>
        /// <para>It is necessary to call this function to start event handling.
        /// The main event loop receives events from the window system and dispatches
        /// these to the application widgets.</para>
        /// <para>Generally, no user interaction can take place before calling
        /// exec().</para>
        /// <para>To make your application perform idle processing, e.g., executing
        /// a special function whenever there are no pending events, use a QTimer with
        /// 0 timeout. More advanced idle processing schemes can be achieved using
        /// processEvents().</para>
        /// <para>We recommend that you connect clean-up code to the aboutToQuit()
        /// signal, instead of putting it in your application's main() function. This
        /// is because, on some platforms, the QApplication::exec() call may not
        /// return.</para>
        /// <para>See also quitOnLastWindowClosed, quit(), exit(), processEvents(),
        /// and QCoreApplication::exec().</para>
        /// </summary>
        public static int Exec()
        {
            var __ret = Internal.Exec_0();
            return __ret;
        }

        /// <summary>
        /// <para>Function that can be used to sync Qt state with the Window
        /// Systems state.</para>
        /// <para>This function will first empty Qts events by calling
        /// QCoreApplication::processEvents(), then the platform plugin will sync up
        /// with the windowsystem, and finally Qts events will be delived by another
        /// call to QCoreApplication::processEvents();</para>
        /// <para>This function is timeconsuming and its use is discouraged.</para>
        /// <para>This function was introduced in  Qt 5.2.</para>
        /// </summary>
        public static void Sync()
        {
            Internal.Sync_0();
        }

        /// <summary>
        /// <para>This property holds the user-visible name of this
        /// application.</para>
        /// <para>This name is shown to the user, for instance in window titles. It
        /// can be translated, if necessary.</para>
        /// <para>If not set, the application display name defaults to the
        /// application name.</para>
        /// <para>This property was introduced in  Qt 5.0.</para>
        /// </summary>
        public static string ApplicationDisplayName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.ApplicationDisplayName_0(new IntPtr(&__ret));
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetApplicationDisplayName_0(arg0);
            }
        }

        /// <summary>
        /// <para>This property holds the default window icon.</para>
        /// </summary>
        public static QIcon WindowIcon
        {
            get
            {
                var __ret = new QtGui.QIcon.Internal();
                Internal.WindowIcon_0(new IntPtr(&__ret));
                return QIcon.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetWindowIcon_0(arg0);
            }
        }

        /// <summary>
        /// <para>Returns the active application override cursor.</para>
        /// <para>This function returns 0 if no application cursor has been defined
        /// (i.e. the internal cursor stack is empty).</para>
        /// <para>See also setOverrideCursor() and restoreOverrideCursor().</para>
        /// <para></para>
        /// <para>Sets the application override cursor to cursor.</para>
        /// <para>Application override cursors are intended for showing the user
        /// that the application is in a special state, for example during an operation
        /// that might take some time.</para>
        /// <para>This cursor will be displayed in all the application's widgets
        /// until restoreOverrideCursor() or another setOverrideCursor() is
        /// called.</para>
        /// <para>Application cursors are stored on an internal stack.
        /// setOverrideCursor() pushes the cursor onto the stack, and
        /// restoreOverrideCursor() pops the active cursor off the stack.
        /// changeOverrideCursor() changes the curently active application override
        /// cursor.</para>
        /// <para>Every setOverrideCursor() must eventually be followed by a
        /// corresponding restoreOverrideCursor(), otherwise the stack will never be
        /// emptied.</para>
        /// <para>Example:</para>
        /// <para>QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));</para>
        /// <para>calculateHugeMandelbrot();              // lunch time...</para>
        /// <para>QApplication::restoreOverrideCursor();</para>
        /// <para>See also overrideCursor(), restoreOverrideCursor(),
        /// changeOverrideCursor(), and QWidget::setCursor().</para>
        /// </summary>
        public static QCursor OverrideCursor
        {
            get
            {
                var __ret = Internal.OverrideCursor_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QCursor.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetOverrideCursor_0(arg0);
            }
        }

        /// <summary>
        /// <para>Returns the default application font.</para>
        /// <para>See also setFont().</para>
        /// <para></para>
        /// <para>Changes the default application font to font.</para>
        /// <para>See also font().</para>
        /// </summary>
        public static QFont Font
        {
            get
            {
                var __ret = new QtGui.QFont.Internal();
                Internal.Font_0(new IntPtr(&__ret));
                return QFont.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFont_0(arg0);
            }
        }

        /// <summary>
        /// <para>Returns the default application palette.</para>
        /// <para>See also setPalette().</para>
        /// <para></para>
        /// <para>Changes the default application palette to pal.</para>
        /// <para>See also palette().</para>
        /// </summary>
        public static QPalette Palette
        {
            get
            {
                var __ret = new QtGui.QPalette.Internal();
                Internal.Palette_0(new IntPtr(&__ret));
                return QPalette.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetPalette_0(arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if Qt is set to use the system's standard colors,
        /// fonts, etc.; otherwise returns false. The default is true.</para>
        /// <para>See also setDesktopSettingsAware().</para>
        /// <para></para>
        /// <para>Sets whether Qt should use the system's standard colors, fonts,
        /// etc., to on. By default, this is true.</para>
        /// <para>This function must be called before creating the QGuiApplication
        /// object, like this:</para>
        /// <para>int main(int argc, char *argv[])</para>
        /// <para>{</para>
        /// <para>    QApplication::setDesktopSettingsAware(false);</para>
        /// <para>    QApplication app(argc, argv);</para>
        /// <para>    ...</para>
        /// <para>    return app.exec();</para>
        /// <para>}</para>
        /// <para>See also desktopSettingsAware().</para>
        /// </summary>
        public static bool DesktopSettingsAware
        {
            get
            {
                var __ret = Internal.DesktopSettingsAware_0();
                return __ret;
            }

            set
            {
                Internal.SetDesktopSettingsAware_0(value);
            }
        }

        /// <summary>
        /// <para>This property holds whether the application implicitly quits when
        /// the last window is closed.</para>
        /// <para>The default is true.</para>
        /// <para>If this property is true, the applications quits when the last
        /// visible primary window (i.e. window with no parent) is closed.</para>
        /// </summary>
        public static bool QuitOnLastWindowClosed
        {
            get
            {
                var __ret = Internal.QuitOnLastWindowClosed_0();
                return __ret;
            }

            set
            {
                Internal.SetQuitOnLastWindowClosed_0(value);
            }
        }

        /// <summary>
        /// <para>Returns a list of all the windows in the application.</para>
        /// <para>The list is empty if there are no windows.</para>
        /// <para>See also topLevelWindows().</para>
        /// </summary>
        public static System.Collections.Generic.IList<QWindow> AllWindows
        {
            get
            {
                var __ret = Internal.AllWindows_0();
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QWindow>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QWindow.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>Returns a list of the top-level windows in the
        /// application.</para>
        /// <para>See also allWindows().</para>
        /// </summary>
        public static System.Collections.Generic.IList<QWindow> TopLevelWindows
        {
            get
            {
                var __ret = Internal.TopLevelWindows_0();
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QWindow>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QWindow.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>This property holds the name of the underlying platform
        /// plugin.</para>
        /// <para>The QPA platform plugins are located in
        /// qtbase\src\plugins\platforms. At the time of writing, the following
        /// platform plugin names are supported:</para>
        /// <para></para>
        /// <para>android</para>
        /// <para>cocoa is a platform plugin for Mac OS X.</para>
        /// <para>directfb</para>
        /// <para>eglfs is a platform plugin for running Qt5 applications on top of
        /// EGL and OpenGL ES 2.0 without an actual windowing system (like X11 or
        /// Wayland). For more information, see EGLFS.</para>
        /// <para>ios</para>
        /// <para>kms is an experimental platform plugin using kernel modesetting
        /// and DRM (Direct Rendering Manager).</para>
        /// <para>linuxfb writes directly to the framebuffer. For more information,
        /// see LinuxFB.</para>
        /// <para>minimal is provided as an examples for developers who want to
        /// write their own platform plugins. However, you can use the plugin to run
        /// GUI applications in environments without a GUI, such as servers.</para>
        /// <para>minimalegl is an example plugin.</para>
        /// <para>offscreen</para>
        /// <para>openwfd</para>
        /// <para>qnx</para>
        /// <para>windows</para>
        /// <para>xcb is the X11 plugin used on regular desktop Linux
        /// platforms.</para>
        /// <para></para>
        /// <para>For more information about the platform plugins for embedded
        /// Linux devices, see Qt for Embedded Linux.</para>
        /// </summary>
        public static string PlatformName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.PlatformName_0(new IntPtr(&__ret));
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the most recently shown modal window. If no modal windows
        /// are visible, this function returns zero.</para>
        /// <para>A modal window is a window which has its modality property set to
        /// Qt::WindowModal or Qt::ApplicationModal. A modal window must be closed
        /// before the user can continue with other parts of the program.</para>
        /// <para>Modal window are organized in a stack. This function returns the
        /// modal window at the top of the stack.</para>
        /// <para>See also Qt::WindowModality and QWindow::setModality().</para>
        /// </summary>
        public static QWindow ModalWindow
        {
            get
            {
                var __ret = Internal.ModalWindow_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the primary (or default) screen of the
        /// application.</para>
        /// <para>This will be the screen where QWindows are initially shown,
        /// unless otherwise specified.</para>
        /// </summary>
        public static QScreen PrimaryScreen
        {
            get
            {
                var __ret = Internal.PrimaryScreen_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QScreen.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns a list of all the screens associated with the windowing
        /// system the application is connected to.</para>
        /// </summary>
        public static System.Collections.Generic.IList<QScreen> Screens
        {
            get
            {
                var __ret = Internal.Screens_0();
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QScreen>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QScreen.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>Returns the object for interacting with the clipboard.</para>
        /// </summary>
        public static QClipboard Clipboard
        {
            get
            {
                var __ret = Internal.Clipboard_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QClipboard.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the application's style hints.</para>
        /// <para>The style hints encapsulate a set of platform dependent
        /// properties such as double click intervals, full width selection and
        /// others.</para>
        /// <para>The hints can be used to integrate tighter with the underlying
        /// platform.</para>
        /// <para>See also QStyleHints.</para>
        /// </summary>
        public static QStyleHints StyleHints
        {
            get
            {
                var __ret = Internal.StyleHints_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QStyleHints.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>returns the input method.</para>
        /// <para>The input method returns properties about the state and position
        /// of the virtual keyboard. It also provides information about the position of
        /// the current focused input element.</para>
        /// <para>See also QInputMethod.</para>
        /// </summary>
        public static QInputMethod InputMethod
        {
            get
            {
                var __ret = Internal.InputMethod_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QInputMethod.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the application has been restored from an earlier
        /// session; otherwise returns false.</para>
        /// <para>See also sessionId(), commitDataRequest(), and
        /// saveStateRequest().</para>
        /// </summary>
        public bool IsSessionRestored
        {
            get
            {
                var __ret = Internal.IsSessionRestored_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the current session's identifier.</para>
        /// <para>If the application has been restored from an earlier session,
        /// this identifier is the same as it was in that previous session. The session
        /// identifier is guaranteed to be unique both for different applications and
        /// for different instances of the same application.</para>
        /// <para>See also isSessionRestored(), sessionKey(), commitDataRequest(),
        /// and saveStateRequest().</para>
        /// </summary>
        public string SessionId
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.SessionId_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the session key in the current session.</para>
        /// <para>If the application has been restored from an earlier session,
        /// this key is the same as it was when the previous session ended.</para>
        /// <para>The session key changes every time the session is saved. If the
        /// shutdown process is cancelled, another session key will be used when
        /// shutting down again.</para>
        /// <para>See also isSessionRestored(), sessionId(), commitDataRequest(),
        /// and saveStateRequest().</para>
        /// </summary>
        public string SessionKey
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.SessionKey_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns true if the application is currently saving the session;
        /// otherwise returns false.</para>
        /// <para>This is true when commitDataRequest() and saveStateRequest() are
        /// emitted, but also when the windows are closed afterwards by session
        /// management.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also sessionId(), commitDataRequest(), and
        /// saveStateRequest().</para>
        /// </summary>
        public bool IsSavingSession
        {
            get
            {
                var __ret = Internal.IsSavingSession_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QGuiApplication()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QGuiApplication) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
                *(void**)(vfptr0 + 52) = *(void**)(native->vfptr0 + 52);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QSurfaceFormat class represents the format of a
    /// QSurface.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The format includes the size of the color buffers, red, green,
    /// and blue; the size of the alpha buffer; the size of the depth and stencil
    /// buffers; and number of samples per pixel for multisampling. In addition,
    /// the format contains surface configuration parameters such as OpenGL profile
    /// and version for rendering, whether or not to enable stereo buffers, and
    /// swap behaviour.</para>
    /// </remarks>
    public unsafe partial class QSurfaceFormat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormatC2E6QFlagsINS_12FormatOptionEE")]
            internal static extern void ctor_1(global::System.IntPtr instance, QSurfaceFormat.FormatOption options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormatC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat10setVersionEii")]
            internal static extern void SetVersion_0(global::System.IntPtr instance, int major, int minor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat9setStereoEb")]
            internal static extern void SetStereo_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat9setOptionE6QFlagsINS_12FormatOptionEE")]
            internal static extern void SetOption_0(global::System.IntPtr instance, QSurfaceFormat.FormatOption opt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat10testOptionE6QFlagsINS_12FormatOptionEE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool TestOption_0(global::System.IntPtr instance, QSurfaceFormat.FormatOption opt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat9setOptionENS_12FormatOptionEb")]
            internal static extern void SetOption_1(global::System.IntPtr instance, QSurfaceFormat.FormatOption option, bool on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat10testOptionENS_12FormatOptionE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool TestOption1_0(global::System.IntPtr instance, QSurfaceFormat.FormatOption option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZeqRK14QSurfaceFormatS1_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZneRK14QSurfaceFormatS1_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat15depthBufferSizeEv")]
            internal static extern int DepthBufferSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat18setDepthBufferSizeEi")]
            internal static extern void SetDepthBufferSize_0(global::System.IntPtr instance, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat17stencilBufferSizeEv")]
            internal static extern int StencilBufferSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat20setStencilBufferSizeEi")]
            internal static extern void SetStencilBufferSize_0(global::System.IntPtr instance, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat13redBufferSizeEv")]
            internal static extern int RedBufferSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat16setRedBufferSizeEi")]
            internal static extern void SetRedBufferSize_0(global::System.IntPtr instance, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat15greenBufferSizeEv")]
            internal static extern int GreenBufferSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat18setGreenBufferSizeEi")]
            internal static extern void SetGreenBufferSize_0(global::System.IntPtr instance, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat14blueBufferSizeEv")]
            internal static extern int BlueBufferSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat17setBlueBufferSizeEi")]
            internal static extern void SetBlueBufferSize_0(global::System.IntPtr instance, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat15alphaBufferSizeEv")]
            internal static extern int AlphaBufferSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat18setAlphaBufferSizeEi")]
            internal static extern void SetAlphaBufferSize_0(global::System.IntPtr instance, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat7samplesEv")]
            internal static extern int Samples_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat10setSamplesEi")]
            internal static extern void SetSamples_0(global::System.IntPtr instance, int numSamples);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat12swapBehaviorEv")]
            internal static extern QSurfaceFormat.SwapBehavior swapBehavior_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat15setSwapBehaviorENS_12SwapBehaviorE")]
            internal static extern void SetSwapBehavior_0(global::System.IntPtr instance, QSurfaceFormat.SwapBehavior behavior);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat7profileEv")]
            internal static extern QSurfaceFormat.OpenGLContextProfile Profile_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat10setProfileENS_20OpenGLContextProfileE")]
            internal static extern void SetProfile_0(global::System.IntPtr instance, QSurfaceFormat.OpenGLContextProfile profile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat14renderableTypeEv")]
            internal static extern QSurfaceFormat.RenderableType renderableType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat17setRenderableTypeENS_14RenderableTypeE")]
            internal static extern void SetRenderableType_0(global::System.IntPtr instance, QSurfaceFormat.RenderableType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat12majorVersionEv")]
            internal static extern int MajorVersion_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat15setMajorVersionEi")]
            internal static extern void SetMajorVersion_0(global::System.IntPtr instance, int majorVersion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat12minorVersionEv")]
            internal static extern int MinorVersion_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat15setMinorVersionEi")]
            internal static extern void SetMinorVersion_0(global::System.IntPtr instance, int minorVersion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat7optionsEv")]
            internal static extern QSurfaceFormat.FormatOption Options_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat10setOptionsE6QFlagsINS_12FormatOptionEE")]
            internal static extern void SetOptions_0(global::System.IntPtr instance, QSurfaceFormat.FormatOption options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat12swapIntervalEv")]
            internal static extern int SwapInterval_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QSurfaceFormat15setSwapIntervalEi")]
            internal static extern void SetSwapInterval_0(global::System.IntPtr instance, int interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QSurfaceFormat13defaultFormatEv")]
            internal static extern void DefaultFormat_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QSurfaceFormat16setDefaultFormatERKS_")]
            internal static extern void SetDefaultFormat_0(global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QSurfaceFormat8hasAlphaEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasAlpha_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum contains format options for use with
        /// QSurfaceFormat.</para>
        /// </summary>
        [Flags]
        public enum FormatOption : uint
        {
            /// <summary>Used to request stereo buffers in the surface format.</summary>
            StereoBuffers = 0x1,
            /// <summary>Used to request a debug context with extra debugging information.</summary>
            DebugContext = 0x2,
            /// <summary>Used to request that deprecated functions be included in the OpenGL context profile. If not specified, you should get a forward compatible context without support functionality marked as deprecated. This requires OpenGL version 3.0 or higher.</summary>
            DeprecatedFunctions = 0x4
        }

        /// <summary>
        /// <para>This enum is used by QSurfaceFormat to specify the swap behaviour
        /// of a surface. The swap behaviour is mostly transparent to the application,
        /// but it affects factors such as rendering latency and throughput.</para>
        /// </summary>
        public enum SwapBehavior : uint
        {
            /// <summary>The default, unspecified swap behaviour of the platform.</summary>
            DefaultSwapBehavior = 0,
            /// <summary>Used to request single buffering, which might result in flickering when OpenGL rendering is done directly to screen without an intermediate offscreen buffer.</summary>
            SingleBuffer = 1,
            /// <summary>This is typically the default swap behaviour on desktop platforms, consisting of one back buffer and one front buffer. Rendering is done to the back buffer, and then the back buffer and front buffer are swapped, or the contents of the back buffer are copied to the front buffer, depending on the implementation.</summary>
            DoubleBuffer = 2,
            /// <summary>This swap behaviour is sometimes used in order to decrease the risk of skipping a frame when the rendering rate is just barely keeping up with the screen refresh rate. Depending on the platform it might also lead to slightly more efficient use of the GPU due to improved pipelining behaviour. Triple buffering comes at the cost of an extra frame of memory usage and latency, and might not be supported depending on the underlying platform.</summary>
            TripleBuffer = 3
        }

        /// <summary>
        /// <para>This enum specifies the rendering backend for the surface.</para>
        /// </summary>
        [Flags]
        public enum RenderableType : uint
        {
            /// <summary>The default, unspecified rendering method</summary>
            DefaultRenderableType = 0x0,
            /// <summary>Desktop OpenGL rendering</summary>
            OpenGL = 0x1,
            /// <summary>OpenGL ES 2.0 rendering</summary>
            OpenGLES = 0x2,
            /// <summary>Open Vector Graphics rendering</summary>
            OpenVG = 0x4
        }

        /// <summary>
        /// <para>This enum is used to specify the OpenGL context profile, in
        /// conjunction with QSurfaceFormat::setMajorVersion() and
        /// QSurfaceFormat::setMinorVersion().</para>
        /// <para>Profiles are exposed in OpenGL 3.2 and above, and are used to
        /// choose between a restricted core profile, and a compatibility profile which
        /// might contain deprecated support functionality.</para>
        /// <para>Note that the core profile might still contain functionality that
        /// is deprecated and scheduled for removal in a higher version. To get access
        /// to the deprecated functionality for the core profile in the set OpenGL
        /// version you can use the QSurfaceFormat format option
        /// QSurfaceFormat::DeprecatedFunctions.</para>
        /// </summary>
        public enum OpenGLContextProfile : uint
        {
            /// <summary>OpenGL version is lower than 3.2.</summary>
            NoProfile = 0,
            /// <summary>Functionality deprecated in OpenGL version 3.0 is not available.</summary>
            CoreProfile = 1,
            /// <summary>Functionality from earlier OpenGL versions is available.</summary>
            CompatibilityProfile = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QSurfaceFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QSurfaceFormat((QSurfaceFormat.Internal*) native);
        }

        public static QSurfaceFormat __CreateInstance(QSurfaceFormat.Internal native)
        {
            return new QSurfaceFormat(native);
        }

        private static QSurfaceFormat.Internal* __CopyValue(QSurfaceFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QSurfaceFormat.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QSurfaceFormat.Internal*) ret;
        }

        private QSurfaceFormat(QSurfaceFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QSurfaceFormat(QSurfaceFormat.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a default initialized QSurfaceFormat.</para>
        /// <para>Note: By default OpenGL 2.0 is requested since this provides the
        /// highest grade of portability between platforms and OpenGL
        /// implementations.</para>
        /// <para></para>
        /// <para>QSurfaceFormat::QSurfaceFormat(FormatOptions options)</para>
        /// <para>Constructs a QSurfaceFormat with the given format options.</para>
        /// </summary>
        public QSurfaceFormat()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QSurfaceFormat with the given format options.</para>
        /// </summary>
        public QSurfaceFormat(QSurfaceFormat.FormatOption options)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = options;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a copy of other.</para>
        /// </summary>
        public QSurfaceFormat(QSurfaceFormat other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the desired major and minor OpenGL versions.</para>
        /// <para>The default version is 2.0.</para>
        /// <para>See also version().</para>
        /// </summary>
        public void SetVersion(int major, int minor)
        {
            Internal.SetVersion_0(__Instance, major, minor);
        }

        /// <summary>
        /// <para>If enable is true enables stereo buffering; otherwise disables
        /// stereo buffering.</para>
        /// <para>Stereo buffering is disabled by default.</para>
        /// <para>Stereo buffering provides extra color buffers to generate
        /// left-eye and right-eye images.</para>
        /// <para>See also stereo().</para>
        /// </summary>
        public void SetStereo(bool enable)
        {
            Internal.SetStereo_0(__Instance, enable);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Use setOption(QSurfaceFormat::FormatOption, bool) or setOptions()
        /// instead.</para>
        /// <para>Sets the format options to the OR combination of opt and the
        /// current format options.</para>
        /// <para>See also options() and testOption().</para>
        /// </summary>
        [System.ObsoleteAttribute("Use setOption(QSurfaceFormat::FormatOption, bool) or setOptions() instead.")]
        public void SetOption(QSurfaceFormat.FormatOption opt)
        {
            var arg0 = opt;
            Internal.SetOption_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Use testOption(QSurfaceFormat::FormatOption) instead.</para>
        /// <para>Returns true if any of the options in opt is currently set on
        /// this object; otherwise returns false.</para>
        /// <para>See also setOption().</para>
        /// </summary>
        [System.ObsoleteAttribute("Use testOption(QSurfaceFormat::FormatOption) instead.")]
        public bool TestOption(QSurfaceFormat.FormatOption opt)
        {
            var arg0 = opt;
            var __ret = Internal.TestOption_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the format option option if on is true; otherwise, clears
        /// the option.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also setOptions(), options(), and testOption().</para>
        /// </summary>
        public void SetOption(QSurfaceFormat.FormatOption option, bool on = true)
        {
            var arg0 = option;
            Internal.SetOption_1(__Instance, arg0, on);
        }

        /// <summary>
        /// <para>Returns true if the format option option is set; otherwise
        /// returns false.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also options().</para>
        /// </summary>
        public bool TestOption1(QSurfaceFormat.FormatOption option)
        {
            var arg0 = option;
            var __ret = Internal.TestOption1_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if all the options of the two QSurfaceFormat objects
        /// a and b are equal.</para>
        /// </summary>
        public static bool operator ==(QSurfaceFormat a, QSurfaceFormat b)
        {
            bool aNull = ReferenceEquals(a, null);
            bool bNull = ReferenceEquals(b, null);
            if (aNull || bNull)
                return aNull && bNull;
            var arg0 = a.__Instance;
            var arg1 = b.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QSurfaceFormat;
        }

        /// <summary>
        /// <para>Returns false if all the options of the two QSurfaceFormat
        /// objects a and b are equal; otherwise returns true.</para>
        /// </summary>
        public static bool operator !=(QSurfaceFormat a, QSurfaceFormat b)
        {
            var arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var arg1 = ReferenceEquals(b, null) ? global::System.IntPtr.Zero : b.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the depth buffer size.</para>
        /// <para>See also setDepthBufferSize().</para>
        /// <para></para>
        /// <para>Set the minimum depth buffer size to size.</para>
        /// <para>See also depthBufferSize().</para>
        /// </summary>
        public int DepthBufferSize
        {
            get
            {
                var __ret = Internal.DepthBufferSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetDepthBufferSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the stencil buffer size in bits.</para>
        /// <para>See also setStencilBufferSize().</para>
        /// <para></para>
        /// <para>Set the preferred stencil buffer size to size bits.</para>
        /// <para>See also stencilBufferSize().</para>
        /// </summary>
        public int StencilBufferSize
        {
            get
            {
                var __ret = Internal.StencilBufferSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStencilBufferSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Get the size in bits of the red channel of the color
        /// buffer.</para>
        /// <para>See also setRedBufferSize().</para>
        /// <para></para>
        /// <para>Set the desired size in bits of the red channel of the color
        /// buffer.</para>
        /// <para>Note: On Mac OSX, be sure to set the buffer size of all color
        /// channels, otherwise this setting will have no effect. If one of the buffer
        /// sizes is not set, the current bit-depth of the screen is used.See also
        /// redBufferSize().</para>
        /// </summary>
        public int RedBufferSize
        {
            get
            {
                var __ret = Internal.RedBufferSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRedBufferSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Get the size in bits of the green channel of the color
        /// buffer.</para>
        /// <para>See also setGreenBufferSize().</para>
        /// <para></para>
        /// <para>Set the desired size in bits of the green channel of the color
        /// buffer.</para>
        /// <para>Note: On Mac OSX, be sure to set the buffer size of all color
        /// channels, otherwise this setting will have no effect. If one of the buffer
        /// sizes is not set, the current bit-depth of the screen is used.See also
        /// greenBufferSize().</para>
        /// </summary>
        public int GreenBufferSize
        {
            get
            {
                var __ret = Internal.GreenBufferSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetGreenBufferSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Get the size in bits of the blue channel of the color
        /// buffer.</para>
        /// <para>See also setBlueBufferSize().</para>
        /// <para></para>
        /// <para>Set the desired size in bits of the blue channel of the color
        /// buffer.</para>
        /// <para>Note: On Mac OSX, be sure to set the buffer size of all color
        /// channels, otherwise this setting will have no effect. If one of the buffer
        /// sizes is not set, the current bit-depth of the screen is used.See also
        /// blueBufferSize().</para>
        /// </summary>
        public int BlueBufferSize
        {
            get
            {
                var __ret = Internal.BlueBufferSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetBlueBufferSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Get the size in bits of the alpha channel of the color
        /// buffer.</para>
        /// <para>See also setAlphaBufferSize().</para>
        /// <para></para>
        /// <para>Set the desired size in bits of the alpha channel of the color
        /// buffer.</para>
        /// <para>See also alphaBufferSize().</para>
        /// </summary>
        public int AlphaBufferSize
        {
            get
            {
                var __ret = Internal.AlphaBufferSize_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetAlphaBufferSize_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of samples per pixel when multisampling is
        /// enabled. By default, multisampling is disabled.</para>
        /// <para>See also setSamples().</para>
        /// <para></para>
        /// <para>Set the preferred number of samples per pixel when multisampling
        /// is enabled to numSamples. By default, multisampling is disabled.</para>
        /// <para>See also samples().</para>
        /// </summary>
        public int Samples
        {
            get
            {
                var __ret = Internal.Samples_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSamples_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the configured swap behaviour.</para>
        /// <para>See also setSwapBehavior().</para>
        /// <para></para>
        /// <para>Set the swap behavior of the surface.</para>
        /// <para>The swap behavior specifies whether single, double, or triple
        /// buffering is desired. The default, DefaultSwapBehavior, gives the default
        /// swap behavior of the platform.</para>
        /// <para>See also swapBehavior().</para>
        /// </summary>
        public QSurfaceFormat.SwapBehavior swapBehavior
        {
            get
            {
                var __ret = Internal.swapBehavior_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetSwapBehavior_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Get the configured OpenGL context profile.</para>
        /// <para>This setting is ignored if the requested OpenGL version is less
        /// than 3.2.</para>
        /// <para>See also setProfile().</para>
        /// <para></para>
        /// <para>Sets the desired OpenGL context profile.</para>
        /// <para>This setting is ignored if the requested OpenGL version is less
        /// than 3.2.</para>
        /// <para>See also profile().</para>
        /// </summary>
        public QSurfaceFormat.OpenGLContextProfile Profile
        {
            get
            {
                var __ret = Internal.Profile_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetProfile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Gets the renderable type.</para>
        /// <para>Chooses between desktop OpenGL, OpenGL ES, and OpenVG.</para>
        /// <para>See also setRenderableType().</para>
        /// <para></para>
        /// <para>Sets the desired renderable type.</para>
        /// <para>Chooses between desktop OpenGL, OpenGL ES, and OpenVG.</para>
        /// <para>See also renderableType().</para>
        /// </summary>
        public QSurfaceFormat.RenderableType renderableType
        {
            get
            {
                var __ret = Internal.renderableType_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetRenderableType_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the major OpenGL version.</para>
        /// <para>The default version is 2.0.</para>
        /// <para>See also setMajorVersion().</para>
        /// <para></para>
        /// <para>Sets the desired major OpenGL version.</para>
        /// <para>See also majorVersion().</para>
        /// </summary>
        public int MajorVersion
        {
            get
            {
                var __ret = Internal.MajorVersion_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMajorVersion_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the minor OpenGL version.</para>
        /// <para>See also setMinorVersion().</para>
        /// <para></para>
        /// <para>Sets the desired minor OpenGL version.</para>
        /// <para>The default version is 2.0.</para>
        /// <para>See also minorVersion().</para>
        /// </summary>
        public int MinorVersion
        {
            get
            {
                var __ret = Internal.MinorVersion_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMinorVersion_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the currently set format options.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also setOption(), setOptions(), and testOption().</para>
        /// <para></para>
        /// <para>Sets the format options to options.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also options() and testOption().</para>
        /// </summary>
        public QSurfaceFormat.FormatOption Options
        {
            get
            {
                var __ret = Internal.Options_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetOptions_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the swap interval.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also setSwapInterval().</para>
        /// <para></para>
        /// <para>Sets the preferred swap interval. The swap interval specifies the
        /// minimum number of video frames that are displayed before a buffer swap
        /// occurs. This can be used to sync the GL drawing into a window to the
        /// vertical refresh of the screen.</para>
        /// <para>Setting an interval value of 0 will turn the vertical refresh
        /// syncing off, any value higher than 0 will turn the vertical syncing on.
        /// Setting interval to a higher value, for example 10, results in having 10
        /// vertical retraces between every buffer swap.</para>
        /// <para>The default interval is 1.</para>
        /// <para>Changing the swap interval may not be supported by the underlying
        /// platform. In this case, the request will be silently ignored.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also swapInterval().</para>
        /// </summary>
        public int SwapInterval
        {
            get
            {
                var __ret = Internal.SwapInterval_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSwapInterval_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the global default surface format.</para>
        /// <para>When setDefaultFormat() is not called, this is a
        /// default-constructed QSurfaceFormat.</para>
        /// <para>This function was introduced in  Qt 5.4.</para>
        /// <para>See also setDefaultFormat().</para>
        /// <para></para>
        /// <para>Sets the global default surface format.</para>
        /// <para>This format is used by default in QOpenGLContext, QWindow,
        /// QOpenGLWidget and similar classes.</para>
        /// <para>It can always be overridden on a per-instance basis by using the
        /// class in question's own setFormat() function. However, it is often more
        /// convenient to set the format for all windows once at the start of the
        /// application. It also guarantees proper behavior in cases where shared
        /// contexts are required, because settings the format via this function
        /// guarantees that all contexts and surfaces, even the ones created internally
        /// by Qt, will use the same format.</para>
        /// <para>This function was introduced in  Qt 5.4.</para>
        /// <para>See also defaultFormat().</para>
        /// </summary>
        public static QSurfaceFormat DefaultFormat
        {
            get
            {
                var __ret = new QtGui.QSurfaceFormat.Internal();
                Internal.DefaultFormat_0(new IntPtr(&__ret));
                return QSurfaceFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetDefaultFormat_0(arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if the alpha buffer size is greater than
        /// zero.</para>
        /// <para>This means that the surface might be used with per pixel
        /// translucency effects.</para>
        /// </summary>
        public bool HasAlpha
        {
            get
            {
                var __ret = Internal.HasAlpha_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QSurface class is an abstraction of renderable surfaces in
    /// Qt.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The size of the surface is accessible with the size() function.
    /// The rendering specific attributes of the surface are accessible through the
    /// format() function.</para>
    /// </remarks>
    public unsafe abstract partial class QSurface : QtGui.IQSurface, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QSurface.SurfaceClass m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QSurfaceC2ENS_12SurfaceClassE")]
            internal static extern void ctor_0(global::System.IntPtr instance, QSurface.SurfaceClass type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QSurfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QSurfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QSurface12surfaceClassEv")]
            internal static extern QSurface.SurfaceClass surfaceClass_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QSurface14supportsOpenGLEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsOpenGL_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>The SurfaceClass enum describes the actual subclass of the
        /// surface.</para>
        /// </summary>
        public enum SurfaceClass : uint
        {
            /// <summary>The surface is an instance of QWindow.</summary>
            Window = 0,
            /// <summary>The surface is an instance of QOffscreenSurface.</summary>
            Offscreen = 1
        }

        /// <summary>
        /// <para>The SurfaceType enum describes what type of surface this
        /// is.</para>
        /// </summary>
        public enum SurfaceType : uint
        {
            /// <summary>The surface is is composed of pixels and can be rendered to using a software rasterizer like Qt's raster paint engine.</summary>
            RasterSurface = 0,
            /// <summary>The surface is an OpenGL compatible surface and can be used in conjunction with QOpenGLContext.</summary>
            OpenGLSurface = 1,
            /// <summary>The surface can be rendered to using a software rasterizer, and also supports OpenGL. This surface type is intended for internal Qt use, and requires the use of private API.</summary>
            RasterGLSurface = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QSurface(QSurface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates a surface with the given type.</para>
        /// </summary>
        protected QSurface(QSurface.SurfaceClass type)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            var arg0 = type;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected QSurface.SurfaceClass M_type
        {
            get
            {
                return ((Internal*) __Instance)->m_type;
            }

            set
            {
                ((Internal*) __Instance)->m_type = value;
            }
        }

        /// <summary>
        /// <para>Returns the surface class of this surface.</para>
        /// </summary>
        public QSurface.SurfaceClass surfaceClass
        {
            get
            {
                var __ret = Internal.surfaceClass_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the format of the surface.</para>
        /// </summary>
        public abstract QSurfaceFormat Format
        {
            get;
        }

        /// <summary>
        /// <para>Returns the type of the surface.</para>
        /// </summary>
        public abstract QSurface.SurfaceType surfaceType
        {
            get;
        }

        /// <summary>
        /// <para>Returns true if the surface is OpenGL compatible and can be used
        /// in conjunction with QOpenGLContext; otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// </summary>
        public bool SupportsOpenGL
        {
            get
            {
                var __ret = Internal.SupportsOpenGL_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QSurface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QSurface) _References[instance].Target;
            target.Dispose();
        }

        // QSurfaceFormat format()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurfaceFormat.Internal _Format_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Format_0Delegate _Format_0DelegateInstance;

        private static QSurfaceFormat.Internal _Format_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QSurface) _References[instance].Target;
            var _ret = target.Format;
            return ReferenceEquals(_ret, null) ? new QSurfaceFormat.Internal() : *(QSurfaceFormat.Internal*) (_ret.__Instance);
        }

        // SurfaceType surfaceType()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurface.SurfaceType _surfaceType_0Delegate(global::System.IntPtr instance);
        private static _surfaceType_0Delegate _surfaceType_0DelegateInstance;

        private static QSurface.SurfaceType _surfaceType_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QSurface) _References[instance].Target;
            var _ret = target.surfaceType;
            return _ret;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
                _surfaceType_0DelegateInstance += _surfaceType_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_surfaceType_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = _Thunks[1];
                *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QSurfaceInternal : QtGui.QSurface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QSurfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QSurfaceInternal((QSurface.Internal*) native);
        }

        public static QSurface __CreateInstance(QSurface.Internal native)
        {
            return new QSurfaceInternal(native);
        }

        private static QSurface.Internal* __CopyValue(QSurface.Internal native)
        {
            var ret = (QSurface.Internal*) Marshal.AllocHGlobal(12);
            *ret = native;
            return ret;
        }

        private QSurfaceInternal(QSurface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QSurfaceInternal(QSurface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QSurface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QSurfaceFormat Format
        {
            get
            {
                void* slot = *(void**) (((QSurface.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___Format_0Delegate = (_Format_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Format_0Delegate));
                var __ret = new QtGui.QSurfaceFormat.Internal();
                ___Format_0Delegate(new IntPtr(&__ret), __Instance);
                return QSurfaceFormat.__CreateInstance(__ret);
            }
        }

        public override QSurface.SurfaceType SurfaceType
        {
            get
            {
                void* slot = *(void**) (((QSurface.Internal*) __Instance)->vfptr0 + 4 * 4);
                var ___surfaceType_0Delegate = (_surfaceType_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_surfaceType_0Delegate));
                var __ret = ___surfaceType_0Delegate(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial interface IQSurface
    {
        QSurface.SurfaceClass M_type { get; set; }

        global::System.IntPtr __Instance { get; }

        QSurface.SurfaceClass SurfaceClass { get; }

        QSurfaceFormat Format { get; }

        QSurface.SurfaceType SurfaceType { get; }

        bool SupportsOpenGL { get; }
    }

    /// <summary>
    /// <para>The QOffscreenSurface class represents an offscreen surface in
    /// the underlying platform.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QOffscreenSurface is intended to be used with QOpenGLContext to
    /// allow rendering with OpenGL in an arbitrary thread without the need to
    /// create a QWindow.</para>
    /// <para>Even though the surface is renderable, the surface's pixels are
    /// not accessible. QOffscreenSurface should only be used to create OpenGL
    /// resources such as textures or framebuffer objects.</para>
    /// <para>An application will typically use QOffscreenSurface to perform
    /// some time-consuming tasks in a separate thread in order to avoid stalling
    /// the main rendering thread. Resources created in the QOffscreenSurface's
    /// context can be shared with the main OpenGL context. Some common use cases
    /// are asynchronous texture uploads or rendering into a
    /// QOpenGLFramebufferObject.</para>
    /// <para>How the offscreen surface is implemented depends on the
    /// underlying platform, but it will typically use a pixel buffer (pbuffer). If
    /// the platform doesn't implement or support offscreen surfaces,
    /// QOffscreenSurface will use an invisible QWindow internally.</para>
    /// <para>Note: Due to the fact that QOffscreenSurface is backed by a
    /// QWindow on some platforms, cross-platform applications must ensure that
    /// create() is only called on the main (GUI) thread. The QOffscreenSurface is
    /// then safe to be used with makeCurrent() on other threads, but the
    /// initialization and destruction must always happen on the main (GUI)
    /// thread.Note: In order to create an offscreen surface that is guaranteed to
    /// be compatible with a given context and window, make sure to set the format
    /// to the context's or the window's actual format, that is, the QSurfaceFormat
    /// returned from QOpenGLContext::format() or QWindow::format() after the
    /// context or window has been created. Passing the format returned from
    /// QWindow::requestedFormat() to setFormat() may result in an incompatible
    /// offscreen surface since the underlying windowing system interface may offer
    /// a different set of configurations for window and pbuffer surfaces.</para>
    /// </remarks>
    public unsafe partial class QOffscreenSurface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QSurface.SurfaceClass m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurfaceC2EP7QScreen")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr screen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurface6createEv")]
            internal static extern void Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurface7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurface9setFormatERK14QSurfaceFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOffscreenSurface6formatEv")]
            internal static extern void Format_0(global::System.IntPtr _return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOffscreenSurface6screenEv")]
            internal static extern global::System.IntPtr Screen_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOffscreenSurface9setScreenEP7QScreen")]
            internal static extern void SetScreen_0(global::System.IntPtr instance, global::System.IntPtr screen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOffscreenSurface11surfaceTypeEv")]
            internal static extern QSurface.SurfaceType SurfaceType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOffscreenSurface7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOffscreenSurface15requestedFormatEv")]
            internal static extern void RequestedFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted when an offscreen surface's screen changes, either by being set explicitly with setScreen(), or automatically when the window's screen is removed.</para>
        /// </summary>
        public event Action<QScreen> ScreenChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "screenChanged(QScreen)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "screenChanged(QScreen)", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOffscreenSurface __CreateInstance(global::System.IntPtr native)
        {
            return new QOffscreenSurface((QOffscreenSurface.Internal*) native);
        }

        public static QOffscreenSurface __CreateInstance(QOffscreenSurface.Internal native)
        {
            return new QOffscreenSurface(native);
        }

        private static QOffscreenSurface.Internal* __CopyValue(QOffscreenSurface.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QOffscreenSurface.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOffscreenSurface.Internal*) ret;
        }

        private QOffscreenSurface(QOffscreenSurface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOffscreenSurface(QOffscreenSurface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates an offscreen surface for the targetScreen.</para>
        /// <para>The underlying platform surface is not created until create() is
        /// called.</para>
        /// <para>See also setScreen() and create().</para>
        /// </summary>
        public QOffscreenSurface(QScreen screen = null)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(screen, null) ? global::System.IntPtr.Zero : screen.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Allocates the platform resources associated with the offscreen
        /// surface.</para>
        /// <para>It is at this point that the surface format set using setFormat()
        /// gets resolved into an actual native surface.</para>
        /// <para>Call destroy() to free the platform resources if
        /// necessary.</para>
        /// <para>Note: Some platforms require this function to be called on the
        /// main (GUI) thread.See also destroy().</para>
        /// </summary>
        public void Create()
        {
            Internal.Create_0(__Instance);
        }

        /// <summary>
        /// <para>Releases the native platform resources associated with this
        /// offscreen surface.</para>
        /// <para>See also create().</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Sets the offscreen surface format.</para>
        /// <para>The surface format will be resolved in the create() function.
        /// Calling this function after create() will not re-resolve the surface format
        /// of the native surface.</para>
        /// <para>See also format(), create(), and destroy().</para>
        /// </summary>
        public void SetFormat(QSurfaceFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.SetFormat_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Reimplemented from QSurface::format().</para>
        /// <para>Returns the actual format of this offscreen surface.</para>
        /// <para>After the offscreen surface has been created, this function will
        /// return the actual surface format of the surface. It might differ from the
        /// requested format if the requested format could not be fulfilled by the
        /// platform.</para>
        /// <para>See also setFormat(), create(), and requestedFormat().</para>
        /// </summary>
        public override QSurfaceFormat Format
        {
            get
            {
                var __ret = new QtGui.QSurfaceFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QSurfaceFormat.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the screen to which the offscreen surface is
        /// connected.</para>
        /// <para>See also setScreen().</para>
        /// <para></para>
        /// <para>Sets the screen to which the offscreen surface is
        /// connected.</para>
        /// <para>If the offscreen surface has been created, it will be recreated
        /// on the newScreen.</para>
        /// <para>See also screen().</para>
        /// </summary>
        public QScreen Screen
        {
            get
            {
                var __ret = Internal.Screen_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QScreen.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetScreen_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QSurface::surfaceType().</para>
        /// <para>Returns the surface type of the offscreen surface.</para>
        /// <para>The surface type of an offscreen surface is always
        /// QSurface::OpenGLSurface.</para>
        /// </summary>
        public override QSurface.SurfaceType SurfaceType
        {
            get
            {
                var __ret = Internal.SurfaceType_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this offscreen surface is valid; otherwise
        /// returns false.</para>
        /// <para>The offscreen surface is valid if the platform resources have
        /// been successfuly allocated.</para>
        /// <para>See also create().</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the requested surfaceformat of this offscreen
        /// surface.</para>
        /// <para>If the requested format was not supported by the platform
        /// implementation, the requestedFormat will differ from the actual offscreen
        /// surface format.</para>
        /// <para>This is the value set with setFormat().</para>
        /// <para>See also setFormat() and format().</para>
        /// </summary>
        public QSurfaceFormat RequestedFormat
        {
            get
            {
                var __ret = new QtGui.QSurfaceFormat.Internal();
                Internal.RequestedFormat_0(new IntPtr(&__ret), __Instance);
                return QSurfaceFormat.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // virtual ~QOffscreenSurface()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOffscreenSurface) _References[instance].Target;
            target.Dispose();
        }

        // SurfaceType surfaceType()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurface.SurfaceType _SurfaceType_0Delegate(global::System.IntPtr instance);
        private static _SurfaceType_0Delegate _SurfaceType_0DelegateInstance;

        private static QSurface.SurfaceType _SurfaceType_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOffscreenSurface) _References[instance].Target;
            var _ret = target.SurfaceType;
            return _ret;
        }

        // QSurfaceFormat format()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurfaceFormat.Internal _Format_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Format_0Delegate _Format_0DelegateInstance;

        private static QSurfaceFormat.Internal _Format_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOffscreenSurface) _References[instance].Target;
            var _ret = target.Format;
            return ReferenceEquals(_ret, null) ? new QSurfaceFormat.Internal() : *(QSurfaceFormat.Internal*) (_ret.__Instance);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _SurfaceType_0DelegateInstance += _SurfaceType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SurfaceType_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(20 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDTRANSFORMFEEDBACKPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDCONDITIONALRENDERPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLPAUSETRANSFORMFEEDBACKPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLRESUMETRANSFORMFEEDBACKPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLRELEASESHADERCOMPILERPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLPOPDEBUGGROUPPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXTUREBARRIERPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLDELETEOBJECTARBPROC(uint obj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLDETACHOBJECTARBPROC(uint containerObj, uint attachedObj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLCOMPILESHADERARBPROC(uint shaderObj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate uint PFNGLCREATEPROGRAMOBJECTARBPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLATTACHOBJECTARBPROC(uint containerObj, uint obj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLLINKPROGRAMARBPROC(uint programObj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLUSEPROGRAMOBJECTARBPROC(uint programObj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVALIDATEPROGRAMARBPROC(uint programObj);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLBLENDBARRIERKHRPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLBEGINFRAGMENTSHADERATIPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDFRAGMENTSHADERATIPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLUNLOCKARRAYSEXTPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLPOPGROUPMARKEREXTPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDTRANSFORMFEEDBACKEXTPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLBEGINVERTEXSHADEREXTPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDVERTEXSHADEREXTPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLFRAMETERMINATORGREMEDYPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLRESIZEBUFFERSMESAPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDCONDITIONALRENDERNVXPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLBLENDBARRIERNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDCONDITIONALRENDERNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEX2HNVPROC(ushort x, ushort y);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEX2HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEX3HNVPROC(ushort x, ushort y, ushort z);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEX3HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEX4HNVPROC(ushort x, ushort y, ushort z, ushort w);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEX4HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLNORMAL3HNVPROC(ushort nx, ushort ny, ushort nz);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLNORMAL3HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLCOLOR3HNVPROC(ushort red, ushort green, ushort blue);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLCOLOR3HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLCOLOR4HNVPROC(ushort red, ushort green, ushort blue, ushort alpha);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLCOLOR4HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD1HNVPROC(ushort s);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD1HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD2HNVPROC(ushort s, ushort t);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD2HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD3HNVPROC(ushort s, ushort t, ushort r);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD3HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD4HNVPROC(ushort s, ushort t, ushort r, ushort q);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXCOORD4HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLFOGCOORDHNVPROC(ushort fog);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLFOGCOORDHVNVPROC(ushort* fog);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLSECONDARYCOLOR3HNVPROC(ushort red, ushort green, ushort blue);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLSECONDARYCOLOR3HVNVPROC(ushort* v);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEXWEIGHTHNVPROC(ushort weight);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVERTEXWEIGHTHVNVPROC(ushort* weight);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDOCCLUSIONQUERYNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLPRIMITIVERESTARTNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTEXTUREBARRIERNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLENDTRANSFORMFEEDBACKNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLPAUSETRANSFORMFEEDBACKNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLRESUMETRANSFORMFEEDBACKNVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVDPAUINITNVPROC(global::System.IntPtr vdpDevice, global::System.IntPtr getProcAddress);

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLVDPAUFININVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLFLUSHVERTEXARRAYRANGENVPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLFLUSHRASTERSGIXPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLSTARTINSTRUMENTSSGIXPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLTAGSAMPLEBUFFERSGIXPROC();

    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate void PFNGLFINISHTEXTURESUNXPROC();

    public unsafe partial class QOpenGLVersionStatus : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QPair.Internal version;

            [FieldOffset(8)]
            public QOpenGLVersionStatus.OpenGLStatus status;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLVersionStatusC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public enum OpenGLStatus : uint
        {
            CoreStatus = 0,
            DeprecatedStatus = 1,
            InvalidStatus = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLVersionStatus __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLVersionStatus((QOpenGLVersionStatus.Internal*) native);
        }

        public static QOpenGLVersionStatus __CreateInstance(QOpenGLVersionStatus.Internal native)
        {
            return new QOpenGLVersionStatus(native);
        }

        private static QOpenGLVersionStatus.Internal* __CopyValue(QOpenGLVersionStatus.Internal native)
        {
            var ret = (QOpenGLVersionStatus.Internal*) Marshal.AllocHGlobal(12);
            *ret = native;
            return ret;
        }

        private QOpenGLVersionStatus(QOpenGLVersionStatus.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLVersionStatus(QOpenGLVersionStatus.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public QOpenGLVersionStatus.OpenGLStatus Status
        {
            get
            {
                return ((Internal*) __Instance)->status;
            }

            set
            {
                ((Internal*) __Instance)->status = value;
            }
        }
    }

    public unsafe partial class QOpenGLVersionFunctionsBackend : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLVersionFunctionsBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLVersionFunctionsBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLVersionFunctionsBackend((QOpenGLVersionFunctionsBackend.Internal*) native);
        }

        public static QOpenGLVersionFunctionsBackend __CreateInstance(QOpenGLVersionFunctionsBackend.Internal native)
        {
            return new QOpenGLVersionFunctionsBackend(native);
        }

        private static QOpenGLVersionFunctionsBackend.Internal* __CopyValue(QOpenGLVersionFunctionsBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLVersionFunctionsBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLVersionFunctionsBackend.Internal*) ret;
        }

        private QOpenGLVersionFunctionsBackend(QOpenGLVersionFunctionsBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLVersionFunctionsBackend(QOpenGLVersionFunctionsBackend.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public QOpenGLContext Context
        {
            get
            {
                return (((Internal*) __Instance)->context == IntPtr.Zero) ? null : QOpenGLContext.__CreateInstance(((Internal*) __Instance)->context);
            }

            set
            {
                ((Internal*) __Instance)->context = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class QAbstractOpenGLFunctionsPrivate
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr owningContext;

            [FieldOffset(4)]
            public bool initialized;
        }
    }

    /// <summary>
    /// <para>The QAbstractOpenGLFunctions class is the base class of a family
    /// of classes that expose all functions for each OpenGL version and
    /// profile.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>OpenGL implementations on different platforms are able to link to
    /// a variable number of OpenGL functions depending upon the OpenGL ABI on that
    /// platform. For example, on Microsoft Windows only functions up to those in
    /// OpenGL 1.1 can be linked to at build time. All other functions must be
    /// resolved at runtime. The traditional solution to this has been to use
    /// either QOpenGLContext::getProcAddress() or QOpenGLFunctions. The former is
    /// tedious and error prone and means dealing directly with function pointers.
    /// The latter only exposes those functions common to OpenGL ES 2 and desktop
    /// OpenGL. There is however much new OpenGL functionality that is useful when
    /// writing real world OpenGL applications.</para>
    /// <para>Qt now provides a family of classes which all inherit from
    /// QAbstractOpenGLFunctions which expose every core OpenGL function by way of
    /// a corresponding member function. There is a class for every valid
    /// combination of OpenGL version and profile. Each class follows the naming
    /// convention:</para>
    /// <para>QOpenGLFunctions_&lt;MAJOR VERSION&gt;_&lt;MINOR
    /// VERSION&gt;[_PROFILE]</para>
    /// <para>For OpenGL versions 1.0 through to 3.0 there are no profiles,
    /// leading to the classes:</para>
    /// <para></para>
    /// <para>QOpenGLFunctions_1_0</para>
    /// <para>QOpenGLFunctions_1_1</para>
    /// <para>QOpenGLFunctions_1_2</para>
    /// <para>QOpenGLFunctions_1_3</para>
    /// <para>QOpenGLFunctions_1_4</para>
    /// <para>QOpenGLFunctions_1_5</para>
    /// <para>QOpenGLFunctions_2_0</para>
    /// <para>QOpenGLFunctions_2_1</para>
    /// <para>QOpenGLFunctions_3_0</para>
    /// <para></para>
    /// <para>where each class inherits from QAbstractOpenGLFunctions.</para>
    /// <para>OpenGL version 3.1 removed many deprecated functions leading to a
    /// much simpler and generic API.</para>
    /// <para>With OpenGL 3.2 the concept of profiles was introduced. Two
    /// profiles are currently defined for OpenGL: Core and Compatibility.</para>
    /// <para>The Core profile does not include any of the functions that were
    /// removed in OpenGL 3.1. The Compatibility profile contains all functions in
    /// the Core profile of the same version plus all of the functions that were
    /// removed in OpenGL 3.1. In this way the Compatibility profile classes allow
    /// use of newer OpenGL functionality but also allows you to keep using your
    /// legacy OpenGL code. For new OpenGL code the Core profile should be
    /// preferred.</para>
    /// <para>Please note that some vendors, notably Apple, do not implement
    /// the Compatibility profile. Therefore if you wish to target new OpenGL
    /// features on OS X then you should ensure that you request a Core profile
    /// context via QSurfaceFormat::setProfile().</para>
    /// <para>Qt provides classes for all version and Core and Compatibility
    /// profile combinations. The classes for OpenGL versions 3.1 through to 4.3
    /// are:</para>
    /// <para></para>
    /// <para>QOpenGLFunctions_3_1</para>
    /// <para>QOpenGLFunctions_3_2_Core</para>
    /// <para>QOpenGLFunctions_3_2_Compatibility</para>
    /// <para>QOpenGLFunctions_3_3_Core</para>
    /// <para>QOpenGLFunctions_3_3_Compatibility</para>
    /// <para>QOpenGLFunctions_4_0_Core</para>
    /// <para>QOpenGLFunctions_4_0_Compatibility</para>
    /// <para>QOpenGLFunctions_4_1_Core</para>
    /// <para>QOpenGLFunctions_4_1_Compatibility</para>
    /// <para>QOpenGLFunctions_4_2_Core</para>
    /// <para>QOpenGLFunctions_4_2_Compatibility</para>
    /// <para>QOpenGLFunctions_4_3_Core</para>
    /// <para>QOpenGLFunctions_4_3_Compatibility</para>
    /// <para></para>
    /// <para>where each class inherits from QAbstractOpenGLFunctions.</para>
    /// <para>A pointer to an object of the class corresponding to the version
    /// and profile of OpenGL in use can be obtained from
    /// QOpenGLContext::versionFunctions(). If obtained in this way, note that the
    /// QOpenGLContext retains ownership of the object. This is so that only one
    /// instance need be created.</para>
    /// <para>Before calling any of the exposed OpenGL functions you must
    /// ensure that the object has resolved the function pointers to the OpenGL
    /// functions. This only needs to be done once per instance with
    /// initializeOpenGLFunctions(). Once initialized, the object can be used to
    /// call any OpenGL function for the corresponding version and profile. Note
    /// that initializeOpenGLFunctions() can fail in some circumstances so check
    /// the return value. Situations in which initialization can fail are if you
    /// have a functions object for a version or profile that contains functions
    /// that are not part of the context being used to resolve the function
    /// pointers.</para>
    /// <para>If you exclusively use function objects then you will get compile
    /// time errors if you attempt to use a function not included in that version
    /// and profile. This is obviously a lot easier to debug than undefined
    /// behavior at run time.</para>
    /// <para></para>
    /// <para>See also QOpenGLContext::versionFunctions().</para>
    /// </remarks>
    public unsafe partial class QAbstractOpenGLFunctions : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QAbstractOpenGLFunctionsC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QAbstractOpenGLFunctionsD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QAbstractOpenGLFunctions __CreateInstance(global::System.IntPtr native)
        {
            return new QAbstractOpenGLFunctions((QAbstractOpenGLFunctions.Internal*) native);
        }

        public static QAbstractOpenGLFunctions __CreateInstance(QAbstractOpenGLFunctions.Internal native)
        {
            return new QAbstractOpenGLFunctions(native);
        }

        private static QAbstractOpenGLFunctions.Internal* __CopyValue(QAbstractOpenGLFunctions.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QAbstractOpenGLFunctions.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QAbstractOpenGLFunctions.Internal*) ret;
        }

        private QAbstractOpenGLFunctions(QAbstractOpenGLFunctions.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAbstractOpenGLFunctions(QAbstractOpenGLFunctions.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_1_0_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 200)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr Viewport;

            [FieldOffset(12)]
            public global::System.IntPtr DepthRange;

            [FieldOffset(16)]
            public global::System.IntPtr IsEnabled;

            [FieldOffset(20)]
            public global::System.IntPtr GetTexLevelParameteriv;

            [FieldOffset(24)]
            public global::System.IntPtr GetTexLevelParameterfv;

            [FieldOffset(28)]
            public global::System.IntPtr GetTexParameteriv;

            [FieldOffset(32)]
            public global::System.IntPtr GetTexParameterfv;

            [FieldOffset(36)]
            public global::System.IntPtr GetTexImage;

            [FieldOffset(40)]
            public global::System.IntPtr GetString;

            [FieldOffset(44)]
            public global::System.IntPtr GetIntegerv;

            [FieldOffset(48)]
            public global::System.IntPtr GetFloatv;

            [FieldOffset(52)]
            public global::System.IntPtr GetError;

            [FieldOffset(56)]
            public global::System.IntPtr GetDoublev;

            [FieldOffset(60)]
            public global::System.IntPtr GetBooleanv;

            [FieldOffset(64)]
            public global::System.IntPtr ReadPixels;

            [FieldOffset(68)]
            public global::System.IntPtr ReadBuffer;

            [FieldOffset(72)]
            public global::System.IntPtr PixelStorei;

            [FieldOffset(76)]
            public global::System.IntPtr PixelStoref;

            [FieldOffset(80)]
            public global::System.IntPtr DepthFunc;

            [FieldOffset(84)]
            public global::System.IntPtr StencilOp;

            [FieldOffset(88)]
            public global::System.IntPtr StencilFunc;

            [FieldOffset(92)]
            public global::System.IntPtr LogicOp;

            [FieldOffset(96)]
            public global::System.IntPtr BlendFunc;

            [FieldOffset(100)]
            public global::System.IntPtr Flush;

            [FieldOffset(104)]
            public global::System.IntPtr Finish;

            [FieldOffset(108)]
            public global::System.IntPtr Enable;

            [FieldOffset(112)]
            public global::System.IntPtr Disable;

            [FieldOffset(116)]
            public global::System.IntPtr DepthMask;

            [FieldOffset(120)]
            public global::System.IntPtr ColorMask;

            [FieldOffset(124)]
            public global::System.IntPtr StencilMask;

            [FieldOffset(128)]
            public global::System.IntPtr ClearDepth;

            [FieldOffset(132)]
            public global::System.IntPtr ClearStencil;

            [FieldOffset(136)]
            public global::System.IntPtr ClearColor;

            [FieldOffset(140)]
            public global::System.IntPtr Clear;

            [FieldOffset(144)]
            public global::System.IntPtr DrawBuffer;

            [FieldOffset(148)]
            public global::System.IntPtr TexImage2D;

            [FieldOffset(152)]
            public global::System.IntPtr TexImage1D;

            [FieldOffset(156)]
            public global::System.IntPtr TexParameteriv;

            [FieldOffset(160)]
            public global::System.IntPtr TexParameteri;

            [FieldOffset(164)]
            public global::System.IntPtr TexParameterfv;

            [FieldOffset(168)]
            public global::System.IntPtr TexParameterf;

            [FieldOffset(172)]
            public global::System.IntPtr Scissor;

            [FieldOffset(176)]
            public global::System.IntPtr PolygonMode;

            [FieldOffset(180)]
            public global::System.IntPtr PointSize;

            [FieldOffset(184)]
            public global::System.IntPtr LineWidth;

            [FieldOffset(188)]
            public global::System.IntPtr Hint;

            [FieldOffset(192)]
            public global::System.IntPtr FrontFace;

            [FieldOffset(196)]
            public global::System.IntPtr CullFace;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_1_0_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_0_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_0_CoreBackend((QOpenGLFunctions_1_0_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_0_CoreBackend __CreateInstance(QOpenGLFunctions_1_0_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_1_0_CoreBackend(native);
        }

        private static QOpenGLFunctions_1_0_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_1_0_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(200);
            QtGui.QOpenGLFunctions_1_0_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_0_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_0_CoreBackend(QOpenGLFunctions_1_0_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_0_CoreBackend(QOpenGLFunctions_1_0_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public Action Flush
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->Flush;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action Finish
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->Finish;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_1_1_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr Indexubv;

            [FieldOffset(12)]
            public global::System.IntPtr Indexub;

            [FieldOffset(16)]
            public global::System.IntPtr IsTexture;

            [FieldOffset(20)]
            public global::System.IntPtr GenTextures;

            [FieldOffset(24)]
            public global::System.IntPtr DeleteTextures;

            [FieldOffset(28)]
            public global::System.IntPtr BindTexture;

            [FieldOffset(32)]
            public global::System.IntPtr TexSubImage2D;

            [FieldOffset(36)]
            public global::System.IntPtr TexSubImage1D;

            [FieldOffset(40)]
            public global::System.IntPtr CopyTexSubImage2D;

            [FieldOffset(44)]
            public global::System.IntPtr CopyTexSubImage1D;

            [FieldOffset(48)]
            public global::System.IntPtr CopyTexImage2D;

            [FieldOffset(52)]
            public global::System.IntPtr CopyTexImage1D;

            [FieldOffset(56)]
            public global::System.IntPtr PolygonOffset;

            [FieldOffset(60)]
            public global::System.IntPtr GetPointerv;

            [FieldOffset(64)]
            public global::System.IntPtr DrawElements;

            [FieldOffset(68)]
            public global::System.IntPtr DrawArrays;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_1_1_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_1_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_1_CoreBackend((QOpenGLFunctions_1_1_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_1_CoreBackend __CreateInstance(QOpenGLFunctions_1_1_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_1_1_CoreBackend(native);
        }

        private static QOpenGLFunctions_1_1_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_1_1_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(72);
            QtGui.QOpenGLFunctions_1_1_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_1_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_1_CoreBackend(QOpenGLFunctions_1_1_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_1_CoreBackend(QOpenGLFunctions_1_1_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_2_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr CopyTexSubImage3D;

            [FieldOffset(12)]
            public global::System.IntPtr TexSubImage3D;

            [FieldOffset(16)]
            public global::System.IntPtr TexImage3D;

            [FieldOffset(20)]
            public global::System.IntPtr DrawRangeElements;

            [FieldOffset(24)]
            public global::System.IntPtr BlendEquation;

            [FieldOffset(28)]
            public global::System.IntPtr BlendColor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_1_2_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_2_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_2_CoreBackend((QOpenGLFunctions_1_2_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_2_CoreBackend __CreateInstance(QOpenGLFunctions_1_2_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_1_2_CoreBackend(native);
        }

        private static QOpenGLFunctions_1_2_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_1_2_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QOpenGLFunctions_1_2_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_2_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_2_CoreBackend(QOpenGLFunctions_1_2_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_2_CoreBackend(QOpenGLFunctions_1_2_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_3_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr GetCompressedTexImage;

            [FieldOffset(12)]
            public global::System.IntPtr CompressedTexSubImage1D;

            [FieldOffset(16)]
            public global::System.IntPtr CompressedTexSubImage2D;

            [FieldOffset(20)]
            public global::System.IntPtr CompressedTexSubImage3D;

            [FieldOffset(24)]
            public global::System.IntPtr CompressedTexImage1D;

            [FieldOffset(28)]
            public global::System.IntPtr CompressedTexImage2D;

            [FieldOffset(32)]
            public global::System.IntPtr CompressedTexImage3D;

            [FieldOffset(36)]
            public global::System.IntPtr SampleCoverage;

            [FieldOffset(40)]
            public global::System.IntPtr ActiveTexture;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_1_3_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_3_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_3_CoreBackend((QOpenGLFunctions_1_3_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_3_CoreBackend __CreateInstance(QOpenGLFunctions_1_3_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_1_3_CoreBackend(native);
        }

        private static QOpenGLFunctions_1_3_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_1_3_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(44);
            QtGui.QOpenGLFunctions_1_3_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_3_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_3_CoreBackend(QOpenGLFunctions_1_3_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_3_CoreBackend(QOpenGLFunctions_1_3_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_4_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr PointParameteriv;

            [FieldOffset(12)]
            public global::System.IntPtr PointParameteri;

            [FieldOffset(16)]
            public global::System.IntPtr PointParameterfv;

            [FieldOffset(20)]
            public global::System.IntPtr PointParameterf;

            [FieldOffset(24)]
            public global::System.IntPtr MultiDrawElements;

            [FieldOffset(28)]
            public global::System.IntPtr MultiDrawArrays;

            [FieldOffset(32)]
            public global::System.IntPtr BlendFuncSeparate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_1_4_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_4_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_4_CoreBackend((QOpenGLFunctions_1_4_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_4_CoreBackend __CreateInstance(QOpenGLFunctions_1_4_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_1_4_CoreBackend(native);
        }

        private static QOpenGLFunctions_1_4_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_1_4_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(36);
            QtGui.QOpenGLFunctions_1_4_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_4_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_4_CoreBackend(QOpenGLFunctions_1_4_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_4_CoreBackend(QOpenGLFunctions_1_4_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_5_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 84)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr GetBufferPointerv;

            [FieldOffset(12)]
            public global::System.IntPtr GetBufferParameteriv;

            [FieldOffset(16)]
            public global::System.IntPtr UnmapBuffer;

            [FieldOffset(20)]
            public global::System.IntPtr MapBuffer;

            [FieldOffset(24)]
            public global::System.IntPtr GetBufferSubData;

            [FieldOffset(28)]
            public global::System.IntPtr BufferSubData;

            [FieldOffset(32)]
            public global::System.IntPtr BufferData;

            [FieldOffset(36)]
            public global::System.IntPtr IsBuffer;

            [FieldOffset(40)]
            public global::System.IntPtr GenBuffers;

            [FieldOffset(44)]
            public global::System.IntPtr DeleteBuffers;

            [FieldOffset(48)]
            public global::System.IntPtr BindBuffer;

            [FieldOffset(52)]
            public global::System.IntPtr GetQueryObjectuiv;

            [FieldOffset(56)]
            public global::System.IntPtr GetQueryObjectiv;

            [FieldOffset(60)]
            public global::System.IntPtr GetQueryiv;

            [FieldOffset(64)]
            public global::System.IntPtr EndQuery;

            [FieldOffset(68)]
            public global::System.IntPtr BeginQuery;

            [FieldOffset(72)]
            public global::System.IntPtr IsQuery;

            [FieldOffset(76)]
            public global::System.IntPtr DeleteQueries;

            [FieldOffset(80)]
            public global::System.IntPtr GenQueries;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_1_5_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_5_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_5_CoreBackend((QOpenGLFunctions_1_5_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_5_CoreBackend __CreateInstance(QOpenGLFunctions_1_5_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_1_5_CoreBackend(native);
        }

        private static QOpenGLFunctions_1_5_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_1_5_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(84);
            QtGui.QOpenGLFunctions_1_5_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_5_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_5_CoreBackend(QOpenGLFunctions_1_5_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_5_CoreBackend(QOpenGLFunctions_1_5_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_2_0_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 236)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr VertexAttribPointer;

            [FieldOffset(12)]
            public global::System.IntPtr ValidateProgram;

            [FieldOffset(16)]
            public global::System.IntPtr UniformMatrix4fv;

            [FieldOffset(20)]
            public global::System.IntPtr UniformMatrix3fv;

            [FieldOffset(24)]
            public global::System.IntPtr UniformMatrix2fv;

            [FieldOffset(28)]
            public global::System.IntPtr Uniform4iv;

            [FieldOffset(32)]
            public global::System.IntPtr Uniform3iv;

            [FieldOffset(36)]
            public global::System.IntPtr Uniform2iv;

            [FieldOffset(40)]
            public global::System.IntPtr Uniform1iv;

            [FieldOffset(44)]
            public global::System.IntPtr Uniform4fv;

            [FieldOffset(48)]
            public global::System.IntPtr Uniform3fv;

            [FieldOffset(52)]
            public global::System.IntPtr Uniform2fv;

            [FieldOffset(56)]
            public global::System.IntPtr Uniform1fv;

            [FieldOffset(60)]
            public global::System.IntPtr Uniform4i;

            [FieldOffset(64)]
            public global::System.IntPtr Uniform3i;

            [FieldOffset(68)]
            public global::System.IntPtr Uniform2i;

            [FieldOffset(72)]
            public global::System.IntPtr Uniform1i;

            [FieldOffset(76)]
            public global::System.IntPtr Uniform4f;

            [FieldOffset(80)]
            public global::System.IntPtr Uniform3f;

            [FieldOffset(84)]
            public global::System.IntPtr Uniform2f;

            [FieldOffset(88)]
            public global::System.IntPtr Uniform1f;

            [FieldOffset(92)]
            public global::System.IntPtr UseProgram;

            [FieldOffset(96)]
            public global::System.IntPtr ShaderSource;

            [FieldOffset(100)]
            public global::System.IntPtr LinkProgram;

            [FieldOffset(104)]
            public global::System.IntPtr IsShader;

            [FieldOffset(108)]
            public global::System.IntPtr IsProgram;

            [FieldOffset(112)]
            public global::System.IntPtr GetVertexAttribPointerv;

            [FieldOffset(116)]
            public global::System.IntPtr GetVertexAttribiv;

            [FieldOffset(120)]
            public global::System.IntPtr GetVertexAttribfv;

            [FieldOffset(124)]
            public global::System.IntPtr GetVertexAttribdv;

            [FieldOffset(128)]
            public global::System.IntPtr GetUniformiv;

            [FieldOffset(132)]
            public global::System.IntPtr GetUniformfv;

            [FieldOffset(136)]
            public global::System.IntPtr GetUniformLocation;

            [FieldOffset(140)]
            public global::System.IntPtr GetShaderSource;

            [FieldOffset(144)]
            public global::System.IntPtr GetShaderInfoLog;

            [FieldOffset(148)]
            public global::System.IntPtr GetShaderiv;

            [FieldOffset(152)]
            public global::System.IntPtr GetProgramInfoLog;

            [FieldOffset(156)]
            public global::System.IntPtr GetProgramiv;

            [FieldOffset(160)]
            public global::System.IntPtr GetAttribLocation;

            [FieldOffset(164)]
            public global::System.IntPtr GetAttachedShaders;

            [FieldOffset(168)]
            public global::System.IntPtr GetActiveUniform;

            [FieldOffset(172)]
            public global::System.IntPtr GetActiveAttrib;

            [FieldOffset(176)]
            public global::System.IntPtr EnableVertexAttribArray;

            [FieldOffset(180)]
            public global::System.IntPtr DisableVertexAttribArray;

            [FieldOffset(184)]
            public global::System.IntPtr DetachShader;

            [FieldOffset(188)]
            public global::System.IntPtr DeleteShader;

            [FieldOffset(192)]
            public global::System.IntPtr DeleteProgram;

            [FieldOffset(196)]
            public global::System.IntPtr CreateShader;

            [FieldOffset(200)]
            public global::System.IntPtr CreateProgram;

            [FieldOffset(204)]
            public global::System.IntPtr CompileShader;

            [FieldOffset(208)]
            public global::System.IntPtr BindAttribLocation;

            [FieldOffset(212)]
            public global::System.IntPtr AttachShader;

            [FieldOffset(216)]
            public global::System.IntPtr StencilMaskSeparate;

            [FieldOffset(220)]
            public global::System.IntPtr StencilFuncSeparate;

            [FieldOffset(224)]
            public global::System.IntPtr StencilOpSeparate;

            [FieldOffset(228)]
            public global::System.IntPtr DrawBuffers;

            [FieldOffset(232)]
            public global::System.IntPtr BlendEquationSeparate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_2_0_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_2_0_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_2_0_CoreBackend((QOpenGLFunctions_2_0_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_2_0_CoreBackend __CreateInstance(QOpenGLFunctions_2_0_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_2_0_CoreBackend(native);
        }

        private static QOpenGLFunctions_2_0_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_2_0_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(236);
            QtGui.QOpenGLFunctions_2_0_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_2_0_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_2_0_CoreBackend(QOpenGLFunctions_2_0_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_2_0_CoreBackend(QOpenGLFunctions_2_0_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_2_1_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr UniformMatrix4x3fv;

            [FieldOffset(12)]
            public global::System.IntPtr UniformMatrix3x4fv;

            [FieldOffset(16)]
            public global::System.IntPtr UniformMatrix4x2fv;

            [FieldOffset(20)]
            public global::System.IntPtr UniformMatrix2x4fv;

            [FieldOffset(24)]
            public global::System.IntPtr UniformMatrix3x2fv;

            [FieldOffset(28)]
            public global::System.IntPtr UniformMatrix2x3fv;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_2_1_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_2_1_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_2_1_CoreBackend((QOpenGLFunctions_2_1_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_2_1_CoreBackend __CreateInstance(QOpenGLFunctions_2_1_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_2_1_CoreBackend(native);
        }

        private static QOpenGLFunctions_2_1_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_2_1_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QOpenGLFunctions_2_1_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_2_1_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_2_1_CoreBackend(QOpenGLFunctions_2_1_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_2_1_CoreBackend(QOpenGLFunctions_2_1_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_3_0_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 264)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr IsVertexArray;

            [FieldOffset(12)]
            public global::System.IntPtr GenVertexArrays;

            [FieldOffset(16)]
            public global::System.IntPtr DeleteVertexArrays;

            [FieldOffset(20)]
            public global::System.IntPtr BindVertexArray;

            [FieldOffset(24)]
            public global::System.IntPtr FlushMappedBufferRange;

            [FieldOffset(28)]
            public global::System.IntPtr MapBufferRange;

            [FieldOffset(32)]
            public global::System.IntPtr FramebufferTextureLayer;

            [FieldOffset(36)]
            public global::System.IntPtr RenderbufferStorageMultisample;

            [FieldOffset(40)]
            public global::System.IntPtr BlitFramebuffer;

            [FieldOffset(44)]
            public global::System.IntPtr GenerateMipmap;

            [FieldOffset(48)]
            public global::System.IntPtr GetFramebufferAttachmentParameteriv;

            [FieldOffset(52)]
            public global::System.IntPtr FramebufferRenderbuffer;

            [FieldOffset(56)]
            public global::System.IntPtr FramebufferTexture3D;

            [FieldOffset(60)]
            public global::System.IntPtr FramebufferTexture2D;

            [FieldOffset(64)]
            public global::System.IntPtr FramebufferTexture1D;

            [FieldOffset(68)]
            public global::System.IntPtr CheckFramebufferStatus;

            [FieldOffset(72)]
            public global::System.IntPtr GenFramebuffers;

            [FieldOffset(76)]
            public global::System.IntPtr DeleteFramebuffers;

            [FieldOffset(80)]
            public global::System.IntPtr BindFramebuffer;

            [FieldOffset(84)]
            public global::System.IntPtr IsFramebuffer;

            [FieldOffset(88)]
            public global::System.IntPtr GetRenderbufferParameteriv;

            [FieldOffset(92)]
            public global::System.IntPtr RenderbufferStorage;

            [FieldOffset(96)]
            public global::System.IntPtr GenRenderbuffers;

            [FieldOffset(100)]
            public global::System.IntPtr DeleteRenderbuffers;

            [FieldOffset(104)]
            public global::System.IntPtr BindRenderbuffer;

            [FieldOffset(108)]
            public global::System.IntPtr IsRenderbuffer;

            [FieldOffset(112)]
            public global::System.IntPtr GetStringi;

            [FieldOffset(116)]
            public global::System.IntPtr ClearBufferfi;

            [FieldOffset(120)]
            public global::System.IntPtr ClearBufferfv;

            [FieldOffset(124)]
            public global::System.IntPtr ClearBufferuiv;

            [FieldOffset(128)]
            public global::System.IntPtr ClearBufferiv;

            [FieldOffset(132)]
            public global::System.IntPtr GetTexParameterIuiv;

            [FieldOffset(136)]
            public global::System.IntPtr GetTexParameterIiv;

            [FieldOffset(140)]
            public global::System.IntPtr TexParameterIuiv;

            [FieldOffset(144)]
            public global::System.IntPtr TexParameterIiv;

            [FieldOffset(148)]
            public global::System.IntPtr Uniform4uiv;

            [FieldOffset(152)]
            public global::System.IntPtr Uniform3uiv;

            [FieldOffset(156)]
            public global::System.IntPtr Uniform2uiv;

            [FieldOffset(160)]
            public global::System.IntPtr Uniform1uiv;

            [FieldOffset(164)]
            public global::System.IntPtr Uniform4ui;

            [FieldOffset(168)]
            public global::System.IntPtr Uniform3ui;

            [FieldOffset(172)]
            public global::System.IntPtr Uniform2ui;

            [FieldOffset(176)]
            public global::System.IntPtr Uniform1ui;

            [FieldOffset(180)]
            public global::System.IntPtr GetFragDataLocation;

            [FieldOffset(184)]
            public global::System.IntPtr BindFragDataLocation;

            [FieldOffset(188)]
            public global::System.IntPtr GetUniformuiv;

            [FieldOffset(192)]
            public global::System.IntPtr GetVertexAttribIuiv;

            [FieldOffset(196)]
            public global::System.IntPtr GetVertexAttribIiv;

            [FieldOffset(200)]
            public global::System.IntPtr VertexAttribIPointer;

            [FieldOffset(204)]
            public global::System.IntPtr EndConditionalRender;

            [FieldOffset(208)]
            public global::System.IntPtr BeginConditionalRender;

            [FieldOffset(212)]
            public global::System.IntPtr ClampColor;

            [FieldOffset(216)]
            public global::System.IntPtr GetTransformFeedbackVarying;

            [FieldOffset(220)]
            public global::System.IntPtr TransformFeedbackVaryings;

            [FieldOffset(224)]
            public global::System.IntPtr BindBufferBase;

            [FieldOffset(228)]
            public global::System.IntPtr BindBufferRange;

            [FieldOffset(232)]
            public global::System.IntPtr EndTransformFeedback;

            [FieldOffset(236)]
            public global::System.IntPtr BeginTransformFeedback;

            [FieldOffset(240)]
            public global::System.IntPtr IsEnabledi;

            [FieldOffset(244)]
            public global::System.IntPtr Disablei;

            [FieldOffset(248)]
            public global::System.IntPtr Enablei;

            [FieldOffset(252)]
            public global::System.IntPtr GetIntegeri_v;

            [FieldOffset(256)]
            public global::System.IntPtr GetBooleani_v;

            [FieldOffset(260)]
            public global::System.IntPtr ColorMaski;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_3_0_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_3_0_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_3_0_CoreBackend((QOpenGLFunctions_3_0_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_3_0_CoreBackend __CreateInstance(QOpenGLFunctions_3_0_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_3_0_CoreBackend(native);
        }

        private static QOpenGLFunctions_3_0_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_3_0_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(264);
            QtGui.QOpenGLFunctions_3_0_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_3_0_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_3_0_CoreBackend(QOpenGLFunctions_3_0_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_3_0_CoreBackend(QOpenGLFunctions_3_0_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public Action EndConditionalRender
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->EndConditionalRender;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action EndTransformFeedback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->EndTransformFeedback;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_3_1_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr CopyBufferSubData;

            [FieldOffset(12)]
            public global::System.IntPtr UniformBlockBinding;

            [FieldOffset(16)]
            public global::System.IntPtr GetActiveUniformBlockName;

            [FieldOffset(20)]
            public global::System.IntPtr GetActiveUniformBlockiv;

            [FieldOffset(24)]
            public global::System.IntPtr GetUniformBlockIndex;

            [FieldOffset(28)]
            public global::System.IntPtr GetActiveUniformName;

            [FieldOffset(32)]
            public global::System.IntPtr GetActiveUniformsiv;

            [FieldOffset(36)]
            public global::System.IntPtr GetUniformIndices;

            [FieldOffset(40)]
            public global::System.IntPtr PrimitiveRestartIndex;

            [FieldOffset(44)]
            public global::System.IntPtr TexBuffer;

            [FieldOffset(48)]
            public global::System.IntPtr DrawElementsInstanced;

            [FieldOffset(52)]
            public global::System.IntPtr DrawArraysInstanced;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_3_1_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_3_1_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_3_1_CoreBackend((QOpenGLFunctions_3_1_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_3_1_CoreBackend __CreateInstance(QOpenGLFunctions_3_1_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_3_1_CoreBackend(native);
        }

        private static QOpenGLFunctions_3_1_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_3_1_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(56);
            QtGui.QOpenGLFunctions_3_1_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_3_1_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_3_1_CoreBackend(QOpenGLFunctions_3_1_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_3_1_CoreBackend(QOpenGLFunctions_3_1_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_3_2_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 84)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr SampleMaski;

            [FieldOffset(12)]
            public global::System.IntPtr GetMultisamplefv;

            [FieldOffset(16)]
            public global::System.IntPtr TexImage3DMultisample;

            [FieldOffset(20)]
            public global::System.IntPtr TexImage2DMultisample;

            [FieldOffset(24)]
            public global::System.IntPtr GetSynciv;

            [FieldOffset(28)]
            public global::System.IntPtr GetInteger64v;

            [FieldOffset(32)]
            public global::System.IntPtr WaitSync;

            [FieldOffset(36)]
            public global::System.IntPtr ClientWaitSync;

            [FieldOffset(40)]
            public global::System.IntPtr DeleteSync;

            [FieldOffset(44)]
            public global::System.IntPtr IsSync;

            [FieldOffset(48)]
            public global::System.IntPtr FenceSync;

            [FieldOffset(52)]
            public global::System.IntPtr ProvokingVertex;

            [FieldOffset(56)]
            public global::System.IntPtr MultiDrawElementsBaseVertex;

            [FieldOffset(60)]
            public global::System.IntPtr DrawElementsInstancedBaseVertex;

            [FieldOffset(64)]
            public global::System.IntPtr DrawRangeElementsBaseVertex;

            [FieldOffset(68)]
            public global::System.IntPtr DrawElementsBaseVertex;

            [FieldOffset(72)]
            public global::System.IntPtr FramebufferTexture;

            [FieldOffset(76)]
            public global::System.IntPtr GetBufferParameteri64v;

            [FieldOffset(80)]
            public global::System.IntPtr GetInteger64i_v;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_3_2_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_3_2_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_3_2_CoreBackend((QOpenGLFunctions_3_2_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_3_2_CoreBackend __CreateInstance(QOpenGLFunctions_3_2_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_3_2_CoreBackend(native);
        }

        private static QOpenGLFunctions_3_2_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_3_2_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(84);
            QtGui.QOpenGLFunctions_3_2_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_3_2_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_3_2_CoreBackend(QOpenGLFunctions_3_2_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_3_2_CoreBackend(QOpenGLFunctions_3_2_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_3_3_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 240)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr VertexAttribP4uiv;

            [FieldOffset(12)]
            public global::System.IntPtr VertexAttribP4ui;

            [FieldOffset(16)]
            public global::System.IntPtr VertexAttribP3uiv;

            [FieldOffset(20)]
            public global::System.IntPtr VertexAttribP3ui;

            [FieldOffset(24)]
            public global::System.IntPtr VertexAttribP2uiv;

            [FieldOffset(28)]
            public global::System.IntPtr VertexAttribP2ui;

            [FieldOffset(32)]
            public global::System.IntPtr VertexAttribP1uiv;

            [FieldOffset(36)]
            public global::System.IntPtr VertexAttribP1ui;

            [FieldOffset(40)]
            public global::System.IntPtr SecondaryColorP3uiv;

            [FieldOffset(44)]
            public global::System.IntPtr SecondaryColorP3ui;

            [FieldOffset(48)]
            public global::System.IntPtr ColorP4uiv;

            [FieldOffset(52)]
            public global::System.IntPtr ColorP4ui;

            [FieldOffset(56)]
            public global::System.IntPtr ColorP3uiv;

            [FieldOffset(60)]
            public global::System.IntPtr ColorP3ui;

            [FieldOffset(64)]
            public global::System.IntPtr NormalP3uiv;

            [FieldOffset(68)]
            public global::System.IntPtr NormalP3ui;

            [FieldOffset(72)]
            public global::System.IntPtr MultiTexCoordP4uiv;

            [FieldOffset(76)]
            public global::System.IntPtr MultiTexCoordP4ui;

            [FieldOffset(80)]
            public global::System.IntPtr MultiTexCoordP3uiv;

            [FieldOffset(84)]
            public global::System.IntPtr MultiTexCoordP3ui;

            [FieldOffset(88)]
            public global::System.IntPtr MultiTexCoordP2uiv;

            [FieldOffset(92)]
            public global::System.IntPtr MultiTexCoordP2ui;

            [FieldOffset(96)]
            public global::System.IntPtr MultiTexCoordP1uiv;

            [FieldOffset(100)]
            public global::System.IntPtr MultiTexCoordP1ui;

            [FieldOffset(104)]
            public global::System.IntPtr TexCoordP4uiv;

            [FieldOffset(108)]
            public global::System.IntPtr TexCoordP4ui;

            [FieldOffset(112)]
            public global::System.IntPtr TexCoordP3uiv;

            [FieldOffset(116)]
            public global::System.IntPtr TexCoordP3ui;

            [FieldOffset(120)]
            public global::System.IntPtr TexCoordP2uiv;

            [FieldOffset(124)]
            public global::System.IntPtr TexCoordP2ui;

            [FieldOffset(128)]
            public global::System.IntPtr TexCoordP1uiv;

            [FieldOffset(132)]
            public global::System.IntPtr TexCoordP1ui;

            [FieldOffset(136)]
            public global::System.IntPtr VertexP4uiv;

            [FieldOffset(140)]
            public global::System.IntPtr VertexP4ui;

            [FieldOffset(144)]
            public global::System.IntPtr VertexP3uiv;

            [FieldOffset(148)]
            public global::System.IntPtr VertexP3ui;

            [FieldOffset(152)]
            public global::System.IntPtr VertexP2uiv;

            [FieldOffset(156)]
            public global::System.IntPtr VertexP2ui;

            [FieldOffset(160)]
            public global::System.IntPtr GetQueryObjectui64v;

            [FieldOffset(164)]
            public global::System.IntPtr GetQueryObjecti64v;

            [FieldOffset(168)]
            public global::System.IntPtr QueryCounter;

            [FieldOffset(172)]
            public global::System.IntPtr GetSamplerParameterIuiv;

            [FieldOffset(176)]
            public global::System.IntPtr GetSamplerParameterfv;

            [FieldOffset(180)]
            public global::System.IntPtr GetSamplerParameterIiv;

            [FieldOffset(184)]
            public global::System.IntPtr GetSamplerParameteriv;

            [FieldOffset(188)]
            public global::System.IntPtr SamplerParameterIuiv;

            [FieldOffset(192)]
            public global::System.IntPtr SamplerParameterIiv;

            [FieldOffset(196)]
            public global::System.IntPtr SamplerParameterfv;

            [FieldOffset(200)]
            public global::System.IntPtr SamplerParameterf;

            [FieldOffset(204)]
            public global::System.IntPtr SamplerParameteriv;

            [FieldOffset(208)]
            public global::System.IntPtr SamplerParameteri;

            [FieldOffset(212)]
            public global::System.IntPtr BindSampler;

            [FieldOffset(216)]
            public global::System.IntPtr IsSampler;

            [FieldOffset(220)]
            public global::System.IntPtr DeleteSamplers;

            [FieldOffset(224)]
            public global::System.IntPtr GenSamplers;

            [FieldOffset(228)]
            public global::System.IntPtr GetFragDataIndex;

            [FieldOffset(232)]
            public global::System.IntPtr BindFragDataLocationIndexed;

            [FieldOffset(236)]
            public global::System.IntPtr VertexAttribDivisor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_3_3_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_3_3_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_3_3_CoreBackend((QOpenGLFunctions_3_3_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_3_3_CoreBackend __CreateInstance(QOpenGLFunctions_3_3_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_3_3_CoreBackend(native);
        }

        private static QOpenGLFunctions_3_3_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_3_3_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(240);
            QtGui.QOpenGLFunctions_3_3_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_3_3_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_3_3_CoreBackend(QOpenGLFunctions_3_3_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_3_3_CoreBackend(QOpenGLFunctions_3_3_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_4_0_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 192)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr GetQueryIndexediv;

            [FieldOffset(12)]
            public global::System.IntPtr EndQueryIndexed;

            [FieldOffset(16)]
            public global::System.IntPtr BeginQueryIndexed;

            [FieldOffset(20)]
            public global::System.IntPtr DrawTransformFeedbackStream;

            [FieldOffset(24)]
            public global::System.IntPtr DrawTransformFeedback;

            [FieldOffset(28)]
            public global::System.IntPtr ResumeTransformFeedback;

            [FieldOffset(32)]
            public global::System.IntPtr PauseTransformFeedback;

            [FieldOffset(36)]
            public global::System.IntPtr IsTransformFeedback;

            [FieldOffset(40)]
            public global::System.IntPtr GenTransformFeedbacks;

            [FieldOffset(44)]
            public global::System.IntPtr DeleteTransformFeedbacks;

            [FieldOffset(48)]
            public global::System.IntPtr BindTransformFeedback;

            [FieldOffset(52)]
            public global::System.IntPtr PatchParameterfv;

            [FieldOffset(56)]
            public global::System.IntPtr PatchParameteri;

            [FieldOffset(60)]
            public global::System.IntPtr GetProgramStageiv;

            [FieldOffset(64)]
            public global::System.IntPtr GetUniformSubroutineuiv;

            [FieldOffset(68)]
            public global::System.IntPtr UniformSubroutinesuiv;

            [FieldOffset(72)]
            public global::System.IntPtr GetActiveSubroutineName;

            [FieldOffset(76)]
            public global::System.IntPtr GetActiveSubroutineUniformName;

            [FieldOffset(80)]
            public global::System.IntPtr GetActiveSubroutineUniformiv;

            [FieldOffset(84)]
            public global::System.IntPtr GetSubroutineIndex;

            [FieldOffset(88)]
            public global::System.IntPtr GetSubroutineUniformLocation;

            [FieldOffset(92)]
            public global::System.IntPtr GetUniformdv;

            [FieldOffset(96)]
            public global::System.IntPtr UniformMatrix4x3dv;

            [FieldOffset(100)]
            public global::System.IntPtr UniformMatrix4x2dv;

            [FieldOffset(104)]
            public global::System.IntPtr UniformMatrix3x4dv;

            [FieldOffset(108)]
            public global::System.IntPtr UniformMatrix3x2dv;

            [FieldOffset(112)]
            public global::System.IntPtr UniformMatrix2x4dv;

            [FieldOffset(116)]
            public global::System.IntPtr UniformMatrix2x3dv;

            [FieldOffset(120)]
            public global::System.IntPtr UniformMatrix4dv;

            [FieldOffset(124)]
            public global::System.IntPtr UniformMatrix3dv;

            [FieldOffset(128)]
            public global::System.IntPtr UniformMatrix2dv;

            [FieldOffset(132)]
            public global::System.IntPtr Uniform4dv;

            [FieldOffset(136)]
            public global::System.IntPtr Uniform3dv;

            [FieldOffset(140)]
            public global::System.IntPtr Uniform2dv;

            [FieldOffset(144)]
            public global::System.IntPtr Uniform1dv;

            [FieldOffset(148)]
            public global::System.IntPtr Uniform4d;

            [FieldOffset(152)]
            public global::System.IntPtr Uniform3d;

            [FieldOffset(156)]
            public global::System.IntPtr Uniform2d;

            [FieldOffset(160)]
            public global::System.IntPtr Uniform1d;

            [FieldOffset(164)]
            public global::System.IntPtr DrawElementsIndirect;

            [FieldOffset(168)]
            public global::System.IntPtr DrawArraysIndirect;

            [FieldOffset(172)]
            public global::System.IntPtr BlendFuncSeparatei;

            [FieldOffset(176)]
            public global::System.IntPtr BlendFunci;

            [FieldOffset(180)]
            public global::System.IntPtr BlendEquationSeparatei;

            [FieldOffset(184)]
            public global::System.IntPtr BlendEquationi;

            [FieldOffset(188)]
            public global::System.IntPtr MinSampleShading;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_4_0_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_4_0_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_4_0_CoreBackend((QOpenGLFunctions_4_0_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_4_0_CoreBackend __CreateInstance(QOpenGLFunctions_4_0_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_4_0_CoreBackend(native);
        }

        private static QOpenGLFunctions_4_0_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_4_0_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(192);
            QtGui.QOpenGLFunctions_4_0_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_4_0_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_4_0_CoreBackend(QOpenGLFunctions_4_0_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_4_0_CoreBackend(QOpenGLFunctions_4_0_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public Action ResumeTransformFeedback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->ResumeTransformFeedback;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action PauseTransformFeedback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->PauseTransformFeedback;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_4_1_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 360)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr GetDoublei_v;

            [FieldOffset(12)]
            public global::System.IntPtr GetFloati_v;

            [FieldOffset(16)]
            public global::System.IntPtr DepthRangeIndexed;

            [FieldOffset(20)]
            public global::System.IntPtr DepthRangeArrayv;

            [FieldOffset(24)]
            public global::System.IntPtr ScissorIndexedv;

            [FieldOffset(28)]
            public global::System.IntPtr ScissorIndexed;

            [FieldOffset(32)]
            public global::System.IntPtr ScissorArrayv;

            [FieldOffset(36)]
            public global::System.IntPtr ViewportIndexedfv;

            [FieldOffset(40)]
            public global::System.IntPtr ViewportIndexedf;

            [FieldOffset(44)]
            public global::System.IntPtr ViewportArrayv;

            [FieldOffset(48)]
            public global::System.IntPtr GetVertexAttribLdv;

            [FieldOffset(52)]
            public global::System.IntPtr VertexAttribLPointer;

            [FieldOffset(56)]
            public global::System.IntPtr VertexAttribL4dv;

            [FieldOffset(60)]
            public global::System.IntPtr VertexAttribL3dv;

            [FieldOffset(64)]
            public global::System.IntPtr VertexAttribL2dv;

            [FieldOffset(68)]
            public global::System.IntPtr VertexAttribL1dv;

            [FieldOffset(72)]
            public global::System.IntPtr VertexAttribL4d;

            [FieldOffset(76)]
            public global::System.IntPtr VertexAttribL3d;

            [FieldOffset(80)]
            public global::System.IntPtr VertexAttribL2d;

            [FieldOffset(84)]
            public global::System.IntPtr VertexAttribL1d;

            [FieldOffset(88)]
            public global::System.IntPtr GetProgramPipelineInfoLog;

            [FieldOffset(92)]
            public global::System.IntPtr ValidateProgramPipeline;

            [FieldOffset(96)]
            public global::System.IntPtr ProgramUniformMatrix4x3dv;

            [FieldOffset(100)]
            public global::System.IntPtr ProgramUniformMatrix3x4dv;

            [FieldOffset(104)]
            public global::System.IntPtr ProgramUniformMatrix4x2dv;

            [FieldOffset(108)]
            public global::System.IntPtr ProgramUniformMatrix2x4dv;

            [FieldOffset(112)]
            public global::System.IntPtr ProgramUniformMatrix3x2dv;

            [FieldOffset(116)]
            public global::System.IntPtr ProgramUniformMatrix2x3dv;

            [FieldOffset(120)]
            public global::System.IntPtr ProgramUniformMatrix4x3fv;

            [FieldOffset(124)]
            public global::System.IntPtr ProgramUniformMatrix3x4fv;

            [FieldOffset(128)]
            public global::System.IntPtr ProgramUniformMatrix4x2fv;

            [FieldOffset(132)]
            public global::System.IntPtr ProgramUniformMatrix2x4fv;

            [FieldOffset(136)]
            public global::System.IntPtr ProgramUniformMatrix3x2fv;

            [FieldOffset(140)]
            public global::System.IntPtr ProgramUniformMatrix2x3fv;

            [FieldOffset(144)]
            public global::System.IntPtr ProgramUniformMatrix4dv;

            [FieldOffset(148)]
            public global::System.IntPtr ProgramUniformMatrix3dv;

            [FieldOffset(152)]
            public global::System.IntPtr ProgramUniformMatrix2dv;

            [FieldOffset(156)]
            public global::System.IntPtr ProgramUniformMatrix4fv;

            [FieldOffset(160)]
            public global::System.IntPtr ProgramUniformMatrix3fv;

            [FieldOffset(164)]
            public global::System.IntPtr ProgramUniformMatrix2fv;

            [FieldOffset(168)]
            public global::System.IntPtr ProgramUniform4uiv;

            [FieldOffset(172)]
            public global::System.IntPtr ProgramUniform4ui;

            [FieldOffset(176)]
            public global::System.IntPtr ProgramUniform4dv;

            [FieldOffset(180)]
            public global::System.IntPtr ProgramUniform4d;

            [FieldOffset(184)]
            public global::System.IntPtr ProgramUniform4fv;

            [FieldOffset(188)]
            public global::System.IntPtr ProgramUniform4f;

            [FieldOffset(192)]
            public global::System.IntPtr ProgramUniform4iv;

            [FieldOffset(196)]
            public global::System.IntPtr ProgramUniform4i;

            [FieldOffset(200)]
            public global::System.IntPtr ProgramUniform3uiv;

            [FieldOffset(204)]
            public global::System.IntPtr ProgramUniform3ui;

            [FieldOffset(208)]
            public global::System.IntPtr ProgramUniform3dv;

            [FieldOffset(212)]
            public global::System.IntPtr ProgramUniform3d;

            [FieldOffset(216)]
            public global::System.IntPtr ProgramUniform3fv;

            [FieldOffset(220)]
            public global::System.IntPtr ProgramUniform3f;

            [FieldOffset(224)]
            public global::System.IntPtr ProgramUniform3iv;

            [FieldOffset(228)]
            public global::System.IntPtr ProgramUniform3i;

            [FieldOffset(232)]
            public global::System.IntPtr ProgramUniform2uiv;

            [FieldOffset(236)]
            public global::System.IntPtr ProgramUniform2ui;

            [FieldOffset(240)]
            public global::System.IntPtr ProgramUniform2dv;

            [FieldOffset(244)]
            public global::System.IntPtr ProgramUniform2d;

            [FieldOffset(248)]
            public global::System.IntPtr ProgramUniform2fv;

            [FieldOffset(252)]
            public global::System.IntPtr ProgramUniform2f;

            [FieldOffset(256)]
            public global::System.IntPtr ProgramUniform2iv;

            [FieldOffset(260)]
            public global::System.IntPtr ProgramUniform2i;

            [FieldOffset(264)]
            public global::System.IntPtr ProgramUniform1uiv;

            [FieldOffset(268)]
            public global::System.IntPtr ProgramUniform1ui;

            [FieldOffset(272)]
            public global::System.IntPtr ProgramUniform1dv;

            [FieldOffset(276)]
            public global::System.IntPtr ProgramUniform1d;

            [FieldOffset(280)]
            public global::System.IntPtr ProgramUniform1fv;

            [FieldOffset(284)]
            public global::System.IntPtr ProgramUniform1f;

            [FieldOffset(288)]
            public global::System.IntPtr ProgramUniform1iv;

            [FieldOffset(292)]
            public global::System.IntPtr ProgramUniform1i;

            [FieldOffset(296)]
            public global::System.IntPtr GetProgramPipelineiv;

            [FieldOffset(300)]
            public global::System.IntPtr IsProgramPipeline;

            [FieldOffset(304)]
            public global::System.IntPtr GenProgramPipelines;

            [FieldOffset(308)]
            public global::System.IntPtr DeleteProgramPipelines;

            [FieldOffset(312)]
            public global::System.IntPtr BindProgramPipeline;

            [FieldOffset(316)]
            public global::System.IntPtr CreateShaderProgramv;

            [FieldOffset(320)]
            public global::System.IntPtr ActiveShaderProgram;

            [FieldOffset(324)]
            public global::System.IntPtr UseProgramStages;

            [FieldOffset(328)]
            public global::System.IntPtr ProgramParameteri;

            [FieldOffset(332)]
            public global::System.IntPtr ProgramBinary;

            [FieldOffset(336)]
            public global::System.IntPtr GetProgramBinary;

            [FieldOffset(340)]
            public global::System.IntPtr ClearDepthf;

            [FieldOffset(344)]
            public global::System.IntPtr DepthRangef;

            [FieldOffset(348)]
            public global::System.IntPtr GetShaderPrecisionFormat;

            [FieldOffset(352)]
            public global::System.IntPtr ShaderBinary;

            [FieldOffset(356)]
            public global::System.IntPtr ReleaseShaderCompiler;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_4_1_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_4_1_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_4_1_CoreBackend((QOpenGLFunctions_4_1_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_4_1_CoreBackend __CreateInstance(QOpenGLFunctions_4_1_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_4_1_CoreBackend(native);
        }

        private static QOpenGLFunctions_4_1_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_4_1_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(360);
            QtGui.QOpenGLFunctions_4_1_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_4_1_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_4_1_CoreBackend(QOpenGLFunctions_4_1_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_4_1_CoreBackend(QOpenGLFunctions_4_1_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public Action ReleaseShaderCompiler
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->ReleaseShaderCompiler;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_4_2_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr TexStorage3D;

            [FieldOffset(12)]
            public global::System.IntPtr TexStorage2D;

            [FieldOffset(16)]
            public global::System.IntPtr TexStorage1D;

            [FieldOffset(20)]
            public global::System.IntPtr MemoryBarrier;

            [FieldOffset(24)]
            public global::System.IntPtr BindImageTexture;

            [FieldOffset(28)]
            public global::System.IntPtr GetActiveAtomicCounterBufferiv;

            [FieldOffset(32)]
            public global::System.IntPtr GetInternalformativ;

            [FieldOffset(36)]
            public global::System.IntPtr DrawTransformFeedbackStreamInstanced;

            [FieldOffset(40)]
            public global::System.IntPtr DrawTransformFeedbackInstanced;

            [FieldOffset(44)]
            public global::System.IntPtr DrawElementsInstancedBaseVertexBaseInstance;

            [FieldOffset(48)]
            public global::System.IntPtr DrawElementsInstancedBaseInstance;

            [FieldOffset(52)]
            public global::System.IntPtr DrawArraysInstancedBaseInstance;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_4_2_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_4_2_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_4_2_CoreBackend((QOpenGLFunctions_4_2_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_4_2_CoreBackend __CreateInstance(QOpenGLFunctions_4_2_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_4_2_CoreBackend(native);
        }

        private static QOpenGLFunctions_4_2_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_4_2_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(56);
            QtGui.QOpenGLFunctions_4_2_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_4_2_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_4_2_CoreBackend(QOpenGLFunctions_4_2_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_4_2_CoreBackend(QOpenGLFunctions_4_2_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_4_3_CoreBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 140)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr TexStorage3DMultisample;

            [FieldOffset(12)]
            public global::System.IntPtr TexStorage2DMultisample;

            [FieldOffset(16)]
            public global::System.IntPtr TexBufferRange;

            [FieldOffset(20)]
            public global::System.IntPtr ShaderStorageBlockBinding;

            [FieldOffset(24)]
            public global::System.IntPtr GetProgramResourceLocationIndex;

            [FieldOffset(28)]
            public global::System.IntPtr GetProgramResourceLocation;

            [FieldOffset(32)]
            public global::System.IntPtr GetProgramResourceiv;

            [FieldOffset(36)]
            public global::System.IntPtr GetProgramResourceName;

            [FieldOffset(40)]
            public global::System.IntPtr GetProgramResourceIndex;

            [FieldOffset(44)]
            public global::System.IntPtr GetProgramInterfaceiv;

            [FieldOffset(48)]
            public global::System.IntPtr MultiDrawElementsIndirect;

            [FieldOffset(52)]
            public global::System.IntPtr MultiDrawArraysIndirect;

            [FieldOffset(56)]
            public global::System.IntPtr InvalidateSubFramebuffer;

            [FieldOffset(60)]
            public global::System.IntPtr InvalidateFramebuffer;

            [FieldOffset(64)]
            public global::System.IntPtr InvalidateBufferData;

            [FieldOffset(68)]
            public global::System.IntPtr InvalidateBufferSubData;

            [FieldOffset(72)]
            public global::System.IntPtr InvalidateTexImage;

            [FieldOffset(76)]
            public global::System.IntPtr InvalidateTexSubImage;

            [FieldOffset(80)]
            public global::System.IntPtr GetInternalformati64v;

            [FieldOffset(84)]
            public global::System.IntPtr GetFramebufferParameteriv;

            [FieldOffset(88)]
            public global::System.IntPtr FramebufferParameteri;

            [FieldOffset(92)]
            public global::System.IntPtr VertexBindingDivisor;

            [FieldOffset(96)]
            public global::System.IntPtr VertexAttribBinding;

            [FieldOffset(100)]
            public global::System.IntPtr VertexAttribLFormat;

            [FieldOffset(104)]
            public global::System.IntPtr VertexAttribIFormat;

            [FieldOffset(108)]
            public global::System.IntPtr VertexAttribFormat;

            [FieldOffset(112)]
            public global::System.IntPtr BindVertexBuffer;

            [FieldOffset(116)]
            public global::System.IntPtr TextureView;

            [FieldOffset(120)]
            public global::System.IntPtr CopyImageSubData;

            [FieldOffset(124)]
            public global::System.IntPtr DispatchComputeIndirect;

            [FieldOffset(128)]
            public global::System.IntPtr DispatchCompute;

            [FieldOffset(132)]
            public global::System.IntPtr ClearBufferSubData;

            [FieldOffset(136)]
            public global::System.IntPtr ClearBufferData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN32QOpenGLFunctions_4_3_CoreBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_4_3_CoreBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_4_3_CoreBackend((QOpenGLFunctions_4_3_CoreBackend.Internal*) native);
        }

        public static QOpenGLFunctions_4_3_CoreBackend __CreateInstance(QOpenGLFunctions_4_3_CoreBackend.Internal native)
        {
            return new QOpenGLFunctions_4_3_CoreBackend(native);
        }

        private static QOpenGLFunctions_4_3_CoreBackend.Internal* __CopyValue(QOpenGLFunctions_4_3_CoreBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(140);
            QtGui.QOpenGLFunctions_4_3_CoreBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_4_3_CoreBackend.Internal*) ret;
        }

        private QOpenGLFunctions_4_3_CoreBackend(QOpenGLFunctions_4_3_CoreBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_4_3_CoreBackend(QOpenGLFunctions_4_3_CoreBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_0_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1040)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr Translatef;

            [FieldOffset(12)]
            public global::System.IntPtr Translated;

            [FieldOffset(16)]
            public global::System.IntPtr Scalef;

            [FieldOffset(20)]
            public global::System.IntPtr Scaled;

            [FieldOffset(24)]
            public global::System.IntPtr Rotatef;

            [FieldOffset(28)]
            public global::System.IntPtr Rotated;

            [FieldOffset(32)]
            public global::System.IntPtr PushMatrix;

            [FieldOffset(36)]
            public global::System.IntPtr PopMatrix;

            [FieldOffset(40)]
            public global::System.IntPtr Ortho;

            [FieldOffset(44)]
            public global::System.IntPtr MultMatrixd;

            [FieldOffset(48)]
            public global::System.IntPtr MultMatrixf;

            [FieldOffset(52)]
            public global::System.IntPtr MatrixMode;

            [FieldOffset(56)]
            public global::System.IntPtr LoadMatrixd;

            [FieldOffset(60)]
            public global::System.IntPtr LoadMatrixf;

            [FieldOffset(64)]
            public global::System.IntPtr LoadIdentity;

            [FieldOffset(68)]
            public global::System.IntPtr Frustum;

            [FieldOffset(72)]
            public global::System.IntPtr IsList;

            [FieldOffset(76)]
            public global::System.IntPtr GetTexGeniv;

            [FieldOffset(80)]
            public global::System.IntPtr GetTexGenfv;

            [FieldOffset(84)]
            public global::System.IntPtr GetTexGendv;

            [FieldOffset(88)]
            public global::System.IntPtr GetTexEnviv;

            [FieldOffset(92)]
            public global::System.IntPtr GetTexEnvfv;

            [FieldOffset(96)]
            public global::System.IntPtr GetPolygonStipple;

            [FieldOffset(100)]
            public global::System.IntPtr GetPixelMapusv;

            [FieldOffset(104)]
            public global::System.IntPtr GetPixelMapuiv;

            [FieldOffset(108)]
            public global::System.IntPtr GetPixelMapfv;

            [FieldOffset(112)]
            public global::System.IntPtr GetMaterialiv;

            [FieldOffset(116)]
            public global::System.IntPtr GetMaterialfv;

            [FieldOffset(120)]
            public global::System.IntPtr GetMapiv;

            [FieldOffset(124)]
            public global::System.IntPtr GetMapfv;

            [FieldOffset(128)]
            public global::System.IntPtr GetMapdv;

            [FieldOffset(132)]
            public global::System.IntPtr GetLightiv;

            [FieldOffset(136)]
            public global::System.IntPtr GetLightfv;

            [FieldOffset(140)]
            public global::System.IntPtr GetClipPlane;

            [FieldOffset(144)]
            public global::System.IntPtr DrawPixels;

            [FieldOffset(148)]
            public global::System.IntPtr CopyPixels;

            [FieldOffset(152)]
            public global::System.IntPtr PixelMapusv;

            [FieldOffset(156)]
            public global::System.IntPtr PixelMapuiv;

            [FieldOffset(160)]
            public global::System.IntPtr PixelMapfv;

            [FieldOffset(164)]
            public global::System.IntPtr PixelTransferi;

            [FieldOffset(168)]
            public global::System.IntPtr PixelTransferf;

            [FieldOffset(172)]
            public global::System.IntPtr PixelZoom;

            [FieldOffset(176)]
            public global::System.IntPtr AlphaFunc;

            [FieldOffset(180)]
            public global::System.IntPtr EvalPoint2;

            [FieldOffset(184)]
            public global::System.IntPtr EvalMesh2;

            [FieldOffset(188)]
            public global::System.IntPtr EvalPoint1;

            [FieldOffset(192)]
            public global::System.IntPtr EvalMesh1;

            [FieldOffset(196)]
            public global::System.IntPtr EvalCoord2fv;

            [FieldOffset(200)]
            public global::System.IntPtr EvalCoord2f;

            [FieldOffset(204)]
            public global::System.IntPtr EvalCoord2dv;

            [FieldOffset(208)]
            public global::System.IntPtr EvalCoord2d;

            [FieldOffset(212)]
            public global::System.IntPtr EvalCoord1fv;

            [FieldOffset(216)]
            public global::System.IntPtr EvalCoord1f;

            [FieldOffset(220)]
            public global::System.IntPtr EvalCoord1dv;

            [FieldOffset(224)]
            public global::System.IntPtr EvalCoord1d;

            [FieldOffset(228)]
            public global::System.IntPtr MapGrid2f;

            [FieldOffset(232)]
            public global::System.IntPtr MapGrid2d;

            [FieldOffset(236)]
            public global::System.IntPtr MapGrid1f;

            [FieldOffset(240)]
            public global::System.IntPtr MapGrid1d;

            [FieldOffset(244)]
            public global::System.IntPtr Map2f;

            [FieldOffset(248)]
            public global::System.IntPtr Map2d;

            [FieldOffset(252)]
            public global::System.IntPtr Map1f;

            [FieldOffset(256)]
            public global::System.IntPtr Map1d;

            [FieldOffset(260)]
            public global::System.IntPtr PushAttrib;

            [FieldOffset(264)]
            public global::System.IntPtr PopAttrib;

            [FieldOffset(268)]
            public global::System.IntPtr Accum;

            [FieldOffset(272)]
            public global::System.IntPtr IndexMask;

            [FieldOffset(276)]
            public global::System.IntPtr ClearIndex;

            [FieldOffset(280)]
            public global::System.IntPtr ClearAccum;

            [FieldOffset(284)]
            public global::System.IntPtr PushName;

            [FieldOffset(288)]
            public global::System.IntPtr PopName;

            [FieldOffset(292)]
            public global::System.IntPtr PassThrough;

            [FieldOffset(296)]
            public global::System.IntPtr LoadName;

            [FieldOffset(300)]
            public global::System.IntPtr InitNames;

            [FieldOffset(304)]
            public global::System.IntPtr RenderMode;

            [FieldOffset(308)]
            public global::System.IntPtr SelectBuffer;

            [FieldOffset(312)]
            public global::System.IntPtr FeedbackBuffer;

            [FieldOffset(316)]
            public global::System.IntPtr TexGeniv;

            [FieldOffset(320)]
            public global::System.IntPtr TexGeni;

            [FieldOffset(324)]
            public global::System.IntPtr TexGenfv;

            [FieldOffset(328)]
            public global::System.IntPtr TexGenf;

            [FieldOffset(332)]
            public global::System.IntPtr TexGendv;

            [FieldOffset(336)]
            public global::System.IntPtr TexGend;

            [FieldOffset(340)]
            public global::System.IntPtr TexEnviv;

            [FieldOffset(344)]
            public global::System.IntPtr TexEnvi;

            [FieldOffset(348)]
            public global::System.IntPtr TexEnvfv;

            [FieldOffset(352)]
            public global::System.IntPtr TexEnvf;

            [FieldOffset(356)]
            public global::System.IntPtr ShadeModel;

            [FieldOffset(360)]
            public global::System.IntPtr PolygonStipple;

            [FieldOffset(364)]
            public global::System.IntPtr Materialiv;

            [FieldOffset(368)]
            public global::System.IntPtr Materiali;

            [FieldOffset(372)]
            public global::System.IntPtr Materialfv;

            [FieldOffset(376)]
            public global::System.IntPtr Materialf;

            [FieldOffset(380)]
            public global::System.IntPtr LineStipple;

            [FieldOffset(384)]
            public global::System.IntPtr LightModeliv;

            [FieldOffset(388)]
            public global::System.IntPtr LightModeli;

            [FieldOffset(392)]
            public global::System.IntPtr LightModelfv;

            [FieldOffset(396)]
            public global::System.IntPtr LightModelf;

            [FieldOffset(400)]
            public global::System.IntPtr Lightiv;

            [FieldOffset(404)]
            public global::System.IntPtr Lighti;

            [FieldOffset(408)]
            public global::System.IntPtr Lightfv;

            [FieldOffset(412)]
            public global::System.IntPtr Lightf;

            [FieldOffset(416)]
            public global::System.IntPtr Fogiv;

            [FieldOffset(420)]
            public global::System.IntPtr Fogi;

            [FieldOffset(424)]
            public global::System.IntPtr Fogfv;

            [FieldOffset(428)]
            public global::System.IntPtr Fogf;

            [FieldOffset(432)]
            public global::System.IntPtr ColorMaterial;

            [FieldOffset(436)]
            public global::System.IntPtr ClipPlane;

            [FieldOffset(440)]
            public global::System.IntPtr Vertex4sv;

            [FieldOffset(444)]
            public global::System.IntPtr Vertex4s;

            [FieldOffset(448)]
            public global::System.IntPtr Vertex4iv;

            [FieldOffset(452)]
            public global::System.IntPtr Vertex4i;

            [FieldOffset(456)]
            public global::System.IntPtr Vertex4fv;

            [FieldOffset(460)]
            public global::System.IntPtr Vertex4f;

            [FieldOffset(464)]
            public global::System.IntPtr Vertex4dv;

            [FieldOffset(468)]
            public global::System.IntPtr Vertex4d;

            [FieldOffset(472)]
            public global::System.IntPtr Vertex3sv;

            [FieldOffset(476)]
            public global::System.IntPtr Vertex3s;

            [FieldOffset(480)]
            public global::System.IntPtr Vertex3iv;

            [FieldOffset(484)]
            public global::System.IntPtr Vertex3i;

            [FieldOffset(488)]
            public global::System.IntPtr Vertex3fv;

            [FieldOffset(492)]
            public global::System.IntPtr Vertex3f;

            [FieldOffset(496)]
            public global::System.IntPtr Vertex3dv;

            [FieldOffset(500)]
            public global::System.IntPtr Vertex3d;

            [FieldOffset(504)]
            public global::System.IntPtr Vertex2sv;

            [FieldOffset(508)]
            public global::System.IntPtr Vertex2s;

            [FieldOffset(512)]
            public global::System.IntPtr Vertex2iv;

            [FieldOffset(516)]
            public global::System.IntPtr Vertex2i;

            [FieldOffset(520)]
            public global::System.IntPtr Vertex2fv;

            [FieldOffset(524)]
            public global::System.IntPtr Vertex2f;

            [FieldOffset(528)]
            public global::System.IntPtr Vertex2dv;

            [FieldOffset(532)]
            public global::System.IntPtr Vertex2d;

            [FieldOffset(536)]
            public global::System.IntPtr TexCoord4sv;

            [FieldOffset(540)]
            public global::System.IntPtr TexCoord4s;

            [FieldOffset(544)]
            public global::System.IntPtr TexCoord4iv;

            [FieldOffset(548)]
            public global::System.IntPtr TexCoord4i;

            [FieldOffset(552)]
            public global::System.IntPtr TexCoord4fv;

            [FieldOffset(556)]
            public global::System.IntPtr TexCoord4f;

            [FieldOffset(560)]
            public global::System.IntPtr TexCoord4dv;

            [FieldOffset(564)]
            public global::System.IntPtr TexCoord4d;

            [FieldOffset(568)]
            public global::System.IntPtr TexCoord3sv;

            [FieldOffset(572)]
            public global::System.IntPtr TexCoord3s;

            [FieldOffset(576)]
            public global::System.IntPtr TexCoord3iv;

            [FieldOffset(580)]
            public global::System.IntPtr TexCoord3i;

            [FieldOffset(584)]
            public global::System.IntPtr TexCoord3fv;

            [FieldOffset(588)]
            public global::System.IntPtr TexCoord3f;

            [FieldOffset(592)]
            public global::System.IntPtr TexCoord3dv;

            [FieldOffset(596)]
            public global::System.IntPtr TexCoord3d;

            [FieldOffset(600)]
            public global::System.IntPtr TexCoord2sv;

            [FieldOffset(604)]
            public global::System.IntPtr TexCoord2s;

            [FieldOffset(608)]
            public global::System.IntPtr TexCoord2iv;

            [FieldOffset(612)]
            public global::System.IntPtr TexCoord2i;

            [FieldOffset(616)]
            public global::System.IntPtr TexCoord2fv;

            [FieldOffset(620)]
            public global::System.IntPtr TexCoord2f;

            [FieldOffset(624)]
            public global::System.IntPtr TexCoord2dv;

            [FieldOffset(628)]
            public global::System.IntPtr TexCoord2d;

            [FieldOffset(632)]
            public global::System.IntPtr TexCoord1sv;

            [FieldOffset(636)]
            public global::System.IntPtr TexCoord1s;

            [FieldOffset(640)]
            public global::System.IntPtr TexCoord1iv;

            [FieldOffset(644)]
            public global::System.IntPtr TexCoord1i;

            [FieldOffset(648)]
            public global::System.IntPtr TexCoord1fv;

            [FieldOffset(652)]
            public global::System.IntPtr TexCoord1f;

            [FieldOffset(656)]
            public global::System.IntPtr TexCoord1dv;

            [FieldOffset(660)]
            public global::System.IntPtr TexCoord1d;

            [FieldOffset(664)]
            public global::System.IntPtr Rectsv;

            [FieldOffset(668)]
            public global::System.IntPtr Rects;

            [FieldOffset(672)]
            public global::System.IntPtr Rectiv;

            [FieldOffset(676)]
            public global::System.IntPtr Recti;

            [FieldOffset(680)]
            public global::System.IntPtr Rectfv;

            [FieldOffset(684)]
            public global::System.IntPtr Rectf;

            [FieldOffset(688)]
            public global::System.IntPtr Rectdv;

            [FieldOffset(692)]
            public global::System.IntPtr Rectd;

            [FieldOffset(696)]
            public global::System.IntPtr RasterPos4sv;

            [FieldOffset(700)]
            public global::System.IntPtr RasterPos4s;

            [FieldOffset(704)]
            public global::System.IntPtr RasterPos4iv;

            [FieldOffset(708)]
            public global::System.IntPtr RasterPos4i;

            [FieldOffset(712)]
            public global::System.IntPtr RasterPos4fv;

            [FieldOffset(716)]
            public global::System.IntPtr RasterPos4f;

            [FieldOffset(720)]
            public global::System.IntPtr RasterPos4dv;

            [FieldOffset(724)]
            public global::System.IntPtr RasterPos4d;

            [FieldOffset(728)]
            public global::System.IntPtr RasterPos3sv;

            [FieldOffset(732)]
            public global::System.IntPtr RasterPos3s;

            [FieldOffset(736)]
            public global::System.IntPtr RasterPos3iv;

            [FieldOffset(740)]
            public global::System.IntPtr RasterPos3i;

            [FieldOffset(744)]
            public global::System.IntPtr RasterPos3fv;

            [FieldOffset(748)]
            public global::System.IntPtr RasterPos3f;

            [FieldOffset(752)]
            public global::System.IntPtr RasterPos3dv;

            [FieldOffset(756)]
            public global::System.IntPtr RasterPos3d;

            [FieldOffset(760)]
            public global::System.IntPtr RasterPos2sv;

            [FieldOffset(764)]
            public global::System.IntPtr RasterPos2s;

            [FieldOffset(768)]
            public global::System.IntPtr RasterPos2iv;

            [FieldOffset(772)]
            public global::System.IntPtr RasterPos2i;

            [FieldOffset(776)]
            public global::System.IntPtr RasterPos2fv;

            [FieldOffset(780)]
            public global::System.IntPtr RasterPos2f;

            [FieldOffset(784)]
            public global::System.IntPtr RasterPos2dv;

            [FieldOffset(788)]
            public global::System.IntPtr RasterPos2d;

            [FieldOffset(792)]
            public global::System.IntPtr Normal3sv;

            [FieldOffset(796)]
            public global::System.IntPtr Normal3s;

            [FieldOffset(800)]
            public global::System.IntPtr Normal3iv;

            [FieldOffset(804)]
            public global::System.IntPtr Normal3i;

            [FieldOffset(808)]
            public global::System.IntPtr Normal3fv;

            [FieldOffset(812)]
            public global::System.IntPtr Normal3f;

            [FieldOffset(816)]
            public global::System.IntPtr Normal3dv;

            [FieldOffset(820)]
            public global::System.IntPtr Normal3d;

            [FieldOffset(824)]
            public global::System.IntPtr Normal3bv;

            [FieldOffset(828)]
            public global::System.IntPtr Normal3b;

            [FieldOffset(832)]
            public global::System.IntPtr Indexsv;

            [FieldOffset(836)]
            public global::System.IntPtr Indexs;

            [FieldOffset(840)]
            public global::System.IntPtr Indexiv;

            [FieldOffset(844)]
            public global::System.IntPtr Indexi;

            [FieldOffset(848)]
            public global::System.IntPtr Indexfv;

            [FieldOffset(852)]
            public global::System.IntPtr Indexf;

            [FieldOffset(856)]
            public global::System.IntPtr Indexdv;

            [FieldOffset(860)]
            public global::System.IntPtr Indexd;

            [FieldOffset(864)]
            public global::System.IntPtr End;

            [FieldOffset(868)]
            public global::System.IntPtr EdgeFlagv;

            [FieldOffset(872)]
            public global::System.IntPtr EdgeFlag;

            [FieldOffset(876)]
            public global::System.IntPtr Color4usv;

            [FieldOffset(880)]
            public global::System.IntPtr Color4us;

            [FieldOffset(884)]
            public global::System.IntPtr Color4uiv;

            [FieldOffset(888)]
            public global::System.IntPtr Color4ui;

            [FieldOffset(892)]
            public global::System.IntPtr Color4ubv;

            [FieldOffset(896)]
            public global::System.IntPtr Color4ub;

            [FieldOffset(900)]
            public global::System.IntPtr Color4sv;

            [FieldOffset(904)]
            public global::System.IntPtr Color4s;

            [FieldOffset(908)]
            public global::System.IntPtr Color4iv;

            [FieldOffset(912)]
            public global::System.IntPtr Color4i;

            [FieldOffset(916)]
            public global::System.IntPtr Color4fv;

            [FieldOffset(920)]
            public global::System.IntPtr Color4f;

            [FieldOffset(924)]
            public global::System.IntPtr Color4dv;

            [FieldOffset(928)]
            public global::System.IntPtr Color4d;

            [FieldOffset(932)]
            public global::System.IntPtr Color4bv;

            [FieldOffset(936)]
            public global::System.IntPtr Color4b;

            [FieldOffset(940)]
            public global::System.IntPtr Color3usv;

            [FieldOffset(944)]
            public global::System.IntPtr Color3us;

            [FieldOffset(948)]
            public global::System.IntPtr Color3uiv;

            [FieldOffset(952)]
            public global::System.IntPtr Color3ui;

            [FieldOffset(956)]
            public global::System.IntPtr Color3ubv;

            [FieldOffset(960)]
            public global::System.IntPtr Color3ub;

            [FieldOffset(964)]
            public global::System.IntPtr Color3sv;

            [FieldOffset(968)]
            public global::System.IntPtr Color3s;

            [FieldOffset(972)]
            public global::System.IntPtr Color3iv;

            [FieldOffset(976)]
            public global::System.IntPtr Color3i;

            [FieldOffset(980)]
            public global::System.IntPtr Color3fv;

            [FieldOffset(984)]
            public global::System.IntPtr Color3f;

            [FieldOffset(988)]
            public global::System.IntPtr Color3dv;

            [FieldOffset(992)]
            public global::System.IntPtr Color3d;

            [FieldOffset(996)]
            public global::System.IntPtr Color3bv;

            [FieldOffset(1000)]
            public global::System.IntPtr Color3b;

            [FieldOffset(1004)]
            public global::System.IntPtr Bitmap;

            [FieldOffset(1008)]
            public global::System.IntPtr Begin;

            [FieldOffset(1012)]
            public global::System.IntPtr ListBase;

            [FieldOffset(1016)]
            public global::System.IntPtr GenLists;

            [FieldOffset(1020)]
            public global::System.IntPtr DeleteLists;

            [FieldOffset(1024)]
            public global::System.IntPtr CallLists;

            [FieldOffset(1028)]
            public global::System.IntPtr CallList;

            [FieldOffset(1032)]
            public global::System.IntPtr EndList;

            [FieldOffset(1036)]
            public global::System.IntPtr NewList;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_1_0_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_0_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_0_DeprecatedBackend((QOpenGLFunctions_1_0_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_0_DeprecatedBackend __CreateInstance(QOpenGLFunctions_1_0_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_1_0_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_1_0_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_1_0_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(1040);
            QtGui.QOpenGLFunctions_1_0_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_0_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_0_DeprecatedBackend(QOpenGLFunctions_1_0_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_0_DeprecatedBackend(QOpenGLFunctions_1_0_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public Action PushMatrix
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->PushMatrix;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action PopMatrix
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->PopMatrix;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action LoadIdentity
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->LoadIdentity;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action PopAttrib
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->PopAttrib;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action PopName
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->PopName;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action InitNames
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->InitNames;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action End
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->End;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }

        public Action EndList
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->EndList;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_1_1_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr PushClientAttrib;

            [FieldOffset(12)]
            public global::System.IntPtr PopClientAttrib;

            [FieldOffset(16)]
            public global::System.IntPtr PrioritizeTextures;

            [FieldOffset(20)]
            public global::System.IntPtr AreTexturesResident;

            [FieldOffset(24)]
            public global::System.IntPtr VertexPointer;

            [FieldOffset(28)]
            public global::System.IntPtr TexCoordPointer;

            [FieldOffset(32)]
            public global::System.IntPtr NormalPointer;

            [FieldOffset(36)]
            public global::System.IntPtr InterleavedArrays;

            [FieldOffset(40)]
            public global::System.IntPtr IndexPointer;

            [FieldOffset(44)]
            public global::System.IntPtr EnableClientState;

            [FieldOffset(48)]
            public global::System.IntPtr EdgeFlagPointer;

            [FieldOffset(52)]
            public global::System.IntPtr DisableClientState;

            [FieldOffset(56)]
            public global::System.IntPtr ColorPointer;

            [FieldOffset(60)]
            public global::System.IntPtr ArrayElement;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_1_1_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_1_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_1_DeprecatedBackend((QOpenGLFunctions_1_1_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_1_DeprecatedBackend __CreateInstance(QOpenGLFunctions_1_1_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_1_1_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_1_1_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_1_1_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(64);
            QtGui.QOpenGLFunctions_1_1_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_1_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_1_DeprecatedBackend(QOpenGLFunctions_1_1_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_1_DeprecatedBackend(QOpenGLFunctions_1_1_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public Action PopClientAttrib
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->PopClientAttrib;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
            }
        }
    }

    public unsafe partial class QOpenGLFunctions_1_2_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr ResetMinmax;

            [FieldOffset(12)]
            public global::System.IntPtr ResetHistogram;

            [FieldOffset(16)]
            public global::System.IntPtr Minmax;

            [FieldOffset(20)]
            public global::System.IntPtr Histogram;

            [FieldOffset(24)]
            public global::System.IntPtr GetMinmaxParameteriv;

            [FieldOffset(28)]
            public global::System.IntPtr GetMinmaxParameterfv;

            [FieldOffset(32)]
            public global::System.IntPtr GetMinmax;

            [FieldOffset(36)]
            public global::System.IntPtr GetHistogramParameteriv;

            [FieldOffset(40)]
            public global::System.IntPtr GetHistogramParameterfv;

            [FieldOffset(44)]
            public global::System.IntPtr GetHistogram;

            [FieldOffset(48)]
            public global::System.IntPtr SeparableFilter2D;

            [FieldOffset(52)]
            public global::System.IntPtr GetSeparableFilter;

            [FieldOffset(56)]
            public global::System.IntPtr GetConvolutionParameteriv;

            [FieldOffset(60)]
            public global::System.IntPtr GetConvolutionParameterfv;

            [FieldOffset(64)]
            public global::System.IntPtr GetConvolutionFilter;

            [FieldOffset(68)]
            public global::System.IntPtr CopyConvolutionFilter2D;

            [FieldOffset(72)]
            public global::System.IntPtr CopyConvolutionFilter1D;

            [FieldOffset(76)]
            public global::System.IntPtr ConvolutionParameteriv;

            [FieldOffset(80)]
            public global::System.IntPtr ConvolutionParameteri;

            [FieldOffset(84)]
            public global::System.IntPtr ConvolutionParameterfv;

            [FieldOffset(88)]
            public global::System.IntPtr ConvolutionParameterf;

            [FieldOffset(92)]
            public global::System.IntPtr ConvolutionFilter2D;

            [FieldOffset(96)]
            public global::System.IntPtr ConvolutionFilter1D;

            [FieldOffset(100)]
            public global::System.IntPtr CopyColorSubTable;

            [FieldOffset(104)]
            public global::System.IntPtr ColorSubTable;

            [FieldOffset(108)]
            public global::System.IntPtr GetColorTableParameteriv;

            [FieldOffset(112)]
            public global::System.IntPtr GetColorTableParameterfv;

            [FieldOffset(116)]
            public global::System.IntPtr GetColorTable;

            [FieldOffset(120)]
            public global::System.IntPtr CopyColorTable;

            [FieldOffset(124)]
            public global::System.IntPtr ColorTableParameteriv;

            [FieldOffset(128)]
            public global::System.IntPtr ColorTableParameterfv;

            [FieldOffset(132)]
            public global::System.IntPtr ColorTable;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_1_2_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_2_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_2_DeprecatedBackend((QOpenGLFunctions_1_2_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_2_DeprecatedBackend __CreateInstance(QOpenGLFunctions_1_2_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_1_2_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_1_2_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_1_2_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(136);
            QtGui.QOpenGLFunctions_1_2_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_2_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_2_DeprecatedBackend(QOpenGLFunctions_1_2_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_2_DeprecatedBackend(QOpenGLFunctions_1_2_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_3_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 156)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr MultTransposeMatrixd;

            [FieldOffset(12)]
            public global::System.IntPtr MultTransposeMatrixf;

            [FieldOffset(16)]
            public global::System.IntPtr LoadTransposeMatrixd;

            [FieldOffset(20)]
            public global::System.IntPtr LoadTransposeMatrixf;

            [FieldOffset(24)]
            public global::System.IntPtr MultiTexCoord4sv;

            [FieldOffset(28)]
            public global::System.IntPtr MultiTexCoord4s;

            [FieldOffset(32)]
            public global::System.IntPtr MultiTexCoord4iv;

            [FieldOffset(36)]
            public global::System.IntPtr MultiTexCoord4i;

            [FieldOffset(40)]
            public global::System.IntPtr MultiTexCoord4fv;

            [FieldOffset(44)]
            public global::System.IntPtr MultiTexCoord4f;

            [FieldOffset(48)]
            public global::System.IntPtr MultiTexCoord4dv;

            [FieldOffset(52)]
            public global::System.IntPtr MultiTexCoord4d;

            [FieldOffset(56)]
            public global::System.IntPtr MultiTexCoord3sv;

            [FieldOffset(60)]
            public global::System.IntPtr MultiTexCoord3s;

            [FieldOffset(64)]
            public global::System.IntPtr MultiTexCoord3iv;

            [FieldOffset(68)]
            public global::System.IntPtr MultiTexCoord3i;

            [FieldOffset(72)]
            public global::System.IntPtr MultiTexCoord3fv;

            [FieldOffset(76)]
            public global::System.IntPtr MultiTexCoord3f;

            [FieldOffset(80)]
            public global::System.IntPtr MultiTexCoord3dv;

            [FieldOffset(84)]
            public global::System.IntPtr MultiTexCoord3d;

            [FieldOffset(88)]
            public global::System.IntPtr MultiTexCoord2sv;

            [FieldOffset(92)]
            public global::System.IntPtr MultiTexCoord2s;

            [FieldOffset(96)]
            public global::System.IntPtr MultiTexCoord2iv;

            [FieldOffset(100)]
            public global::System.IntPtr MultiTexCoord2i;

            [FieldOffset(104)]
            public global::System.IntPtr MultiTexCoord2fv;

            [FieldOffset(108)]
            public global::System.IntPtr MultiTexCoord2f;

            [FieldOffset(112)]
            public global::System.IntPtr MultiTexCoord2dv;

            [FieldOffset(116)]
            public global::System.IntPtr MultiTexCoord2d;

            [FieldOffset(120)]
            public global::System.IntPtr MultiTexCoord1sv;

            [FieldOffset(124)]
            public global::System.IntPtr MultiTexCoord1s;

            [FieldOffset(128)]
            public global::System.IntPtr MultiTexCoord1iv;

            [FieldOffset(132)]
            public global::System.IntPtr MultiTexCoord1i;

            [FieldOffset(136)]
            public global::System.IntPtr MultiTexCoord1fv;

            [FieldOffset(140)]
            public global::System.IntPtr MultiTexCoord1f;

            [FieldOffset(144)]
            public global::System.IntPtr MultiTexCoord1dv;

            [FieldOffset(148)]
            public global::System.IntPtr MultiTexCoord1d;

            [FieldOffset(152)]
            public global::System.IntPtr ClientActiveTexture;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_1_3_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_3_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_3_DeprecatedBackend((QOpenGLFunctions_1_3_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_3_DeprecatedBackend __CreateInstance(QOpenGLFunctions_1_3_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_1_3_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_1_3_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_1_3_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(156);
            QtGui.QOpenGLFunctions_1_3_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_3_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_3_DeprecatedBackend(QOpenGLFunctions_1_3_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_3_DeprecatedBackend(QOpenGLFunctions_1_3_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_1_4_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 160)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr WindowPos3sv;

            [FieldOffset(12)]
            public global::System.IntPtr WindowPos3s;

            [FieldOffset(16)]
            public global::System.IntPtr WindowPos3iv;

            [FieldOffset(20)]
            public global::System.IntPtr WindowPos3i;

            [FieldOffset(24)]
            public global::System.IntPtr WindowPos3fv;

            [FieldOffset(28)]
            public global::System.IntPtr WindowPos3f;

            [FieldOffset(32)]
            public global::System.IntPtr WindowPos3dv;

            [FieldOffset(36)]
            public global::System.IntPtr WindowPos3d;

            [FieldOffset(40)]
            public global::System.IntPtr WindowPos2sv;

            [FieldOffset(44)]
            public global::System.IntPtr WindowPos2s;

            [FieldOffset(48)]
            public global::System.IntPtr WindowPos2iv;

            [FieldOffset(52)]
            public global::System.IntPtr WindowPos2i;

            [FieldOffset(56)]
            public global::System.IntPtr WindowPos2fv;

            [FieldOffset(60)]
            public global::System.IntPtr WindowPos2f;

            [FieldOffset(64)]
            public global::System.IntPtr WindowPos2dv;

            [FieldOffset(68)]
            public global::System.IntPtr WindowPos2d;

            [FieldOffset(72)]
            public global::System.IntPtr SecondaryColorPointer;

            [FieldOffset(76)]
            public global::System.IntPtr SecondaryColor3usv;

            [FieldOffset(80)]
            public global::System.IntPtr SecondaryColor3us;

            [FieldOffset(84)]
            public global::System.IntPtr SecondaryColor3uiv;

            [FieldOffset(88)]
            public global::System.IntPtr SecondaryColor3ui;

            [FieldOffset(92)]
            public global::System.IntPtr SecondaryColor3ubv;

            [FieldOffset(96)]
            public global::System.IntPtr SecondaryColor3ub;

            [FieldOffset(100)]
            public global::System.IntPtr SecondaryColor3sv;

            [FieldOffset(104)]
            public global::System.IntPtr SecondaryColor3s;

            [FieldOffset(108)]
            public global::System.IntPtr SecondaryColor3iv;

            [FieldOffset(112)]
            public global::System.IntPtr SecondaryColor3i;

            [FieldOffset(116)]
            public global::System.IntPtr SecondaryColor3fv;

            [FieldOffset(120)]
            public global::System.IntPtr SecondaryColor3f;

            [FieldOffset(124)]
            public global::System.IntPtr SecondaryColor3dv;

            [FieldOffset(128)]
            public global::System.IntPtr SecondaryColor3d;

            [FieldOffset(132)]
            public global::System.IntPtr SecondaryColor3bv;

            [FieldOffset(136)]
            public global::System.IntPtr SecondaryColor3b;

            [FieldOffset(140)]
            public global::System.IntPtr FogCoordPointer;

            [FieldOffset(144)]
            public global::System.IntPtr FogCoorddv;

            [FieldOffset(148)]
            public global::System.IntPtr FogCoordd;

            [FieldOffset(152)]
            public global::System.IntPtr FogCoordfv;

            [FieldOffset(156)]
            public global::System.IntPtr FogCoordf;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_1_4_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_1_4_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_1_4_DeprecatedBackend((QOpenGLFunctions_1_4_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_1_4_DeprecatedBackend __CreateInstance(QOpenGLFunctions_1_4_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_1_4_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_1_4_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_1_4_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(160);
            QtGui.QOpenGLFunctions_1_4_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_1_4_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_1_4_DeprecatedBackend(QOpenGLFunctions_1_4_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_1_4_DeprecatedBackend(QOpenGLFunctions_1_4_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_2_0_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr VertexAttrib4usv;

            [FieldOffset(12)]
            public global::System.IntPtr VertexAttrib4uiv;

            [FieldOffset(16)]
            public global::System.IntPtr VertexAttrib4ubv;

            [FieldOffset(20)]
            public global::System.IntPtr VertexAttrib4sv;

            [FieldOffset(24)]
            public global::System.IntPtr VertexAttrib4s;

            [FieldOffset(28)]
            public global::System.IntPtr VertexAttrib4iv;

            [FieldOffset(32)]
            public global::System.IntPtr VertexAttrib4fv;

            [FieldOffset(36)]
            public global::System.IntPtr VertexAttrib4f;

            [FieldOffset(40)]
            public global::System.IntPtr VertexAttrib4dv;

            [FieldOffset(44)]
            public global::System.IntPtr VertexAttrib4d;

            [FieldOffset(48)]
            public global::System.IntPtr VertexAttrib4bv;

            [FieldOffset(52)]
            public global::System.IntPtr VertexAttrib4Nusv;

            [FieldOffset(56)]
            public global::System.IntPtr VertexAttrib4Nuiv;

            [FieldOffset(60)]
            public global::System.IntPtr VertexAttrib4Nubv;

            [FieldOffset(64)]
            public global::System.IntPtr VertexAttrib4Nub;

            [FieldOffset(68)]
            public global::System.IntPtr VertexAttrib4Nsv;

            [FieldOffset(72)]
            public global::System.IntPtr VertexAttrib4Niv;

            [FieldOffset(76)]
            public global::System.IntPtr VertexAttrib4Nbv;

            [FieldOffset(80)]
            public global::System.IntPtr VertexAttrib3sv;

            [FieldOffset(84)]
            public global::System.IntPtr VertexAttrib3s;

            [FieldOffset(88)]
            public global::System.IntPtr VertexAttrib3fv;

            [FieldOffset(92)]
            public global::System.IntPtr VertexAttrib3f;

            [FieldOffset(96)]
            public global::System.IntPtr VertexAttrib3dv;

            [FieldOffset(100)]
            public global::System.IntPtr VertexAttrib3d;

            [FieldOffset(104)]
            public global::System.IntPtr VertexAttrib2sv;

            [FieldOffset(108)]
            public global::System.IntPtr VertexAttrib2s;

            [FieldOffset(112)]
            public global::System.IntPtr VertexAttrib2fv;

            [FieldOffset(116)]
            public global::System.IntPtr VertexAttrib2f;

            [FieldOffset(120)]
            public global::System.IntPtr VertexAttrib2dv;

            [FieldOffset(124)]
            public global::System.IntPtr VertexAttrib2d;

            [FieldOffset(128)]
            public global::System.IntPtr VertexAttrib1sv;

            [FieldOffset(132)]
            public global::System.IntPtr VertexAttrib1s;

            [FieldOffset(136)]
            public global::System.IntPtr VertexAttrib1fv;

            [FieldOffset(140)]
            public global::System.IntPtr VertexAttrib1f;

            [FieldOffset(144)]
            public global::System.IntPtr VertexAttrib1dv;

            [FieldOffset(148)]
            public global::System.IntPtr VertexAttrib1d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_2_0_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_2_0_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_2_0_DeprecatedBackend((QOpenGLFunctions_2_0_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_2_0_DeprecatedBackend __CreateInstance(QOpenGLFunctions_2_0_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_2_0_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_2_0_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_2_0_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(152);
            QtGui.QOpenGLFunctions_2_0_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_2_0_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_2_0_DeprecatedBackend(QOpenGLFunctions_2_0_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_2_0_DeprecatedBackend(QOpenGLFunctions_2_0_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    public unsafe partial class QOpenGLFunctions_3_0_DeprecatedBackend : QtGui.QOpenGLVersionFunctionsBackend, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr context;

            [FieldOffset(4)]
            internal QtCore.QAtomicInt.Internal refs;

            [FieldOffset(8)]
            public global::System.IntPtr VertexAttribI4usv;

            [FieldOffset(12)]
            public global::System.IntPtr VertexAttribI4ubv;

            [FieldOffset(16)]
            public global::System.IntPtr VertexAttribI4sv;

            [FieldOffset(20)]
            public global::System.IntPtr VertexAttribI4bv;

            [FieldOffset(24)]
            public global::System.IntPtr VertexAttribI4uiv;

            [FieldOffset(28)]
            public global::System.IntPtr VertexAttribI3uiv;

            [FieldOffset(32)]
            public global::System.IntPtr VertexAttribI2uiv;

            [FieldOffset(36)]
            public global::System.IntPtr VertexAttribI1uiv;

            [FieldOffset(40)]
            public global::System.IntPtr VertexAttribI4iv;

            [FieldOffset(44)]
            public global::System.IntPtr VertexAttribI3iv;

            [FieldOffset(48)]
            public global::System.IntPtr VertexAttribI2iv;

            [FieldOffset(52)]
            public global::System.IntPtr VertexAttribI1iv;

            [FieldOffset(56)]
            public global::System.IntPtr VertexAttribI4ui;

            [FieldOffset(60)]
            public global::System.IntPtr VertexAttribI3ui;

            [FieldOffset(64)]
            public global::System.IntPtr VertexAttribI2ui;

            [FieldOffset(68)]
            public global::System.IntPtr VertexAttribI1ui;

            [FieldOffset(72)]
            public global::System.IntPtr VertexAttribI4i;

            [FieldOffset(76)]
            public global::System.IntPtr VertexAttribI3i;

            [FieldOffset(80)]
            public global::System.IntPtr VertexAttribI2i;

            [FieldOffset(84)]
            public global::System.IntPtr VertexAttribI1i;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN38QOpenGLFunctions_3_0_DeprecatedBackendC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLFunctions_3_0_DeprecatedBackend __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions_3_0_DeprecatedBackend((QOpenGLFunctions_3_0_DeprecatedBackend.Internal*) native);
        }

        public static QOpenGLFunctions_3_0_DeprecatedBackend __CreateInstance(QOpenGLFunctions_3_0_DeprecatedBackend.Internal native)
        {
            return new QOpenGLFunctions_3_0_DeprecatedBackend(native);
        }

        private static QOpenGLFunctions_3_0_DeprecatedBackend.Internal* __CopyValue(QOpenGLFunctions_3_0_DeprecatedBackend.Internal native)
        {
            var ret = Marshal.AllocHGlobal(88);
            QtGui.QOpenGLFunctions_3_0_DeprecatedBackend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFunctions_3_0_DeprecatedBackend.Internal*) ret;
        }

        private QOpenGLFunctions_3_0_DeprecatedBackend(QOpenGLFunctions_3_0_DeprecatedBackend.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions_3_0_DeprecatedBackend(QOpenGLFunctions_3_0_DeprecatedBackend.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QOpenGLVersionFunctionsBackend.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QOpenGLVersionProfile class represents the version and if
    /// applicable the profile of an OpenGL context.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>An object of this class can be passed to
    /// QOpenGLContext::versionFunctions() to request a functions object for a
    /// specific version and profile of OpenGL.</para>
    /// <para>It also contains some helper functions to check if a version
    /// supports profiles or is a legacy version.</para>
    /// </remarks>
    public unsafe partial class QOpenGLVersionProfile : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QOpenGLVersionProfileC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QOpenGLVersionProfileC2ERK14QSurfaceFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QOpenGLVersionProfileC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QOpenGLVersionProfileD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QOpenGLVersionProfile10setVersionEii")]
            internal static extern void SetVersion_0(global::System.IntPtr instance, int majorVersion, int minorVersion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK21QOpenGLVersionProfile7profileEv")]
            internal static extern QSurfaceFormat.OpenGLContextProfile Profile_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QOpenGLVersionProfile10setProfileEN14QSurfaceFormat20OpenGLContextProfileE")]
            internal static extern void SetProfile_0(global::System.IntPtr instance, QSurfaceFormat.OpenGLContextProfile profile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK21QOpenGLVersionProfile11hasProfilesEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasProfiles_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK21QOpenGLVersionProfile15isLegacyVersionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsLegacyVersion_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK21QOpenGLVersionProfile7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLVersionProfile __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLVersionProfile((QOpenGLVersionProfile.Internal*) native);
        }

        public static QOpenGLVersionProfile __CreateInstance(QOpenGLVersionProfile.Internal native)
        {
            return new QOpenGLVersionProfile(native);
        }

        private static QOpenGLVersionProfile.Internal* __CopyValue(QOpenGLVersionProfile.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QOpenGLVersionProfile.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QOpenGLVersionProfile.Internal*) ret;
        }

        private QOpenGLVersionProfile(QOpenGLVersionProfile.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLVersionProfile(QOpenGLVersionProfile.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a default invalid QOpenGLVersionProfile object.</para>
        /// </summary>
        public QOpenGLVersionProfile()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a QOpenGLVersionProfile object initialised with the
        /// version and profile from format.</para>
        /// </summary>
        public QOpenGLVersionProfile(QSurfaceFormat format)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a copy of other.</para>
        /// </summary>
        public QOpenGLVersionProfile(QOpenGLVersionProfile other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the major and minor version numbers to majorVersion and
        /// minorVersion respectively.</para>
        /// <para>See also version().</para>
        /// </summary>
        public void SetVersion(int majorVersion, int minorVersion)
        {
            Internal.SetVersion_0(__Instance, majorVersion, minorVersion);
        }

        /// <summary>
        /// <para>Returns the OpenGL profile. Only makes sense if profiles are
        /// supported by this version.</para>
        /// <para>See also setProfile().</para>
        /// <para></para>
        /// <para>Sets the OpenGL profile profile. Only makes sense if profiles are
        /// supported by this version.</para>
        /// <para>See also profile().</para>
        /// </summary>
        public QSurfaceFormat.OpenGLContextProfile Profile
        {
            get
            {
                var __ret = Internal.Profile_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetProfile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if profiles are supported by the OpenGL version
        /// returned by version(). Only OpenGL versions &gt;= 3.2 support
        /// profiles.</para>
        /// <para>See also profile() and version().</para>
        /// </summary>
        public bool HasProfiles
        {
            get
            {
                var __ret = Internal.HasProfiles_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true is the OpenGL version returned by version() contains
        /// deprecated functions and does not support profiles i.e. if the OpenGL
        /// version is &lt;= 3.1.</para>
        /// </summary>
        public bool IsLegacyVersion
        {
            get
            {
                var __ret = Internal.IsLegacyVersion_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the version number is valid. Note that for a
        /// default constructed QOpenGLVersionProfile object this function will return
        /// false.</para>
        /// <para>See also setVersion() and version().</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLContextGroup class represents a group of contexts
    /// sharing OpenGL resources.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QOpenGLContextGroup is automatically created and managed by
    /// QOpenGLContext instances. Its purpose is to identify all the contexts that
    /// are sharing resources.</para>
    /// <para></para>
    /// <para>See also QOpenGLContext::shareGroup().</para>
    /// </remarks>
    public unsafe partial class QOpenGLContextGroup : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QOpenGLContextGroupC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QOpenGLContextGroupD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QOpenGLContextGroup6sharesEv")]
            internal static extern QList.Internal Shares_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN19QOpenGLContextGroup19currentContextGroupEv")]
            internal static extern global::System.IntPtr CurrentContextGroup_0();
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLContextGroup __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLContextGroup((QOpenGLContextGroup.Internal*) native);
        }

        public static QOpenGLContextGroup __CreateInstance(QOpenGLContextGroup.Internal native)
        {
            return new QOpenGLContextGroup(native);
        }

        private static QOpenGLContextGroup.Internal* __CopyValue(QOpenGLContextGroup.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLContextGroup.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLContextGroup.Internal*) ret;
        }

        private QOpenGLContextGroup(QOpenGLContextGroup.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLContextGroup(QOpenGLContextGroup.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns all the QOpenGLContext objects in this share
        /// group.</para>
        /// </summary>
        public System.Collections.Generic.IList<QOpenGLContext> Shares
        {
            get
            {
                var __ret = Internal.Shares_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QOpenGLContext>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QOpenGLContext.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>Returns the QOpenGLContextGroup corresponding to the current
        /// context.</para>
        /// <para>See also QOpenGLContext::currentContext().</para>
        /// </summary>
        public static QOpenGLContextGroup CurrentContextGroup
        {
            get
            {
                var __ret = Internal.CurrentContextGroup_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLContextGroup.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QOpenGLContextGroup()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLContextGroup) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLContext class represents a native OpenGL context,
    /// enabling OpenGL rendering on a QSurface.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QOpenGLContext represents the OpenGL state of an underlying
    /// OpenGL context. To set up a context, set its screen and format such that
    /// they match those of the surface or surfaces with which the context is meant
    /// to be used, if necessary make it share resources with other contexts with
    /// setShareContext(), and finally call create(). Use the return value or
    /// isValid() to check if the context was successfully initialized.</para>
    /// <para>A context can be made current against a given surface by calling
    /// makeCurrent(). When OpenGL rendering is done, call swapBuffers() to swap
    /// the front and back buffers of the surface, so that the newly rendered
    /// content becomes visible. To be able to support certain platforms,
    /// QOpenGLContext requires that you call makeCurrent() again before starting
    /// rendering a new frame, after calling swapBuffers().</para>
    /// <para>If the context is temporarily not needed, such as when the
    /// application is not rendering, it can be useful to delete it in order to
    /// free resources. You can connect to the aboutToBeDestroyed() signal to clean
    /// up any resources that have been allocated with different ownership from the
    /// QOpenGLContext itself.</para>
    /// <para>Once a QOpenGLContext has been made current, you can render to it
    /// in a platform independent way by using Qt's OpenGL enablers such as
    /// QOpenGLFunctions, QOpenGLBuffer, QOpenGLShaderProgram, and
    /// QOpenGLFramebufferObject. It is also possible to use the platform's OpenGL
    /// API directly, without using the Qt enablers, although potentially at the
    /// cost of portability. The latter is necessary when wanting to use OpenGL 1.x
    /// or OpenGL ES 1.x.</para>
    /// <para>For more information about the OpenGL API, refer to the official
    /// OpenGL documentation.</para>
    /// <para>For an example of how to use QOpenGLContext see the OpenGL Window
    /// example.</para>
    /// <para></para>
    /// <para>Thread Affinity</para>
    /// <para>QOpenGLContext can be moved to a different thread with
    /// moveToThread(). Do not call makeCurrent() from a different thread than the
    /// one to which the QOpenGLContext object belongs. A context can only be
    /// current in one thread and against one surface at a time, and a thread only
    /// has one context current at a time.</para>
    /// <para></para>
    /// <para>Context Resource Sharing</para>
    /// <para>Resources, such as framebuffer objects, textures, and vertex
    /// buffer objects can be shared between contexts. Use setShareContext() before
    /// calling create() to specify that the contexts should share these resources.
    /// QOpenGLContext internally keeps track of a QOpenGLContextGroup object which
    /// can be accessed with shareGroup(), and which can be used to find all the
    /// contexts in a given share group. A share group consists of all contexts
    /// that have been successfully initialized and are sharing with an existing
    /// context in the share group. A non-sharing context has a share group
    /// consisting of a single context.</para>
    /// <para></para>
    /// <para>Default Framebuffer</para>
    /// <para>On certain platforms, a framebuffer other than 0 might be the
    /// default frame buffer depending on the current surface. Instead of calling
    /// glBindFramebuffer(0), it is recommended that you use
    /// glBindFramebuffer(ctx-&gt;defaultFramebufferObject()), to ensure that your
    /// application is portable between different platforms. However, if you use
    /// QOpenGLFunctions::glBindFramebuffer(), this is done automatically for
    /// you.</para>
    /// <para></para>
    /// <para>See also QOpenGLFunctions, QOpenGLBuffer, QOpenGLShaderProgram,
    /// and QOpenGLFramebufferObject.</para>
    /// </remarks>
    public unsafe partial class QOpenGLContext : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContextC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContextD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext11makeCurrentEP8QSurface")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool MakeCurrent_0(global::System.IntPtr instance, global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext11doneCurrentEv")]
            internal static extern void DoneCurrent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext11swapBuffersEP8QSurface")]
            internal static extern void SwapBuffers_0(global::System.IntPtr instance, global::System.IntPtr surface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QOpenGLContext10areSharingEPS_S0_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AreSharing_0(global::System.IntPtr first, global::System.IntPtr second);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext16versionFunctionsERK21QOpenGLVersionProfile")]
            internal static extern global::System.IntPtr VersionFunctions_0(global::System.IntPtr instance, global::System.IntPtr versionProfile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QOpenGLContext18openGLModuleHandleEv")]
            internal static extern global::System.IntPtr OpenGLModuleHandle_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QOpenGLContext16openGLModuleTypeEv")]
            internal static extern QOpenGLContext.OpenGLModuleType openGLModuleType_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext6formatEv")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext9setFormatERK14QSurfaceFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext12shareContextEv")]
            internal static extern global::System.IntPtr ShareContext_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext15setShareContextEPS_")]
            internal static extern void SetShareContext_0(global::System.IntPtr instance, global::System.IntPtr shareContext);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext6screenEv")]
            internal static extern global::System.IntPtr Screen_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLContext9setScreenEP7QScreen")]
            internal static extern void SetScreen_0(global::System.IntPtr instance, global::System.IntPtr screen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext10shareGroupEv")]
            internal static extern global::System.IntPtr ShareGroup_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext7surfaceEv")]
            internal static extern global::System.IntPtr Surface_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QOpenGLContext14currentContextEv")]
            internal static extern global::System.IntPtr CurrentContext_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext9functionsEv")]
            internal static extern global::System.IntPtr Functions_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLContext10isOpenGLESEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOpenGLES_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum defines the type of the underlying OpenGL
        /// implementation.</para>
        /// <para>This enum was introduced or modified in  Qt 5.3.</para>
        /// </summary>
        public enum OpenGLModuleType : uint
        {
            /// <summary>OpenGL</summary>
            LibGL = 0,
            /// <summary>OpenGL ES 2.0 or higher</summary>
            LibGLES = 1
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted before the underlying native OpenGL context is destroyed, such that users may clean up OpenGL resources that might otherwise be left dangling in the case of shared OpenGL contexts.</para>
        /// <para>If you wish to make the context current in order to do clean-up, make sure to only connect to the signal using a direct connection.</para>
        /// </summary>
        public event Action AboutToBeDestroyed
        {
        	add
        	{
                ConnectDynamicSlot(this, "aboutToBeDestroyed()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "aboutToBeDestroyed()", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLContext __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLContext((QOpenGLContext.Internal*) native);
        }

        public static QOpenGLContext __CreateInstance(QOpenGLContext.Internal native)
        {
            return new QOpenGLContext(native);
        }

        private static QOpenGLContext.Internal* __CopyValue(QOpenGLContext.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLContext.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLContext.Internal*) ret;
        }

        private QOpenGLContext(QOpenGLContext.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLContext(QOpenGLContext.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Attempts to create the OpenGL context with the current
        /// configuration.</para>
        /// <para>The current configuration includes the format, the share context,
        /// and the screen.</para>
        /// <para>If the OpenGL implementation on your system does not support the
        /// requested version of OpenGL context, then QOpenGLContext will try to create
        /// the closest matching version. The actual created context properties can be
        /// queried using the QSurfaceFormat returned by the format() function. For
        /// example, if you request a context that supports OpenGL 4.3 Core profile but
        /// the driver and/or hardware only supports version 3.2 Core profile contexts
        /// then you will get a 3.2 Core profile context.</para>
        /// <para>Returns true if the native context was successfully created and
        /// is ready to be used with makeCurrent(), swapBuffers(), etc.</para>
        /// <para>Note: If the context is already created, this function will first
        /// call destroy(), and then create a new OpenGL context.See also makeCurrent()
        /// and format().</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Makes the context current in the current thread, against the
        /// given surface. Returns true if successful.</para>
        /// <para>If surface is 0 this is equivalent to calling
        /// doneCurrent().</para>
        /// <para>Do not call this function from a different thread than the one
        /// the QOpenGLContext instance lives in. If you wish to use QOpenGLContext
        /// from a different thread you should first call make sure it's not current in
        /// the current thread, by calling doneCurrent() if necessary. Then call
        /// moveToThread(otherThread) before using it in the other thread.</para>
        /// <para>See also functions() and doneCurrent().</para>
        /// </summary>
        public bool MakeCurrent(QSurface surface)
        {
            var arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            var __ret = Internal.MakeCurrent_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Convenience function for calling makeCurrent with a 0
        /// surface.</para>
        /// <para>This results in no context being current in the current
        /// thread.</para>
        /// <para>See also makeCurrent() and currentContext().</para>
        /// </summary>
        public void DoneCurrent()
        {
            Internal.DoneCurrent_0(__Instance);
        }

        /// <summary>
        /// <para>Swap the back and front buffers of surface.</para>
        /// <para>Call this to finish a frame of OpenGL rendering, and make sure to
        /// call makeCurrent() again before you begin a new frame.</para>
        /// </summary>
        public void SwapBuffers(QSurface surface)
        {
            var arg0 = ReferenceEquals(surface, null) ? global::System.IntPtr.Zero : surface.__Instance;
            Internal.SwapBuffers_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns a pointer to an object that provides access to all
        /// functions for the versionProfile of this context. Before using any of the
        /// functions they must be initialized by calling
        /// QAbstractOpenGLFunctions::initializeOpenGLFunctions() with this context
        /// being the current context.</para>
        /// <para>Usually one would use the template version of this function to
        /// automatically have the result cast to the correct type.</para>
        /// </summary>
        public QAbstractOpenGLFunctions VersionFunctions(QOpenGLVersionProfile versionProfile)
        {
            var arg0 = ReferenceEquals(versionProfile, null) ? global::System.IntPtr.Zero : versionProfile.__Instance;
            var __ret = Internal.VersionFunctions_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QAbstractOpenGLFunctions.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a pointer to an object that provides access to all
        /// functions for the versionProfile of this context. Before using any of the
        /// functions they must be initialized by calling
        /// QAbstractOpenGLFunctions::initializeOpenGLFunctions() with this context
        /// being the current context.</para>
        /// <para>Usually one would use the template version of this function to
        /// automatically have the result cast to the correct type.</para>
        /// </summary>
        public QAbstractOpenGLFunctions VersionFunctions()
        {
            return VersionFunctions(new QOpenGLVersionProfile());
        }

        /// <summary>
        /// <para>Returns true if the first and second contexts are sharing OpenGL
        /// resources.</para>
        /// </summary>
        public static bool AreSharing(QOpenGLContext first, QOpenGLContext second)
        {
            var arg0 = ReferenceEquals(first, null) ? global::System.IntPtr.Zero : first.__Instance;
            var arg1 = ReferenceEquals(second, null) ? global::System.IntPtr.Zero : second.__Instance;
            var __ret = Internal.AreSharing_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the platform-specific handle for the OpenGL
        /// implementation that is currently in use. (for example, a HMODULE on
        /// Windows)</para>
        /// <para>On platforms that do not use dynamic GL switch the return value
        /// is null.</para>
        /// <para>The library might be GL-only, meaning that windowing system
        /// interface functions (for example EGL) may live in another, separate
        /// library.</para>
        /// <para>Note: This function requires that the QGuiApplication instance is
        /// already created.This function was introduced in  Qt 5.3.</para>
        /// <para>See also openGLModuleType().</para>
        /// </summary>
        public static global::System.IntPtr OpenGLModuleHandle()
        {
            var __ret = Internal.OpenGLModuleHandle_0();
            if (__ret == global::System.IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        /// <summary>
        /// <para>Returns the underlying OpenGL implementation type.</para>
        /// <para>On platforms where the OpenGL implementation is not dynamically
        /// loaded, the return value is determined during compile time and never
        /// changes.</para>
        /// <para>Note: A desktop OpenGL implementation may be capable of creating
        /// ES-compatible contexts too. Therefore in most cases it is more appropriate
        /// to check QSurfaceFormat::renderableType() or using the the convenience
        /// function isOpenGLES().Note: This function requires that the QGuiApplication
        /// instance is already created.This function was introduced in  Qt 5.3.</para>
        /// </summary>
        public static QOpenGLContext.OpenGLModuleType openGLModuleType()
        {
            var __ret = Internal.openGLModuleType_0();
            return __ret;
        }

        /// <summary>
        /// <para>Returns the format of the underlying platform context, if
        /// create() has been called.</para>
        /// <para>Otherwise, returns the requested format.</para>
        /// <para>The requested and the actual format may differ. Requesting a
        /// given OpenGL version does not mean the resulting context will target
        /// exactly the requested version. It is only guaranteed that the
        /// version/profile/options combination for the created context is compatible
        /// with the request, as long as the driver is able to provide such a
        /// context.</para>
        /// <para>For example, requesting an OpenGL version 3.x core profile
        /// context may result in an OpenGL 4.x core profile context. Similarly, a
        /// request for OpenGL 2.1 may result in an OpenGL 3.0 context with deprecated
        /// functions enabled. Finally, depending on the driver, unsupported versions
        /// may result in either a context creation failure or in a context for the
        /// highest supported version.</para>
        /// <para>Similar differences are possible in the buffer sizes, for
        /// example, the resulting context may have a larger depth buffer than
        /// requested. This is perfectly normal.</para>
        /// <para>See also setFormat().</para>
        /// <para></para>
        /// <para>Sets the format the OpenGL context should be compatible with. You
        /// need to call create() before it takes effect.</para>
        /// <para>When the format is not explicitly set via this function, the
        /// format returned by QSurfaceFormat::defaultFormat() will be used. This means
        /// that when having multiple contexts, individual calls to this function can
        /// be replaced by one single call to QSurfaceFormat::setDefaultFormat() before
        /// creating the first context.</para>
        /// <para>See also format().</para>
        /// </summary>
        public QSurfaceFormat Format
        {
            get
            {
                var __ret = new QtGui.QSurfaceFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QSurfaceFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the share context this context was created with.</para>
        /// <para>If the underlying platform was not able to support the requested
        /// sharing, this will return 0.</para>
        /// <para>See also setShareContext().</para>
        /// <para></para>
        /// <para>Makes this context share textures, shaders, and other OpenGL
        /// resources with shareContext. You need to call create() before it takes
        /// effect.</para>
        /// <para>See also shareContext().</para>
        /// </summary>
        public QOpenGLContext ShareContext
        {
            get
            {
                var __ret = Internal.ShareContext_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLContext.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetShareContext_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the screen the context was created for.</para>
        /// <para>See also setScreen().</para>
        /// <para></para>
        /// <para>Sets the screen the OpenGL context should be valid for. You need
        /// to call create() before it takes effect.</para>
        /// <para>See also screen().</para>
        /// </summary>
        public QScreen Screen
        {
            get
            {
                var __ret = Internal.Screen_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QScreen.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetScreen_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns if this context is valid, i.e. has been successfully
        /// created.</para>
        /// <para>See also create().</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the share group this context belongs to.</para>
        /// </summary>
        public QOpenGLContextGroup ShareGroup
        {
            get
            {
                var __ret = Internal.ShareGroup_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLContextGroup.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the surface the context has been made current
        /// with.</para>
        /// <para>This is the surface passed as an argument to
        /// makeCurrent().</para>
        /// </summary>
        public QSurface Surface
        {
            get
            {
                var __ret = Internal.Surface_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QSurfaceInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the last context which called makeCurrent in the current
        /// thread, or 0, if no context is current.</para>
        /// </summary>
        public static QOpenGLContext CurrentContext
        {
            get
            {
                var __ret = Internal.CurrentContext_0();
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLContext.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Get the QOpenGLFunctions instance for this context.</para>
        /// <para>QOpenGLContext offers this as a convenient way to access
        /// QOpenGLFunctions without having to manage it manually.</para>
        /// <para>The context or a sharing context must be current.</para>
        /// <para>The returned QOpenGLFunctions instance is ready to be used and it
        /// does not need initializeOpenGLFunctions() to be called.</para>
        /// </summary>
        public QOpenGLFunctions Functions
        {
            get
            {
                var __ret = Internal.Functions_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLFunctions.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the context is an OpenGL ES context.</para>
        /// <para>If the context has not yet been created, the result is based on
        /// the requested format set via setFormat().</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also create(), format(), and setFormat().</para>
        /// </summary>
        public bool IsOpenGLES
        {
            get
            {
                var __ret = Internal.IsOpenGLES_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QOpenGLContext()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLContext) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QWindow class represents a window in the underlying windowing
    /// system.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A window that is supplied a parent becomes a native child window
    /// of their parent window.</para>
    /// <para>An application will typically use QWidget or QQuickView for its
    /// UI, and not QWindow directly. Still, it is possible to render directly to a
    /// QWindow with QBackingStore or QOpenGLContext, when wanting to keep
    /// dependencies to a minimum or when wanting to use OpenGL directly. The
    /// Raster Window Example and OpenGL Window Example are useful reference
    /// examples for how to render to a QWindow using either approach.</para>
    /// <para></para>
    /// <para>Resource Management</para>
    /// <para>Windows can potentially use a lot of memory. A usual measurement
    /// is width times height times color depth. A window might also include
    /// multiple buffers to support double and triple buffering, as well as depth
    /// and stencil buffers. To release a window's memory resources, call the
    /// destroy() function.</para>
    /// <para></para>
    /// <para>Content Orientation</para>
    /// <para>QWindow has reportContentOrientationChange() that can be used to
    /// specify the layout of the window contents in relation to the screen. The
    /// content orientation is simply a hint to the windowing system about which
    /// orientation the window contents are in. It's useful when you wish to keep
    /// the same window size, but rotate the contents instead, especially when
    /// doing rotation animations between different orientations. The windowing
    /// system might use this value to determine the layout of system popups or
    /// dialogs.</para>
    /// <para></para>
    /// <para>Visibility and Windowing System Exposure</para>
    /// <para>By default, the window is not visible, and you must call
    /// setVisible(true), or show() or similar to make it visible. To make a window
    /// hidden again, call setVisible(false) or hide(). The visible property
    /// describes the state the application wants the window to be in. Depending on
    /// the underlying system, a visible window might still not be shown on the
    /// screen. It could, for instance, be covered by other opaque windows or moved
    /// outside the physical area of the screen. On windowing systems that have
    /// exposure notifications, the isExposed() accessor describes whether the
    /// window should be treated as directly visible on screen. The exposeEvent()
    /// function is called whenever the windows exposure in the windowing system
    /// changes. On windowing systems that do not make this information visible to
    /// the application, isExposed() will simply return the same value as
    /// isVisible().</para>
    /// <para>QWindow::Visibility queried through visibility() is a convenience
    /// API combining the functions of visible() and windowState().</para>
    /// <para></para>
    /// <para>Rendering</para>
    /// <para>There are two Qt APIs that can be used to render content into a
    /// window, QBackingStore for rendering with a QPainter and flushing the
    /// contents to a window with type QSurface::RasterSurface, and QOpenGLContext
    /// for rendering with OpenGL to a window with type
    /// QSurface::OpenGLSurface.</para>
    /// <para>The application can start rendering as soon as isExposed()
    /// returns true, and can keep rendering until it isExposed() returns false. To
    /// find out when isExposed() changes, reimplement exposeEvent(). The window
    /// will always get a resize event before the first expose event.</para>
    /// <para></para>
    /// <para>Initial Geometry</para>
    /// <para>If the window's width and height are left uninitialized, the
    /// window will get a reasonable default geometry from the platform window. If
    /// the position is left uninitialized, then the platform window will allow the
    /// windowing system to position the window. For example on X11, the window
    /// manager usually does some kind of smart positioning to try to avoid having
    /// new windows completely obscure existing windows. However setGeometry()
    /// initializes both the position and the size, so if you want a fixed size but
    /// an automatic position, you should call resize() or setWidth() and
    /// setHeight() instead.</para>
    /// </remarks>
    public unsafe partial class QWindow : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QSurface.SurfaceClass m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindowC2EP7QScreen")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr screen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindowC2EPS_")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindowC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindowD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow14setSurfaceTypeEN8QSurface11SurfaceTypeE")]
            internal static extern void SetSurfaceType_0(global::System.IntPtr instance, QSurface.SurfaceType surfaceType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow6createEv")]
            internal static extern void Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9setFormatERK14QSurfaceFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow12isAncestorOfEPKS_NS_12AncestorModeE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsAncestorOf_0(global::System.IntPtr instance, global::System.IntPtr child, QWindow.AncestorMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11setGeometryEiiii")]
            internal static extern void SetGeometry_0(global::System.IntPtr instance, int posx, int posy, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11setPositionEii")]
            internal static extern void SetPosition_1(global::System.IntPtr instance, int posx, int posy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow6resizeEii")]
            internal static extern void Resize_1(global::System.IntPtr instance, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow22setKeyboardGrabEnabledEb")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetKeyboardGrabEnabled_0(global::System.IntPtr instance, bool grab);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow19setMouseGrabEnabledEb")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetMouseGrabEnabled_0(global::System.IntPtr instance, bool grab);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11unsetCursorEv")]
            internal static extern void UnsetCursor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow15requestActivateEv")]
            internal static extern void RequestActivate_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow4showEv")]
            internal static extern void Show_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow4hideEv")]
            internal static extern void Hide_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow13showMinimizedEv")]
            internal static extern void ShowMinimized_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow13showMaximizedEv")]
            internal static extern void ShowMaximized_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow14showFullScreenEv")]
            internal static extern void ShowFullScreen_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow10showNormalEv")]
            internal static extern void ShowNormal_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow5closeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Close_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow5raiseEv")]
            internal static extern void Raise_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow5lowerEv")]
            internal static extern void Lower_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow4setXEi")]
            internal static extern void SetX_0(global::System.IntPtr instance, int arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow4setYEi")]
            internal static extern void SetY_0(global::System.IntPtr instance, int arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow8setWidthEi")]
            internal static extern void SetWidth_0(global::System.IntPtr instance, int arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9setHeightEi")]
            internal static extern void SetHeight_0(global::System.IntPtr instance, int arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow15setMinimumWidthEi")]
            internal static extern void SetMinimumWidth_0(global::System.IntPtr instance, int w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow16setMinimumHeightEi")]
            internal static extern void SetMinimumHeight_0(global::System.IntPtr instance, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow15setMaximumWidthEi")]
            internal static extern void SetMaximumWidth_0(global::System.IntPtr instance, int w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow16setMaximumHeightEi")]
            internal static extern void SetMaximumHeight_0(global::System.IntPtr instance, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow5alertEi")]
            internal static extern void Alert_0(global::System.IntPtr instance, int msec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11exposeEventEP12QExposeEvent")]
            internal static extern void OnExposeEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11resizeEventEP12QResizeEvent")]
            internal static extern void OnResizeEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9moveEventEP10QMoveEvent")]
            internal static extern void OnMoveEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow12focusInEventEP11QFocusEvent")]
            internal static extern void OnFocusInEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow13focusOutEventEP11QFocusEvent")]
            internal static extern void OnFocusOutEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9showEventEP10QShowEvent")]
            internal static extern void OnShowEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9hideEventEP10QHideEvent")]
            internal static extern void OnHideEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow13keyPressEventEP9QKeyEvent")]
            internal static extern void OnKeyPressEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow15keyReleaseEventEP9QKeyEvent")]
            internal static extern void OnKeyReleaseEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow15mousePressEventEP11QMouseEvent")]
            internal static extern void OnMousePressEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow17mouseReleaseEventEP11QMouseEvent")]
            internal static extern void OnMouseReleaseEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow21mouseDoubleClickEventEP11QMouseEvent")]
            internal static extern void OnMouseDoubleClickEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow14mouseMoveEventEP11QMouseEvent")]
            internal static extern void OnMouseMoveEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow10wheelEventEP11QWheelEvent")]
            internal static extern void OnWheelEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow10touchEventEP11QTouchEvent")]
            internal static extern void OnTouchEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11tabletEventEP12QTabletEvent")]
            internal static extern void OnTabletEvent_0(global::System.IntPtr instance, global::System.IntPtr ev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow11surfaceTypeEv")]
            internal static extern QSurface.SurfaceType SurfaceType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow10visibilityEv")]
            internal static extern QWindow.Visibility visibility_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow13setVisibilityENS_10VisibilityE")]
            internal static extern void SetVisibility_0(global::System.IntPtr instance, QWindow.Visibility v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow6parentEv")]
            internal static extern global::System.IntPtr Parent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9setParentEPS_")]
            internal static extern void SetParent_0(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow6formatEv")]
            internal static extern void Format_0(global::System.IntPtr _return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow4maskEv")]
            internal static extern void Mask_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow7setMaskERK7QRegion")]
            internal static extern void SetMask_0(global::System.IntPtr instance, global::System.IntPtr region);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow15transientParentEv")]
            internal static extern global::System.IntPtr TransientParent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow18setTransientParentEPS_")]
            internal static extern void SetTransientParent_0(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow8filePathEv")]
            internal static extern void FilePath_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow11setFilePathERK7QString")]
            internal static extern void SetFilePath_0(global::System.IntPtr instance, global::System.IntPtr filePath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow4iconEv")]
            internal static extern void Icon_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow7setIconERK5QIcon")]
            internal static extern void SetIcon_0(global::System.IntPtr instance, global::System.IntPtr icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow6screenEv")]
            internal static extern global::System.IntPtr Screen_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9setScreenEP7QScreen")]
            internal static extern void SetScreen_0(global::System.IntPtr instance, global::System.IntPtr screen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow6cursorEv")]
            internal static extern void Cursor_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow9setCursorERK7QCursor")]
            internal static extern void SetCursor_0(global::System.IntPtr instance, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow9isVisibleEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Visible_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow10setVisibleEb")]
            internal static extern void SetVisible_0(global::System.IntPtr instance, bool visible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow5titleEv")]
            internal static extern void Title_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QWindow8setTitleERK7QString")]
            internal static extern void SetTitle_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QSurface12surfaceClassEv")]
            internal static extern QSurface.SurfaceClass SurfaceClass_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QSurface14supportsOpenGLEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsOpenGL_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow10isTopLevelEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsTopLevel_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow7isModalEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsModal_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow15requestedFormatEv")]
            internal static extern void RequestedFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow8isActiveEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsActive_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow9isExposedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsExposed_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QWindow14accessibleRootEv")]
            internal static extern global::System.IntPtr AccessibleRoot_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes what part of the screen the window occupies
        /// or should occupy.</para>
        /// <para>This enum was introduced or modified in  Qt 5.1.</para>
        /// </summary>
        public enum Visibility : uint
        {
            /// <summary>The window is not visible in any way, however it may remember a latent visibility which can be restored by setting AutomaticVisibility.</summary>
            Hidden = 0,
            /// <summary>This means to give the window a default visible state, which might be fullscreen or windowed depending on the platform. It can be given as a parameter to setVisibility but will never be read back from the visibility accessor.</summary>
            AutomaticVisibility = 1,
            /// <summary>The window occupies part of the screen, but not necessarily the entire screen. This state will occur only on windowing systems which support showing multiple windows simultaneously. In this state it is possible for the user to move and resize the window manually, if WindowFlags permit it and if it is supported by the windowing system.</summary>
            Windowed = 2,
            /// <summary>The window is reduced to an entry or icon on the task bar, dock, task list or desktop, depending on how the windowing system handles minimized windows.</summary>
            Minimized = 3,
            /// <summary>The window occupies one entire screen, and the titlebar is still visible. On most windowing systems this is the state achieved by clicking the maximize button on the toolbar.</summary>
            Maximized = 4,
            /// <summary>The window occupies one entire screen, is not resizable, and there is no titlebar. On some platforms which do not support showing multiple simultaneous windows, this can be the usual visibility when the window is not hidden.</summary>
            FullScreen = 5
        }

        /// <summary>
        /// <para>This enum is used to control whether or not transient parents
        /// should be considered ancestors.</para>
        /// </summary>
        public enum AncestorMode : uint
        {
            /// <summary>Transient parents are not considered ancestors.</summary>
            ExcludeTransients = 0,
            /// <summary>Transient parents are considered ancestors.</summary>
            IncludeTransients = 1
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>The expose event (ev) is sent by the window system whenever the window's exposure on screen changes.</para>
        /// <para>The application can start rendering into the window with QBackingStore and QOpenGLContext as soon as it gets an exposeEvent() such that isExposed() is true.</para>
        /// <para>If the window is moved off screen, is made totally obscured by another window, iconified or similar, this function might be called and the value of isExposed() might change to false. When this happens, an application should stop its rendering as it is no longer visible to the user.</para>
        /// <para>A resize event will always be sent before the expose event the first time a window is shown.</para>
        /// <para>See also isExposed().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QExposeEvent>> ExposeEvent
        {
        	add
        	{
        		QEventArgs<QExposeEvent> qEventArgs = new QEventArgs<QExposeEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Expose });
        		QEventHandler<QExposeEvent> qEventHandler = new QEventHandler<QExposeEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle resize events (ev).</para>
        /// <para>The resize event is called whenever the window is resized in the windowing system, either directly through the windowing system acknowledging a setGeometry() or resize() request, or indirectly through the user resizing the window manually.</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QResizeEvent>> ResizeEvent
        {
        	add
        	{
        		QEventArgs<QResizeEvent> qEventArgs = new QEventArgs<QResizeEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Resize });
        		QEventHandler<QResizeEvent> qEventHandler = new QEventHandler<QResizeEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle window move events (ev).</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QMoveEvent>> MoveEvent
        {
        	add
        	{
        		QEventArgs<QMoveEvent> qEventArgs = new QEventArgs<QMoveEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Move });
        		QEventHandler<QMoveEvent> qEventHandler = new QEventHandler<QMoveEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle focus in events (ev).</para>
        /// <para>Focus in events are sent when the window receives keyboard focus.</para>
        /// <para>See also focusOutEvent().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QFocusEvent>> FocusInEvent
        {
        	add
        	{
        		QEventArgs<QFocusEvent> qEventArgs = new QEventArgs<QFocusEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.FocusIn });
        		QEventHandler<QFocusEvent> qEventHandler = new QEventHandler<QFocusEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle focus out events (ev).</para>
        /// <para>Focus out events are sent when the window loses keyboard focus.</para>
        /// <para>See also focusInEvent().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QFocusEvent>> FocusOutEvent
        {
        	add
        	{
        		QEventArgs<QFocusEvent> qEventArgs = new QEventArgs<QFocusEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.FocusOut });
        		QEventHandler<QFocusEvent> qEventHandler = new QEventHandler<QFocusEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle show events (ev).</para>
        /// <para>The function is called when the window has requested becoming visible.</para>
        /// <para>If the window is successfully shown by the windowing system, this will be followed by a resize and an expose event.</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QShowEvent>> ShowEvent
        {
        	add
        	{
        		QEventArgs<QShowEvent> qEventArgs = new QEventArgs<QShowEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Show });
        		QEventHandler<QShowEvent> qEventHandler = new QEventHandler<QShowEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle hide events (ev).</para>
        /// <para>The function is called when the window has requested being hidden in the windowing system.</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QHideEvent>> HideEvent
        {
        	add
        	{
        		QEventArgs<QHideEvent> qEventArgs = new QEventArgs<QHideEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Hide });
        		QEventHandler<QHideEvent> qEventHandler = new QEventHandler<QHideEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle key press events (ev).</para>
        /// <para>See also keyReleaseEvent().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QKeyEvent>> KeyPressEvent
        {
        	add
        	{
        		QEventArgs<QKeyEvent> qEventArgs = new QEventArgs<QKeyEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.KeyPress });
        		QEventHandler<QKeyEvent> qEventHandler = new QEventHandler<QKeyEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle key release events (ev).</para>
        /// <para>See also keyPressEvent().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QKeyEvent>> KeyReleaseEvent
        {
        	add
        	{
        		QEventArgs<QKeyEvent> qEventArgs = new QEventArgs<QKeyEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.KeyRelease });
        		QEventHandler<QKeyEvent> qEventHandler = new QEventHandler<QKeyEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle mouse press events (ev).</para>
        /// <para>See also mouseReleaseEvent().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QMouseEvent>> MousePressEvent
        {
        	add
        	{
        		QEventArgs<QMouseEvent> qEventArgs = new QEventArgs<QMouseEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.MouseButtonPress });
        		QEventHandler<QMouseEvent> qEventHandler = new QEventHandler<QMouseEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle mouse release events (ev).</para>
        /// <para>See also mousePressEvent().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QMouseEvent>> MouseReleaseEvent
        {
        	add
        	{
        		QEventArgs<QMouseEvent> qEventArgs = new QEventArgs<QMouseEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.MouseButtonRelease });
        		QEventHandler<QMouseEvent> qEventHandler = new QEventHandler<QMouseEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle mouse double click events (ev).</para>
        /// <para>See also mousePressEvent() and QStyleHints::mouseDoubleClickInterval().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QMouseEvent>> MouseDoubleClickEvent
        {
        	add
        	{
        		QEventArgs<QMouseEvent> qEventArgs = new QEventArgs<QMouseEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.MouseButtonDblClick });
        		QEventHandler<QMouseEvent> qEventHandler = new QEventHandler<QMouseEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle mouse move events (ev).</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QMouseEvent>> MouseMoveEvent
        {
        	add
        	{
        		QEventArgs<QMouseEvent> qEventArgs = new QEventArgs<QMouseEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.MouseMove });
        		QEventHandler<QMouseEvent> qEventHandler = new QEventHandler<QMouseEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle mouse wheel or other wheel events (ev).</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QWheelEvent>> WheelEvent
        {
        	add
        	{
        		QEventArgs<QWheelEvent> qEventArgs = new QEventArgs<QWheelEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Wheel });
        		QEventHandler<QWheelEvent> qEventHandler = new QEventHandler<QWheelEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle touch events (ev).</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QTouchEvent>> TouchEvent
        {
        	add
        	{
        		QEventArgs<QTouchEvent> qEventArgs = new QEventArgs<QTouchEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Touch });
        		QEventHandler<QTouchEvent> qEventHandler = new QEventHandler<QTouchEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Override this to handle tablet press, move, and release events (ev).</para>
        /// <para>Proximity enter and leave events are not sent to windows, they are delivered to the application instance.</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QTabletEvent>> TabletEvent
        {
        	add
        	{
        		QEventArgs<QTabletEvent> qEventArgs = new QEventArgs<QTabletEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.TabletMove, QEvent.Type.TabletPress, QEvent.Type.TabletRelease, QEvent.Type.TabletEnterProximity, QEvent.Type.TabletLeaveProximity });
        		QEventHandler<QTabletEvent> qEventHandler = new QEventHandler<QTabletEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when a window's screen changes, either by being set explicitly with setScreen(), or automatically when the window's screen is removed.</para>
        /// </summary>
        public event Action<QScreen> ScreenChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "screenChanged(QScreen)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "screenChanged(QScreen)", value);
        	}
        }

        public event Action<string> WindowTitleChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "windowTitleChanged(QString)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "windowTitleChanged(QString)", value);
        	}
        }

        public event Action<int> XChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "xChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "xChanged(int)", value);
        	}
        }

        public event Action<int> YChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "yChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "yChanged(int)", value);
        	}
        }

        public event Action<int> WidthChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "widthChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "widthChanged(int)", value);
        	}
        }

        public event Action<int> HeightChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "heightChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "heightChanged(int)", value);
        	}
        }

        public event Action<int> MinimumWidthChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "minimumWidthChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "minimumWidthChanged(int)", value);
        	}
        }

        public event Action<int> MinimumHeightChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "minimumHeightChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "minimumHeightChanged(int)", value);
        	}
        }

        public event Action<int> MaximumWidthChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "maximumWidthChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "maximumWidthChanged(int)", value);
        	}
        }

        public event Action<int> MaximumHeightChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "maximumHeightChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "maximumHeightChanged(int)", value);
        	}
        }

        public event Action<bool> VisibleChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "visibleChanged(bool)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "visibleChanged(bool)", value);
        	}
        }

        public event Action<QWindow.Visibility> VisibilityChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "visibilityChanged(QWindow.Visibility)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "visibilityChanged(QWindow.Visibility)", value);
        	}
        }

        public event Action ActiveChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "activeChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "activeChanged()", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QWindow __CreateInstance(global::System.IntPtr native)
        {
            return new QWindow((QWindow.Internal*) native);
        }

        public static QWindow __CreateInstance(QWindow.Internal native)
        {
            return new QWindow(native);
        }

        private static QWindow.Internal* __CopyValue(QWindow.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            QtGui.QWindow.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QWindow.Internal*) ret;
        }

        private QWindow(QWindow.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QWindow(QWindow.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates a window as a top level on the targetScreen.</para>
        /// <para>The window is not shown until setVisible(true), show(), or
        /// similar is called.</para>
        /// <para>See also setScreen().</para>
        /// </summary>
        public QWindow(QScreen screen = null)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(screen, null) ? global::System.IntPtr.Zero : screen.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates a window as a child of the given parent window.</para>
        /// <para>The window will be embedded inside the parent window, its
        /// coordinates relative to the parent.</para>
        /// <para>The screen is inherited from the parent.</para>
        /// <para>See also setParent().</para>
        /// </summary>
        public QWindow(QWindow parent)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            Internal.ctor_1(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the surfaceType of the window.</para>
        /// <para>Specifies whether the window is meant for raster rendering with
        /// QBackingStore, or OpenGL rendering with QOpenGLContext.</para>
        /// <para>The surfaceType will be used when the native surface is created
        /// in the create() function. Calling this function after the native surface
        /// has been created requires calling destroy() and create() to release the old
        /// native surface and create a new one.</para>
        /// <para>See also surfaceType(), QBackingStore, QOpenGLContext, create(),
        /// and destroy().</para>
        /// </summary>
        public void SetSurfaceType(QSurface.SurfaceType surfaceType)
        {
            var arg0 = surfaceType;
            Internal.SetSurfaceType_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Allocates the platform resources associated with the
        /// window.</para>
        /// <para>It is at this point that the surface format set using setFormat()
        /// gets resolved into an actual native surface. However, the window remains
        /// hidden until setVisible() is called.</para>
        /// <para>Note that it is not usually necessary to call this function
        /// directly, as it will be implicitly called by show(), setVisible(), and
        /// other functions that require access to the platform resources.</para>
        /// <para>Call destroy() to free the platform resources if
        /// necessary.</para>
        /// <para>See also destroy().</para>
        /// </summary>
        public void Create()
        {
            Internal.Create_0(__Instance);
        }

        /// <summary>
        /// <para>Sets the window's surface format.</para>
        /// <para>The format determines properties such as color depth, alpha,
        /// depth and stencil buffer size, etc. For example, to give a window a
        /// transparent background (provided that the window system supports
        /// compositing, and provided that other content in the window does not make it
        /// opaque again):</para>
        /// <para>QSurfaceFormat format;</para>
        /// <para>format.setAlphaBufferSize(8);</para>
        /// <para>window.setFormat(format);</para>
        /// <para>The surface format will be resolved in the create() function.
        /// Calling this function after create() has been called will not re-resolve
        /// the surface format of the native surface.</para>
        /// <para>When the format is not explicitly set via this function, the
        /// format returned by QSurfaceFormat::defaultFormat() will be used. This means
        /// that when having multiple windows, individual calls to this function can be
        /// replaced by one single call to QSurfaceFormat::setDefaultFormat() before
        /// creating the first window.</para>
        /// <para>See also format(), create(), destroy(), and
        /// QSurfaceFormat::setDefaultFormat().</para>
        /// </summary>
        public void SetFormat(QSurfaceFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.SetFormat_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns true if the window is an ancestor of the given child. If
        /// mode is IncludeTransients, then transient parents are also considered
        /// ancestors.</para>
        /// </summary>
        public bool IsAncestorOf(QWindow child, QWindow.AncestorMode mode = QWindow.AncestorMode.IncludeTransients)
        {
            var arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            var arg1 = mode;
            var __ret = Internal.IsAncestorOf_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the geometry of the window, excluding its window frame, to a
        /// rectangle constructed from posx, posy, w and h.</para>
        /// <para>See also geometry().</para>
        /// </summary>
        public void SetGeometry(int posx, int posy, int w, int h)
        {
            Internal.SetGeometry_0(__Instance, posx, posy, w, h);
        }

        /// <summary>
        /// <para>set the position of the window on the desktop to posx,
        /// posy</para>
        /// <para>See also position().</para>
        /// </summary>
        public void SetPosition(int posx, int posy)
        {
            Internal.SetPosition_1(__Instance, posx, posy);
        }

        /// <summary>
        /// <para>set the size of the window, excluding any window frame, to a
        /// QSize constructed from width w and height h</para>
        /// <para>See also size() and geometry().</para>
        /// </summary>
        public void Resize(int w, int h)
        {
            Internal.Resize_1(__Instance, w, h);
        }

        /// <summary>
        /// <para>Releases the native platform resources associated with this
        /// window.</para>
        /// <para>See also create().</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Sets whether keyboard grab should be enabled or not
        /// (grab).</para>
        /// <para>If the return value is true, the window receives all key events
        /// until setKeyboardGrabEnabled(false) is called; other windows get no key
        /// events at all. Mouse events are not affected. Use setMouseGrabEnabled() if
        /// you want to grab that.</para>
        /// <para>See also setMouseGrabEnabled().</para>
        /// </summary>
        public bool SetKeyboardGrabEnabled(bool grab)
        {
            var __ret = Internal.SetKeyboardGrabEnabled_0(__Instance, grab);
            return __ret;
        }

        /// <summary>
        /// <para>Sets whether mouse grab should be enabled or not (grab).</para>
        /// <para>If the return value is true, the window receives all mouse events
        /// until setMouseGrabEnabled(false) is called; other windows get no mouse
        /// events at all. Keyboard events are not affected. Use
        /// setKeyboardGrabEnabled() if you want to grab that.</para>
        /// <para>See also setKeyboardGrabEnabled().</para>
        /// </summary>
        public bool SetMouseGrabEnabled(bool grab)
        {
            var __ret = Internal.SetMouseGrabEnabled_0(__Instance, grab);
            return __ret;
        }

        /// <summary>
        /// <para>Restores the default arrow cursor for this window.</para>
        /// </summary>
        public void UnsetCursor()
        {
            Internal.UnsetCursor_0(__Instance);
        }

        /// <summary>
        /// <para>Requests the window to be activated, i.e. receive keyboard
        /// focus.</para>
        /// <para>See also isActive() and QGuiApplication::focusWindow().</para>
        /// </summary>
        public void RequestActivate()
        {
            Internal.RequestActivate_0(__Instance);
        }

        /// <summary>
        /// <para>Shows the window.</para>
        /// <para>This is equivalent to calling showFullScreen(), showMaximized(),
        /// or showNormal(), depending on the platform's default behavior for the
        /// window type and flags.</para>
        /// <para>See also showFullScreen(), showMaximized(), showNormal(), hide(),
        /// QStyleHints::showIsFullScreen(), and flags().</para>
        /// </summary>
        public void Show()
        {
            Internal.Show_0(__Instance);
        }

        /// <summary>
        /// <para>Hides the window.</para>
        /// <para>Equivalent to calling setVisible(false).</para>
        /// <para>See also show() and setVisible().</para>
        /// </summary>
        public void Hide()
        {
            Internal.Hide_0(__Instance);
        }

        /// <summary>
        /// <para>Shows the window as minimized.</para>
        /// <para>Equivalent to calling setWindowState(Qt::WindowMinimized) and
        /// then setVisible(true).</para>
        /// <para>See also setWindowState() and setVisible().</para>
        /// </summary>
        public void ShowMinimized()
        {
            Internal.ShowMinimized_0(__Instance);
        }

        /// <summary>
        /// <para>Shows the window as maximized.</para>
        /// <para>Equivalent to calling setWindowState(Qt::WindowMaximized) and
        /// then setVisible(true).</para>
        /// <para>See also setWindowState() and setVisible().</para>
        /// </summary>
        public void ShowMaximized()
        {
            Internal.ShowMaximized_0(__Instance);
        }

        /// <summary>
        /// <para>Shows the window as fullscreen.</para>
        /// <para>Equivalent to calling setWindowState(Qt::WindowFullScreen) and
        /// then setVisible(true).</para>
        /// <para>See also setWindowState() and setVisible().</para>
        /// </summary>
        public void ShowFullScreen()
        {
            Internal.ShowFullScreen_0(__Instance);
        }

        /// <summary>
        /// <para>Shows the window as normal, i.e. neither maximized, minimized,
        /// nor fullscreen.</para>
        /// <para>Equivalent to calling setWindowState(Qt::WindowNoState) and then
        /// setVisible(true).</para>
        /// <para>See also setWindowState() and setVisible().</para>
        /// </summary>
        public void ShowNormal()
        {
            Internal.ShowNormal_0(__Instance);
        }

        /// <summary>
        /// <para>Close the window.</para>
        /// <para>This closes the window, effectively calling destroy(), and
        /// potentially quitting the application. Returns true on success, false if it
        /// has a parent window (in which case the top level window should be closed
        /// instead).</para>
        /// <para>See also destroy() and
        /// QGuiApplication::quitOnLastWindowClosed().</para>
        /// </summary>
        public bool Close()
        {
            var __ret = Internal.Close_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Raise the window in the windowing system.</para>
        /// <para>Requests that the window be raised to appear above other
        /// windows.</para>
        /// </summary>
        public void Raise()
        {
            Internal.Raise_0(__Instance);
        }

        /// <summary>
        /// <para>Lower the window in the windowing system.</para>
        /// <para>Requests that the window be lowered to appear below other
        /// windows.</para>
        /// </summary>
        public void Lower()
        {
            Internal.Lower_0(__Instance);
        }

        public void SetX(int arg)
        {
            Internal.SetX_0(__Instance, arg);
        }

        public void SetY(int arg)
        {
            Internal.SetY_0(__Instance, arg);
        }

        public void SetWidth(int arg)
        {
            Internal.SetWidth_0(__Instance, arg);
        }

        public void SetHeight(int arg)
        {
            Internal.SetHeight_0(__Instance, arg);
        }

        public void SetMinimumWidth(int w)
        {
            Internal.SetMinimumWidth_0(__Instance, w);
        }

        public void SetMinimumHeight(int h)
        {
            Internal.SetMinimumHeight_0(__Instance, h);
        }

        public void SetMaximumWidth(int w)
        {
            Internal.SetMaximumWidth_0(__Instance, w);
        }

        public void SetMaximumHeight(int h)
        {
            Internal.SetMaximumHeight_0(__Instance, h);
        }

        /// <summary>
        /// <para>Causes an alert to be shown for msec miliseconds. If msec is 0
        /// (the default), then the alert is shown indefinitely until the window
        /// becomes active again. This function has no effect on an active
        /// window.</para>
        /// <para>In alert state, the window indicates that it demands attention,
        /// for example by flashing or bouncing the taskbar entry.</para>
        /// <para>This function was introduced in  Qt 5.1.</para>
        /// </summary>
        public void Alert(int msec)
        {
            Internal.Alert_0(__Instance, msec);
        }

        /// <summary>
        /// <para>The expose event (ev) is sent by the window system whenever the
        /// window's exposure on screen changes.</para>
        /// <para>The application can start rendering into the window with
        /// QBackingStore and QOpenGLContext as soon as it gets an exposeEvent() such
        /// that isExposed() is true.</para>
        /// <para>If the window is moved off screen, is made totally obscured by
        /// another window, iconified or similar, this function might be called and the
        /// value of isExposed() might change to false. When this happens, an
        /// application should stop its rendering as it is no longer visible to the
        /// user.</para>
        /// <para>A resize event will always be sent before the expose event the
        /// first time a window is shown.</para>
        /// <para>See also isExposed().</para>
        /// </summary>
        protected virtual void OnExposeEvent(QExposeEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnExposeEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle resize events (ev).</para>
        /// <para>The resize event is called whenever the window is resized in the
        /// windowing system, either directly through the windowing system
        /// acknowledging a setGeometry() or resize() request, or indirectly through
        /// the user resizing the window manually.</para>
        /// </summary>
        protected virtual void OnResizeEvent(QResizeEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnResizeEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle window move events (ev).</para>
        /// </summary>
        protected virtual void OnMoveEvent(QMoveEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnMoveEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle focus in events (ev).</para>
        /// <para>Focus in events are sent when the window receives keyboard
        /// focus.</para>
        /// <para>See also focusOutEvent().</para>
        /// </summary>
        protected virtual void OnFocusInEvent(QFocusEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnFocusInEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle focus out events (ev).</para>
        /// <para>Focus out events are sent when the window loses keyboard
        /// focus.</para>
        /// <para>See also focusInEvent().</para>
        /// </summary>
        protected virtual void OnFocusOutEvent(QFocusEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnFocusOutEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle show events (ev).</para>
        /// <para>The function is called when the window has requested becoming
        /// visible.</para>
        /// <para>If the window is successfully shown by the windowing system, this
        /// will be followed by a resize and an expose event.</para>
        /// </summary>
        protected virtual void OnShowEvent(QShowEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnShowEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle hide events (ev).</para>
        /// <para>The function is called when the window has requested being hidden
        /// in the windowing system.</para>
        /// </summary>
        protected virtual void OnHideEvent(QHideEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnHideEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle key press events (ev).</para>
        /// <para>See also keyReleaseEvent().</para>
        /// </summary>
        protected virtual void OnKeyPressEvent(QKeyEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnKeyPressEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle key release events (ev).</para>
        /// <para>See also keyPressEvent().</para>
        /// </summary>
        protected virtual void OnKeyReleaseEvent(QKeyEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnKeyReleaseEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle mouse press events (ev).</para>
        /// <para>See also mouseReleaseEvent().</para>
        /// </summary>
        protected virtual void OnMousePressEvent(QMouseEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnMousePressEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle mouse release events (ev).</para>
        /// <para>See also mousePressEvent().</para>
        /// </summary>
        protected virtual void OnMouseReleaseEvent(QMouseEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnMouseReleaseEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle mouse double click events (ev).</para>
        /// <para>See also mousePressEvent() and
        /// QStyleHints::mouseDoubleClickInterval().</para>
        /// </summary>
        protected virtual void OnMouseDoubleClickEvent(QMouseEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnMouseDoubleClickEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle mouse move events (ev).</para>
        /// </summary>
        protected virtual void OnMouseMoveEvent(QMouseEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnMouseMoveEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle mouse wheel or other wheel events
        /// (ev).</para>
        /// </summary>
        protected virtual void OnWheelEvent(QWheelEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnWheelEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle touch events (ev).</para>
        /// </summary>
        protected virtual void OnTouchEvent(QTouchEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnTouchEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Override this to handle tablet press, move, and release events
        /// (ev).</para>
        /// <para>Proximity enter and leave events are not sent to windows, they
        /// are delivered to the application instance.</para>
        /// </summary>
        protected virtual void OnTabletEvent(QTabletEvent ev)
        {
            var arg0 = ReferenceEquals(ev, null) ? global::System.IntPtr.Zero : ev.__Instance;
            Internal.OnTabletEvent_0(__Instance, arg0);
        }

        protected QSurface.SurfaceClass M_type
        {
            get
            {
                return ((Internal*) __Instance)->m_type;
            }

            set
            {
                ((Internal*) __Instance)->m_type = value;
            }
        }

        /// <summary>
        /// <para>Reimplemented from QSurface::surfaceType().</para>
        /// <para>Returns the surface type of the window.</para>
        /// <para>See also setSurfaceType().</para>
        /// </summary>
        public override QSurface.SurfaceType SurfaceType
        {
            get
            {
                var __ret = Internal.SurfaceType_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This property holds the screen-occupation state of the
        /// window.</para>
        /// <para>Visibility is whether the window should appear in the windowing
        /// system as normal, minimized, maximized, fullscreen or hidden.</para>
        /// <para>To set the visibility to AutomaticVisibility means to give the
        /// window a default visible state, which might be fullscreen or windowed
        /// depending on the platform. When reading the visibility property you will
        /// always get the actual state, never AutomaticVisibility.</para>
        /// <para>This property was introduced in  Qt 5.1.</para>
        /// </summary>
        public QWindow.Visibility visibility
        {
            get
            {
                var __ret = Internal.visibility_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetVisibility_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the parent window, if any.</para>
        /// <para>A window without a parent is known as a top level window.</para>
        /// <para>See also setParent().</para>
        /// <para></para>
        /// <para>Sets the parent Window. This will lead to the windowing system
        /// managing the clip of the window, so it will be clipped to the parent
        /// window.</para>
        /// <para>Setting parent to be 0 will make the window become a top level
        /// window.</para>
        /// <para>If parent is a window created by fromWinId(), then the current
        /// window will be embedded inside parent, if the platform supports it. Window
        /// embedding is currently supported only by the X11 platform plugin.</para>
        /// <para>See also parent().</para>
        /// </summary>
        public QWindow Parent
        {
            get
            {
                var __ret = Internal.Parent_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetParent_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QSurface::format().</para>
        /// <para>Returns the actual format of this window.</para>
        /// <para>After the window has been created, this function will return the
        /// actual surface format of the window. It might differ from the requested
        /// format if the requested format could not be fulfilled by the platform. It
        /// might also be a superset, for example certain buffer sizes may be larger
        /// than requested.</para>
        /// <para>Note: Depending on the platform, certain values in this surface
        /// format may still contain the requested values, that is, the values that
        /// have been passed to setFormat(). Typical examples are the OpenGL version,
        /// profile and options. These may not get updated during create() since these
        /// are context specific and a single window may be used together with multiple
        /// contexts over its lifetime. Use the QOpenGLContext's format() instead to
        /// query such values.See also setFormat(), create(), requestedFormat(), and
        /// QOpenGLContext::format().</para>
        /// </summary>
        public override QSurfaceFormat Format
        {
            get
            {
                var __ret = new QtGui.QSurfaceFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QSurfaceFormat.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the mask set on the window.</para>
        /// <para>The mask is a hint to the windowing system that the application
        /// does not want to receive mouse or touch input outside the given
        /// region.</para>
        /// <para>See also setMask().</para>
        /// <para></para>
        /// <para>Sets the mask of the window.</para>
        /// <para>The mask is a hint to the windowing system that the application
        /// does not want to receive mouse or touch input outside the given
        /// region.</para>
        /// <para>The window manager may or may not choose to display any areas of
        /// the window not included in the mask, thus it is the application's
        /// responsibility to clear to transparent the areas that are not part of the
        /// mask.</para>
        /// <para>Setting the mask before the window has been created has no
        /// effect.</para>
        /// <para>See also mask().</para>
        /// </summary>
        public QRegion Mask
        {
            get
            {
                var __ret = new QtGui.QRegion.Internal();
                Internal.Mask_0(new IntPtr(&__ret), __Instance);
                return QRegion.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetMask_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the transient parent of the window.</para>
        /// <para>See also setTransientParent() and parent().</para>
        /// <para></para>
        /// <para>Sets the transient parent</para>
        /// <para>This is a hint to the window manager that this window is a dialog
        /// or pop-up on behalf of the given window.</para>
        /// <para>In order to cause the window to be centered above its transient
        /// parent by default, depending on the window manager, it may also be
        /// necessary to call setFlags() with a suitable Qt::WindowType (such as
        /// Qt::Dialog).</para>
        /// <para>See also transientParent() and parent().</para>
        /// </summary>
        public QWindow TransientParent
        {
            get
            {
                var __ret = Internal.TransientParent_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetTransientParent_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>the file name this window is representing.</para>
        /// <para>See also setFilePath().</para>
        /// <para></para>
        /// <para>set the file name this window is representing.</para>
        /// <para>The windowing system might use filePath to display the path of
        /// the document this window is representing in the tile bar.</para>
        /// <para>See also filePath().</para>
        /// </summary>
        public string FilePath
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FilePath_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFilePath_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Sets the window's icon in the windowing system</para>
        /// <para>See also setIcon().</para>
        /// <para></para>
        /// <para>Sets the window's icon in the windowing system</para>
        /// <para>The window icon might be used by the windowing system for example
        /// to decorate the window, and/or in the task switcher.</para>
        /// <para>See also icon().</para>
        /// </summary>
        public QIcon Icon
        {
            get
            {
                var __ret = new QtGui.QIcon.Internal();
                Internal.Icon_0(new IntPtr(&__ret), __Instance);
                return QIcon.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetIcon_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the screen on which the window is shown.</para>
        /// <para>For child windows, this returns the screen of the corresponding
        /// top level window.</para>
        /// <para>See also setScreen() and QScreen::virtualSiblings().</para>
        /// <para></para>
        /// <para>Sets the screen on which the window should be shown.</para>
        /// <para>If the window has been created, it will be recreated on the
        /// newScreen.</para>
        /// <para>Note that if the screen is part of a virtual desktop of multiple
        /// screens, the window can appear on any of the screens returned by
        /// QScreen::virtualSiblings().</para>
        /// <para>This function only works for top level windows.</para>
        /// <para>See also screen() and QScreen::virtualSiblings().</para>
        /// </summary>
        public QScreen Screen
        {
            get
            {
                var __ret = Internal.Screen_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QScreen.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetScreen_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>the cursor shape for this window</para>
        /// <para>See also setCursor() and unsetCursor().</para>
        /// <para></para>
        /// <para>set the cursor shape for this window</para>
        /// <para>The mouse cursor will assume this shape when it is over this
        /// window, unless an override cursor is set. See the list of predefined cursor
        /// objects for a range of useful shapes.</para>
        /// <para>By default, the cursor has the Qt::ArrowCursor shape.</para>
        /// <para>Some underlying window implementations will reset the cursor if
        /// it leaves a window even if the mouse is grabbed. If you want to have a
        /// cursor set for all windows, even when outside the window, consider
        /// QGuiApplication::setOverrideCursor().</para>
        /// <para>See also cursor() and
        /// QGuiApplication::setOverrideCursor().</para>
        /// </summary>
        public QCursor Cursor
        {
            get
            {
                var __ret = new QtGui.QCursor.Internal();
                Internal.Cursor_0(new IntPtr(&__ret), __Instance);
                return QCursor.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetCursor_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds whether the window is visible or not.</para>
        /// <para>This property controls the visibility of the window in the
        /// windowing system.</para>
        /// <para>By default, the window is not visible, you must call
        /// setVisible(true), or show() or similar to make it visible.</para>
        /// </summary>
        public bool Visible
        {
            get
            {
                var __ret = Internal.Visible_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetVisible_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>This property holds the window's title in the windowing
        /// system.</para>
        /// <para>The window title might appear in the title area of the window
        /// decorations, depending on the windowing system and the window flags. It
        /// might also be used by the windowing system to identify the window in other
        /// contexts, such as in the task switcher.</para>
        /// </summary>
        public string Title
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Title_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetTitle_0(__Instance, arg0);
            }
        }

        public QSurface.SurfaceClass SurfaceClass
        {
            get
            {
                var __ret = Internal.SurfaceClass_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Reimplemented from QSurface::format().</para>
        /// <para>Returns the actual format of this window.</para>
        /// <para>After the window has been created, this function will return the
        /// actual surface format of the window. It might differ from the requested
        /// format if the requested format could not be fulfilled by the platform. It
        /// might also be a superset, for example certain buffer sizes may be larger
        /// than requested.</para>
        /// <para>Note: Depending on the platform, certain values in this surface
        /// format may still contain the requested values, that is, the values that
        /// have been passed to setFormat(). Typical examples are the OpenGL version,
        /// profile and options. These may not get updated during create() since these
        /// are context specific and a single window may be used together with multiple
        /// contexts over its lifetime. Use the QOpenGLContext's format() instead to
        /// query such values.See also setFormat(), create(), requestedFormat(), and
        /// QOpenGLContext::format().</para>
        /// </summary>
        public abstract QSurfaceFormat Format
        {
            get;
        }

        /// <summary>
        /// <para>Reimplemented from QSurface::surfaceType().</para>
        /// <para>Returns the surface type of the window.</para>
        /// <para>See also setSurfaceType().</para>
        /// </summary>
        public abstract QSurface.SurfaceType SurfaceType
        {
            get;
        }

        public bool SupportsOpenGL
        {
            get
            {
                var __ret = Internal.SupportsOpenGL_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns whether the window is top level, i.e. has no parent
        /// window.</para>
        /// </summary>
        public bool IsTopLevel
        {
            get
            {
                var __ret = Internal.IsTopLevel_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns whether the window is modal.</para>
        /// <para>A modal window prevents other windows from getting any
        /// input.</para>
        /// <para>See also QWindow::modality.</para>
        /// </summary>
        public bool IsModal
        {
            get
            {
                var __ret = Internal.IsModal_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the requested surface format of this window.</para>
        /// <para>If the requested format was not supported by the platform
        /// implementation, the requestedFormat will differ from the actual window
        /// format.</para>
        /// <para>This is the value set with setFormat().</para>
        /// <para>See also setFormat() and format().</para>
        /// </summary>
        public QSurfaceFormat RequestedFormat
        {
            get
            {
                var __ret = new QtGui.QSurfaceFormat.Internal();
                Internal.RequestedFormat_0(new IntPtr(&__ret), __Instance);
                return QSurfaceFormat.__CreateInstance(__ret);
            }
        }

        public bool IsActive
        {
            get
            {
                var __ret = Internal.IsActive_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns if this window is exposed in the windowing system.</para>
        /// <para>When the window is not exposed, it is shown by the application
        /// but it is still not showing in the windowing system, so the application
        /// should minimize rendering and other graphical activities.</para>
        /// <para>An exposeEvent() is sent every time this value changes.</para>
        /// <para>See also exposeEvent().</para>
        /// </summary>
        public bool IsExposed
        {
            get
            {
                var __ret = Internal.IsExposed_0(__Instance);
                return __ret;
            }
        }

        public virtual QAccessibleInterface AccessibleRoot
        {
            get
            {
                var __ret = Internal.AccessibleRoot_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAccessibleInterfaceInternal.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // virtual ~QWindow()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.Dispose();
        }

        // SurfaceType surfaceType()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurface.SurfaceType _SurfaceType_0Delegate(global::System.IntPtr instance);
        private static _SurfaceType_0Delegate _SurfaceType_0DelegateInstance;

        private static QSurface.SurfaceType _SurfaceType_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            var _ret = target.SurfaceType;
            return _ret;
        }

        // QSurfaceFormat format()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurfaceFormat.Internal _Format_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Format_0Delegate _Format_0DelegateInstance;

        private static QSurfaceFormat.Internal _Format_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            var _ret = target.Format;
            return ReferenceEquals(_ret, null) ? new QSurfaceFormat.Internal() : *(QSurfaceFormat.Internal*) (_ret.__Instance);
        }

        // QAccessibleInterface *accessibleRoot()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleRoot_0Delegate(global::System.IntPtr instance);
        private static _AccessibleRoot_0Delegate _AccessibleRoot_0DelegateInstance;

        private static global::System.IntPtr _AccessibleRoot_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            var _ret = target.AccessibleRoot;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void exposeEvent(QExposeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnExposeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnExposeEvent_0Delegate _OnExposeEvent_0DelegateInstance;

        private static void _OnExposeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnExposeEvent((ev == IntPtr.Zero) ? null : QExposeEvent.__CreateInstance(ev));
        }

        // void resizeEvent(QResizeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnResizeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnResizeEvent_0Delegate _OnResizeEvent_0DelegateInstance;

        private static void _OnResizeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnResizeEvent((ev == IntPtr.Zero) ? null : QResizeEvent.__CreateInstance(ev));
        }

        // void moveEvent(QMoveEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMoveEvent_0Delegate _OnMoveEvent_0DelegateInstance;

        private static void _OnMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnMoveEvent((ev == IntPtr.Zero) ? null : QMoveEvent.__CreateInstance(ev));
        }

        // void focusInEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusInEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusInEvent_0Delegate _OnFocusInEvent_0DelegateInstance;

        private static void _OnFocusInEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnFocusInEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void focusOutEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusOutEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusOutEvent_0Delegate _OnFocusOutEvent_0DelegateInstance;

        private static void _OnFocusOutEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnFocusOutEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void showEvent(QShowEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnShowEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnShowEvent_0Delegate _OnShowEvent_0DelegateInstance;

        private static void _OnShowEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnShowEvent((ev == IntPtr.Zero) ? null : QShowEvent.__CreateInstance(ev));
        }

        // void hideEvent(QHideEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnHideEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnHideEvent_0Delegate _OnHideEvent_0DelegateInstance;

        private static void _OnHideEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnHideEvent((ev == IntPtr.Zero) ? null : QHideEvent.__CreateInstance(ev));
        }

        // void keyPressEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyPressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyPressEvent_0Delegate _OnKeyPressEvent_0DelegateInstance;

        private static void _OnKeyPressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnKeyPressEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void keyReleaseEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyReleaseEvent_0Delegate _OnKeyReleaseEvent_0DelegateInstance;

        private static void _OnKeyReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnKeyReleaseEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void mousePressEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMousePressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMousePressEvent_0Delegate _OnMousePressEvent_0DelegateInstance;

        private static void _OnMousePressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnMousePressEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseReleaseEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseReleaseEvent_0Delegate _OnMouseReleaseEvent_0DelegateInstance;

        private static void _OnMouseReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnMouseReleaseEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseDoubleClickEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseDoubleClickEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseDoubleClickEvent_0Delegate _OnMouseDoubleClickEvent_0DelegateInstance;

        private static void _OnMouseDoubleClickEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnMouseDoubleClickEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseMoveEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseMoveEvent_0Delegate _OnMouseMoveEvent_0DelegateInstance;

        private static void _OnMouseMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnMouseMoveEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void wheelEvent(QWheelEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnWheelEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnWheelEvent_0Delegate _OnWheelEvent_0DelegateInstance;

        private static void _OnWheelEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnWheelEvent((ev == IntPtr.Zero) ? null : QWheelEvent.__CreateInstance(ev));
        }

        // void touchEvent(QTouchEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTouchEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTouchEvent_0Delegate _OnTouchEvent_0DelegateInstance;

        private static void _OnTouchEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnTouchEvent((ev == IntPtr.Zero) ? null : QTouchEvent.__CreateInstance(ev));
        }

        // void tabletEvent(QTabletEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTabletEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTabletEvent_0Delegate _OnTabletEvent_0DelegateInstance;

        private static void _OnTabletEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QWindow) _References[instance].Target;
            target.OnTabletEvent((ev == IntPtr.Zero) ? null : QTabletEvent.__CreateInstance(ev));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[20];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _SurfaceType_0DelegateInstance += _SurfaceType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SurfaceType_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
                _AccessibleRoot_0DelegateInstance += _AccessibleRoot_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_AccessibleRoot_0DelegateInstance).ToPointer();
                _OnExposeEvent_0DelegateInstance += _OnExposeEvent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_OnExposeEvent_0DelegateInstance).ToPointer();
                _OnResizeEvent_0DelegateInstance += _OnResizeEvent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_OnResizeEvent_0DelegateInstance).ToPointer();
                _OnMoveEvent_0DelegateInstance += _OnMoveEvent_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_OnMoveEvent_0DelegateInstance).ToPointer();
                _OnFocusInEvent_0DelegateInstance += _OnFocusInEvent_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_OnFocusInEvent_0DelegateInstance).ToPointer();
                _OnFocusOutEvent_0DelegateInstance += _OnFocusOutEvent_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_OnFocusOutEvent_0DelegateInstance).ToPointer();
                _OnShowEvent_0DelegateInstance += _OnShowEvent_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_OnShowEvent_0DelegateInstance).ToPointer();
                _OnHideEvent_0DelegateInstance += _OnHideEvent_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_OnHideEvent_0DelegateInstance).ToPointer();
                _OnKeyPressEvent_0DelegateInstance += _OnKeyPressEvent_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_OnKeyPressEvent_0DelegateInstance).ToPointer();
                _OnKeyReleaseEvent_0DelegateInstance += _OnKeyReleaseEvent_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_OnKeyReleaseEvent_0DelegateInstance).ToPointer();
                _OnMousePressEvent_0DelegateInstance += _OnMousePressEvent_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_OnMousePressEvent_0DelegateInstance).ToPointer();
                _OnMouseReleaseEvent_0DelegateInstance += _OnMouseReleaseEvent_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_OnMouseReleaseEvent_0DelegateInstance).ToPointer();
                _OnMouseDoubleClickEvent_0DelegateInstance += _OnMouseDoubleClickEvent_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_OnMouseDoubleClickEvent_0DelegateInstance).ToPointer();
                _OnMouseMoveEvent_0DelegateInstance += _OnMouseMoveEvent_0DelegateHook;
                _Thunks[16] = Marshal.GetFunctionPointerForDelegate(_OnMouseMoveEvent_0DelegateInstance).ToPointer();
                _OnWheelEvent_0DelegateInstance += _OnWheelEvent_0DelegateHook;
                _Thunks[17] = Marshal.GetFunctionPointerForDelegate(_OnWheelEvent_0DelegateInstance).ToPointer();
                _OnTouchEvent_0DelegateInstance += _OnTouchEvent_0DelegateHook;
                _Thunks[18] = Marshal.GetFunctionPointerForDelegate(_OnTouchEvent_0DelegateInstance).ToPointer();
                _OnTabletEvent_0DelegateInstance += _OnTabletEvent_0DelegateHook;
                _Thunks[19] = Marshal.GetFunctionPointerForDelegate(_OnTabletEvent_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(39 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[3];
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = _Thunks[4];
                *(void**)(vfptr0 + 72) = _Thunks[5];
                *(void**)(vfptr0 + 76) = _Thunks[6];
                *(void**)(vfptr0 + 80) = _Thunks[7];
                *(void**)(vfptr0 + 84) = _Thunks[8];
                *(void**)(vfptr0 + 88) = _Thunks[9];
                *(void**)(vfptr0 + 92) = _Thunks[10];
                *(void**)(vfptr0 + 96) = _Thunks[11];
                *(void**)(vfptr0 + 100) = _Thunks[12];
                *(void**)(vfptr0 + 104) = _Thunks[13];
                *(void**)(vfptr0 + 108) = _Thunks[14];
                *(void**)(vfptr0 + 112) = _Thunks[15];
                *(void**)(vfptr0 + 116) = _Thunks[16];
                *(void**)(vfptr0 + 120) = _Thunks[17];
                *(void**)(vfptr0 + 124) = _Thunks[18];
                *(void**)(vfptr0 + 128) = _Thunks[19];
                *(void**)(vfptr0 + 132) = *(void**)(native->vfptr0 + 132);
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QPaintDeviceWindow : QtGui.QWindow, QtGui.IQPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QSurface.SurfaceClass m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_reserved;

            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QPaintDeviceWindowC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QPaintDeviceWindowD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QPaintDeviceWindow6updateERK7QRegion")]
            internal static extern void Update_1(global::System.IntPtr instance, global::System.IntPtr region);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QPaintDeviceWindow6updateEv")]
            internal static extern void Update_2(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QPaintDeviceWindow10paintEventEP11QPaintEvent")]
            internal static extern void OnPaintEvent_0(global::System.IntPtr instance, global::System.IntPtr _event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QPaintDeviceWindow6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QPaintDeviceWindow11exposeEventEP12QExposeEvent")]
            internal static extern void OnExposeEvent_0(global::System.IntPtr instance, global::System.IntPtr _254);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice11initPainterEP8QPainter")]
            internal static extern void InitPainter_0(global::System.IntPtr instance, global::System.IntPtr painter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice11initPainterEP8QPainter")]
            internal static extern void initPainter_0(global::System.IntPtr instance, global::System.IntPtr painter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice6metricENS_17PaintDeviceMetricE")]
            internal static extern int metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QPaintDeviceWindow11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice13sharedPainterEv")]
            internal static extern global::System.IntPtr SharedPainter_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>Handles paint events passed in the event parameter.</para>
        /// <para>The default implementation does nothing. Reimplement this function to perform painting. If necessary, the dirty area is retrievable from the event.</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QPaintEvent>> PaintEvent
        {
        	add
        	{
        		QEventArgs<QPaintEvent> qEventArgs = new QEventArgs<QPaintEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Paint });
        		QEventHandler<QPaintEvent> qEventHandler = new QEventHandler<QPaintEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        public virtual event EventHandler<QEventArgs<QExposeEvent>> ExposeEvent
        {
        	add
        	{
        		QEventArgs<QExposeEvent> qEventArgs = new QEventArgs<QExposeEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Expose });
        		QEventHandler<QExposeEvent> qEventHandler = new QEventHandler<QExposeEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        private readonly bool __ownsNativeInstance;

        public static new QPaintDeviceWindow __CreateInstance(global::System.IntPtr native)
        {
            return new QPaintDeviceWindow((QPaintDeviceWindow.Internal*) native);
        }

        public static QPaintDeviceWindow __CreateInstance(QPaintDeviceWindow.Internal native)
        {
            return new QPaintDeviceWindow(native);
        }

        private static QPaintDeviceWindow.Internal* __CopyValue(QPaintDeviceWindow.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QPaintDeviceWindow.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QPaintDeviceWindow.Internal*) ret;
        }

        private QPaintDeviceWindow(QPaintDeviceWindow.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPaintDeviceWindow(QPaintDeviceWindow.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QWindow.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Marks the region of the window as dirty and schedules a
        /// repaint.</para>
        /// <para>Note: Subsequent calls to this function before the next paint
        /// event will get ignored.</para>
        /// <para></para>
        /// <para>[slot] void QPaintDeviceWindow::update()</para>
        /// <para>Marks the entire window as dirty and schedules a repaint.</para>
        /// <para>Note: Subsequent calls to this function before the next paint
        /// event will get ignored.</para>
        /// </summary>
        public void Update(QRegion region)
        {
            var arg0 = ReferenceEquals(region, null) ? global::System.IntPtr.Zero : region.__Instance;
            Internal.Update_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Marks the entire window as dirty and schedules a repaint.</para>
        /// <para>Note: Subsequent calls to this function before the next paint
        /// event will get ignored.</para>
        /// </summary>
        public void Update()
        {
            Internal.Update_2(__Instance);
        }

        /// <summary>
        /// <para>Handles paint events passed in the event parameter.</para>
        /// <para>The default implementation does nothing. Reimplement this
        /// function to perform painting. If necessary, the dirty area is retrievable
        /// from the event.</para>
        /// </summary>
        protected virtual void OnPaintEvent(QPaintEvent _event)
        {
            var arg0 = ReferenceEquals(_event, null) ? global::System.IntPtr.Zero : _event.__Instance;
            Internal.OnPaintEvent_0(__Instance, arg0);
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        protected override void OnExposeEvent(QExposeEvent _254)
        {
            var arg0 = ReferenceEquals(_254, null) ? global::System.IntPtr.Zero : _254.__Instance;
            Internal.OnExposeEvent_0(__Instance, arg0);
        }

        protected void InitPainter(QPainter painter)
        {
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            Internal.InitPainter_0(__Instance, arg0);
        }

        protected void initPainter(QPainter painter)
        {
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            Internal.initPainter_0(__Instance, arg0);
        }

        public abstract QPaintEngine paintEngine();

        protected int metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.metric_0(__Instance, arg0);
            return __ret;
        }

        public override QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }

        public QPainter SharedPainter
        {
            get
            {
                var __ret = Internal.SharedPainter_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPainter.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // SurfaceType surfaceType()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurface.SurfaceType _SurfaceType_0Delegate(global::System.IntPtr instance);
        private static _SurfaceType_0Delegate _SurfaceType_0DelegateInstance;

        private static QSurface.SurfaceType _SurfaceType_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            var _ret = target.SurfaceType;
            return _ret;
        }

        // QSurfaceFormat format()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurfaceFormat.Internal _Format_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Format_0Delegate _Format_0DelegateInstance;

        private static QSurfaceFormat.Internal _Format_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            var _ret = target.Format;
            return ReferenceEquals(_ret, null) ? new QSurfaceFormat.Internal() : *(QSurfaceFormat.Internal*) (_ret.__Instance);
        }

        // QAccessibleInterface *accessibleRoot()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleRoot_0Delegate(global::System.IntPtr instance);
        private static _AccessibleRoot_0Delegate _AccessibleRoot_0DelegateInstance;

        private static global::System.IntPtr _AccessibleRoot_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            var _ret = target.AccessibleRoot;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void exposeEvent(QExposeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnExposeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _254);
        private static _OnExposeEvent_0Delegate _OnExposeEvent_0DelegateInstance;

        private static void _OnExposeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _254)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnExposeEvent((_254 == IntPtr.Zero) ? null : QExposeEvent.__CreateInstance(_254));
        }

        // void resizeEvent(QResizeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnResizeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnResizeEvent_0Delegate _OnResizeEvent_0DelegateInstance;

        private static void _OnResizeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnResizeEvent((ev == IntPtr.Zero) ? null : QResizeEvent.__CreateInstance(ev));
        }

        // void moveEvent(QMoveEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMoveEvent_0Delegate _OnMoveEvent_0DelegateInstance;

        private static void _OnMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnMoveEvent((ev == IntPtr.Zero) ? null : QMoveEvent.__CreateInstance(ev));
        }

        // void focusInEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusInEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusInEvent_0Delegate _OnFocusInEvent_0DelegateInstance;

        private static void _OnFocusInEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnFocusInEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void focusOutEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusOutEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusOutEvent_0Delegate _OnFocusOutEvent_0DelegateInstance;

        private static void _OnFocusOutEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnFocusOutEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void showEvent(QShowEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnShowEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnShowEvent_0Delegate _OnShowEvent_0DelegateInstance;

        private static void _OnShowEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnShowEvent((ev == IntPtr.Zero) ? null : QShowEvent.__CreateInstance(ev));
        }

        // void hideEvent(QHideEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnHideEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnHideEvent_0Delegate _OnHideEvent_0DelegateInstance;

        private static void _OnHideEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnHideEvent((ev == IntPtr.Zero) ? null : QHideEvent.__CreateInstance(ev));
        }

        // void keyPressEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyPressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyPressEvent_0Delegate _OnKeyPressEvent_0DelegateInstance;

        private static void _OnKeyPressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnKeyPressEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void keyReleaseEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyReleaseEvent_0Delegate _OnKeyReleaseEvent_0DelegateInstance;

        private static void _OnKeyReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnKeyReleaseEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void mousePressEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMousePressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMousePressEvent_0Delegate _OnMousePressEvent_0DelegateInstance;

        private static void _OnMousePressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnMousePressEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseReleaseEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseReleaseEvent_0Delegate _OnMouseReleaseEvent_0DelegateInstance;

        private static void _OnMouseReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnMouseReleaseEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseDoubleClickEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseDoubleClickEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseDoubleClickEvent_0Delegate _OnMouseDoubleClickEvent_0DelegateInstance;

        private static void _OnMouseDoubleClickEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnMouseDoubleClickEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseMoveEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseMoveEvent_0Delegate _OnMouseMoveEvent_0DelegateInstance;

        private static void _OnMouseMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnMouseMoveEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void wheelEvent(QWheelEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnWheelEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnWheelEvent_0Delegate _OnWheelEvent_0DelegateInstance;

        private static void _OnWheelEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnWheelEvent((ev == IntPtr.Zero) ? null : QWheelEvent.__CreateInstance(ev));
        }

        // void touchEvent(QTouchEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTouchEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTouchEvent_0Delegate _OnTouchEvent_0DelegateInstance;

        private static void _OnTouchEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnTouchEvent((ev == IntPtr.Zero) ? null : QTouchEvent.__CreateInstance(ev));
        }

        // void tabletEvent(QTabletEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTabletEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTabletEvent_0Delegate _OnTabletEvent_0DelegateInstance;

        private static void _OnTabletEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnTabletEvent((ev == IntPtr.Zero) ? null : QTabletEvent.__CreateInstance(ev));
        }

        // void paintEvent(QPaintEvent *event)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnPaintEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _event);
        private static _OnPaintEvent_0Delegate _OnPaintEvent_0DelegateInstance;

        private static void _OnPaintEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _event)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.OnPaintEvent((_event == IntPtr.Zero) ? null : QPaintEvent.__CreateInstance(_event));
        }

        // int metric(PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintDeviceWindow) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[24];
                _SurfaceType_0DelegateInstance += _SurfaceType_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SurfaceType_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
                _AccessibleRoot_0DelegateInstance += _AccessibleRoot_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AccessibleRoot_0DelegateInstance).ToPointer();
                _OnExposeEvent_0DelegateInstance += _OnExposeEvent_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_OnExposeEvent_0DelegateInstance).ToPointer();
                _OnResizeEvent_0DelegateInstance += _OnResizeEvent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_OnResizeEvent_0DelegateInstance).ToPointer();
                _OnMoveEvent_0DelegateInstance += _OnMoveEvent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_OnMoveEvent_0DelegateInstance).ToPointer();
                _OnFocusInEvent_0DelegateInstance += _OnFocusInEvent_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_OnFocusInEvent_0DelegateInstance).ToPointer();
                _OnFocusOutEvent_0DelegateInstance += _OnFocusOutEvent_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_OnFocusOutEvent_0DelegateInstance).ToPointer();
                _OnShowEvent_0DelegateInstance += _OnShowEvent_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_OnShowEvent_0DelegateInstance).ToPointer();
                _OnHideEvent_0DelegateInstance += _OnHideEvent_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_OnHideEvent_0DelegateInstance).ToPointer();
                _OnKeyPressEvent_0DelegateInstance += _OnKeyPressEvent_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_OnKeyPressEvent_0DelegateInstance).ToPointer();
                _OnKeyReleaseEvent_0DelegateInstance += _OnKeyReleaseEvent_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_OnKeyReleaseEvent_0DelegateInstance).ToPointer();
                _OnMousePressEvent_0DelegateInstance += _OnMousePressEvent_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_OnMousePressEvent_0DelegateInstance).ToPointer();
                _OnMouseReleaseEvent_0DelegateInstance += _OnMouseReleaseEvent_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_OnMouseReleaseEvent_0DelegateInstance).ToPointer();
                _OnMouseDoubleClickEvent_0DelegateInstance += _OnMouseDoubleClickEvent_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_OnMouseDoubleClickEvent_0DelegateInstance).ToPointer();
                _OnMouseMoveEvent_0DelegateInstance += _OnMouseMoveEvent_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_OnMouseMoveEvent_0DelegateInstance).ToPointer();
                _OnWheelEvent_0DelegateInstance += _OnWheelEvent_0DelegateHook;
                _Thunks[16] = Marshal.GetFunctionPointerForDelegate(_OnWheelEvent_0DelegateInstance).ToPointer();
                _OnTouchEvent_0DelegateInstance += _OnTouchEvent_0DelegateHook;
                _Thunks[17] = Marshal.GetFunctionPointerForDelegate(_OnTouchEvent_0DelegateInstance).ToPointer();
                _OnTabletEvent_0DelegateInstance += _OnTabletEvent_0DelegateHook;
                _Thunks[18] = Marshal.GetFunctionPointerForDelegate(_OnTabletEvent_0DelegateInstance).ToPointer();
                _OnPaintEvent_0DelegateInstance += _OnPaintEvent_0DelegateHook;
                _Thunks[19] = Marshal.GetFunctionPointerForDelegate(_OnPaintEvent_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[20] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[21] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[22] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[23] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(49 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[0];
                *(void**)(vfptr0 + 52) = _Thunks[1];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[2];
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = _Thunks[3];
                *(void**)(vfptr0 + 72) = _Thunks[4];
                *(void**)(vfptr0 + 76) = _Thunks[5];
                *(void**)(vfptr0 + 80) = _Thunks[6];
                *(void**)(vfptr0 + 84) = _Thunks[7];
                *(void**)(vfptr0 + 88) = _Thunks[8];
                *(void**)(vfptr0 + 92) = _Thunks[9];
                *(void**)(vfptr0 + 96) = _Thunks[10];
                *(void**)(vfptr0 + 100) = _Thunks[11];
                *(void**)(vfptr0 + 104) = _Thunks[12];
                *(void**)(vfptr0 + 108) = _Thunks[13];
                *(void**)(vfptr0 + 112) = _Thunks[14];
                *(void**)(vfptr0 + 116) = _Thunks[15];
                *(void**)(vfptr0 + 120) = _Thunks[16];
                *(void**)(vfptr0 + 124) = _Thunks[17];
                *(void**)(vfptr0 + 128) = _Thunks[18];
                *(void**)(vfptr0 + 132) = *(void**)(native->vfptr0 + 132);
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 140) = _Thunks[19];
                *(void**)(vfptr0 + 144) = _Thunks[20];
                *(void**)(vfptr0 + 148) = _Thunks[21];
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 52) = _Thunks[1];
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 48) = _Thunks[0];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 200) = *(void**)(native->vfptr0 + 200);
                *(void**)(vfptr0 + 148) = _Thunks[21];
                *(void**)(vfptr0 + 144) = _Thunks[20];
                *(void**)(vfptr0 + 212) = _Thunks[22];
                *(void**)(vfptr0 + 216) = *(void**)(native->vfptr0 + 216);
                *(void**)(vfptr0 + 220) = _Thunks[23];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLWindow class is a convenience subclass of QWindow to
    /// perform OpenGL painting.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QOpenGLWindow is an enhanced QWindow that allows easily creating
    /// windows that perform OpenGL rendering using an API that is compatible with
    /// QOpenGLWidget and is similar to the legacy QGLWidget. Unlike QOpenGLWidget,
    /// QOpenGLWindow has no dependency on the widgets module and offers better
    /// performance.</para>
    /// <para>A typical application will subclass QOpenGLWindow and reimplement
    /// the following virtual functions:</para>
    /// <para></para>
    /// <para>initializeGL() to perform OpenGL resource initialization</para>
    /// <para>resizeGL() to set up the transformation matrices and other window
    /// size dependent resources</para>
    /// <para>paintGL() to issue OpenGL commands or draw using QPainter</para>
    /// <para></para>
    /// <para>To schedule a repaint, call the update() function. Note that this
    /// will not immediately result in a call to paintGL(). Calling update()
    /// multiple times in a row will not change the behavior in any way.</para>
    /// <para>This is a slot so it can be connected to a QTimer::timeout()
    /// signal to perform animation. Note however that in the modern OpenGL world
    /// it is a much better choice to rely on synchronization to the vertical
    /// refresh rate of the display. See setSwapInterval() on a description of the
    /// swap interval. With a swap interval of 1, which is the case on most systems
    /// by default, the swapBuffers() call, that is executed internally by
    /// QOpenGLWindow after each repaint, will block and wait for vsync. This means
    /// that whenever the swap is done, an update can be scheduled again by calling
    /// update(), without relying on timers.</para>
    /// <para>To request a specific configuration for the context, use
    /// setFormat() like for any other QWindow. This allows, among others,
    /// requesting a given OpenGL version and profile, or enabling depth and
    /// stencil buffers.</para>
    /// <para>Unlike QWindow, QOpenGLWindow allows opening a painter on itself
    /// and perform QPainter-based drawing.</para>
    /// <para>QOpenGLWindow supports multiple update behaviors. The default,
    /// NoPartialUpdate is equivalent to a regular, OpenGL-based QWindow or the
    /// legacy QGLWidget. In contrast, PartialUpdateBlit and PartialUpdateBlend are
    /// more in line with QOpenGLWidget's way of working, where there is always an
    /// extra, dedicated framebuffer object present. These modes allow, by
    /// sacrificing some performance, redrawing only a smaller area on each paint
    /// and having the rest of the content preserved from of the previous frame.
    /// This is useful for applications than render incrementally using QPainter,
    /// because this way they do not have to redraw the entire window content on
    /// each paintGL() call.</para>
    /// <para>Similarly to QOpenGLWidget, QOpenGLWindow supports the
    /// Qt::AA_ShareOpenGLContexts attribute. When enabled, the OpenGL contexts of
    /// all QOpenGLWindow instances will share with each other. This allows
    /// accessing each other's shareable OpenGL resources.</para>
    /// <para>For more information on graphics in Qt, see Graphics.</para>
    /// </remarks>
    public unsafe partial class QOpenGLWindow : QtGui.QPaintDeviceWindow, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QSurface.SurfaceClass m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_reserved;

            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindowC2ENS_14UpdateBehaviorEP7QWindow")]
            internal static extern void ctor_0(global::System.IntPtr instance, QOpenGLWindow.UpdateBehavior updateBehavior, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindowC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindowD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow11makeCurrentEv")]
            internal static extern void MakeCurrent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow11doneCurrentEv")]
            internal static extern void DoneCurrent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow12initializeGLEv")]
            internal static extern void InitializeGL_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow8resizeGLEii")]
            internal static extern void ResizeGL_0(global::System.IntPtr instance, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow7paintGLEv")]
            internal static extern void PaintGL_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow12paintUnderGLEv")]
            internal static extern void PaintUnderGL_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow11paintOverGLEv")]
            internal static extern void PaintOverGL_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow10paintEventEP11QPaintEvent")]
            internal static extern void OnPaintEvent_0(global::System.IntPtr instance, global::System.IntPtr _event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow11resizeEventEP12QResizeEvent")]
            internal static extern void OnResizeEvent_0(global::System.IntPtr instance, global::System.IntPtr _event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLWindow6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLWindow14updateBehaviorEv")]
            internal static extern QOpenGLWindow.UpdateBehavior updateBehavior_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLWindow7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLWindow7contextEv")]
            internal static extern global::System.IntPtr Context_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLWindow15grabFramebufferEv")]
            internal static extern void GrabFramebuffer_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the update strategy of the
        /// QOpenGLWindow.</para>
        /// </summary>
        public enum UpdateBehavior : uint
        {
            /// <summary>Indicates that the entire window surface will redrawn on each update and so no additional framebuffers are needed. This is the setting used in most cases and is equivalent to how drawing directly via QWindow would function.</summary>
            NoPartialUpdate = 0,
            /// <summary>Indicates that the drawing performed in paintGL() does not cover the entire window. In this case an extra framebuffer object is created under the hood, and rendering performed in paintGL() will target this framebuffer. This framebuffer is then blitted onto the window surface's default framebuffer after each paint. This allows having QPainter-based drawing code in paintGL() which only repaints a smaller area at a time, because, unlike NoPartialUpdate, the previous content is preserved.</summary>
            PartialUpdateBlit = 1,
            /// <summary>Similar to PartialUpdateBlit, but instead of using framebuffer blits, the contents of the extra framebuffer is rendered by drawing a textured quad with blending enabled. This, unlike PartialUpdateBlit, allows alpha blended content and works even when the glBlitFramebuffer is not available. Performance-wise this setting is likely to be somewhat slower than PartialUpdateBlit.</summary>
            PartialUpdateBlend = 2
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>Reimplemented from QPaintDeviceWindow::paintEvent().</para>
        /// <para>Paint event handler. Calls paintGL().</para>
        /// <para>See also paintGL().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QPaintEvent>> PaintEvent
        {
        	add
        	{
        		QEventArgs<QPaintEvent> qEventArgs = new QEventArgs<QPaintEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Paint });
        		QEventHandler<QPaintEvent> qEventHandler = new QEventHandler<QPaintEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>Reimplemented from QWindow::resizeEvent().</para>
        /// <para>Resize event handler. Calls resizeGL().</para>
        /// <para>See also resizeGL().</para>
        /// </summary>
        public virtual event EventHandler<QEventArgs<QResizeEvent>> ResizeEvent
        {
        	add
        	{
        		QEventArgs<QResizeEvent> qEventArgs = new QEventArgs<QResizeEvent>(new System.Collections.Generic.List<QEvent.Type> { QEvent.Type.Resize });
        		QEventHandler<QResizeEvent> qEventHandler = new QEventHandler<QResizeEvent>(this, qEventArgs, value);
                foreach (QEventHandler eventFilter in eventFilters)
                {
                    this.RemoveEventFilter(eventFilter);
                }
        		eventFilters.Add(qEventHandler);
                for (int i = eventFilters.Count - 1; i >= 0; i--)
                {
        		    this.InstallEventFilter(eventFilters[i]);                    
                }
        	}
        	remove
        	{
        		for (int i = eventFilters.Count - 1; i >= 0; i--)
        		{
        			QEventHandler eventFilter = eventFilters[i];
        			if (eventFilter.Handler == value)
        			{
        				this.RemoveEventFilter(eventFilter);
        				eventFilters.RemoveAt(i);
                        break;
        			}
        		}
        	}
        }

        /// <summary>
        /// <para>This signal is emitted after the potentially blocking buffer swap has been done. Applications that wish to continuously repaint synchronized to the vertical refresh, should issue an update() upon this signal. This allows for a much smoother experience compared to the traditional usage of timers.</para>
        /// </summary>
        public event Action FrameSwapped
        {
        	add
        	{
                ConnectDynamicSlot(this, "frameSwapped()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "frameSwapped()", value);
        	}
        }

        private readonly bool __ownsNativeInstance;

        public static new QOpenGLWindow __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLWindow((QOpenGLWindow.Internal*) native);
        }

        public static QOpenGLWindow __CreateInstance(QOpenGLWindow.Internal native)
        {
            return new QOpenGLWindow(native);
        }

        private static QOpenGLWindow.Internal* __CopyValue(QOpenGLWindow.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QOpenGLWindow.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLWindow.Internal*) ret;
        }

        private QOpenGLWindow(QOpenGLWindow.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLWindow(QOpenGLWindow.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDeviceWindow.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new QOpenGLWindow with the given parent and
        /// updateBehavior.</para>
        /// <para>See also QOpenGLWindow::UpdateBehavior.</para>
        /// </summary>
        public QOpenGLWindow(QOpenGLWindow.UpdateBehavior updateBehavior = QOpenGLWindow.UpdateBehavior.NoPartialUpdate, QWindow parent = null)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            var arg0 = updateBehavior;
            var arg1 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            Internal.ctor_0(__Instance, arg0, arg1);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Prepares for rendering OpenGL content for this window by making
        /// the corresponding context current and binding the framebuffer object, if
        /// there is one, in that context context.</para>
        /// <para>It is not necessary to call this function in most cases, because
        /// it is called automatically before invoking paintGL(). It is provided
        /// nonetheless to support advanced, multi-threaded scenarios where a thread
        /// different than the GUI or main thread may want to update the surface or
        /// framebuffer contents. See QOpenGLContext for more information on threading
        /// related issues.</para>
        /// <para>This function is suitable for calling also when the underlying
        /// platform window is already destroyed. This means that it is safe to call
        /// this function from a QOpenGLWindow subclass' destructor. If there is no
        /// native window anymore, an offscreen surface is used instead. This ensures
        /// that OpenGL resource cleanup operations in the destructor will always work,
        /// as long as this function is called first.</para>
        /// <para>See also QOpenGLContext, context(), paintGL(), and
        /// doneCurrent().</para>
        /// </summary>
        public void MakeCurrent()
        {
            Internal.MakeCurrent_0(__Instance);
        }

        /// <summary>
        /// <para>Releases the context.</para>
        /// <para>It is not necessary to call this function in most cases, since
        /// the widget will make sure the context is bound and released properly when
        /// invoking paintGL().</para>
        /// <para>See also makeCurrent().</para>
        /// </summary>
        public void DoneCurrent()
        {
            Internal.DoneCurrent_0(__Instance);
        }

        /// <summary>
        /// <para>This virtual function is called once before the first call to
        /// paintGL() or resizeGL(). Reimplement it in a subclass.</para>
        /// <para>This function should set up any required OpenGL resources and
        /// state.</para>
        /// <para>There is no need to call makeCurrent() because this has already
        /// been done when this function is called. Note however that the framebuffer,
        /// in case partial update mode is used, is not yet available at this stage, so
        /// avoid issuing draw calls from here. Defer such calls to paintGL()
        /// instead.</para>
        /// <para>See also paintGL() and resizeGL().</para>
        /// </summary>
        protected virtual void InitializeGL()
        {
            Internal.InitializeGL_0(__Instance);
        }

        /// <summary>
        /// <para>This virtual function is called whenever the widget has been
        /// resized. Reimplement it in a subclass. The new size is passed in w and
        /// h.</para>
        /// <para>Note: This is merely a convenience function in order to provide
        /// an API that is compatible with QOpenGLWidget. Unlike with QOpenGLWidget,
        /// derived classes are free to choose to override resizeEvent() instead of
        /// this function.Note: Avoid issuing OpenGL commands from this function as
        /// there may not be a context current when it is invoked. If it cannot be
        /// avoided, call makeCurrent().Note: Scheduling updates from here is not
        /// necessary. The windowing systems will send expose events that trigger an
        /// update automatically.See also initializeGL() and paintGL().</para>
        /// </summary>
        protected virtual void ResizeGL(int w, int h)
        {
            Internal.ResizeGL_0(__Instance, w, h);
        }

        /// <summary>
        /// <para>This virtual function is called whenever the window contents
        /// needs to be painted. Reimplement it in a subclass.</para>
        /// <para>There is no need to call makeCurrent() because this has already
        /// been done when this function is called.</para>
        /// <para>Before invoking this function, the context and the framebuffer,
        /// if there is one, are bound, and the viewport is set up by a call to
        /// glViewport(). No other state is set and no clearing or drawing is performed
        /// by the framework.</para>
        /// <para>Note: When using a partial update behavior, like
        /// PartialUpdateBlend, the output of the previous paintGL() call is preserved
        /// and, after the additional drawing perfomed in the current invocation of the
        /// function, the content is blitted or blended over the content drawn directly
        /// to the window in paintUnderGL().See also initializeGL(), resizeGL(),
        /// paintUnderGL(), paintOverGL(), and UpdateBehavior.</para>
        /// </summary>
        protected virtual void PaintGL()
        {
            Internal.PaintGL_0(__Instance);
        }

        /// <summary>
        /// <para>The virtual function is called before each invocation of
        /// paintGL().</para>
        /// <para>When the update mode is set to NoPartialUpdate, there is no
        /// difference between this function and paintGL(), performing rendering in
        /// either of them leads to the same result.</para>
        /// <para>The difference becomes significant when using PartialUpdateBlend,
        /// where an extra framebuffer object is used. There, paintGL() targets this
        /// additional framebuffer object, which preserves its contents, while
        /// paintUnderGL() and paintOverGL() target the default framebuffer, i.e.
        /// directly the window surface, the contents of which is lost after each
        /// displayed frame.</para>
        /// <para>Note: Avoid relying on this function when the update behavior is
        /// PartialUpdateBlit. This mode involves blitting the extra framebuffer used
        /// by paintGL() onto the default framebuffer after each invocation of
        /// paintGL(), thus overwriting all drawing generated in this function.See also
        /// paintGL(), paintOverGL(), and UpdateBehavior.</para>
        /// </summary>
        protected virtual void PaintUnderGL()
        {
            Internal.PaintUnderGL_0(__Instance);
        }

        /// <summary>
        /// <para>This virtual function is called after each invocation of
        /// paintGL().</para>
        /// <para>When the update mode is set to NoPartialUpdate, there is no
        /// difference between this function and paintGL(), performing rendering in
        /// either of them leads to the same result.</para>
        /// <para>Like paintUnderGL(), rendering in this function targets the
        /// default framebuffer of the window, regardless of the update behavior. It
        /// gets called after paintGL() has returned and the blit (PartialUpdateBlit)
        /// or quad drawing (PartialUpdateBlend) has been done.</para>
        /// <para>See also paintGL(), paintUnderGL(), and UpdateBehavior.</para>
        /// </summary>
        protected virtual void PaintOverGL()
        {
            Internal.PaintOverGL_0(__Instance);
        }

        /// <summary>
        /// <para>Reimplemented from QPaintDeviceWindow::paintEvent().</para>
        /// <para>Paint event handler. Calls paintGL().</para>
        /// <para>See also paintGL().</para>
        /// </summary>
        protected override void OnPaintEvent(QPaintEvent _event)
        {
            var arg0 = ReferenceEquals(_event, null) ? global::System.IntPtr.Zero : _event.__Instance;
            Internal.OnPaintEvent_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Reimplemented from QWindow::resizeEvent().</para>
        /// <para>Resize event handler. Calls resizeGL().</para>
        /// <para>See also resizeGL().</para>
        /// </summary>
        protected override void OnResizeEvent(QResizeEvent _event)
        {
            var arg0 = ReferenceEquals(_event, null) ? global::System.IntPtr.Zero : _event.__Instance;
            Internal.OnResizeEvent_0(__Instance, arg0);
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the update behavior for this QOpenGLWindow.</para>
        /// </summary>
        public QOpenGLWindow.UpdateBehavior updateBehavior
        {
            get
            {
                var __ret = Internal.updateBehavior_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the window's OpenGL resources, like the context,
        /// have been successfully initialized. Note that the return value is always
        /// false until the window becomes exposed (shown).</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns The QOpenGLContext used by this window or 0 if not yet
        /// initialized.</para>
        /// </summary>
        public QOpenGLContext Context
        {
            get
            {
                var __ret = Internal.Context_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLContext.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns a 32-bit RGB image of the framebuffer.</para>
        /// <para>Note: This is a potentially expensive operation because it relies
        /// on glReadPixels() to read back the pixels. This may be slow and can stall
        /// the GPU pipeline.Note: When used together with update behavior
        /// NoPartialUpdate, the returned image may not contain the desired content
        /// when called after the front and back buffers have been swapped (unless
        /// preserved swap is enabled in the underlying windowing system interface). In
        /// this mode the function reads from the back buffer and the contents of that
        /// may not match the content on the screen (the front buffer). In this case
        /// the only place where this function can safely be used is paintGL() or
        /// paintOverGL().</para>
        /// <para></para>
        /// <para>[virtual protected] void QOpenGLWindow::initializeGL()</para>
        /// <para>This virtual function is called once before the first call to
        /// paintGL() or resizeGL(). Reimplement it in a subclass.</para>
        /// <para>This function should set up any required OpenGL resources and
        /// state.</para>
        /// <para>There is no need to call makeCurrent() because this has already
        /// been done when this function is called. Note however that the framebuffer,
        /// in case partial update mode is used, is not yet available at this stage, so
        /// avoid issuing draw calls from here. Defer such calls to paintGL()
        /// instead.</para>
        /// <para>See also paintGL() and resizeGL().</para>
        /// </summary>
        public QImage GrabFramebuffer
        {
            get
            {
                var __ret = new QtGui.QImage.Internal();
                Internal.GrabFramebuffer_0(new IntPtr(&__ret), __Instance);
                return QImage.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // SurfaceType surfaceType()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurface.SurfaceType _SurfaceType_0Delegate(global::System.IntPtr instance);
        private static _SurfaceType_0Delegate _SurfaceType_0DelegateInstance;

        private static QSurface.SurfaceType _SurfaceType_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            var _ret = target.SurfaceType;
            return _ret;
        }

        // QSurfaceFormat format()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurfaceFormat.Internal _Format_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Format_0Delegate _Format_0DelegateInstance;

        private static QSurfaceFormat.Internal _Format_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            var _ret = target.Format;
            return ReferenceEquals(_ret, null) ? new QSurfaceFormat.Internal() : *(QSurfaceFormat.Internal*) (_ret.__Instance);
        }

        // QAccessibleInterface *accessibleRoot()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleRoot_0Delegate(global::System.IntPtr instance);
        private static _AccessibleRoot_0Delegate _AccessibleRoot_0DelegateInstance;

        private static global::System.IntPtr _AccessibleRoot_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            var _ret = target.AccessibleRoot;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void exposeEvent(QExposeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnExposeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _254);
        private static _OnExposeEvent_0Delegate _OnExposeEvent_0DelegateInstance;

        private static void _OnExposeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _254)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnExposeEvent((_254 == IntPtr.Zero) ? null : QExposeEvent.__CreateInstance(_254));
        }

        // void resizeEvent(QResizeEvent *event)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnResizeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _event);
        private static _OnResizeEvent_0Delegate _OnResizeEvent_0DelegateInstance;

        private static void _OnResizeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _event)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnResizeEvent((_event == IntPtr.Zero) ? null : QResizeEvent.__CreateInstance(_event));
        }

        // void moveEvent(QMoveEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMoveEvent_0Delegate _OnMoveEvent_0DelegateInstance;

        private static void _OnMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnMoveEvent((ev == IntPtr.Zero) ? null : QMoveEvent.__CreateInstance(ev));
        }

        // void focusInEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusInEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusInEvent_0Delegate _OnFocusInEvent_0DelegateInstance;

        private static void _OnFocusInEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnFocusInEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void focusOutEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusOutEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusOutEvent_0Delegate _OnFocusOutEvent_0DelegateInstance;

        private static void _OnFocusOutEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnFocusOutEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void showEvent(QShowEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnShowEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnShowEvent_0Delegate _OnShowEvent_0DelegateInstance;

        private static void _OnShowEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnShowEvent((ev == IntPtr.Zero) ? null : QShowEvent.__CreateInstance(ev));
        }

        // void hideEvent(QHideEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnHideEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnHideEvent_0Delegate _OnHideEvent_0DelegateInstance;

        private static void _OnHideEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnHideEvent((ev == IntPtr.Zero) ? null : QHideEvent.__CreateInstance(ev));
        }

        // void keyPressEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyPressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyPressEvent_0Delegate _OnKeyPressEvent_0DelegateInstance;

        private static void _OnKeyPressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnKeyPressEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void keyReleaseEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyReleaseEvent_0Delegate _OnKeyReleaseEvent_0DelegateInstance;

        private static void _OnKeyReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnKeyReleaseEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void mousePressEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMousePressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMousePressEvent_0Delegate _OnMousePressEvent_0DelegateInstance;

        private static void _OnMousePressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnMousePressEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseReleaseEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseReleaseEvent_0Delegate _OnMouseReleaseEvent_0DelegateInstance;

        private static void _OnMouseReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnMouseReleaseEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseDoubleClickEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseDoubleClickEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseDoubleClickEvent_0Delegate _OnMouseDoubleClickEvent_0DelegateInstance;

        private static void _OnMouseDoubleClickEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnMouseDoubleClickEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseMoveEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseMoveEvent_0Delegate _OnMouseMoveEvent_0DelegateInstance;

        private static void _OnMouseMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnMouseMoveEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void wheelEvent(QWheelEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnWheelEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnWheelEvent_0Delegate _OnWheelEvent_0DelegateInstance;

        private static void _OnWheelEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnWheelEvent((ev == IntPtr.Zero) ? null : QWheelEvent.__CreateInstance(ev));
        }

        // void touchEvent(QTouchEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTouchEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTouchEvent_0Delegate _OnTouchEvent_0DelegateInstance;

        private static void _OnTouchEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnTouchEvent((ev == IntPtr.Zero) ? null : QTouchEvent.__CreateInstance(ev));
        }

        // void tabletEvent(QTabletEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTabletEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTabletEvent_0Delegate _OnTabletEvent_0DelegateInstance;

        private static void _OnTabletEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnTabletEvent((ev == IntPtr.Zero) ? null : QTabletEvent.__CreateInstance(ev));
        }

        // void paintEvent(QPaintEvent *event)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnPaintEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _event);
        private static _OnPaintEvent_0Delegate _OnPaintEvent_0DelegateInstance;

        private static void _OnPaintEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _event)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.OnPaintEvent((_event == IntPtr.Zero) ? null : QPaintEvent.__CreateInstance(_event));
        }

        // int metric(PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void initializeGL()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitializeGL_0Delegate(global::System.IntPtr instance);
        private static _InitializeGL_0Delegate _InitializeGL_0DelegateInstance;

        private static void _InitializeGL_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.InitializeGL();
        }

        // void resizeGL(int w, int h)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _ResizeGL_0Delegate(global::System.IntPtr instance, int w, int h);
        private static _ResizeGL_0Delegate _ResizeGL_0DelegateInstance;

        private static void _ResizeGL_0DelegateHook(global::System.IntPtr instance, int w, int h)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.ResizeGL(w, h);
        }

        // void paintGL()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _PaintGL_0Delegate(global::System.IntPtr instance);
        private static _PaintGL_0Delegate _PaintGL_0DelegateInstance;

        private static void _PaintGL_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.PaintGL();
        }

        // void paintUnderGL()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _PaintUnderGL_0Delegate(global::System.IntPtr instance);
        private static _PaintUnderGL_0Delegate _PaintUnderGL_0DelegateInstance;

        private static void _PaintUnderGL_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.PaintUnderGL();
        }

        // void paintOverGL()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _PaintOverGL_0Delegate(global::System.IntPtr instance);
        private static _PaintOverGL_0Delegate _PaintOverGL_0DelegateInstance;

        private static void _PaintOverGL_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.PaintOverGL();
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLWindow) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[29];
                _SurfaceType_0DelegateInstance += _SurfaceType_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SurfaceType_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
                _AccessibleRoot_0DelegateInstance += _AccessibleRoot_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AccessibleRoot_0DelegateInstance).ToPointer();
                _OnExposeEvent_0DelegateInstance += _OnExposeEvent_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_OnExposeEvent_0DelegateInstance).ToPointer();
                _OnResizeEvent_0DelegateInstance += _OnResizeEvent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_OnResizeEvent_0DelegateInstance).ToPointer();
                _OnMoveEvent_0DelegateInstance += _OnMoveEvent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_OnMoveEvent_0DelegateInstance).ToPointer();
                _OnFocusInEvent_0DelegateInstance += _OnFocusInEvent_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_OnFocusInEvent_0DelegateInstance).ToPointer();
                _OnFocusOutEvent_0DelegateInstance += _OnFocusOutEvent_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_OnFocusOutEvent_0DelegateInstance).ToPointer();
                _OnShowEvent_0DelegateInstance += _OnShowEvent_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_OnShowEvent_0DelegateInstance).ToPointer();
                _OnHideEvent_0DelegateInstance += _OnHideEvent_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_OnHideEvent_0DelegateInstance).ToPointer();
                _OnKeyPressEvent_0DelegateInstance += _OnKeyPressEvent_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_OnKeyPressEvent_0DelegateInstance).ToPointer();
                _OnKeyReleaseEvent_0DelegateInstance += _OnKeyReleaseEvent_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_OnKeyReleaseEvent_0DelegateInstance).ToPointer();
                _OnMousePressEvent_0DelegateInstance += _OnMousePressEvent_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_OnMousePressEvent_0DelegateInstance).ToPointer();
                _OnMouseReleaseEvent_0DelegateInstance += _OnMouseReleaseEvent_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_OnMouseReleaseEvent_0DelegateInstance).ToPointer();
                _OnMouseDoubleClickEvent_0DelegateInstance += _OnMouseDoubleClickEvent_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_OnMouseDoubleClickEvent_0DelegateInstance).ToPointer();
                _OnMouseMoveEvent_0DelegateInstance += _OnMouseMoveEvent_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_OnMouseMoveEvent_0DelegateInstance).ToPointer();
                _OnWheelEvent_0DelegateInstance += _OnWheelEvent_0DelegateHook;
                _Thunks[16] = Marshal.GetFunctionPointerForDelegate(_OnWheelEvent_0DelegateInstance).ToPointer();
                _OnTouchEvent_0DelegateInstance += _OnTouchEvent_0DelegateHook;
                _Thunks[17] = Marshal.GetFunctionPointerForDelegate(_OnTouchEvent_0DelegateInstance).ToPointer();
                _OnTabletEvent_0DelegateInstance += _OnTabletEvent_0DelegateHook;
                _Thunks[18] = Marshal.GetFunctionPointerForDelegate(_OnTabletEvent_0DelegateInstance).ToPointer();
                _OnPaintEvent_0DelegateInstance += _OnPaintEvent_0DelegateHook;
                _Thunks[19] = Marshal.GetFunctionPointerForDelegate(_OnPaintEvent_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[20] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[21] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _InitializeGL_0DelegateInstance += _InitializeGL_0DelegateHook;
                _Thunks[22] = Marshal.GetFunctionPointerForDelegate(_InitializeGL_0DelegateInstance).ToPointer();
                _ResizeGL_0DelegateInstance += _ResizeGL_0DelegateHook;
                _Thunks[23] = Marshal.GetFunctionPointerForDelegate(_ResizeGL_0DelegateInstance).ToPointer();
                _PaintGL_0DelegateInstance += _PaintGL_0DelegateHook;
                _Thunks[24] = Marshal.GetFunctionPointerForDelegate(_PaintGL_0DelegateInstance).ToPointer();
                _PaintUnderGL_0DelegateInstance += _PaintUnderGL_0DelegateHook;
                _Thunks[25] = Marshal.GetFunctionPointerForDelegate(_PaintUnderGL_0DelegateInstance).ToPointer();
                _PaintOverGL_0DelegateInstance += _PaintOverGL_0DelegateHook;
                _Thunks[26] = Marshal.GetFunctionPointerForDelegate(_PaintOverGL_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[27] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[28] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(55 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[0];
                *(void**)(vfptr0 + 52) = _Thunks[1];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[2];
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = _Thunks[3];
                *(void**)(vfptr0 + 72) = _Thunks[4];
                *(void**)(vfptr0 + 76) = _Thunks[5];
                *(void**)(vfptr0 + 80) = _Thunks[6];
                *(void**)(vfptr0 + 84) = _Thunks[7];
                *(void**)(vfptr0 + 88) = _Thunks[8];
                *(void**)(vfptr0 + 92) = _Thunks[9];
                *(void**)(vfptr0 + 96) = _Thunks[10];
                *(void**)(vfptr0 + 100) = _Thunks[11];
                *(void**)(vfptr0 + 104) = _Thunks[12];
                *(void**)(vfptr0 + 108) = _Thunks[13];
                *(void**)(vfptr0 + 112) = _Thunks[14];
                *(void**)(vfptr0 + 116) = _Thunks[15];
                *(void**)(vfptr0 + 120) = _Thunks[16];
                *(void**)(vfptr0 + 124) = _Thunks[17];
                *(void**)(vfptr0 + 128) = _Thunks[18];
                *(void**)(vfptr0 + 132) = *(void**)(native->vfptr0 + 132);
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 140) = _Thunks[19];
                *(void**)(vfptr0 + 144) = _Thunks[20];
                *(void**)(vfptr0 + 148) = _Thunks[21];
                *(void**)(vfptr0 + 152) = _Thunks[22];
                *(void**)(vfptr0 + 156) = _Thunks[23];
                *(void**)(vfptr0 + 160) = _Thunks[24];
                *(void**)(vfptr0 + 164) = _Thunks[25];
                *(void**)(vfptr0 + 168) = _Thunks[26];
                *(void**)(vfptr0 + 172) = *(void**)(native->vfptr0 + 172);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 52) = _Thunks[1];
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 48) = _Thunks[0];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 224) = *(void**)(native->vfptr0 + 224);
                *(void**)(vfptr0 + 148) = _Thunks[21];
                *(void**)(vfptr0 + 144) = _Thunks[20];
                *(void**)(vfptr0 + 236) = _Thunks[27];
                *(void**)(vfptr0 + 172) = *(void**)(native->vfptr0 + 172);
                *(void**)(vfptr0 + 244) = _Thunks[28];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QPalette class contains color groups for each widget
    /// state.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A palette consists of three color groups: Active, Disabled, and
    /// Inactive. All widgets in Qt contain a palette and use their palette to draw
    /// themselves. This makes the user interface easily configurable and easier to
    /// keep consistent.</para>
    /// <para>If you create a new widget we strongly recommend that you use the
    /// colors in the palette rather than hard-coding specific colors.</para>
    /// <para>The color groups:</para>
    /// <para></para>
    /// <para>The Active group is used for the window that has keyboard
    /// focus.</para>
    /// <para>The Inactive group is used for other windows.</para>
    /// <para>The Disabled group is used for widgets (not windows) that are
    /// disabled for some reason.</para>
    /// <para></para>
    /// <para>Both active and inactive windows can contain disabled widgets.
    /// (Disabled widgets are often called inaccessible or grayed out.)</para>
    /// <para>In most styles, Active and Inactive look the same.</para>
    /// <para>Colors and brushes can be set for particular roles in any of a
    /// palette's color groups with setColor() and setBrush(). A color group
    /// contains a group of colors used by widgets for drawing themselves. We
    /// recommend that widgets use color group roles from the palette such as
    /// &quot;foreground&quot; and &quot;base&quot; rather than literal colors like
    /// &quot;red&quot; or &quot;turquoise&quot;. The color roles are enumerated
    /// and defined in the ColorRole documentation.</para>
    /// <para>We strongly recommend that you use the default palette of the
    /// current style (returned by QGuiApplication::palette()) and modify that as
    /// necessary. This is done by Qt's widgets when they are drawn.</para>
    /// <para>To modify a color group you call the functions setColor() and
    /// setBrush(), depending on whether you want a pure color or a pixmap
    /// pattern.</para>
    /// <para>There are also corresponding color() and brush() getters, and a
    /// commonly used convenience function to get the ColorRole for the current
    /// ColorGroup: window(), windowText(), base(), etc.</para>
    /// <para>You can copy a palette using the copy constructor and test to see
    /// if two palettes are identical using isCopyOf().</para>
    /// <para>QPalette is optimized by the use of implicit sharing, so it is
    /// very efficient to pass QPalette objects as arguments.</para>
    /// <para>Warning: Some styles do not use the palette for all drawing, for
    /// instance, if they make use of native theme engines. This is the case for
    /// both the Windows XP, Windows Vista, and the Mac OS X styles.</para>
    /// <para></para>
    /// <para>See also QApplication::setPalette(), QWidget::setPalette(), and
    /// QColor.</para>
    /// </remarks>
    public unsafe partial class QPalette : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [FieldOffset(4)]
            internal QPalette._.Internal _0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteC2ERK6QColor")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteC2ERK6QColorS2_")]
            internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr button, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteC2ERK6QBrushS2_S2_S2_S2_S2_S2_S2_S2_")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr windowText, global::System.IntPtr button, global::System.IntPtr light, global::System.IntPtr dark, global::System.IntPtr mid, global::System.IntPtr text, global::System.IntPtr bright_text, global::System.IntPtr @base, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteC2ERK6QColorS2_S2_S2_S2_S2_S2_")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr windowText, global::System.IntPtr window, global::System.IntPtr light, global::System.IntPtr dark, global::System.IntPtr mid, global::System.IntPtr text, global::System.IntPtr @base);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteC2ERKS_")]
            internal static extern void cctor_6(global::System.IntPtr instance, global::System.IntPtr palette);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPaletteD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPalette5brushENS_10ColorGroupENS_9ColorRoleE")]
            internal static extern global::System.IntPtr Brush_0(global::System.IntPtr instance, QPalette.ColorGroup cg, QPalette.ColorRole cr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPalette10isBrushSetENS_10ColorGroupENS_9ColorRoleE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsBrushSet_0(global::System.IntPtr instance, QPalette.ColorGroup cg, QPalette.ColorRole cr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPalette8setBrushENS_10ColorGroupENS_9ColorRoleERK6QBrush")]
            internal static extern void SetBrush_1(global::System.IntPtr instance, QPalette.ColorGroup cg, QPalette.ColorRole cr, global::System.IntPtr brush);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPalette13setColorGroupENS_10ColorGroupERK6QBrushS3_S3_S3_S3_S3_S3_S3_S3_")]
            internal static extern void SetColorGroup_0(global::System.IntPtr instance, QPalette.ColorGroup cr, global::System.IntPtr windowText, global::System.IntPtr button, global::System.IntPtr light, global::System.IntPtr dark, global::System.IntPtr mid, global::System.IntPtr text, global::System.IntPtr bright_text, global::System.IntPtr @base, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPalette7isEqualENS_10ColorGroupES0_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEqual_0(global::System.IntPtr instance, QPalette.ColorGroup cr1, QPalette.ColorGroup cr2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPaletteeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPalette8isCopyOfERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCopyOf_0(global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPalette7resolveERKS_")]
            internal static extern void Resolve_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr other);
        }

        public enum ColorGroup : uint
        {
            Active = 0,
            Disabled = 1,
            Inactive = 2,
            NColorGroups = 3,
            Current = 4,
            All = 5,
            /// <summary>synonym for Active</summary>
            Normal = 0
        }

        /// <summary>
        /// <para>The ColorRole enum defines the different symbolic color roles
        /// used in current GUIs.</para>
        /// <para>The central roles are:</para>
        /// <para>There are some color roles used mostly for 3D bevel and shadow
        /// effects. All of these are normally derived from Window, and used in ways
        /// that depend on that relationship. For example, buttons depend on it to make
        /// the bevels look attractive, and Motif scroll bars depend on Mid to be
        /// slightly different from Window.</para>
        /// <para>Selected (marked) items have two roles:</para>
        /// <para>There are two color roles related to hyperlinks:</para>
        /// <para>Note that we do not use the Link and LinkVisited roles when
        /// rendering rich text in Qt, and that we recommend that you use CSS and the
        /// QTextDocument::setDefaultStyleSheet() function to alter the appearance of
        /// links. For example:</para>
        /// <para>    QTextBrowser browser;</para>
        /// <para>    QColor linkColor(Qt::red);</para>
        /// <para>    QString sheet = QString::fromLatin1(&quot;a {
        /// text-decoration: underline; color: %1
        /// }&quot;).arg(linkColor.name());</para>
        /// <para>    browser.document()-&gt;setDefaultStyleSheet(sheet);</para>
        /// </summary>
        public enum ColorRole : uint
        {
            /// <summary>A general foreground color.</summary>
            WindowText = 0,
            /// <summary>The general button background color. This background can be different from Window as some styles require a different background color for buttons.</summary>
            Button = 1,
            /// <summary>Lighter than Button color.</summary>
            Light = 2,
            /// <summary>Between Button and Light.</summary>
            Midlight = 3,
            /// <summary>Darker than Button.</summary>
            Dark = 4,
            /// <summary>Between Button and Dark.</summary>
            Mid = 5,
            /// <summary>The foreground color used with Base. This is usually the same as the WindowText, in which case it must provide good contrast with Window and Base.</summary>
            Text = 6,
            /// <summary>A text color that is very different from WindowText, and contrasts well with e.g. Dark. Typically used for text that needs to be drawn where Text or WindowText would give poor contrast, such as on pressed push buttons. Note that text colors can be used for things other than just words; text colors are usually used for text, but it's quite common to use the text color roles for lines, icons, etc.</summary>
            BrightText = 7,
            /// <summary>A foreground color used with the Button color.</summary>
            ButtonText = 8,
            /// <summary>Used mostly as the background color for text entry widgets, but can also be used for other painting - such as the background of combobox drop down lists and toolbar handles. It is usually white or another light color.</summary>
            Base = 9,
            /// <summary>A general background color.</summary>
            Window = 10,
            /// <summary>A very dark color. By default, the shadow color is Qt::black.</summary>
            Shadow = 11,
            /// <summary>A color to indicate a selected item or the current item. By default, the highlight color is Qt::darkBlue.</summary>
            Highlight = 12,
            /// <summary>A text color that contrasts with Highlight. By default, the highlighted text color is Qt::white.</summary>
            HighlightedText = 13,
            /// <summary>A text color used for unvisited hyperlinks. By default, the link color is Qt::blue.</summary>
            Link = 14,
            /// <summary>A text color used for already visited hyperlinks. By default, the linkvisited color is Qt::magenta.</summary>
            LinkVisited = 15,
            /// <summary>Used as the alternate background color in views with alternating row colors (see QAbstractItemView::setAlternatingRowColors()).</summary>
            AlternateBase = 16,
            /// <summary>No role; this special role is often used to indicate that a role has not been assigned.</summary>
            NoRole = 17,
            /// <summary>Used as the background color for QToolTip and QWhatsThis. Tool tips use the Inactive color group of QPalette, because tool tips are not active windows.</summary>
            ToolTipBase = 18,
            /// <summary>Used as the foreground color for QToolTip and QWhatsThis. Tool tips use the Inactive color group of QPalette, because tool tips are not active windows.</summary>
            ToolTipText = 19,
            NColorRoles = 20,
            /// <summary>This value is obsolete. Use WindowText instead.</summary>
            Foreground = 0,
            /// <summary>This value is obsolete. Use Window instead.</summary>
            Background = 10
        }

        internal unsafe partial class Data
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint current_group;

                [FieldOffset(0)]
                public uint resolve_mask;
            }
        }

        internal unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal QPalette.Data.Internal data;

                [FieldOffset(0)]
                public uint for_faster_swapping_dont_use;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPalette __CreateInstance(global::System.IntPtr native)
        {
            return new QPalette((QPalette.Internal*) native);
        }

        public static QPalette __CreateInstance(QPalette.Internal native)
        {
            return new QPalette(native);
        }

        private static QPalette.Internal* __CopyValue(QPalette.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QPalette.Internal.cctor_6(ret, new global::System.IntPtr(&native));
            return (QPalette.Internal*) ret;
        }

        private QPalette(QPalette.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPalette(QPalette.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a palette object that uses the application's default
        /// palette.</para>
        /// <para>See also QApplication::setPalette() and
        /// QApplication::palette().</para>
        /// </summary>
        public QPalette()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a palette from the button color. The other colors are
        /// automatically calculated, based on this color. Window will be the button
        /// color as well.</para>
        /// </summary>
        public QPalette(QColor button)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(button, null) ? global::System.IntPtr.Zero : button.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a palette from a button color and a window. The other
        /// colors are automatically calculated, based on these colors.</para>
        /// </summary>
        public QPalette(QColor button, QColor window)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(button, null) ? global::System.IntPtr.Zero : button.__Instance;
            var arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            Internal.ctor_3(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a palette. You can pass either brushes, pixmaps or
        /// plain colors for windowText, button, light, dark, mid, text, bright_text,
        /// base and window.</para>
        /// <para>See also QBrush.</para>
        /// </summary>
        public QPalette(QBrush windowText, QBrush button, QBrush light, QBrush dark, QBrush mid, QBrush text, QBrush bright_text, QBrush @base, QBrush window)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(windowText, null) ? global::System.IntPtr.Zero : windowText.__Instance;
            var arg1 = ReferenceEquals(button, null) ? global::System.IntPtr.Zero : button.__Instance;
            var arg2 = ReferenceEquals(light, null) ? global::System.IntPtr.Zero : light.__Instance;
            var arg3 = ReferenceEquals(dark, null) ? global::System.IntPtr.Zero : dark.__Instance;
            var arg4 = ReferenceEquals(mid, null) ? global::System.IntPtr.Zero : mid.__Instance;
            var arg5 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var arg6 = ReferenceEquals(bright_text, null) ? global::System.IntPtr.Zero : bright_text.__Instance;
            var arg7 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
            var arg8 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            Internal.ctor_4(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }

        /// <summary>
        /// <para>Constructs a palette with the specified windowText, window,
        /// light, dark, mid, text, and base colors. The button color will be set to
        /// the window color.</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public QPalette(QColor windowText, QColor window, QColor light, QColor dark, QColor mid, QColor text, QColor @base)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(windowText, null) ? global::System.IntPtr.Zero : windowText.__Instance;
            var arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var arg2 = ReferenceEquals(light, null) ? global::System.IntPtr.Zero : light.__Instance;
            var arg3 = ReferenceEquals(dark, null) ? global::System.IntPtr.Zero : dark.__Instance;
            var arg4 = ReferenceEquals(mid, null) ? global::System.IntPtr.Zero : mid.__Instance;
            var arg5 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var arg6 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
            Internal.ctor_5(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        }

        /// <summary>
        /// <para>Constructs a copy of p.</para>
        /// <para>This constructor is fast thanks to implicit sharing.</para>
        /// </summary>
        public QPalette(QPalette palette)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(palette, null) ? global::System.IntPtr.Zero : palette.__Instance;
            Internal.cctor_6(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the brush in the specified color group, used for the
        /// given color role.</para>
        /// <para>See also color(), setBrush(), and ColorRole.</para>
        /// </summary>
        public QBrush Brush(QPalette.ColorGroup cg, QPalette.ColorRole cr)
        {
            var arg0 = cg;
            var arg1 = cr;
            var __ret = Internal.Brush_0(__Instance, arg0, arg1);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QBrush.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if the ColorGroup cg and ColorRole cr has been set
        /// previously on this palette; otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setBrush().</para>
        /// </summary>
        public bool IsBrushSet(QPalette.ColorGroup cg, QPalette.ColorRole cr)
        {
            var arg0 = cg;
            var arg1 = cr;
            var __ret = Internal.IsBrushSet_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the brush in the specified color group, used for the given
        /// color role, to brush.</para>
        /// <para>See also brush(), setColor(), and ColorRole.</para>
        /// </summary>
        public void SetBrush(QPalette.ColorGroup cg, QPalette.ColorRole cr, QBrush brush)
        {
            var arg0 = cg;
            var arg1 = cr;
            var arg2 = ReferenceEquals(brush, null) ? global::System.IntPtr.Zero : brush.__Instance;
            Internal.SetBrush_1(__Instance, arg0, arg1, arg2);
        }

        /// <summary>
        /// <para>Sets a the group at cg. You can pass either brushes, pixmaps or
        /// plain colors for windowText, button, light, dark, mid, text, bright_text,
        /// base and window.</para>
        /// <para>See also QBrush.</para>
        /// </summary>
        public void SetColorGroup(QPalette.ColorGroup cr, QBrush windowText, QBrush button, QBrush light, QBrush dark, QBrush mid, QBrush text, QBrush bright_text, QBrush @base, QBrush window)
        {
            var arg0 = cr;
            var arg1 = ReferenceEquals(windowText, null) ? global::System.IntPtr.Zero : windowText.__Instance;
            var arg2 = ReferenceEquals(button, null) ? global::System.IntPtr.Zero : button.__Instance;
            var arg3 = ReferenceEquals(light, null) ? global::System.IntPtr.Zero : light.__Instance;
            var arg4 = ReferenceEquals(dark, null) ? global::System.IntPtr.Zero : dark.__Instance;
            var arg5 = ReferenceEquals(mid, null) ? global::System.IntPtr.Zero : mid.__Instance;
            var arg6 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var arg7 = ReferenceEquals(bright_text, null) ? global::System.IntPtr.Zero : bright_text.__Instance;
            var arg8 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
            var arg9 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            Internal.SetColorGroup_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }

        /// <summary>
        /// <para>Returns true (usually quickly) if color group cg1 is equal to
        /// cg2; otherwise returns false.</para>
        /// </summary>
        public bool IsEqual(QPalette.ColorGroup cr1, QPalette.ColorGroup cr2)
        {
            var arg0 = cr1;
            var arg1 = cr2;
            var __ret = Internal.IsEqual_0(__Instance, arg0, arg1);
            return __ret;
        }

        public static bool operator !=(QPalette __op, QPalette p)
        {
            return !(__op == p);
        }

        /// <summary>
        /// <para>Returns true (usually quickly) if this palette is equal to p;
        /// otherwise returns false (slowly).</para>
        /// <para>Note: The current ColorGroup is not taken into account when
        /// comparing palettesSee also operator!=().</para>
        /// </summary>
        public static bool operator ==(QPalette __op, QPalette p)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool pNull = ReferenceEquals(p, null);
            if (__opNull || pNull)
                return __opNull && pNull;
            var arg0 = __op.__Instance;
            var arg1 = p.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QPalette;
        }

        /// <summary>
        /// <para>Returns true if this palette and p are copies of each other, i.e.
        /// one of them was created as a copy of the other and neither was subsequently
        /// modified; otherwise returns false. This is much stricter than
        /// equality.</para>
        /// <para>See also operator=() and operator==().</para>
        /// </summary>
        public bool IsCopyOf(QPalette p)
        {
            var arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            var __ret = Internal.IsCopyOf_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a new QPalette that has attributes copied from
        /// other.</para>
        /// </summary>
        public QPalette Resolve(QPalette other)
        {
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = new QtGui.QPalette.Internal();
            Internal.Resolve_0(new IntPtr(&__ret), __Instance, arg0);
            return QPalette.__CreateInstance(__ret);
        }
    }

    public unsafe partial class QRasterWindow : QtGui.QPaintDeviceWindow, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public QSurface.SurfaceClass m_type;

            [FieldOffset(8)]
            public global::System.IntPtr m_reserved;

            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QRasterWindowC2EP7QWindow")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QRasterWindowC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QRasterWindowD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QRasterWindow6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        private readonly bool __ownsNativeInstance;

        public static new QRasterWindow __CreateInstance(global::System.IntPtr native)
        {
            return new QRasterWindow((QRasterWindow.Internal*) native);
        }

        public static QRasterWindow __CreateInstance(QRasterWindow.Internal native)
        {
            return new QRasterWindow(native);
        }

        private static QRasterWindow.Internal* __CopyValue(QRasterWindow.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QRasterWindow.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QRasterWindow.Internal*) ret;
        }

        private QRasterWindow(QRasterWindow.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QRasterWindow(QRasterWindow.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDeviceWindow.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new QRasterWindow with parent.</para>
        /// </summary>
        public QRasterWindow(QWindow parent = null)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        #region Virtual table interop

        // SurfaceType surfaceType()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurface.SurfaceType _SurfaceType_0Delegate(global::System.IntPtr instance);
        private static _SurfaceType_0Delegate _SurfaceType_0DelegateInstance;

        private static QSurface.SurfaceType _SurfaceType_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            var _ret = target.SurfaceType;
            return _ret;
        }

        // QSurfaceFormat format()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QSurfaceFormat.Internal _Format_0Delegate(global::System.IntPtr instance, global::System.IntPtr _return);
        private static _Format_0Delegate _Format_0DelegateInstance;

        private static QSurfaceFormat.Internal _Format_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _return)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            var _ret = target.Format;
            return ReferenceEquals(_ret, null) ? new QSurfaceFormat.Internal() : *(QSurfaceFormat.Internal*) (_ret.__Instance);
        }

        // QAccessibleInterface *accessibleRoot()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _AccessibleRoot_0Delegate(global::System.IntPtr instance);
        private static _AccessibleRoot_0Delegate _AccessibleRoot_0DelegateInstance;

        private static global::System.IntPtr _AccessibleRoot_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            var _ret = target.AccessibleRoot;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void exposeEvent(QExposeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnExposeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _254);
        private static _OnExposeEvent_0Delegate _OnExposeEvent_0DelegateInstance;

        private static void _OnExposeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _254)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnExposeEvent((_254 == IntPtr.Zero) ? null : QExposeEvent.__CreateInstance(_254));
        }

        // void resizeEvent(QResizeEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnResizeEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnResizeEvent_0Delegate _OnResizeEvent_0DelegateInstance;

        private static void _OnResizeEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnResizeEvent((ev == IntPtr.Zero) ? null : QResizeEvent.__CreateInstance(ev));
        }

        // void moveEvent(QMoveEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMoveEvent_0Delegate _OnMoveEvent_0DelegateInstance;

        private static void _OnMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnMoveEvent((ev == IntPtr.Zero) ? null : QMoveEvent.__CreateInstance(ev));
        }

        // void focusInEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusInEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusInEvent_0Delegate _OnFocusInEvent_0DelegateInstance;

        private static void _OnFocusInEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnFocusInEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void focusOutEvent(QFocusEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnFocusOutEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnFocusOutEvent_0Delegate _OnFocusOutEvent_0DelegateInstance;

        private static void _OnFocusOutEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnFocusOutEvent((ev == IntPtr.Zero) ? null : QFocusEvent.__CreateInstance(ev));
        }

        // void showEvent(QShowEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnShowEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnShowEvent_0Delegate _OnShowEvent_0DelegateInstance;

        private static void _OnShowEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnShowEvent((ev == IntPtr.Zero) ? null : QShowEvent.__CreateInstance(ev));
        }

        // void hideEvent(QHideEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnHideEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnHideEvent_0Delegate _OnHideEvent_0DelegateInstance;

        private static void _OnHideEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnHideEvent((ev == IntPtr.Zero) ? null : QHideEvent.__CreateInstance(ev));
        }

        // void keyPressEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyPressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyPressEvent_0Delegate _OnKeyPressEvent_0DelegateInstance;

        private static void _OnKeyPressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnKeyPressEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void keyReleaseEvent(QKeyEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnKeyReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnKeyReleaseEvent_0Delegate _OnKeyReleaseEvent_0DelegateInstance;

        private static void _OnKeyReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnKeyReleaseEvent((ev == IntPtr.Zero) ? null : QKeyEvent.__CreateInstance(ev));
        }

        // void mousePressEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMousePressEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMousePressEvent_0Delegate _OnMousePressEvent_0DelegateInstance;

        private static void _OnMousePressEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnMousePressEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseReleaseEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseReleaseEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseReleaseEvent_0Delegate _OnMouseReleaseEvent_0DelegateInstance;

        private static void _OnMouseReleaseEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnMouseReleaseEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseDoubleClickEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseDoubleClickEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseDoubleClickEvent_0Delegate _OnMouseDoubleClickEvent_0DelegateInstance;

        private static void _OnMouseDoubleClickEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnMouseDoubleClickEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void mouseMoveEvent(QMouseEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnMouseMoveEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnMouseMoveEvent_0Delegate _OnMouseMoveEvent_0DelegateInstance;

        private static void _OnMouseMoveEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnMouseMoveEvent((ev == IntPtr.Zero) ? null : QMouseEvent.__CreateInstance(ev));
        }

        // void wheelEvent(QWheelEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnWheelEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnWheelEvent_0Delegate _OnWheelEvent_0DelegateInstance;

        private static void _OnWheelEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnWheelEvent((ev == IntPtr.Zero) ? null : QWheelEvent.__CreateInstance(ev));
        }

        // void touchEvent(QTouchEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTouchEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTouchEvent_0Delegate _OnTouchEvent_0DelegateInstance;

        private static void _OnTouchEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnTouchEvent((ev == IntPtr.Zero) ? null : QTouchEvent.__CreateInstance(ev));
        }

        // void tabletEvent(QTabletEvent *)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnTabletEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr ev);
        private static _OnTabletEvent_0Delegate _OnTabletEvent_0DelegateInstance;

        private static void _OnTabletEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr ev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnTabletEvent((ev == IntPtr.Zero) ? null : QTabletEvent.__CreateInstance(ev));
        }

        // void paintEvent(QPaintEvent *event)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _OnPaintEvent_0Delegate(global::System.IntPtr instance, global::System.IntPtr _event);
        private static _OnPaintEvent_0Delegate _OnPaintEvent_0DelegateInstance;

        private static void _OnPaintEvent_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr _event)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.OnPaintEvent((_event == IntPtr.Zero) ? null : QPaintEvent.__CreateInstance(_event));
        }

        // int metric(PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRasterWindow) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[24];
                _SurfaceType_0DelegateInstance += _SurfaceType_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SurfaceType_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
                _AccessibleRoot_0DelegateInstance += _AccessibleRoot_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AccessibleRoot_0DelegateInstance).ToPointer();
                _OnExposeEvent_0DelegateInstance += _OnExposeEvent_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_OnExposeEvent_0DelegateInstance).ToPointer();
                _OnResizeEvent_0DelegateInstance += _OnResizeEvent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_OnResizeEvent_0DelegateInstance).ToPointer();
                _OnMoveEvent_0DelegateInstance += _OnMoveEvent_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_OnMoveEvent_0DelegateInstance).ToPointer();
                _OnFocusInEvent_0DelegateInstance += _OnFocusInEvent_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_OnFocusInEvent_0DelegateInstance).ToPointer();
                _OnFocusOutEvent_0DelegateInstance += _OnFocusOutEvent_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_OnFocusOutEvent_0DelegateInstance).ToPointer();
                _OnShowEvent_0DelegateInstance += _OnShowEvent_0DelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_OnShowEvent_0DelegateInstance).ToPointer();
                _OnHideEvent_0DelegateInstance += _OnHideEvent_0DelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_OnHideEvent_0DelegateInstance).ToPointer();
                _OnKeyPressEvent_0DelegateInstance += _OnKeyPressEvent_0DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_OnKeyPressEvent_0DelegateInstance).ToPointer();
                _OnKeyReleaseEvent_0DelegateInstance += _OnKeyReleaseEvent_0DelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_OnKeyReleaseEvent_0DelegateInstance).ToPointer();
                _OnMousePressEvent_0DelegateInstance += _OnMousePressEvent_0DelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_OnMousePressEvent_0DelegateInstance).ToPointer();
                _OnMouseReleaseEvent_0DelegateInstance += _OnMouseReleaseEvent_0DelegateHook;
                _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_OnMouseReleaseEvent_0DelegateInstance).ToPointer();
                _OnMouseDoubleClickEvent_0DelegateInstance += _OnMouseDoubleClickEvent_0DelegateHook;
                _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_OnMouseDoubleClickEvent_0DelegateInstance).ToPointer();
                _OnMouseMoveEvent_0DelegateInstance += _OnMouseMoveEvent_0DelegateHook;
                _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_OnMouseMoveEvent_0DelegateInstance).ToPointer();
                _OnWheelEvent_0DelegateInstance += _OnWheelEvent_0DelegateHook;
                _Thunks[16] = Marshal.GetFunctionPointerForDelegate(_OnWheelEvent_0DelegateInstance).ToPointer();
                _OnTouchEvent_0DelegateInstance += _OnTouchEvent_0DelegateHook;
                _Thunks[17] = Marshal.GetFunctionPointerForDelegate(_OnTouchEvent_0DelegateInstance).ToPointer();
                _OnTabletEvent_0DelegateInstance += _OnTabletEvent_0DelegateHook;
                _Thunks[18] = Marshal.GetFunctionPointerForDelegate(_OnTabletEvent_0DelegateInstance).ToPointer();
                _OnPaintEvent_0DelegateInstance += _OnPaintEvent_0DelegateHook;
                _Thunks[19] = Marshal.GetFunctionPointerForDelegate(_OnPaintEvent_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[20] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[21] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[22] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[23] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(50 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[0];
                *(void**)(vfptr0 + 52) = _Thunks[1];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[2];
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = _Thunks[3];
                *(void**)(vfptr0 + 72) = _Thunks[4];
                *(void**)(vfptr0 + 76) = _Thunks[5];
                *(void**)(vfptr0 + 80) = _Thunks[6];
                *(void**)(vfptr0 + 84) = _Thunks[7];
                *(void**)(vfptr0 + 88) = _Thunks[8];
                *(void**)(vfptr0 + 92) = _Thunks[9];
                *(void**)(vfptr0 + 96) = _Thunks[10];
                *(void**)(vfptr0 + 100) = _Thunks[11];
                *(void**)(vfptr0 + 104) = _Thunks[12];
                *(void**)(vfptr0 + 108) = _Thunks[13];
                *(void**)(vfptr0 + 112) = _Thunks[14];
                *(void**)(vfptr0 + 116) = _Thunks[15];
                *(void**)(vfptr0 + 120) = _Thunks[16];
                *(void**)(vfptr0 + 124) = _Thunks[17];
                *(void**)(vfptr0 + 128) = _Thunks[18];
                *(void**)(vfptr0 + 132) = *(void**)(native->vfptr0 + 132);
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 140) = _Thunks[19];
                *(void**)(vfptr0 + 144) = _Thunks[20];
                *(void**)(vfptr0 + 148) = _Thunks[21];
                *(void**)(vfptr0 + 152) = *(void**)(native->vfptr0 + 152);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 52) = _Thunks[1];
                *(void**)(vfptr0 + 136) = *(void**)(native->vfptr0 + 136);
                *(void**)(vfptr0 + 48) = _Thunks[0];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                *(void**)(vfptr0 + 204) = *(void**)(native->vfptr0 + 204);
                *(void**)(vfptr0 + 148) = _Thunks[21];
                *(void**)(vfptr0 + 144) = _Thunks[20];
                *(void**)(vfptr0 + 216) = _Thunks[22];
                *(void**)(vfptr0 + 152) = *(void**)(native->vfptr0 + 152);
                *(void**)(vfptr0 + 224) = _Thunks[23];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QScreen class is used to query screen properties.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A note on logical vs physical dots per inch: physical DPI is
    /// based on the actual physical pixel sizes when available, and is useful for
    /// print preview and other cases where it's desirable to know the exact
    /// physical dimensions of screen displayed contents.</para>
    /// <para>Logical dots per inch are used to convert font and user interface
    /// elements from point sizes to pixel sizes, and might be different from the
    /// physical dots per inch. The logical dots per inch are sometimes
    /// user-settable in the desktop environment's settings panel, to let the user
    /// globally control UI and font sizes in different applications.</para>
    /// </remarks>
    public unsafe partial class QScreen : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QScreenC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN7QScreenD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QScreen4nameEv")]
            internal static extern void Name_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QScreen5depthEv")]
            internal static extern int Depth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK7QScreen15virtualSiblingsEv")]
            internal static extern QList.Internal VirtualSiblings_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QScreen __CreateInstance(global::System.IntPtr native)
        {
            return new QScreen((QScreen.Internal*) native);
        }

        public static QScreen __CreateInstance(QScreen.Internal native)
        {
            return new QScreen(native);
        }

        private static QScreen.Internal* __CopyValue(QScreen.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QScreen.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QScreen.Internal*) ret;
        }

        private QScreen(QScreen.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QScreen(QScreen.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>This property holds a user presentable string representing the
        /// screen.</para>
        /// <para>For example, on X11 these correspond to the XRandr screen names,
        /// typically &quot;VGA1&quot;, &quot;HDMI1&quot;, etc.</para>
        /// </summary>
        public string Name
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Name_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>This property holds the color depth of the screen.</para>
        /// </summary>
        public int Depth
        {
            get
            {
                var __ret = Internal.Depth_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the screen's virtual siblings.</para>
        /// <para>The virtual siblings are the screen instances sharing the same
        /// virtual desktop. They share a common coordinate system, and windows can
        /// freely be moved or positioned across them without having to be
        /// re-created.</para>
        /// </summary>
        public System.Collections.Generic.IList<QScreen> VirtualSiblings
        {
            get
            {
                var __ret = Internal.VirtualSiblings_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QScreen>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QScreen.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        #region Virtual table interop

        // ~QScreen()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QScreen) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QSessionManager class provides access to the session
    /// manager.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A session manager in a desktop environment (in which Qt GUI
    /// applications live) keeps track of a session, which is a group of running
    /// applications, each of which has a particular state. The state of an
    /// application contains (most notably) the documents the application has open
    /// and the position and size of its windows.</para>
    /// <para>The session manager is used to save the session, e.g., when the
    /// machine is shut down, and to restore a session, e.g., when the machine is
    /// started up. We recommend that you use QSettings to save an application's
    /// settings, for example, window positions, recently used files, etc. When the
    /// application is restarted by the session manager, you can restore the
    /// settings.</para>
    /// <para>QSessionManager provides an interface between the application and
    /// the session manager so that the program can work well with the session
    /// manager. In Qt, session management requests for action are handled by the
    /// two signals QGuiApplication::commitDataRequest() and
    /// QGuiApplication::saveStateRequest(). Both provide a reference to a session
    /// manager object as argument, to allow the application to communicate with
    /// the session manager. The session manager can only be accessed through these
    /// functions.</para>
    /// <para>No user interaction is possible unless the application gets
    /// explicit permission from the session manager. You ask for permission by
    /// calling allowsInteraction() or, if it is really urgent,
    /// allowsErrorInteraction(). Qt does not enforce this, but the session manager
    /// may.</para>
    /// <para>You can try to abort the shutdown process by calling cancel().
    /// The default commitData() function does this if some top-level window
    /// rejected its closeEvent().</para>
    /// <para>For sophisticated session managers provided on Unix/X11,
    /// QSessionManager offers further possibilities to fine-tune an application's
    /// session management behavior: setRestartCommand(), setDiscardCommand(),
    /// setRestartHint(), setProperty(), requestPhase2(). See the respective
    /// function descriptions for further details.</para>
    /// <para></para>
    /// <para>See also QGuiApplication and Session Management.</para>
    /// </remarks>
    public unsafe partial class QSessionManager : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManagerC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManagerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager7releaseEv")]
            internal static extern void Release_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager6cancelEv")]
            internal static extern void Cancel_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager18setManagerPropertyERK7QStringS2_")]
            internal static extern void SetManagerProperty_0(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager13requestPhase2Ev")]
            internal static extern void RequestPhase2_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QSessionManager11restartHintEv")]
            internal static extern QSessionManager.RestartHint restartHint_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager14setRestartHintENS_11RestartHintE")]
            internal static extern void SetRestartHint_0(global::System.IntPtr instance, QSessionManager.RestartHint hint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QSessionManager9sessionIdEv")]
            internal static extern void SessionId_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QSessionManager10sessionKeyEv")]
            internal static extern void SessionKey_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager17allowsInteractionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AllowsInteraction_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QSessionManager22allowsErrorInteractionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AllowsErrorInteraction_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QSessionManager8isPhase2Ev")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsPhase2_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type defines the circumstances under which this
        /// application wants to be restarted by the session manager. The current
        /// values are:</para>
        /// <para>The default hint is RestartIfRunning.</para>
        /// </summary>
        public enum RestartHint : uint
        {
            /// <summary>If the application is still running when the session is shut down, it wants to be restarted at the start of the next session.</summary>
            RestartIfRunning = 0,
            /// <summary>The application wants to be started at the start of the next session, no matter what. (This is useful for utilities that run just after startup and then quit.)</summary>
            RestartAnyway = 1,
            /// <summary>The application wants to be started immediately whenever it is not running.</summary>
            RestartImmediately = 2,
            /// <summary>The application does not want to be restarted automatically.</summary>
            RestartNever = 3
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QSessionManager __CreateInstance(global::System.IntPtr native)
        {
            return new QSessionManager((QSessionManager.Internal*) native);
        }

        public static QSessionManager __CreateInstance(QSessionManager.Internal native)
        {
            return new QSessionManager(native);
        }

        private static QSessionManager.Internal* __CopyValue(QSessionManager.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QSessionManager.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QSessionManager.Internal*) ret;
        }

        private QSessionManager(QSessionManager.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QSessionManager(QSessionManager.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Releases the session manager's interaction semaphore after an
        /// interaction phase.</para>
        /// <para>See also allowsInteraction() and allowsErrorInteraction().</para>
        /// </summary>
        public void Release()
        {
            Internal.Release_0(__Instance);
        }

        /// <summary>
        /// <para>Tells the session manager to cancel the shutdown process.
        /// Applications should not call this function without asking the user
        /// first.</para>
        /// <para>See also allowsInteraction() and allowsErrorInteraction().</para>
        /// </summary>
        public void Cancel()
        {
            Internal.Cancel_0(__Instance);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Low-level write access to the application's identification and
        /// state records are kept in the session manager.</para>
        /// <para>The property called name has its value set to the string
        /// value.</para>
        /// </summary>
        public void SetManagerProperty(string name, string value)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.SetManagerProperty_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Requests a second session management phase for the application.
        /// The application may then return immediately from the
        /// QGuiApplication::commitDataRequest() or QApplication::saveStateRequest()
        /// function, and they will be called again once most or all other applications
        /// have finished their session management.</para>
        /// <para>The two phases are useful for applications such as the X11 window
        /// manager that need to store information about another application's windows
        /// and therefore have to wait until these applications have completed their
        /// respective session management tasks.</para>
        /// <para>Note: If another application has requested a second phase it may
        /// get called before, simultaneously with, or after your application's second
        /// phase.See also isPhase2().</para>
        /// </summary>
        public void RequestPhase2()
        {
            Internal.RequestPhase2_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the application's current restart hint. The default is
        /// RestartIfRunning.</para>
        /// <para>See also setRestartHint().</para>
        /// <para></para>
        /// <para>Sets the application's restart hint to hint. On application
        /// startup, the hint is set to RestartIfRunning.</para>
        /// <para>Note: These flags are only hints, a session manager may or may
        /// not respect them.We recommend setting the restart hint in
        /// QGuiApplication::saveStateRequest() because most session managers perform a
        /// checkpoint shortly after an application's startup.</para>
        /// <para>See also restartHint().</para>
        /// </summary>
        public QSessionManager.RestartHint restartHint
        {
            get
            {
                var __ret = Internal.restartHint_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetRestartHint_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the identifier of the current session.</para>
        /// <para>If the application has been restored from an earlier session,
        /// this identifier is the same as it was in the earlier session.</para>
        /// <para>See also sessionKey() and QGuiApplication::sessionId().</para>
        /// </summary>
        public string SessionId
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.SessionId_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the session key in the current session.</para>
        /// <para>If the application has been restored from an earlier session,
        /// this key is the same as it was when the previous session ended.</para>
        /// <para>The session key changes with every call of commitData() or
        /// saveState().</para>
        /// <para>See also sessionId() and QGuiApplication::sessionKey().</para>
        /// </summary>
        public string SessionKey
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.SessionKey_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Asks the session manager for permission to interact with the
        /// user. Returns true if interaction is permitted; otherwise returns
        /// false.</para>
        /// <para>The rationale behind this mechanism is to make it possible to
        /// synchronize user interaction during a shutdown. Advanced session managers
        /// may ask all applications simultaneously to commit their data, resulting in
        /// a much faster shutdown.</para>
        /// <para>When the interaction is completed we strongly recommend releasing
        /// the user interaction semaphore with a call to release(). This way, other
        /// applications may get the chance to interact with the user while your
        /// application is still busy saving data. (The semaphore is implicitly
        /// released when the application exits.)</para>
        /// <para>If the user decides to cancel the shutdown process during the
        /// interaction phase, you must tell the session manager that this has happened
        /// by calling cancel().</para>
        /// <para>Here's an example of how an application's
        /// QGuiApplication::commitDataRequest() might be implemented:</para>
        /// <para>MyMainWidget::MyMainWidget(QWidget *parent)</para>
        /// <para>    :QWidget(parent)</para>
        /// <para>{</para>
        /// <para>    connect(qApp, SIGNAL(commitDataRequest(QSessionManager)),
        /// SLOT(commitData(QSessionManager)));</para>
        /// <para>}</para>
        /// <para></para>
        /// <para>void MyMainWidget::commitData(QSessionManager&amp;
        /// manager)</para>
        /// <para>{</para>
        /// <para>    if (manager.allowsInteraction()) {</para>
        /// <para>        int ret = QMessageBox::warning(</para>
        /// <para>                    mainWindow,</para>
        /// <para>                    tr(&quot;My Application&quot;),</para>
        /// <para>                    tr(&quot;Save changes to
        /// document?&quot;),</para>
        /// <para>                    QMessageBox::Save | QMessageBox::Discard |
        /// QMessageBox::Cancel);</para>
        /// <para></para>
        /// <para>        switch (ret) {</para>
        /// <para>        case QMessageBox::Save:</para>
        /// <para>            manager.release();</para>
        /// <para>            if (!saveDocument())</para>
        /// <para>                manager.cancel();</para>
        /// <para>            break;</para>
        /// <para>        case QMessageBox::Discard:</para>
        /// <para>            break;</para>
        /// <para>        case QMessageBox::Cancel:</para>
        /// <para>        default:</para>
        /// <para>            manager.cancel();</para>
        /// <para>        }</para>
        /// <para>    } else {</para>
        /// <para>        // we did not get permission to interact, then</para>
        /// <para>        // do something reasonable instead</para>
        /// <para>    }</para>
        /// <para>}</para>
        /// <para>If an error occurred within the application while saving its
        /// data, you may want to try allowsErrorInteraction() instead.</para>
        /// <para>See also QGuiApplication::commitDataRequest(), release(), and
        /// cancel().</para>
        /// </summary>
        public bool AllowsInteraction
        {
            get
            {
                var __ret = Internal.AllowsInteraction_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if error interaction is permitted; otherwise returns
        /// false.</para>
        /// <para>This is similar to allowsInteraction(), but also enables the
        /// application to tell the user about any errors that occur. Session managers
        /// may give error interaction requests higher priority, which means that it is
        /// more likely that an error interaction is permitted. However, you are still
        /// not guaranteed that the session manager will allow interaction.</para>
        /// <para>See also allowsInteraction(), release(), and cancel().</para>
        /// </summary>
        public bool AllowsErrorInteraction
        {
            get
            {
                var __ret = Internal.AllowsErrorInteraction_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the session manager is currently performing a
        /// second session management phase; otherwise returns false.</para>
        /// <para>See also requestPhase2().</para>
        /// </summary>
        public bool IsPhase2
        {
            get
            {
                var __ret = Internal.IsPhase2_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QSessionManager()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QSessionManager) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QStyleHints class contains platform specific hints and
    /// settings.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>An object of this class, obtained from QGuiApplication, provides
    /// access to certain global user interface parameters of the current
    /// platform.</para>
    /// <para>Access is read only; typically the platform itself provides the
    /// user a way to tune these parameters.</para>
    /// <para>Access to these parameters are useful when implementing custom
    /// user interface components, in that they allow the components to exhibit the
    /// same behaviour and feel as other components.</para>
    /// <para></para>
    /// <para>See also QGuiApplication::styleHints().</para>
    /// </remarks>
    public unsafe partial class QStyleHints : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHintsC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHintsD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints17startDragVelocityEv")]
            internal static extern int StartDragVelocity_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints16showIsFullScreenEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool ShowIsFullScreen_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints22setFocusOnTouchReleaseEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetFocusOnTouchRelease_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints24mouseDoubleClickIntervalEv")]
            internal static extern int MouseDoubleClickInterval_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHints27setMouseDoubleClickIntervalEi")]
            internal static extern void SetMouseDoubleClickInterval_0(global::System.IntPtr instance, int mouseDoubleClickInterval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints17startDragDistanceEv")]
            internal static extern int StartDragDistance_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHints20setStartDragDistanceEi")]
            internal static extern void SetStartDragDistance_0(global::System.IntPtr instance, int startDragDistance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints13startDragTimeEv")]
            internal static extern int StartDragTime_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHints16setStartDragTimeEi")]
            internal static extern void SetStartDragTime_0(global::System.IntPtr instance, int startDragTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints21keyboardInputIntervalEv")]
            internal static extern int KeyboardInputInterval_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHints24setKeyboardInputIntervalEi")]
            internal static extern void SetKeyboardInputInterval_0(global::System.IntPtr instance, int keyboardInputInterval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints15cursorFlashTimeEv")]
            internal static extern int CursorFlashTime_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStyleHints18setCursorFlashTimeEi")]
            internal static extern void SetCursorFlashTime_0(global::System.IntPtr instance, int cursorFlashTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints25mousePressAndHoldIntervalEv")]
            internal static extern int MousePressAndHoldInterval_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints22keyboardAutoRepeatRateEv")]
            internal static extern int KeyboardAutoRepeatRate_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints17passwordMaskDelayEv")]
            internal static extern int PasswordMaskDelay_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStyleHints16useRtlExtensionsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool UseRtlExtensions_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QStyleHints __CreateInstance(global::System.IntPtr native)
        {
            return new QStyleHints((QStyleHints.Internal*) native);
        }

        public static QStyleHints __CreateInstance(QStyleHints.Internal native)
        {
            return new QStyleHints(native);
        }

        private static QStyleHints.Internal* __CopyValue(QStyleHints.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QStyleHints.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QStyleHints.Internal*) ret;
        }

        private QStyleHints(QStyleHints.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QStyleHints(QStyleHints.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the limit for the velocity, in pixels per second, that
        /// the mouse may be moved, with a button held down, for a drag and drop
        /// operation to begin. A value of 0 means there is no such limit.</para>
        /// <para>See also startDragDistance() and Drag and Drop.</para>
        /// </summary>
        public int StartDragVelocity()
        {
            var __ret = Internal.StartDragVelocity_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the platform defaults to windows being
        /// fullscreen, otherwise false.</para>
        /// <para>Note: The platform may still choose to show certain windows
        /// non-fullscreen, such as popups or dialogs. This method only returns the
        /// default behavior.See also QWindow::show().</para>
        /// </summary>
        public bool ShowIsFullScreen()
        {
            var __ret = Internal.ShowIsFullScreen_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if focus objects (line edits etc) should receive
        /// input focus after a touch/mouse release. This is normal behavior on touch
        /// platforms. On desktop platforms, the standard is to set focus already on
        /// touch/mouse press.</para>
        /// </summary>
        public bool SetFocusOnTouchRelease()
        {
            var __ret = Internal.SetFocusOnTouchRelease_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the time limit in milliseconds that distinguishes a
        /// double click from two consecutive mouse clicks.</para>
        /// </summary>
        public int MouseDoubleClickInterval
        {
            get
            {
                var __ret = Internal.MouseDoubleClickInterval_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMouseDoubleClickInterval_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the distance, in pixels, that the mouse must be moved
        /// with a button held down before a drag and drop operation will begin.</para>
        /// <para>If you support drag and drop in your application, and want to
        /// start a drag and drop operation after the user has moved the cursor a
        /// certain distance with a button held down, you should use this property's
        /// value as the minimum distance required.</para>
        /// <para>For example, if the mouse position of the click is stored in
        /// startPos and the current position (e.g. in the mouse move event) is
        /// currentPos, you can find out if a drag should be started with code like
        /// this:</para>
        /// <para>if ((startPos - currentPos).manhattanLength() &gt;=</para>
        /// <para>        QApplication::startDragDistance())</para>
        /// <para>    startTheDrag();</para>
        /// <para>See also startDragTime(), QPoint::manhattanLength(), and Drag and
        /// Drop.</para>
        /// </summary>
        public int StartDragDistance
        {
            get
            {
                var __ret = Internal.StartDragDistance_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStartDragDistance_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the time, in milliseconds, that a mouse button must be
        /// held down before a drag and drop operation will begin.</para>
        /// <para>If you support drag and drop in your application, and want to
        /// start a drag and drop operation after the user has held down a mouse button
        /// for a certain amount of time, you should use this property's value as the
        /// delay.</para>
        /// <para>See also startDragDistance() and Drag and Drop.</para>
        /// </summary>
        public int StartDragTime
        {
            get
            {
                var __ret = Internal.StartDragTime_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStartDragTime_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the time limit, in milliseconds, that distinguishes a key
        /// press from two consecutive key presses.</para>
        /// </summary>
        public int KeyboardInputInterval
        {
            get
            {
                var __ret = Internal.KeyboardInputInterval_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetKeyboardInputInterval_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the text cursor's flash (blink) time in
        /// milliseconds.</para>
        /// <para>The flash time is the time used to display, invert and restore
        /// the caret display. Usually the text cursor is displayed for half the cursor
        /// flash time, then hidden for the same amount of time.</para>
        /// </summary>
        public int CursorFlashTime
        {
            get
            {
                var __ret = Internal.CursorFlashTime_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetCursorFlashTime_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the time limit in milliseconds that activates a press and
        /// hold.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// </summary>
        public int MousePressAndHoldInterval
        {
            get
            {
                var __ret = Internal.MousePressAndHoldInterval_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the rate, in events per second, in which additional
        /// repeated key presses will automatically be generated if a key is being held
        /// down.</para>
        /// </summary>
        public int KeyboardAutoRepeatRate
        {
            get
            {
                var __ret = Internal.KeyboardAutoRepeatRate_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the time, in milliseconds, a typed letter is displayed
        /// unshrouded in a text input field in password mode.</para>
        /// </summary>
        public int PasswordMaskDelay
        {
            get
            {
                var __ret = Internal.PasswordMaskDelay_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if right-to-left writing direction is enabled,
        /// otherwise false.</para>
        /// </summary>
        public bool UseRtlExtensions
        {
            get
            {
                var __ret = Internal.UseRtlExtensions_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QGenericMatrix class is a template class that represents a
    /// NxM transformation matrix with N columns and M rows.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QGenericMatrix template has three parameters:</para>
    /// <para></para>
    /// <para> N	Number of columns.</para>
    /// <para>M	Number of rows.</para>
    /// <para>T	Element type that is visible to users of the class.</para>
    /// </remarks>
    public unsafe partial class QGenericMatrix
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct Internal
        {
        }
    }

    /// <summary>
    /// <para>The QVector3D class represents a vector or vertex in 3D
    /// space.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Vectors are one of the main building blocks of 3D representation
    /// and drawing. They consist of three coordinates, traditionally called x, y,
    /// and z.</para>
    /// <para>The QVector3D class can also be used to represent vertices in 3D
    /// space. We therefore do not need to provide a separate vertex class.</para>
    /// <para></para>
    /// <para>See also QVector2D, QVector4D, and QQuaternion.</para>
    /// </remarks>
    public unsafe partial class QVector3D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public float xp;

            [FieldOffset(4)]
            public float yp;

            [FieldOffset(8)]
            public float zp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector3DC2ERK9QVector2D")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector3DC2ERK9QVector2Df")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr vector, float zpos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector3DC2ERK9QVector4D")]
            internal static extern void ctor_6(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector3DC2ERKS_")]
            internal static extern void cctor_7(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector3D9normalizeEv")]
            internal static extern void Normalize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QVector3D10dotProductERKS_S1_")]
            internal static extern float DotProduct_0(global::System.IntPtr v1, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QVector3D12crossProductERKS_S1_")]
            internal static extern void CrossProduct_0(global::System.IntPtr @return, global::System.IntPtr v1, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QVector3D6normalERKS_S1_")]
            internal static extern void Normal_0(global::System.IntPtr @return, global::System.IntPtr v1, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QVector3D6normalERKS_S1_S1_")]
            internal static extern void Normal_1(global::System.IntPtr @return, global::System.IntPtr v1, global::System.IntPtr v2, global::System.IntPtr v3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D15distanceToPointERKS_")]
            internal static extern float DistanceToPoint_0(global::System.IntPtr instance, global::System.IntPtr point);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D15distanceToPlaneERKS_S1_")]
            internal static extern float DistanceToPlane_0(global::System.IntPtr instance, global::System.IntPtr plane, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D15distanceToPlaneERKS_S1_S1_")]
            internal static extern float DistanceToPlane_1(global::System.IntPtr instance, global::System.IntPtr plane1, global::System.IntPtr plane2, global::System.IntPtr plane3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D14distanceToLineERKS_S1_")]
            internal static extern float DistanceToLine_0(global::System.IntPtr instance, global::System.IntPtr point, global::System.IntPtr direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D10toVector2DEv")]
            internal static extern QVector2D.Internal ToVector2D_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D10toVector4DEv")]
            internal static extern void ToVector4D_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D6lengthEv")]
            internal static extern float Length_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D13lengthSquaredEv")]
            internal static extern float LengthSquared_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector3D10normalizedEv")]
            internal static extern void Normalized_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QVector3D __CreateInstance(global::System.IntPtr native)
        {
            return new QVector3D((QVector3D.Internal*) native);
        }

        public static QVector3D __CreateInstance(QVector3D.Internal native)
        {
            return new QVector3D(native);
        }

        private static QVector3D.Internal* __CopyValue(QVector3D.Internal native)
        {
            var ret = (QVector3D.Internal*) Marshal.AllocHGlobal(12);
            *ret = native;
            return ret;
        }

        private QVector3D(QVector3D.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QVector3D(QVector3D.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a 3D vector from the specified 2D vector. The z
        /// coordinate is set to zero.</para>
        /// <para>See also toVector2D().</para>
        /// </summary>
        public QVector3D(QVector2D vector)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a 3D vector from the specified 2D vector. The z
        /// coordinate is set to zpos.</para>
        /// <para>See also toVector2D().</para>
        /// </summary>
        public QVector3D(QVector2D vector, float zpos)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_5(__Instance, arg0, zpos);
        }

        /// <summary>
        /// <para>Constructs a 3D vector from the specified 4D vector. The w
        /// coordinate is dropped.</para>
        /// <para>See also toVector4D().</para>
        /// </summary>
        public QVector3D(QVector4D vector)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_6(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Normalizes the currect vector in place. Nothing happens if this
        /// vector is a null vector or the length of the vector is very close to
        /// 1.</para>
        /// <para>See also length() and normalized().</para>
        /// </summary>
        public void Normalize()
        {
            Internal.Normalize_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the distance from this vertex to a point defined by the
        /// vertex point.</para>
        /// <para>This function was introduced in  Qt 5.1.</para>
        /// <para>See also distanceToPlane() and distanceToLine().</para>
        /// </summary>
        public float DistanceToPoint(QVector3D point)
        {
            var arg0 = ReferenceEquals(point, null) ? global::System.IntPtr.Zero : point.__Instance;
            var __ret = Internal.DistanceToPoint_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the distance from this vertex to a plane defined by the
        /// vertex plane and a normal unit vector. The normal parameter is assumed to
        /// have been normalized to a unit vector.</para>
        /// <para>The return value will be negative if the vertex is below the
        /// plane, or zero if it is on the plane.</para>
        /// <para>See also normal() and distanceToLine().</para>
        /// </summary>
        public float DistanceToPlane(QVector3D plane, QVector3D normal)
        {
            var arg0 = ReferenceEquals(plane, null) ? global::System.IntPtr.Zero : plane.__Instance;
            var arg1 = ReferenceEquals(normal, null) ? global::System.IntPtr.Zero : normal.__Instance;
            var __ret = Internal.DistanceToPlane_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the distance from this vertex a plane defined by the
        /// vertices plane1, plane2 and plane3.</para>
        /// <para>The return value will be negative if the vertex is below the
        /// plane, or zero if it is on the plane.</para>
        /// <para>The two vectors that define the plane are plane2 - plane1 and
        /// plane3 - plane1.</para>
        /// <para>See also normal() and distanceToLine().</para>
        /// </summary>
        public float DistanceToPlane(QVector3D plane1, QVector3D plane2, QVector3D plane3)
        {
            var arg0 = ReferenceEquals(plane1, null) ? global::System.IntPtr.Zero : plane1.__Instance;
            var arg1 = ReferenceEquals(plane2, null) ? global::System.IntPtr.Zero : plane2.__Instance;
            var arg2 = ReferenceEquals(plane3, null) ? global::System.IntPtr.Zero : plane3.__Instance;
            var __ret = Internal.DistanceToPlane_1(__Instance, arg0, arg1, arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the distance that this vertex is from a line defined by
        /// point and the unit vector direction.</para>
        /// <para>If direction is a null vector, then it does not define a line. In
        /// that case, the distance from point to this vertex is returned.</para>
        /// <para>See also distanceToPlane().</para>
        /// </summary>
        public float DistanceToLine(QVector3D point, QVector3D direction)
        {
            var arg0 = ReferenceEquals(point, null) ? global::System.IntPtr.Zero : point.__Instance;
            var arg1 = ReferenceEquals(direction, null) ? global::System.IntPtr.Zero : direction.__Instance;
            var __ret = Internal.DistanceToLine_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the 2D vector form of this 3D vector, dropping the z
        /// coordinate.</para>
        /// <para>See also toVector4D() and toPoint().</para>
        /// </summary>
        public QVector2D ToVector2D()
        {
            var __ret = Internal.ToVector2D_0(__Instance);
            return QVector2D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the 4D form of this 3D vector, with the w coordinate set
        /// to zero.</para>
        /// <para>See also toVector2D() and toPoint().</para>
        /// </summary>
        public QVector4D ToVector4D()
        {
            var __ret = new QtGui.QVector4D.Internal();
            Internal.ToVector4D_0(new IntPtr(&__ret), __Instance);
            return QVector4D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the dot product of v1 and v2.</para>
        /// </summary>
        public static float DotProduct(QVector3D v1, QVector3D v2)
        {
            var arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            var __ret = Internal.DotProduct_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the cross-product of vectors v1 and v2, which corresponds
        /// to the normal vector of a plane defined by v1 and v2.</para>
        /// <para>See also normal().</para>
        /// </summary>
        public static QVector3D CrossProduct(QVector3D v1, QVector3D v2)
        {
            var arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            var __ret = new QtGui.QVector3D.Internal();
            Internal.CrossProduct_0(new IntPtr(&__ret), arg0, arg1);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the normal vector of a plane defined by vectors v1 and
        /// v2, normalized to be a unit vector.</para>
        /// <para>Use crossProduct() to compute the cross-product of v1 and v2 if
        /// you do not need the result to be normalized to a unit vector.</para>
        /// <para>See also crossProduct() and distanceToPlane().</para>
        /// </summary>
        public static QVector3D Normal(QVector3D v1, QVector3D v2)
        {
            var arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            var __ret = new QtGui.QVector3D.Internal();
            Internal.Normal_0(new IntPtr(&__ret), arg0, arg1);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the normal vector of a plane defined by vectors v2 - v1
        /// and v3 - v1, normalized to be a unit vector.</para>
        /// <para>Use crossProduct() to compute the cross-product of v2 - v1 and v3
        /// - v1 if you do not need the result to be normalized to a unit
        /// vector.</para>
        /// <para>See also crossProduct() and distanceToPlane().</para>
        /// </summary>
        public static QVector3D Normal(QVector3D v1, QVector3D v2, QVector3D v3)
        {
            var arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            var arg2 = ReferenceEquals(v3, null) ? global::System.IntPtr.Zero : v3.__Instance;
            var __ret = new QtGui.QVector3D.Internal();
            Internal.Normal_1(new IntPtr(&__ret), arg0, arg1, arg2);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the length of the vector from the origin.</para>
        /// <para>See also lengthSquared() and normalized().</para>
        /// </summary>
        public float Length
        {
            get
            {
                var __ret = Internal.Length_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the squared length of the vector from the origin. This is
        /// equivalent to the dot product of the vector with itself.</para>
        /// <para>See also length() and dotProduct().</para>
        /// </summary>
        public float LengthSquared
        {
            get
            {
                var __ret = Internal.LengthSquared_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the normalized unit vector form of this vector.</para>
        /// <para>If this vector is null, then a null vector is returned. If the
        /// length of the vector is very close to 1, then the vector will be returned
        /// as-is. Otherwise the normalized form of the vector of length 1 will be
        /// returned.</para>
        /// <para>See also length() and normalize().</para>
        /// </summary>
        public QVector3D Normalized
        {
            get
            {
                var __ret = new QtGui.QVector3D.Internal();
                Internal.Normalized_0(new IntPtr(&__ret), __Instance);
                return QVector3D.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QVector4D class represents a vector or vertex in 4D
    /// space.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QVector4D class can also be used to represent vertices in 4D
    /// space. We therefore do not need to provide a separate vertex class.</para>
    /// <para></para>
    /// <para>See also QQuaternion, QVector2D, and QVector3D.</para>
    /// </remarks>
    public unsafe partial class QVector4D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public float xp;

            [FieldOffset(4)]
            public float yp;

            [FieldOffset(8)]
            public float zp;

            [FieldOffset(12)]
            public float wp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector4DC2ERK9QVector2D")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector4DC2ERK9QVector2Dff")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr vector, float zpos, float wpos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector4DC2ERK9QVector3D")]
            internal static extern void ctor_6(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector4DC2ERK9QVector3Df")]
            internal static extern void ctor_7(global::System.IntPtr instance, global::System.IntPtr vector, float wpos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector4DC2ERKS_")]
            internal static extern void cctor_8(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QVector4D9normalizeEv")]
            internal static extern void Normalize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QVector4D10dotProductERKS_S1_")]
            internal static extern float DotProduct_0(global::System.IntPtr v1, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D10toVector2DEv")]
            internal static extern QVector2D.Internal ToVector2D_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D16toVector2DAffineEv")]
            internal static extern QVector2D.Internal ToVector2DAffine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D10toVector3DEv")]
            internal static extern void ToVector3D_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D16toVector3DAffineEv")]
            internal static extern void ToVector3DAffine_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D6lengthEv")]
            internal static extern float Length_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D13lengthSquaredEv")]
            internal static extern float LengthSquared_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QVector4D10normalizedEv")]
            internal static extern void Normalized_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QVector4D __CreateInstance(global::System.IntPtr native)
        {
            return new QVector4D((QVector4D.Internal*) native);
        }

        public static QVector4D __CreateInstance(QVector4D.Internal native)
        {
            return new QVector4D(native);
        }

        private static QVector4D.Internal* __CopyValue(QVector4D.Internal native)
        {
            var ret = (QVector4D.Internal*) Marshal.AllocHGlobal(16);
            *ret = native;
            return ret;
        }

        private QVector4D(QVector4D.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QVector4D(QVector4D.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a 4D vector from the specified 2D vector. The z and w
        /// coordinates are set to zero.</para>
        /// <para>See also toVector2D().</para>
        /// </summary>
        public QVector4D(QVector2D vector)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a 4D vector from the specified 2D vector. The z and w
        /// coordinates are set to zpos and wpos respectively.</para>
        /// <para>See also toVector2D().</para>
        /// </summary>
        public QVector4D(QVector2D vector, float zpos, float wpos)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_5(__Instance, arg0, zpos, wpos);
        }

        /// <summary>
        /// <para>Constructs a 4D vector from the specified 3D vector. The w
        /// coordinate is set to zero.</para>
        /// <para>See also toVector3D().</para>
        /// </summary>
        public QVector4D(QVector3D vector)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_6(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a 4D vector from the specified 3D vector. The w
        /// coordinate is set to wpos.</para>
        /// <para>See also toVector3D().</para>
        /// </summary>
        public QVector4D(QVector3D vector, float wpos)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.ctor_7(__Instance, arg0, wpos);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Normalizes the currect vector in place. Nothing happens if this
        /// vector is a null vector or the length of the vector is very close to
        /// 1.</para>
        /// <para>See also length() and normalized().</para>
        /// </summary>
        public void Normalize()
        {
            Internal.Normalize_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the 2D vector form of this 4D vector, dropping the z and
        /// w coordinates.</para>
        /// <para>See also toVector2DAffine(), toVector3D(), and toPoint().</para>
        /// </summary>
        public QVector2D ToVector2D()
        {
            var __ret = Internal.ToVector2D_0(__Instance);
            return QVector2D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the 2D vector form of this 4D vector, dividing the x and
        /// y coordinates by the w coordinate and dropping the z coordinate. Returns a
        /// null vector if w is zero.</para>
        /// <para>See also toVector2D(), toVector3DAffine(), and toPoint().</para>
        /// </summary>
        public QVector2D ToVector2DAffine()
        {
            var __ret = Internal.ToVector2DAffine_0(__Instance);
            return QVector2D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the 3D vector form of this 4D vector, dropping the w
        /// coordinate.</para>
        /// <para>See also toVector3DAffine(), toVector2D(), and toPoint().</para>
        /// </summary>
        public QVector3D ToVector3D()
        {
            var __ret = new QtGui.QVector3D.Internal();
            Internal.ToVector3D_0(new IntPtr(&__ret), __Instance);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the 3D vector form of this 4D vector, dividing the x, y,
        /// and z coordinates by the w coordinate. Returns a null vector if w is
        /// zero.</para>
        /// <para>See also toVector3D(), toVector2DAffine(), and toPoint().</para>
        /// </summary>
        public QVector3D ToVector3DAffine()
        {
            var __ret = new QtGui.QVector3D.Internal();
            Internal.ToVector3DAffine_0(new IntPtr(&__ret), __Instance);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the dot product of v1 and v2.</para>
        /// </summary>
        public static float DotProduct(QVector4D v1, QVector4D v2)
        {
            var arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            var __ret = Internal.DotProduct_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the length of the vector from the origin.</para>
        /// <para>See also lengthSquared() and normalized().</para>
        /// </summary>
        public float Length
        {
            get
            {
                var __ret = Internal.Length_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the squared length of the vector from the origin. This is
        /// equivalent to the dot product of the vector with itself.</para>
        /// <para>See also length() and dotProduct().</para>
        /// </summary>
        public float LengthSquared
        {
            get
            {
                var __ret = Internal.LengthSquared_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the normalized unit vector form of this vector.</para>
        /// <para>If this vector is null, then a null vector is returned. If the
        /// length of the vector is very close to 1, then the vector will be returned
        /// as-is. Otherwise the normalized form of the vector of length 1 will be
        /// returned.</para>
        /// <para>See also length() and normalize().</para>
        /// </summary>
        public QVector4D Normalized
        {
            get
            {
                var __ret = new QtGui.QVector4D.Internal();
                Internal.Normalized_0(new IntPtr(&__ret), __Instance);
                return QVector4D.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QQuaternion class represents a quaternion consisting of a
    /// vector and scalar.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Quaternions are used to represent rotations in 3D space, and
    /// consist of a 3D rotation axis specified by the x, y, and z coordinates, and
    /// a scalar representing the rotation angle.</para>
    /// </remarks>
    public unsafe partial class QQuaternion : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public float wp;

            [FieldOffset(4)]
            public float xp;

            [FieldOffset(8)]
            public float yp;

            [FieldOffset(12)]
            public float zp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QQuaternionC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QQuaternion9normalizeEv")]
            internal static extern void Normalize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QQuaternion13rotatedVectorERK9QVector3D")]
            internal static extern void RotatedVector_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QQuaternion16fromAxisAndAngleERK9QVector3Df")]
            internal static extern void FromAxisAndAngle_0(global::System.IntPtr @return, global::System.IntPtr axis, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QQuaternion16fromAxisAndAngleEffff")]
            internal static extern void FromAxisAndAngle_1(global::System.IntPtr @return, float x, float y, float z, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QQuaternion5slerpERKS_S1_f")]
            internal static extern void Slerp_0(global::System.IntPtr @return, global::System.IntPtr q1, global::System.IntPtr q2, float t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11QQuaternion5nlerpERKS_S1_f")]
            internal static extern void Nlerp_0(global::System.IntPtr @return, global::System.IntPtr q1, global::System.IntPtr q2, float t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QQuaternion6lengthEv")]
            internal static extern float Length_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QQuaternion13lengthSquaredEv")]
            internal static extern float LengthSquared_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QQuaternion10normalizedEv")]
            internal static extern void Normalized_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QQuaternion __CreateInstance(global::System.IntPtr native)
        {
            return new QQuaternion((QQuaternion.Internal*) native);
        }

        public static QQuaternion __CreateInstance(QQuaternion.Internal native)
        {
            return new QQuaternion(native);
        }

        private static QQuaternion.Internal* __CopyValue(QQuaternion.Internal native)
        {
            var ret = (QQuaternion.Internal*) Marshal.AllocHGlobal(16);
            *ret = native;
            return ret;
        }

        private QQuaternion(QQuaternion.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QQuaternion(QQuaternion.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Normalizes the current quaternion in place. Nothing happens if
        /// this is a null quaternion or the length of the quaternion is very close to
        /// 1.</para>
        /// <para>See also length() and normalized().</para>
        /// </summary>
        public void Normalize()
        {
            Internal.Normalize_0(__Instance);
        }

        /// <summary>
        /// <para>Rotates vector with this quaternion to produce a new vector in 3D
        /// space. The following code:</para>
        /// <para>QVector3D result = q.rotatedVector(vector);</para>
        /// <para>is equivalent to the following:</para>
        /// <para>QVector3D result = (q * QQuaternion(0, vector) *
        /// q.conjugate()).vector();</para>
        /// </summary>
        public QVector3D RotatedVector(QVector3D vector)
        {
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            var __ret = new QtGui.QVector3D.Internal();
            Internal.RotatedVector_0(new IntPtr(&__ret), __Instance, arg0);
            return QVector3D.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates a normalized quaternion that corresponds to rotating
        /// through angle degrees about the specified 3D axis.</para>
        /// </summary>
        public static QQuaternion FromAxisAndAngle(QVector3D axis, float angle)
        {
            var arg0 = ReferenceEquals(axis, null) ? global::System.IntPtr.Zero : axis.__Instance;
            var __ret = new QtGui.QQuaternion.Internal();
            Internal.FromAxisAndAngle_0(new IntPtr(&__ret), arg0, angle);
            return QQuaternion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates a normalized quaternion that corresponds to rotating
        /// through angle degrees about the 3D axis (x, y, z).</para>
        /// </summary>
        public static QQuaternion FromAxisAndAngle(float x, float y, float z, float angle)
        {
            var __ret = new QtGui.QQuaternion.Internal();
            Internal.FromAxisAndAngle_1(new IntPtr(&__ret), x, y, z, angle);
            return QQuaternion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Interpolates along the shortest spherical path between the
        /// rotational positions q1 and q2. The value t should be between 0 and 1,
        /// indicating the spherical distance to travel between q1 and q2.</para>
        /// <para>If t is less than or equal to 0, then q1 will be returned. If t
        /// is greater than or equal to 1, then q2 will be returned.</para>
        /// <para>See also nlerp().</para>
        /// </summary>
        public static QQuaternion Slerp(QQuaternion q1, QQuaternion q2, float t)
        {
            var arg0 = ReferenceEquals(q1, null) ? global::System.IntPtr.Zero : q1.__Instance;
            var arg1 = ReferenceEquals(q2, null) ? global::System.IntPtr.Zero : q2.__Instance;
            var __ret = new QtGui.QQuaternion.Internal();
            Internal.Slerp_0(new IntPtr(&__ret), arg0, arg1, t);
            return QQuaternion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Interpolates along the shortest linear path between the
        /// rotational positions q1 and q2. The value t should be between 0 and 1,
        /// indicating the distance to travel between q1 and q2. The result will be
        /// normalized().</para>
        /// <para>If t is less than or equal to 0, then q1 will be returned. If t
        /// is greater than or equal to 1, then q2 will be returned.</para>
        /// <para>The nlerp() function is typically faster than slerp() and will
        /// give approximate results to spherical interpolation that are good enough
        /// for some applications.</para>
        /// <para>See also slerp().</para>
        /// </summary>
        public static QQuaternion Nlerp(QQuaternion q1, QQuaternion q2, float t)
        {
            var arg0 = ReferenceEquals(q1, null) ? global::System.IntPtr.Zero : q1.__Instance;
            var arg1 = ReferenceEquals(q2, null) ? global::System.IntPtr.Zero : q2.__Instance;
            var __ret = new QtGui.QQuaternion.Internal();
            Internal.Nlerp_0(new IntPtr(&__ret), arg0, arg1, t);
            return QQuaternion.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the length of the quaternion. This is also called the
        /// &quot;norm&quot;.</para>
        /// <para>See also lengthSquared() and normalized().</para>
        /// </summary>
        public float Length
        {
            get
            {
                var __ret = Internal.Length_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the squared length of the quaternion.</para>
        /// <para>See also length().</para>
        /// </summary>
        public float LengthSquared
        {
            get
            {
                var __ret = Internal.LengthSquared_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the normalized unit form of this quaternion.</para>
        /// <para>If this quaternion is null, then a null quaternion is returned.
        /// If the length of the quaternion is very close to 1, then the quaternion
        /// will be returned as-is. Otherwise the normalized form of the quaternion of
        /// length 1 will be returned.</para>
        /// <para>See also length() and normalize().</para>
        /// </summary>
        public QQuaternion Normalized
        {
            get
            {
                var __ret = new QtGui.QQuaternion.Internal();
                Internal.Normalized_0(new IntPtr(&__ret), __Instance);
                return QQuaternion.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QMatrix4x4 class represents a 4x4 transformation matrix in 3D
    /// space.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QMatrix4x4 class in general is treated as a row-major matrix,
    /// in that the constructors and operator() functions take data in row-major
    /// format, as is familiar in C-style usage.</para>
    /// <para>Internally the data is stored as column-major format, so as to be
    /// optimal for passing to OpenGL functions, which expect column-major
    /// data.</para>
    /// <para>When using these functions be aware that they return data in
    /// column-major format:</para>
    /// <para></para>
    /// <para>data()</para>
    /// <para>constData()</para>
    /// </remarks>
    public unsafe partial class QMatrix4x4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 68)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public fixed float m[16];

            [FieldOffset(64)]
            public int flagBits;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x4C2EPKf")]
            internal static extern void ctor_1(global::System.IntPtr instance, float* values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x4C2EPKfii")]
            internal static extern void ctor_3(global::System.IntPtr instance, float* values, int cols, int rows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x4C2ERK10QTransform")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x4C2ERK7QMatrix")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x4C2ERKS_")]
            internal static extern void cctor_7(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x48invertedEPb")]
            internal static extern void Inverted_0(global::System.IntPtr @return, global::System.IntPtr instance, bool* invertible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x45scaleERK9QVector3D")]
            internal static extern void Scale_0(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x49translateERK9QVector3D")]
            internal static extern void Translate_0(global::System.IntPtr instance, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x46rotateEfRK9QVector3D")]
            internal static extern void Rotate_0(global::System.IntPtr instance, float angle, global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x45scaleEff")]
            internal static extern void Scale_1(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x45scaleEfff")]
            internal static extern void Scale_2(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x45scaleEf")]
            internal static extern void Scale_3(global::System.IntPtr instance, float factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x49translateEff")]
            internal static extern void Translate_1(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x49translateEfff")]
            internal static extern void Translate_2(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x46rotateEffff")]
            internal static extern void Rotate_1(global::System.IntPtr instance, float angle, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x46rotateERK11QQuaternion")]
            internal static extern void Rotate_2(global::System.IntPtr instance, global::System.IntPtr quaternion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x45orthoEffffff")]
            internal static extern void Ortho_2(global::System.IntPtr instance, float left, float right, float bottom, float top, float nearPlane, float farPlane);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x47frustumEffffff")]
            internal static extern void Frustum_0(global::System.IntPtr instance, float left, float right, float bottom, float top, float nearPlane, float farPlane);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x411perspectiveEffff")]
            internal static extern void Perspective_0(global::System.IntPtr instance, float verticalAngle, float aspectRatio, float nearPlane, float farPlane);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x46lookAtERK9QVector3DS2_S2_")]
            internal static extern void LookAt_0(global::System.IntPtr instance, global::System.IntPtr eye, global::System.IntPtr center, global::System.IntPtr up);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x48viewportEffffff")]
            internal static extern void Viewport_1(global::System.IntPtr instance, float left, float bottom, float width, float height, float nearPlane, float farPlane);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x415flipCoordinatesEv")]
            internal static extern void FlipCoordinates_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x410copyDataToEPf")]
            internal static extern void CopyDataTo_0(global::System.IntPtr instance, float* values);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x48toAffineEv")]
            internal static extern void ToAffine_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x411toTransformEv")]
            internal static extern void ToTransform_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x411toTransformEf")]
            internal static extern void ToTransform_1(global::System.IntPtr @return, global::System.IntPtr instance, float distanceToPlane);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QMatrix4x48optimizeEv")]
            internal static extern void Optimize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZdvRK10QMatrix4x4f")]
            internal static extern void OperatorSlash_0(global::System.IntPtr @return, global::System.IntPtr matrix, float divisor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x411determinantEv")]
            internal static extern double Determinant_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QMatrix4x410transposedEv")]
            internal static extern void Transposed_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QMatrix4x4 __CreateInstance(global::System.IntPtr native)
        {
            return new QMatrix4x4((QMatrix4x4.Internal*) native);
        }

        public static QMatrix4x4 __CreateInstance(QMatrix4x4.Internal native)
        {
            return new QMatrix4x4(native);
        }

        private static QMatrix4x4.Internal* __CopyValue(QMatrix4x4.Internal native)
        {
            var ret = (QMatrix4x4.Internal*) Marshal.AllocHGlobal(68);
            *ret = native;
            return ret;
        }

        private QMatrix4x4(QMatrix4x4.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QMatrix4x4(QMatrix4x4.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a matrix from the given 16 floating-point values. The
        /// contents of the array values is assumed to be in row-major order.</para>
        /// <para>If the matrix has a special type (identity, translate, scale,
        /// etc), the programmer should follow this constructor with a call to
        /// optimize() if they wish QMatrix4x4 to optimize further calls to
        /// translate(), scale(), etc.</para>
        /// <para>See also copyDataTo() and optimize().</para>
        /// </summary>
        public QMatrix4x4(float* values)
        {
            __Instance = Marshal.AllocHGlobal(68);
            __ownsNativeInstance = true;
            var arg0 = values;
            Internal.ctor_1(__Instance, arg0);
        }

        public QMatrix4x4(float* values, int cols, int rows)
        {
            __Instance = Marshal.AllocHGlobal(68);
            __ownsNativeInstance = true;
            var arg0 = values;
            Internal.ctor_3(__Instance, arg0, cols, rows);
        }

        /// <summary>
        /// <para>Constructs a 4x4 matrix from the conventional Qt 2D
        /// transformation matrix transform.</para>
        /// <para>If transform has a special type (identity, translate, scale,
        /// etc), the programmer should follow this constructor with a call to
        /// optimize() if they wish QMatrix4x4 to optimize further calls to
        /// translate(), scale(), etc.</para>
        /// <para>See also toTransform() and optimize().</para>
        /// </summary>
        public QMatrix4x4(QTransform transform)
        {
            __Instance = Marshal.AllocHGlobal(68);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(transform, null) ? global::System.IntPtr.Zero : transform.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a 4x4 matrix from a conventional Qt 2D affine
        /// transformation matrix.</para>
        /// <para>If matrix has a special type (identity, translate, scale, etc),
        /// the programmer should follow this constructor with a call to optimize() if
        /// they wish QMatrix4x4 to optimize further calls to translate(), scale(),
        /// etc.</para>
        /// <para>See also toAffine() and optimize().</para>
        /// </summary>
        public QMatrix4x4(QMatrix matrix)
        {
            __Instance = Marshal.AllocHGlobal(68);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            Internal.ctor_5(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the inverse of this matrix. Returns the identity if this
        /// matrix cannot be inverted; i.e. determinant() is zero. If invertible is not
        /// null, then true will be written to that location if the matrix can be
        /// inverted; false otherwise.</para>
        /// <para>If the matrix is recognized as the identity or an orthonormal
        /// matrix, then this function will quickly invert the matrix using optimized
        /// routines.</para>
        /// <para>See also determinant() and normalMatrix().</para>
        /// </summary>
        public QMatrix4x4 Inverted(bool* invertible = null)
        {
            var arg0 = invertible;
            var __ret = new QtGui.QMatrix4x4.Internal();
            Internal.Inverted_0(new IntPtr(&__ret), __Instance, arg0);
            return QMatrix4x4.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that scales coordinates by the
        /// components of vector.</para>
        /// <para>See also translate() and rotate().</para>
        /// </summary>
        public void Scale(QVector3D vector)
        {
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.Scale_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that translates coordinates by
        /// the components of vector.</para>
        /// <para>See also scale() and rotate().</para>
        /// </summary>
        public void Translate(QVector3D vector)
        {
            var arg0 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.Translate_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Multiples this matrix by another that rotates coordinates through
        /// angle degrees about vector.</para>
        /// <para>See also scale() and translate().</para>
        /// </summary>
        public void Rotate(float angle, QVector3D vector)
        {
            var arg1 = ReferenceEquals(vector, null) ? global::System.IntPtr.Zero : vector.__Instance;
            Internal.Rotate_0(__Instance, angle, arg1);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Multiplies this matrix by another that scales coordinates by the
        /// components x, and y.</para>
        /// <para>See also translate() and rotate().</para>
        /// </summary>
        public void Scale(float x, float y)
        {
            Internal.Scale_1(__Instance, x, y);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Multiplies this matrix by another that scales coordinates by the
        /// components x, y, and z.</para>
        /// <para>See also translate() and rotate().</para>
        /// </summary>
        public void Scale(float x, float y, float z)
        {
            Internal.Scale_2(__Instance, x, y, z);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Multiplies this matrix by another that scales coordinates by the
        /// given factor.</para>
        /// <para>See also translate() and rotate().</para>
        /// </summary>
        public void Scale(float factor)
        {
            Internal.Scale_3(__Instance, factor);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Multiplies this matrix by another that translates coordinates by
        /// the components x, and y.</para>
        /// <para>See also scale() and rotate().</para>
        /// </summary>
        public void Translate(float x, float y)
        {
            Internal.Translate_1(__Instance, x, y);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Multiplies this matrix by another that translates coordinates by
        /// the components x, y, and z.</para>
        /// <para>See also scale() and rotate().</para>
        /// </summary>
        public void Translate(float x, float y, float z)
        {
            Internal.Translate_2(__Instance, x, y, z);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Multiplies this matrix by another that rotates coordinates
        /// through angle degrees about the vector (x, y, z).</para>
        /// <para>See also scale() and translate().</para>
        /// </summary>
        public void Rotate(float angle, float x, float y, float z = 0.0F)
        {
            Internal.Rotate_1(__Instance, angle, x, y, z);
        }

        /// <summary>
        /// <para>Multiples this matrix by another that rotates coordinates
        /// according to a specified quaternion. The quaternion is assumed to have been
        /// normalized.</para>
        /// <para>See also scale(), translate(), and QQuaternion.</para>
        /// </summary>
        public void Rotate(QQuaternion quaternion)
        {
            var arg0 = ReferenceEquals(quaternion, null) ? global::System.IntPtr.Zero : quaternion.__Instance;
            Internal.Rotate_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that applies an orthographic
        /// projection for a window with lower-left corner (left, bottom), upper-right
        /// corner (right, top), and the specified nearPlane and farPlane clipping
        /// planes.</para>
        /// <para>See also frustum() and perspective().</para>
        /// </summary>
        public void Ortho(float left, float right, float bottom, float top, float nearPlane, float farPlane)
        {
            Internal.Ortho_2(__Instance, left, right, bottom, top, nearPlane, farPlane);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that applies a perspective
        /// frustum projection for a window with lower-left corner (left, bottom),
        /// upper-right corner (right, top), and the specified nearPlane and farPlane
        /// clipping planes.</para>
        /// <para>See also ortho() and perspective().</para>
        /// </summary>
        public void Frustum(float left, float right, float bottom, float top, float nearPlane, float farPlane)
        {
            Internal.Frustum_0(__Instance, left, right, bottom, top, nearPlane, farPlane);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that applies a perspective
        /// projection. The vertical field of view will be verticalAngle degrees within
        /// a window with a given aspectRatio that determines the horizontal field of
        /// view. The projection will have the specified nearPlane and farPlane
        /// clipping planes which are the distances from the viewer to the
        /// corresponding planes.</para>
        /// <para>See also ortho() and frustum().</para>
        /// </summary>
        public void Perspective(float verticalAngle, float aspectRatio, float nearPlane, float farPlane)
        {
            Internal.Perspective_0(__Instance, verticalAngle, aspectRatio, nearPlane, farPlane);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that applies an eye position
        /// transformation. The center value indicates the center of the view that the
        /// eye is looking at. The up value indicates which direction should be
        /// considered up with respect to the eye.</para>
        /// </summary>
        public void LookAt(QVector3D eye, QVector3D center, QVector3D up)
        {
            var arg0 = ReferenceEquals(eye, null) ? global::System.IntPtr.Zero : eye.__Instance;
            var arg1 = ReferenceEquals(center, null) ? global::System.IntPtr.Zero : center.__Instance;
            var arg2 = ReferenceEquals(up, null) ? global::System.IntPtr.Zero : up.__Instance;
            Internal.LookAt_0(__Instance, arg0, arg1, arg2);
        }

        /// <summary>
        /// <para>Multiplies this matrix by another that performs the scale and
        /// bias transformation used by OpenGL to transform from normalized device
        /// coordinates (NDC) to viewport (window) coordinates. That is it maps points
        /// from the cube ranging over [-1, 1] in each dimension to the viewport with
        /// it's near-lower-left corner at (left, bottom, nearPlane) and with size
        /// (width, height, farPlane - nearPlane).</para>
        /// <para>This matches the transform used by the fixed function OpenGL
        /// viewport transform controlled by the functions glViewport() and
        /// glDepthRange().</para>
        /// </summary>
        public void Viewport(float left, float bottom, float width, float height, float nearPlane = 0.0F, float farPlane = 1.0F)
        {
            Internal.Viewport_1(__Instance, left, bottom, width, height, nearPlane, farPlane);
        }

        /// <summary>
        /// <para>Flips between right-handed and left-handed coordinate systems by
        /// multiplying the y and z co-ordinates by -1. This is normally used to create
        /// a left-handed orthographic view without scaling the viewport as ortho()
        /// does.</para>
        /// <para>See also ortho().</para>
        /// <para></para>
        /// <para>Related Non-Members</para>
        /// <para></para>
        /// <para>QGenericMatrix&lt;N, M, float&gt;
        /// qGenericMatrixFromMatrix4x4(const QMatrix4x4 &amp; matrix)</para>
        /// <para>Returns a NxM generic matrix constructed from the left-most N
        /// columns and top-most M rows of matrix. If N or M is greater than 4, then
        /// the remaining elements are filled with elements from the identity
        /// matrix.</para>
        /// <para>See also QMatrix4x4::toGenericMatrix().</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public void FlipCoordinates()
        {
            Internal.FlipCoordinates_0(__Instance);
        }

        /// <summary>
        /// <para>Retrieves the 16 items in this matrix and copies them to values
        /// in row-major order.</para>
        /// </summary>
        public void CopyDataTo(float* values)
        {
            var arg0 = values;
            Internal.CopyDataTo_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns the conventional Qt 2D affine transformation matrix that
        /// corresponds to this matrix. It is assumed that this matrix only contains 2D
        /// affine transformation elements.</para>
        /// <para>See also toTransform().</para>
        /// </summary>
        public QMatrix ToAffine()
        {
            var __ret = new QtGui.QMatrix.Internal();
            Internal.ToAffine_0(new IntPtr(&__ret), __Instance);
            return QMatrix.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the conventional Qt 2D transformation matrix that
        /// corresponds to this matrix.</para>
        /// <para>The returned QTransform is formed by simply dropping the third
        /// row and third column of the QMatrix4x4. This is suitable for implementing
        /// orthographic projections where the z co-ordinate should be dropped rather
        /// than projected.</para>
        /// <para>See also toAffine().</para>
        /// </summary>
        public QTransform ToTransform()
        {
            var __ret = new QtGui.QTransform.Internal();
            Internal.ToTransform_0(new IntPtr(&__ret), __Instance);
            return QTransform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the conventional Qt 2D transformation matrix that
        /// corresponds to this matrix.</para>
        /// <para>If distanceToPlane is non-zero, it indicates a projection factor
        /// to use to adjust for the z co-ordinate. The value of 1024 corresponds to
        /// the projection factor used by QTransform::rotate() for the x and y
        /// axes.</para>
        /// <para>If distanceToPlane is zero, then the returned QTransform is
        /// formed by simply dropping the third row and third column of the QMatrix4x4.
        /// This is suitable for implementing orthographic projections where the z
        /// co-ordinate should be dropped rather than projected.</para>
        /// <para>See also toAffine().</para>
        /// </summary>
        public QTransform ToTransform(float distanceToPlane)
        {
            var __ret = new QtGui.QTransform.Internal();
            Internal.ToTransform_1(new IntPtr(&__ret), __Instance, distanceToPlane);
            return QTransform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Optimize the usage of this matrix from its current
        /// elements.</para>
        /// <para>Some operations such as translate(), scale(), and rotate() can be
        /// performed more efficiently if the matrix being modified is already known to
        /// be the identity, a previous translate(), a previous scale(), etc.</para>
        /// <para>Normally the QMatrix4x4 class keeps track of this special type
        /// internally as operations are performed. However, if the matrix is modified
        /// directly with operator()() or data(), then QMatrix4x4 will lose track of
        /// the special type and will revert to the safest but least efficient
        /// operations thereafter.</para>
        /// <para>By calling optimize() after directly modifying the matrix, the
        /// programmer can force QMatrix4x4 to recover the special type if the elements
        /// appear to conform to one of the known optimized types.</para>
        /// <para>See also operator()(), data(), and translate().</para>
        /// </summary>
        public void Optimize()
        {
            Internal.Optimize_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the result of dividing all elements of matrix by
        /// divisor.</para>
        /// </summary>
        public static QMatrix4x4 operator /(QMatrix4x4 matrix, float divisor)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = new QtGui.QMatrix4x4.Internal();
            Internal.OperatorSlash_0(new IntPtr(&__ret), arg0, divisor);
            return QMatrix4x4.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the determinant of this matrix.</para>
        /// </summary>
        public double Determinant
        {
            get
            {
                var __ret = Internal.Determinant_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns this matrix, transposed about its diagonal.</para>
        /// </summary>
        public QMatrix4x4 Transposed
        {
            get
            {
                var __ret = new QtGui.QMatrix4x4.Internal();
                Internal.Transposed_0(new IntPtr(&__ret), __Instance);
                return QMatrix4x4.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLBuffer class provides functions for creating and
    /// managing OpenGL buffer objects.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Buffer objects are created in the OpenGL server so that the
    /// client application can avoid uploading vertices, indices, texture image
    /// data, etc every time they are needed.</para>
    /// <para>QOpenGLBuffer objects can be copied around as a reference to the
    /// underlying OpenGL buffer object:</para>
    /// <para>QOpenGLBuffer buffer1(QOpenGLBuffer::IndexBuffer);</para>
    /// <para>buffer1.create();</para>
    /// <para></para>
    /// <para>QOpenGLBuffer buffer2 = buffer1;</para>
    /// <para>QOpenGLBuffer performs a shallow copy when objects are copied in
    /// this manner, but does not implement copy-on-write semantics. The original
    /// object will be affected whenever the copy is modified.</para>
    /// </remarks>
    public unsafe partial class QOpenGLBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBufferC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBufferC2ENS_4TypeE")]
            internal static extern void ctor_1(global::System.IntPtr instance, QOpenGLBuffer.Type type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBufferC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBufferD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer4bindEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Bind_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer7releaseEv")]
            internal static extern void Release_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QOpenGLBuffer7releaseENS_4TypeE")]
            internal static extern void Release_1(QOpenGLBuffer.Type type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer4readEiPvi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Read_0(global::System.IntPtr instance, int offset, global::System.IntPtr data, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer5writeEiPKvi")]
            internal static extern void Write_0(global::System.IntPtr instance, int offset, global::System.IntPtr data, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer8allocateEPKvi")]
            internal static extern void Allocate_0(global::System.IntPtr instance, global::System.IntPtr data, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer3mapENS_6AccessE")]
            internal static extern global::System.IntPtr Map_0(global::System.IntPtr instance, QOpenGLBuffer.Access access);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer8mapRangeEii6QFlagsINS_15RangeAccessFlagEE")]
            internal static extern global::System.IntPtr MapRange_0(global::System.IntPtr instance, int offset, int count, QOpenGLBuffer.RangeAccessFlag access);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer5unmapEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Unmap_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLBuffer12usagePatternEv")]
            internal static extern QOpenGLBuffer.UsagePattern usagePattern_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLBuffer15setUsagePatternENS_12UsagePatternE")]
            internal static extern void SetUsagePattern_0(global::System.IntPtr instance, QOpenGLBuffer.UsagePattern value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLBuffer4typeEv")]
            internal static extern QOpenGLBuffer.Type type_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLBuffer9isCreatedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCreated_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLBuffer4sizeEv")]
            internal static extern int Size_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum defines the type of OpenGL buffer object to create with
        /// QOpenGLBuffer.</para>
        /// </summary>
        public enum Type : uint
        {
            /// <summary>Vertex buffer object for use when specifying vertex arrays.</summary>
            VertexBuffer = 0x8892,
            /// <summary>Index buffer object for use with glDrawElements().</summary>
            IndexBuffer = 0x8893,
            /// <summary>Pixel pack buffer object for reading pixel data from the OpenGL server (for example, with glReadPixels()). Not supported under OpenGL/ES.</summary>
            PixelPackBuffer = 0x88eb,
            /// <summary>Pixel unpack buffer object for writing pixel data to the OpenGL server (for example, with glTexImage2D()). Not supported under OpenGL/ES.</summary>
            PixelUnpackBuffer = 0x88ec
        }

        /// <summary>
        /// <para>This enum defines the usage pattern of a QOpenGLBuffer
        /// object.</para>
        /// </summary>
        public enum UsagePattern : uint
        {
            /// <summary>The data will be set once and used a few times for drawing operations. Under OpenGL/ES 1.1 this is identical to StaticDraw.</summary>
            StreamDraw = 0x88e0,
            /// <summary>The data will be set once and used a few times for reading data back from the OpenGL server. Not supported under OpenGL/ES.</summary>
            StreamRead = 0x88e1,
            /// <summary>The data will be set once and used a few times for reading data back from the OpenGL server for use in further drawing operations. Not supported under OpenGL/ES.</summary>
            StreamCopy = 0x88e2,
            /// <summary>The data will be set once and used many times for drawing operations.</summary>
            StaticDraw = 0x88e4,
            /// <summary>The data will be set once and used many times for reading data back from the OpenGL server. Not supported under OpenGL/ES.</summary>
            StaticRead = 0x88e5,
            /// <summary>The data will be set once and used many times for reading data back from the OpenGL server for use in further drawing operations. Not supported under OpenGL/ES.</summary>
            StaticCopy = 0x88e6,
            /// <summary>The data will be modified repeatedly and used many times for drawing operations.</summary>
            DynamicDraw = 0x88e8,
            /// <summary>The data will be modified repeatedly and used many times for reading data back from the OpenGL server. Not supported under OpenGL/ES.</summary>
            DynamicRead = 0x88e9,
            /// <summary>The data will be modified repeatedly and used many times for reading data back from the OpenGL server for use in further drawing operations. Not supported under OpenGL/ES.</summary>
            DynamicCopy = 0x88ea
        }

        /// <summary>
        /// <para>This enum defines the access mode for
        /// QOpenGLBuffer::map().</para>
        /// </summary>
        public enum Access : uint
        {
            /// <summary>The buffer will be mapped for reading only.</summary>
            ReadOnly = 0x88b8,
            /// <summary>The buffer will be mapped for writing only.</summary>
            WriteOnly = 0x88b9,
            /// <summary>The buffer will be mapped for reading and writing.</summary>
            ReadWrite = 0x88ba
        }

        /// <summary>
        /// <para>This enum defines the access mode bits for
        /// QOpenGLBuffer::mapRange().</para>
        /// </summary>
        [Flags]
        public enum RangeAccessFlag : uint
        {
            /// <summary>The buffer will be mapped for reading.</summary>
            RangeRead = 0x1,
            /// <summary>The buffer will be mapped for writing.</summary>
            RangeWrite = 0x2,
            /// <summary>Discard the previous contents of the specified range.</summary>
            RangeInvalidate = 0x4,
            /// <summary>Discard the previous contents of the entire buffer.</summary>
            RangeInvalidateBuffer = 0x8,
            /// <summary>Indicates that modifications are to be flushed explicitly via glFlushMappedBufferRange.</summary>
            RangeFlushExplicit = 0x10,
            /// <summary>Indicates that pending operations should not be synchronized before returning from mapRange().</summary>
            RangeUnsynchronized = 0x20
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLBuffer __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLBuffer((QOpenGLBuffer.Internal*) native);
        }

        public static QOpenGLBuffer __CreateInstance(QOpenGLBuffer.Internal native)
        {
            return new QOpenGLBuffer(native);
        }

        private static QOpenGLBuffer.Internal* __CopyValue(QOpenGLBuffer.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QOpenGLBuffer.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QOpenGLBuffer.Internal*) ret;
        }

        private QOpenGLBuffer(QOpenGLBuffer.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLBuffer(QOpenGLBuffer.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a new buffer object of type
        /// QOpenGLBuffer::VertexBuffer.</para>
        /// <para>Note: this constructor just creates the QOpenGLBuffer instance.
        /// The actual buffer object in the OpenGL server is not created until create()
        /// is called.</para>
        /// <para>See also create().</para>
        /// </summary>
        public QOpenGLBuffer()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a new buffer object of type.</para>
        /// <para>Note: this constructor just creates the QOpenGLBuffer instance.
        /// The actual buffer object in the OpenGL server is not created until create()
        /// is called.</para>
        /// <para>See also create().</para>
        /// </summary>
        public QOpenGLBuffer(QOpenGLBuffer.Type type)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = type;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a shallow copy of other.</para>
        /// <para>Note: QOpenGLBuffer does not implement copy-on-write semantics,
        /// so other will be affected whenever the copy is modified.</para>
        /// </summary>
        public QOpenGLBuffer(QOpenGLBuffer other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Creates the buffer object in the OpenGL server. Returns true if
        /// the object was created; false otherwise.</para>
        /// <para>This function must be called with a current QOpenGLContext. The
        /// buffer will be bound to and can only be used in that context (or any other
        /// context that is shared with it).</para>
        /// <para>This function will return false if the OpenGL implementation does
        /// not support buffers, or there is no current QOpenGLContext.</para>
        /// <para>See also isCreated(), allocate(), write(), and destroy().</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Destroys this buffer object, including the storage being used in
        /// the OpenGL server. All references to the buffer will become invalid.</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Binds the buffer associated with this object to the current
        /// OpenGL context. Returns false if binding was not possible, usually because
        /// type() is not supported on this OpenGL implementation.</para>
        /// <para>The buffer must be bound to the same QOpenGLContext current when
        /// create() was called, or to another QOpenGLContext that is sharing with it.
        /// Otherwise, false will be returned from this function.</para>
        /// <para>See also release() and create().</para>
        /// </summary>
        public bool Bind()
        {
            var __ret = Internal.Bind_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Releases the buffer associated with this object from the current
        /// OpenGL context.</para>
        /// <para>This function must be called with the same QOpenGLContext current
        /// as when bind() was called on the buffer.</para>
        /// <para>See also bind().</para>
        /// </summary>
        public void Release()
        {
            Internal.Release_0(__Instance);
        }

        /// <summary>
        /// <para>Reads the count bytes in this buffer starting at offset into
        /// data. Returns true on success; false if reading from the buffer is not
        /// supported. Buffer reading is not supported under OpenGL/ES.</para>
        /// <para>It is assumed that this buffer has been bound to the current
        /// context.</para>
        /// <para>See also write() and bind().</para>
        /// </summary>
        public bool Read(int offset, global::System.IntPtr data, int count)
        {
            var arg1 = data;
            var __ret = Internal.Read_0(__Instance, offset, arg1, count);
            return __ret;
        }

        /// <summary>
        /// <para>Replaces the count bytes of this buffer starting at offset with
        /// the contents of data. Any other bytes in the buffer will be left
        /// unmodified.</para>
        /// <para>It is assumed that create() has been called on this buffer and
        /// that it has been bound to the current context.</para>
        /// <para>See also create(), read(), and allocate().</para>
        /// </summary>
        public void Write(int offset, global::System.IntPtr data, int count)
        {
            var arg1 = data;
            Internal.Write_0(__Instance, offset, arg1, count);
        }

        /// <summary>
        /// <para>Allocates count bytes of space to the buffer, initialized to the
        /// contents of data. Any previous contents will be removed.</para>
        /// <para>It is assumed that create() has been called on this buffer and
        /// that it has been bound to the current context.</para>
        /// <para>See also create(), read(), and write().</para>
        /// </summary>
        public void Allocate(global::System.IntPtr data, int count)
        {
            var arg0 = data;
            Internal.Allocate_0(__Instance, arg0, count);
        }

        /// <summary>
        /// <para>Maps the contents of this buffer into the application's memory
        /// space and returns a pointer to it. Returns null if memory mapping is not
        /// possible. The access parameter indicates the type of access to be
        /// performed.</para>
        /// <para>It is assumed that create() has been called on this buffer and
        /// that it has been bound to the current context.</para>
        /// <para>Note: This function is only supported under OpenGL ES 2.0 or
        /// earlier if the GL_OES_mapbuffer extension is present.Note: On OpenGL ES 3.0
        /// and newer, or, in case if desktop OpenGL, if GL_ARB_map_buffer_range is
        /// supported, this function uses glMapBufferRange instead of glMapBuffer.See
        /// also unmap(), create(), bind(), and mapRange().</para>
        /// </summary>
        public global::System.IntPtr Map(QOpenGLBuffer.Access access)
        {
            var arg0 = access;
            var __ret = Internal.Map_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        /// <summary>
        /// <para>Maps the range specified by offset and count of the contents of
        /// this buffer into the application's memory space and returns a pointer to
        /// it. Returns null if memory mapping is not possible. The access parameter
        /// specifies a combination of access flags.</para>
        /// <para>It is assumed that create() has been called on this buffer and
        /// that it has been bound to the current context.</para>
        /// <para>Note: This function is not available on OpenGL ES 2.0 and
        /// earlier.See also unmap(), create(), and bind().</para>
        /// </summary>
        public global::System.IntPtr MapRange(int offset, int count, QOpenGLBuffer.RangeAccessFlag access)
        {
            var arg2 = access;
            var __ret = Internal.MapRange_0(__Instance, offset, count, arg2);
            if (__ret == global::System.IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        /// <summary>
        /// <para>Unmaps the buffer after it was mapped into the application's
        /// memory space with a previous call to map(). Returns true if the unmap
        /// succeeded; false otherwise.</para>
        /// <para>It is assumed that this buffer has been bound to the current
        /// context, and that it was previously mapped with map().</para>
        /// <para>Note: This function is only supported under OpenGL ES 2.0 and
        /// earlier if the GL_OES_mapbuffer extension is present.See also map().</para>
        /// </summary>
        public bool Unmap()
        {
            var __ret = Internal.Unmap_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Releases the buffer associated with type in the current
        /// QOpenGLContext.</para>
        /// <para>This function is a direct call to glBindBuffer(type, 0) for use
        /// when the caller does not know which QOpenGLBuffer has been bound to the
        /// context but wants to make sure that it is released.</para>
        /// <para>QOpenGLBuffer::release(QOpenGLBuffer::VertexBuffer);</para>
        /// </summary>
        public static void Release(QOpenGLBuffer.Type type)
        {
            var arg0 = type;
            Internal.Release_1(arg0);
        }

        /// <summary>
        /// <para>Returns the usage pattern for this buffer object. The default
        /// value is StaticDraw.</para>
        /// <para>See also setUsagePattern().</para>
        /// <para></para>
        /// <para>Sets the usage pattern for this buffer object to value. This
        /// function must be called before allocate() or write().</para>
        /// <para>See also usagePattern(), allocate(), and write().</para>
        /// </summary>
        public QOpenGLBuffer.UsagePattern usagePattern
        {
            get
            {
                var __ret = Internal.usagePattern_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetUsagePattern_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the type of buffer represented by this object.</para>
        /// </summary>
        public QOpenGLBuffer.Type type
        {
            get
            {
                var __ret = Internal.type_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this buffer has been created; false
        /// otherwise.</para>
        /// <para>See also create() and destroy().</para>
        /// </summary>
        public bool IsCreated
        {
            get
            {
                var __ret = Internal.IsCreated_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the size of the data in this buffer, for reading
        /// operations. Returns -1 if fetching the buffer size is not supported, or the
        /// buffer has not been created.</para>
        /// <para>It is assumed that this buffer has been bound to the current
        /// context.</para>
        /// <para>See also isCreated() and bind().</para>
        /// </summary>
        public int Size
        {
            get
            {
                var __ret = Internal.Size_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLDebugMessage class wraps an OpenGL debug
    /// message.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Debug messages are usually created by the OpenGL server and then
    /// read by OpenGL clients (either from the OpenGL internal debug log, or
    /// logged in real-time). A debug message has a textual representation, a
    /// vendor-specific numeric id, a source, a type and a severity.</para>
    /// <para>It's also possible for applications or third-party libraries and
    /// toolkits to create and insert messages in the debug log. In order to do so,
    /// you can use the createApplicationMessage() or the createThirdPartyMessage()
    /// static functions.</para>
    /// <para></para>
    /// <para>See also QOpenGLDebugLogger.</para>
    /// </remarks>
    public unsafe partial class QOpenGLDebugMessage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QOpenGLDebugMessageC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QOpenGLDebugMessageC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr debugMessage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QOpenGLDebugMessageD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QOpenGLDebugMessageeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr debugMessage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QOpenGLDebugMessage6sourceEv")]
            internal static extern QOpenGLDebugMessage.Source source_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QOpenGLDebugMessage4typeEv")]
            internal static extern QOpenGLDebugMessage.Type type_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QOpenGLDebugMessage8severityEv")]
            internal static extern QOpenGLDebugMessage.Severity severity_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QOpenGLDebugMessage7messageEv")]
            internal static extern void Message_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>The Source enum defines the source of the debug message.</para>
        /// </summary>
        public enum Source : uint
        {
            /// <summary>The source of the message is invalid; this is the source of a default-constructed QOpenGLDebugMessage object.</summary>
            InvalidSource = 0x0,
            /// <summary>The message was generated in response to OpenGL API calls.</summary>
            APISource = 0x1,
            /// <summary>The message was generated by the window system.</summary>
            WindowSystemSource = 0x2,
            /// <summary>The message was generated by the shader compiler.</summary>
            ShaderCompilerSource = 0x4,
            /// <summary>The message was generated by a third party, for instance an OpenGL framework a or debugging toolkit.</summary>
            ThirdPartySource = 0x8,
            /// <summary>The message was generated by the application itself.</summary>
            ApplicationSource = 0x10,
            /// <summary>The message was generated by a source not included in this enumeration.</summary>
            OtherSource = 0x20,
            LastSource = 32,
            /// <summary>This value corresponds to a mask of all possible message sources.</summary>
            AnySource = 0xffffffff
        }

        /// <summary>
        /// <para>The Type enum defines the type of the debug message.</para>
        /// </summary>
        public enum Type : uint
        {
            /// <summary>The type of the message is invalid; this is the type of a default-constructed QOpenGLDebugMessage object.</summary>
            InvalidType = 0x0,
            /// <summary>The message represents an error.</summary>
            ErrorType = 0x1,
            /// <summary>The message represents an usage of deprecated behavior.</summary>
            DeprecatedBehaviorType = 0x2,
            /// <summary>The message represents an usage of undefined behavior.</summary>
            UndefinedBehaviorType = 0x4,
            /// <summary>The message represents an usage of vendor-specific behavior, that might pose portability concerns.</summary>
            PortabilityType = 0x8,
            /// <summary>The message represents a performance issue.</summary>
            PerformanceType = 0x10,
            /// <summary>The message represents a type not included in this enumeration.</summary>
            OtherType = 0x20,
            /// <summary>The message represents a marker in the debug log.</summary>
            MarkerType = 0x40,
            /// <summary>The message represents a debug group push operation.</summary>
            GroupPushType = 0x80,
            /// <summary>The message represents a debug group pop operation.</summary>
            GroupPopType = 0x100,
            LastType = 256,
            /// <summary>This value corresponds to a mask of all possible message types.</summary>
            AnyType = 0xffffffff
        }

        /// <summary>
        /// <para>The Severity enum defines the severity of the debug
        /// message.</para>
        /// </summary>
        public enum Severity : uint
        {
            /// <summary>The severity of the message is invalid; this is the severity of a default-constructed QOpenGLDebugMessage object.</summary>
            InvalidSeverity = 0x0,
            /// <summary>The message has a high severity.</summary>
            HighSeverity = 0x1,
            /// <summary>The message has a medium severity.</summary>
            MediumSeverity = 0x2,
            /// <summary>The message has a low severity.</summary>
            LowSeverity = 0x4,
            /// <summary>The message is a notification.</summary>
            NotificationSeverity = 0x8,
            LastSeverity = 8,
            /// <summary>This value corresponds to a mask of all possible message severities.</summary>
            AnySeverity = 0xffffffff
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLDebugMessage __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLDebugMessage((QOpenGLDebugMessage.Internal*) native);
        }

        public static QOpenGLDebugMessage __CreateInstance(QOpenGLDebugMessage.Internal native)
        {
            return new QOpenGLDebugMessage(native);
        }

        private static QOpenGLDebugMessage.Internal* __CopyValue(QOpenGLDebugMessage.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QOpenGLDebugMessage.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLDebugMessage.Internal*) ret;
        }

        private QOpenGLDebugMessage(QOpenGLDebugMessage.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLDebugMessage(QOpenGLDebugMessage.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a debug message with an empty message string, id set
        /// to 0, source set to InvalidSource, type set to InvalidType, and severity
        /// set to InvalidSeverity.</para>
        /// <para>Note: This constructor should not be used to create a debug
        /// message; instead, use the createApplicationMessage() or the
        /// createThirdPartyMessage() static functions.See also
        /// createApplicationMessage() and createThirdPartyMessage().</para>
        /// </summary>
        public QOpenGLDebugMessage()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a debug message as a copy of debugMessage.</para>
        /// <para>See also operator=().</para>
        /// </summary>
        public QOpenGLDebugMessage(QOpenGLDebugMessage debugMessage)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(debugMessage, null) ? global::System.IntPtr.Zero : debugMessage.__Instance;
            Internal.cctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public static bool operator !=(QOpenGLDebugMessage __op, QOpenGLDebugMessage debugMessage)
        {
            return !(__op == debugMessage);
        }

        /// <summary>
        /// <para>Returns true if this debug message is equal to debugMessage, or
        /// false otherwise. Two debugging messages are equal if they have the same
        /// textual message, the same id, the same source, the same type and the same
        /// severity.</para>
        /// <para>See also operator!=().</para>
        /// </summary>
        public static bool operator ==(QOpenGLDebugMessage __op, QOpenGLDebugMessage debugMessage)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool debugMessageNull = ReferenceEquals(debugMessage, null);
            if (__opNull || debugMessageNull)
                return __opNull && debugMessageNull;
            var arg0 = __op.__Instance;
            var arg1 = debugMessage.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QOpenGLDebugMessage;
        }

        /// <summary>
        /// <para>Returns the source of the debug message.</para>
        /// </summary>
        public QOpenGLDebugMessage.Source source
        {
            get
            {
                var __ret = Internal.source_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the type of the debug message.</para>
        /// </summary>
        public QOpenGLDebugMessage.Type type
        {
            get
            {
                var __ret = Internal.type_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the severity of the debug message.</para>
        /// </summary>
        public QOpenGLDebugMessage.Severity severity
        {
            get
            {
                var __ret = Internal.severity_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the textual message contained by this debug
        /// message.</para>
        /// </summary>
        public string Message
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Message_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLDebugLogger enables logging of OpenGL debugging
    /// messages.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para></para>
    /// <para>Introduction</para>
    /// <para>OpenGL programming can be very error prone. Most of the time, a
    /// single failing call to OpenGL can cause an entire portion of an application
    /// to stop working, with nothing being drawn on the screen.</para>
    /// <para>The only way to be sure that no errors are being returned from
    /// the OpenGL implementation is checking with glGetError after each and every
    /// API call. Moreover, OpenGL errors stack up, therefore glGetError should
    /// always be used in a loop like this:</para>
    /// <para>GLenum error = GL_NO_ERROR;</para>
    /// <para>do {</para>
    /// <para>    error = glGetError();</para>
    /// <para>    if (error != GL_NO_ERROR)</para>
    /// <para>        // handle the error</para>
    /// <para>} while (error != GL_NO_ERROR);</para>
    /// <para>There are also many other information we are interested in (as
    /// application developers), for instance performance issues, or warnings about
    /// using deprecated APIs. Those kind of messages are not reported through the
    /// ordinary OpenGL error reporting mechanisms.</para>
    /// <para>QOpenGLDebugLogger aims at addressing these issues by providing
    /// access to the OpenGL debug log. If your OpenGL implementation supports it
    /// (by exposing the GL_KHR_debug extension), messages from the OpenGL server
    /// will be either logged in an internal OpenGL log, or passed in
    /// &quot;real-time&quot; to listeners as they're generated from OpenGL.</para>
    /// <para>QOpenGLDebugLogger supports both these modes of operation. Refer
    /// to the following sections to find out the differences between them.</para>
    /// <para></para>
    /// <para>Creating an OpenGL Debug Context</para>
    /// <para>For efficiency reasons, OpenGL implementations are allowed not to
    /// create any debug output at all, unless the OpenGL context is a debug
    /// context. In order to create a debug context from Qt, you must set the
    /// QSurfaceFormat::DebugContext format option on the QSurfaceFormat used to
    /// create the QOpenGLContext object:</para>
    /// <para>QSurfaceFormat format;</para>
    /// <para>// asks for a OpenGL 3.2 debug context using the Core
    /// profile</para>
    /// <para>format.setMajorVersion(3);</para>
    /// <para>format.setMinorVersion(2);</para>
    /// <para>format.setProfile(QSurfaceFormat::CoreProfile);</para>
    /// <para>format.setOption(QSurfaceFormat::DebugContext);</para>
    /// <para></para>
    /// <para>QOpenGLContext *context = new QOpenGLContext;</para>
    /// <para>context-&gt;setFormat(format);</para>
    /// <para>context-&gt;create();</para>
    /// <para>Note that requesting a 3.2 OpenGL Core Profile is just for the
    /// example's purposes; this class is not tied to any specific OpenGL or OpenGL
    /// ES version, as it relies on the availability of the GL_KHR_debug extension
    /// (see below).</para>
    /// <para></para>
    /// <para>Creating and Initializing a QOpenGLDebugLogger</para>
    /// <para>QOpenGLDebugLogger is a simple QObject-derived class. Just like
    /// all QObject subclasses, you create an instance (and optionally specify a
    /// parent object), and like the other OpenGL functions in Qt you must
    /// initialize it before usage by calling initialize() whilst there is a
    /// current OpenGL context:</para>
    /// <para>QOpenGLContext *ctx = QOpenGLContext::currentContext();</para>
    /// <para>QOpenGLDebugLogger *logger = new QOpenGLDebugLogger(this);</para>
    /// <para></para>
    /// <para>logger-&gt;initialize(); // initializes in the current context,
    /// i.e. ctx</para>
    /// <para>Note that the GL_KHR_debug extension must be available in the
    /// context in order to access the messages logged by OpenGL. You can check the
    /// presence of this extension by calling:</para>
    ///
    /// <para>ctx-&gt;hasExtension(QByteArrayLiteral(&quot;GL_KHR_debug&quot;))</pa
    /// ra>
    /// <para>where ctx is a valid QOpenGLContext. If the extension is not
    /// available, initialize() will return false.</para>
    /// <para></para>
    /// <para>Reading the Internal OpenGL Debug Log</para>
    /// <para>OpenGL implementations keep an internal log of debug messages.
    /// Messages stored in this log can be retrieved by using the loggedMessages()
    /// function:</para>
    /// <para>QList&lt;QOpenGLDebugMessage&gt; messages =
    /// logger-&gt;loggedMessages();</para>
    /// <para>foreach (const QOpenGLDebugMessage &amp;message, messages)</para>
    /// <para>    qDebug() &lt;&lt; message;</para>
    /// <para>The internal log has a limited size; when it fills up, older
    /// messages will get discarded to make room for the new incoming messages.
    /// When you call loggedMessages(), the internal log will be emptied as
    /// well.</para>
    /// <para>If you want to be sure not to lose any debug message, you must
    /// use real-time logging instead of calling this function. However, debug
    /// messages might still be generated in the timespan between context creation
    /// and activation of real-time logging (or, in general, when the real-time
    /// logging is disabled).</para>
    /// <para></para>
    /// <para>Real-time logging of messages</para>
    /// <para>It is also possible to receive a stream of debug messages from
    /// the OpenGL server as they are generated by the implementation. In order to
    /// do so, you need to connect a suitable slot to the messageLogged() signal,
    /// and start logging by calling startLogging():</para>
    /// <para>connect(logger, &amp;QOpenGLDebugLogger::messageLogged, receiver,
    /// &amp;LogHandler::handleLoggedMessage);</para>
    /// <para>logger-&gt;startLogging();</para>
    /// <para>Similarly, logging can be disabled at any time by calling the
    /// stopLogging() function.</para>
    /// <para>Real-time logging can be either asynchronous or synchronous,
    /// depending on the parameter passed to startLogging(). When logging in
    /// asynchronous mode (the default, as it has a very small overhead), the
    /// OpenGL implementation can generate messages at any time, and/or in an order
    /// which is different from the order of the OpenGL commands which caused those
    /// messages to be logged. The messages could also be generated from a thread
    /// that it's different from the thread the context is currently bound to. This
    /// is because OpenGL implementations are usually highly threaded and
    /// asynchronous, and therefore no warranties are made about the relative order
    /// and the timings of the debug messages.</para>
    /// <para>On the other hand, logging in synchronous mode has a high
    /// overhead, but the OpenGL implementation guarantees that all the messages
    /// caused by a certain command are received in order, before the command
    /// returns, and from the same thread the OpenGL context is bound to.</para>
    /// <para>This means that when logging in synchronous mode you will be able
    /// to run your OpenGL application in a debugger, put a breakpoint on a slot
    /// connected to the messageLogged() signal, and see in the backtrace the exact
    /// call that caused the logged message. This can be extremely useful to debug
    /// an OpenGL problem. Note that if OpenGL rendering is happening in another
    /// thread, you must force the signal/slot connection type to
    /// Qt::DirectConnection in order to be able to see the actual
    /// backtrace.</para>
    /// <para>Refer to the LoggingMode enum documentation for more information
    /// about logging modes.</para>
    /// <para>Note: When real-time logging is enabled, debug messages will not
    /// be inserted in the internal OpenGL debug log any more; messages already
    /// present in the internal log will not be deleted, nor they will be emitted
    /// through the messageLogged() signal. Since some messages might be generated
    /// before real-time logging is started (and therefore be kept in the internal
    /// OpenGL log), it is important to always check if it contains any message
    /// after calling startLogging().</para>
    /// <para>Inserting Messages in the Debug Log</para>
    /// <para>It is possible for applications and libraries to insert custom
    /// messages in the debug log, for instance for marking a group of related
    /// OpenGL commands and therefore being then able to identify eventual messages
    /// coming from them.</para>
    /// <para>In order to do so, you can create a QOpenGLDebugMessage object by
    /// calling createApplicationMessage() or createThirdPartyMessage(), and then
    /// inserting it into the log by calling logMessage():</para>
    /// <para>QOpenGLDebugMessage message =</para>
    /// <para>
    /// QOpenGLDebugMessage::createApplicationMessage(QStringLiteral(&quot;Custom
    /// message&quot;));</para>
    /// <para></para>
    /// <para>logger-&gt;logMessage(message);</para>
    /// <para>Note that OpenGL implementations have a vendor-specific limit to
    /// the length of the messages that can be inserted in the debug log. You can
    /// retrieve this length by calling the maximumMessageLength() method; messages
    /// longer than the limit will automatically get truncated.</para>
    /// <para></para>
    /// <para>Controlling the Debug Output</para>
    /// <para>QOpenGLDebugMessage is also able to apply filters to the debug
    /// messages, and therefore limit the amount of messages logged. You can enable
    /// or disable logging of messages by calling enableMessages() and
    /// disableMessages() respectively. By default, all messages are logged.</para>
    /// <para>It is possible to enable or disable messages by selecting them
    /// by:</para>
    /// <para></para>
    /// <para>source, type and severity (and including all ids in the
    /// selection);</para>
    /// <para>id, source and type (and including all severities in the
    /// selection).</para>
    /// <para></para>
    /// <para>Note that the &quot;enabled&quot; status for a given message is a
    /// property of the (id, source, type, severity) tuple; the message attributes
    /// do not form a hierarchy of any kind. You should be careful about the order
    /// of the calls to enableMessages() and disableMessages(), as it will change
    /// which messages will are enabled / disabled.</para>
    /// <para>It's not possible to filter by the message text itself;
    /// applications have to do that on their own (in slots connected to the
    /// messageLogged() signal, or after fetching the messages in the internal
    /// debug log through loggedMessages()).</para>
    /// <para>In order to simplify the management of the enabled / disabled
    /// statuses, QOpenGLDebugMessage also supports the concept of debug groups. A
    /// debug group contains the group of enabled / disabled configurations of
    /// debug messages. Moreover, debug groups are organized in a stack: it is
    /// possible to push and pop groups by calling pushGroup() and popGroup()
    /// respectively. (When an OpenGL context is created, there is already a group
    /// in the stack).</para>
    /// <para>The enableMessages() and disableMessages() functions will modify
    /// the configuration in the current debug group, that is, the one at the top
    /// of the debug groups stack.</para>
    /// <para>When a new group is pushed onto the debug groups stack, it will
    /// inherit the configuration of the group that was previously on the top of
    /// the stack. Vice versa, popping a debug group will restore the configuration
    /// of the debug group that becomes the new top.</para>
    /// <para>Pushing (respectively popping) debug groups will also
    /// automatically generate a debug message of type
    /// QOpenGLDebugMessage::GroupPushType (respectively GroupPopType).</para>
    /// <para></para>
    /// <para>See also QOpenGLDebugMessage.</para>
    /// </remarks>
    public unsafe partial class QOpenGLDebugLogger : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLoggerC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLoggerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger10initializeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Initialize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger8popGroupEv")]
            internal static extern void PopGroup_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger14enableMessagesE6QFlagsIN19QOpenGLDebugMessage6SourceEES0_INS1_4TypeEES0_INS1_8SeverityEE")]
            internal static extern void EnableMessages_0(global::System.IntPtr instance, QOpenGLDebugMessage.Source sources, QOpenGLDebugMessage.Type types, QOpenGLDebugMessage.Severity severities);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger15disableMessagesE6QFlagsIN19QOpenGLDebugMessage6SourceEES0_INS1_4TypeEES0_INS1_8SeverityEE")]
            internal static extern void DisableMessages_0(global::System.IntPtr instance, QOpenGLDebugMessage.Source sources, QOpenGLDebugMessage.Type types, QOpenGLDebugMessage.Severity severities);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger10logMessageERK19QOpenGLDebugMessage")]
            internal static extern void LogMessage_0(global::System.IntPtr instance, global::System.IntPtr debugMessage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger12startLoggingENS_11LoggingModeE")]
            internal static extern void StartLogging_0(global::System.IntPtr instance, QOpenGLDebugLogger.LoggingMode loggingMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLDebugLogger11stopLoggingEv")]
            internal static extern void StopLogging_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLDebugLogger9isLoggingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsLogging_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLDebugLogger11loggingModeEv")]
            internal static extern QOpenGLDebugLogger.LoggingMode loggingMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLDebugLogger14loggedMessagesEv")]
            internal static extern QList.Internal LoggedMessages_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>The LoggingMode enum defines the logging mode of the logger
        /// object.</para>
        /// </summary>
        public enum LoggingMode : uint
        {
            /// <summary>Messages from the OpenGL server are logged asynchronously. This means that messages can be logged some time after the corresponding OpenGL actions that caused them, and even be received in an out-of-order fashion, depending on the OpenGL implementation. This mode has a very low performance penalty, as OpenGL implementations are heavily threaded and asynchronous by nature.</summary>
            AsynchronousLogging = 0,
            /// <summary>Messages from the OpenGL server are logged synchronously and sequentially. This has a severe performance hit, as OpenGL implementations are very asynchronous by nature; but it's very useful to debug OpenGL problems, as OpenGL guarantees that the messages generated by a OpenGL command will be logged before the corresponding command execution has returned. Therefore, you can install a breakpoint on the messageLogged() signal and see in the backtrace which OpenGL command caused it; the only caveat is that if you are using OpenGL from multiple threads you may need to force direct connection when connecting to the messageLogged() signal.</summary>
            SynchronousLogging = 1
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted when a debug message (wrapped by the debugMessage argument) is logged from the OpenGL server.</para>
        /// <para>Depending on the OpenGL implementation, this signal can be emitted from other threads than the one(s) the receiver(s) lives in, and even different from the thread the QOpenGLContext in which this object has been initialized lives in. Moreover, the signal could be emitted from multiple threads at the same time. This is normally not a problem, as Qt will utilize a queued connection for cross-thread signal emissions, but if you force the connection type to Direct then you must be aware of the potential races in the slots connected to this signal.</para>
        /// <para>If logging have been started in SynchronousLogging mode, OpenGL guarantees that this signal will be emitted from the same thread the QOpenGLContext has been bound to, and no concurrent invocations will ever happen.</para>
        /// <para>Note: Logging must have been started, or this signal will not be emitted.See also startLogging().</para>
        /// </summary>
        public event Action<QOpenGLDebugMessage> MessageLogged
        {
        	add
        	{
                ConnectDynamicSlot(this, "messageLogged(QOpenGLDebugMessage)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "messageLogged(QOpenGLDebugMessage)", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLDebugLogger __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLDebugLogger((QOpenGLDebugLogger.Internal*) native);
        }

        public static QOpenGLDebugLogger __CreateInstance(QOpenGLDebugLogger.Internal native)
        {
            return new QOpenGLDebugLogger(native);
        }

        private static QOpenGLDebugLogger.Internal* __CopyValue(QOpenGLDebugLogger.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLDebugLogger.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLDebugLogger.Internal*) ret;
        }

        private QOpenGLDebugLogger(QOpenGLDebugLogger.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLDebugLogger(QOpenGLDebugLogger.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Initializes the object in the current OpenGL context. The context
        /// must support the GL_KHR_debug extension for the initialization to succeed.
        /// The object must be initialized before any logging can happen.</para>
        /// <para>It is safe to call this function multiple times from the same
        /// context.</para>
        /// <para>This function can also be used to change the context of a
        /// previously initialized object; note that in this case the object must not
        /// be logging when you call this function.</para>
        /// <para>Returns true if the logger is successfully initialized; false
        /// otherwise.</para>
        /// <para>See also QOpenGLContext.</para>
        /// </summary>
        public bool Initialize()
        {
            var __ret = Internal.Initialize_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Pops the topmost debug group from the debug groups stack. If the
        /// group is successfully popped, OpenGL will automatically log a message with
        /// message, id and source matching those of the popped group, type
        /// QOpenGLDebugMessage::GroupPopType and severity
        /// QOpenGLDebugMessage::NotificationSeverity.</para>
        /// <para>Popping a debug group will restore the message filtering settings
        /// of the group that becomes the top of the debug groups stack.</para>
        /// <para>Note: The object must be initialized before managing debug
        /// groups.See also pushGroup().</para>
        /// </summary>
        public void PopGroup()
        {
            Internal.PopGroup_0(__Instance);
        }

        /// <summary>
        /// <para>Enables the logging of messages from the given sources, of the
        /// given types and with the given severities and any message id.</para>
        /// <para>The logging will be enabled in the current control group.</para>
        /// <para>See also disableMessages(), pushGroup(), and popGroup().</para>
        /// </summary>
        public void EnableMessages(QOpenGLDebugMessage.Source sources = QOpenGLDebugMessage.Source.AnySource, QOpenGLDebugMessage.Type types = QOpenGLDebugMessage.Type.AnyType, QOpenGLDebugMessage.Severity severities = QOpenGLDebugMessage.Severity.AnySeverity)
        {
            var arg0 = sources;
            var arg1 = types;
            var arg2 = severities;
            Internal.EnableMessages_0(__Instance, arg0, arg1, arg2);
        }

        /// <summary>
        /// <para>Disables the logging of messages with the given sources, of the
        /// given types and with the given severities and any message id.</para>
        /// <para>The logging will be disabled in the current control group.</para>
        /// <para>See also enableMessages(), pushGroup(), and popGroup().</para>
        /// </summary>
        public void DisableMessages(QOpenGLDebugMessage.Source sources = QOpenGLDebugMessage.Source.AnySource, QOpenGLDebugMessage.Type types = QOpenGLDebugMessage.Type.AnyType, QOpenGLDebugMessage.Severity severities = QOpenGLDebugMessage.Severity.AnySeverity)
        {
            var arg0 = sources;
            var arg1 = types;
            var arg2 = severities;
            Internal.DisableMessages_0(__Instance, arg0, arg1, arg2);
        }

        /// <summary>
        /// <para>Inserts the message debugMessage into the OpenGL debug log. This
        /// provides a way for applications or libraries to insert custom messages that
        /// can ease the debugging of OpenGL applications.</para>
        /// <para>Note: debugMessage must have
        /// QOpenGLDebugMessage::ApplicationSource or
        /// QOpenGLDebugMessage::ThirdPartySource as its source, and a valid type and
        /// severity, otherwise it will not be inserted into the log.Note: The object
        /// must be initialized before logging can happen.See also initialize().</para>
        /// </summary>
        public void LogMessage(QOpenGLDebugMessage debugMessage)
        {
            var arg0 = ReferenceEquals(debugMessage, null) ? global::System.IntPtr.Zero : debugMessage.__Instance;
            Internal.LogMessage_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Starts logging messages coming from the OpenGL server. When a new
        /// message is received, the signal messageLogged() is emitted, carrying the
        /// logged message as argument.</para>
        /// <para>loggingMode specifies whether the logging must be asynchronous
        /// (the default) or synchronous.</para>
        /// <para>QOpenGLDebugLogger will record the values of GL_DEBUG_OUTPUT and
        /// GL_DEBUG_OUTPUT_SYNCHRONOUS when logging is started, and set them back when
        /// logging is stopped. Moreover, any user-defined OpenGL debug callback
        /// installed when this function is invoked will be restored when logging is
        /// stopped; QOpenGLDebugLogger will ensure that the pre-existing callback will
        /// still be invoked when logging.</para>
        /// <para>Note: It's not possible to change the logging mode without
        /// stopping and starting logging again. This might change in a future version
        /// of Qt.Note: The object must be initialized before logging can happen.See
        /// also stopLogging() and initialize().</para>
        /// </summary>
        public void StartLogging(QOpenGLDebugLogger.LoggingMode loggingMode = QOpenGLDebugLogger.LoggingMode.AsynchronousLogging)
        {
            var arg0 = loggingMode;
            Internal.StartLogging_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Stops logging messages from the OpenGL server.</para>
        /// <para>See also startLogging().</para>
        /// </summary>
        public void StopLogging()
        {
            Internal.StopLogging_0(__Instance);
        }

        /// <summary>
        /// <para>Returns true if this object is currently logging, false
        /// otherwise.</para>
        /// <para>See also startLogging().</para>
        /// </summary>
        public bool IsLogging
        {
            get
            {
                var __ret = Internal.IsLogging_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This property holds the logging mode passed to
        /// startLogging().</para>
        /// <para>Note that logging must have been started or the value of this
        /// property will be meaningless.</para>
        /// </summary>
        public QOpenGLDebugLogger.LoggingMode loggingMode
        {
            get
            {
                var __ret = Internal.loggingMode_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Reads all the available messages in the OpenGL internal debug log
        /// and returns them. Moreover, this function will clear the internal debug
        /// log, so that subsequent invocations will not return messages that were
        /// already returned.</para>
        /// <para>See also startLogging().</para>
        /// </summary>
        public System.Collections.Generic.IList<QOpenGLDebugMessage> LoggedMessages
        {
            get
            {
                var __ret = Internal.LoggedMessages_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QOpenGLDebugMessage>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QOpenGLDebugMessage.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        #region Virtual table interop

        // ~QOpenGLDebugLogger()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLDebugLogger) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLFramebufferObject class encapsulates an OpenGL
    /// framebuffer object.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QOpenGLFramebufferObject class encapsulates an OpenGL
    /// framebuffer object, defined by the GL_EXT_framebuffer_object extension. It
    /// provides a rendering surface that can be painted on with a QPainter with
    /// the help of QOpenGLPaintDevice, or rendered to using native OpenGL calls.
    /// This surface can be bound and used as a regular texture in your own OpenGL
    /// drawing code. By default, the QOpenGLFramebufferObject class generates a 2D
    /// OpenGL texture (using the GL_TEXTURE_2D target), which is used as the
    /// internal rendering target.</para>
    /// <para>It is important to have a current OpenGL context when creating a
    /// QOpenGLFramebufferObject, otherwise initialization will fail.</para>
    /// <para>Create the QOpenGLFrameBufferObject instance with the
    /// CombinedDepthStencil attachment if you want QPainter to render correctly.
    /// Note that you need to create a QOpenGLFramebufferObject with more than one
    /// sample per pixel for primitives to be antialiased when drawing using a
    /// QPainter. To create a multisample framebuffer object you should use one of
    /// the constructors that take a QOpenGLFramebufferObjectFormat parameter, and
    /// set the QOpenGLFramebufferObjectFormat::samples() property to a non-zero
    /// value.</para>
    /// <para>For multisample framebuffer objects a color render buffer is
    /// created, otherwise a texture with the specified texture target is created.
    /// The color render buffer or texture will have the specified internal format,
    /// and will be bound to the GL_COLOR_ATTACHMENT0 attachment in the framebuffer
    /// object.</para>
    /// <para>If you want to use a framebuffer object with multisampling
    /// enabled as a texture, you first need to copy from it to a regular
    /// framebuffer object using QOpenGLContext::blitFramebuffer().</para>
    /// <para>It is possible to draw into a QOpenGLFramebufferObject using
    /// QPainter and QOpenGLPaintDevice in a separate thread.</para>
    /// </remarks>
    public unsafe partial class QOpenGLFramebufferObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            internal QScopedPointer.Internal d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLFramebufferObjectC2EiiRK30QOpenGLFramebufferObjectFormat")]
            internal static extern void ctor_5(global::System.IntPtr instance, int width, int height, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLFramebufferObjectC2ERKS_")]
            internal static extern void cctor_6(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLFramebufferObjectD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLFramebufferObject4bindEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Bind_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLFramebufferObject7toImageEv")]
            internal static extern void ToImage_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLFramebufferObject7toImageEb")]
            internal static extern void ToImage_1(global::System.IntPtr @return, global::System.IntPtr instance, bool flipped);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24QOpenGLFramebufferObject11bindDefaultEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool BindDefault_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLFramebufferObject10attachmentEv")]
            internal static extern QOpenGLFramebufferObject.Attachment attachment_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLFramebufferObject13setAttachmentENS_10AttachmentE")]
            internal static extern void SetAttachment_0(global::System.IntPtr instance, QOpenGLFramebufferObject.Attachment attachment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLFramebufferObject6formatEv")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLFramebufferObject7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLFramebufferObject7isBoundEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsBound_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLFramebufferObject7releaseEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Release_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24QOpenGLFramebufferObject27hasOpenGLFramebufferObjectsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasOpenGLFramebufferObjects_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24QOpenGLFramebufferObject24hasOpenGLFramebufferBlitEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasOpenGLFramebufferBlit_0();
        }

        /// <summary>
        /// <para>This enum type is used to configure the depth and stencil buffers
        /// attached to the framebuffer object when it is created.</para>
        /// <para>See also attachment().</para>
        /// </summary>
        public enum Attachment : uint
        {
            /// <summary>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</summary>
            NoAttachment = 0,
            /// <summary>If the GL_EXT_packed_depth_stencil extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</summary>
            CombinedDepthStencil = 1,
            /// <summary>A depth buffer is attached to the framebuffer object.</summary>
            Depth = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLFramebufferObject __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFramebufferObject((QOpenGLFramebufferObject.Internal*) native);
        }

        public static QOpenGLFramebufferObject __CreateInstance(QOpenGLFramebufferObject.Internal native)
        {
            return new QOpenGLFramebufferObject(native);
        }

        private static QOpenGLFramebufferObject.Internal* __CopyValue(QOpenGLFramebufferObject.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLFramebufferObject.Internal.cctor_6(ret, new global::System.IntPtr(&native));
            return (QOpenGLFramebufferObject.Internal*) ret;
        }

        private QOpenGLFramebufferObject(QOpenGLFramebufferObject.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFramebufferObject(QOpenGLFramebufferObject.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Constructs an OpenGL framebuffer object of the given width and
        /// height based on the supplied format.</para>
        /// </summary>
        public QOpenGLFramebufferObject(int width, int height, QOpenGLFramebufferObjectFormat format)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg2 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.ctor_5(__Instance, width, height, arg2);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Switches rendering from the default, windowing system provided
        /// framebuffer to this framebuffer object. Returns true upon success, false
        /// otherwise.</para>
        /// <para>Note: If takeTexture() was called, a new texture is created and
        /// associated with the framebuffer object. This is potentially expensive and
        /// changes the context state (the currently bound texture).See also
        /// release().</para>
        /// </summary>
        public bool Bind()
        {
            var __ret = Internal.Bind_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the contents of this framebuffer object as a QImage. This
        /// method flips the image from OpenGL coordinates to raster
        /// coordinates.</para>
        /// </summary>
        public QImage ToImage()
        {
            var __ret = new QtGui.QImage.Internal();
            Internal.ToImage_0(new IntPtr(&__ret), __Instance);
            return QImage.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the contents of this framebuffer object as a
        /// QImage.</para>
        /// <para>If flipped is true the image is flipped from OpenGL coordinates
        /// to raster coordinates. If used together with QOpenGLPaintDevice, flipped
        /// should be the opposite of the value of
        /// QOpenGLPaintDevice::paintFlipped().</para>
        /// <para>The returned image has a format of premultiplied ARGB32 or RGB32.
        /// The latter is used only when internalTextureFormat() is set to
        /// GL_RGB.</para>
        /// <para>If the rendering in the framebuffer was not done with
        /// premultiplied alpha in mind, create a wrapper QImage with a
        /// non-premultiplied format. This is necessary before performing operations
        /// like QImage::save() because otherwise the image data would get
        /// unpremultiplied, even though it was not premultiplied in the first place.
        /// To create such a wrapper without performing a copy of the pixel data, do
        /// the following:</para>
        /// <para>QImage fboImage(fbo.toImage());</para>
        /// <para>QImage image(fboImage.constBits(), fboImage.width(),
        /// fboImage.height(), QImage::Format_ARGB32);</para>
        /// <para>Since Qt 5.2 the function will fall back to premultiplied
        /// RGBA8888 or RGBx8888 when reading to (A)RGB32 is not supported. Since 5.4
        /// an A2BGR30 image is returned if the internal format is RGB10_A2.</para>
        /// <para>For multisampled framebuffer objects the samples are resolved
        /// using the GL_EXT_framebuffer_blit extension. If the extension is not
        /// available, the contents of the returned image is undefined.</para>
        /// <para>For singlesampled framebuffers the contents is retrieved via
        /// glReadPixels. This is a potentially expensive and inefficient operation.
        /// Therefore it is recommended that this function is used as seldom as
        /// possible.</para>
        /// <para>See also QOpenGLPaintDevice::paintFlipped().</para>
        /// </summary>
        public QImage ToImage(bool flipped)
        {
            var __ret = new QtGui.QImage.Internal();
            Internal.ToImage_1(new IntPtr(&__ret), __Instance, flipped);
            return QImage.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Switches rendering back to the default, windowing system provided
        /// framebuffer. Returns true upon success, false otherwise.</para>
        /// <para>See also bind() and release().</para>
        /// </summary>
        public static bool BindDefault()
        {
            var __ret = Internal.BindDefault_0();
            return __ret;
        }

        /// <summary>
        /// <para>Returns the status of the depth and stencil buffers attached to
        /// this framebuffer object.</para>
        /// <para>See also setAttachment().</para>
        /// <para></para>
        /// <para>Sets the attachments of the framebuffer object to
        /// attachment.</para>
        /// <para>This can be used to free or reattach the depth and stencil buffer
        /// attachments as needed.</para>
        /// <para>Note: This function alters the current framebuffer binding.See
        /// also attachment().</para>
        /// </summary>
        public QOpenGLFramebufferObject.Attachment attachment
        {
            get
            {
                var __ret = Internal.attachment_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetAttachment_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the format of this framebuffer object.</para>
        /// </summary>
        public QOpenGLFramebufferObjectFormat Format
        {
            get
            {
                var __ret = new QtGui.QOpenGLFramebufferObjectFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QOpenGLFramebufferObjectFormat.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the framebuffer object is valid.</para>
        /// <para>The framebuffer can become invalid if the initialization process
        /// fails, the user attaches an invalid buffer to the framebuffer object, or a
        /// non-power of two width/height is specified as the texture size if the
        /// texture target is GL_TEXTURE_2D. The non-power of two limitation does not
        /// apply if the OpenGL version is 2.0 or higher, or if the
        /// GL_ARB_texture_non_power_of_two extension is present.</para>
        /// <para>The framebuffer can also become invalid if the QOpenGLContext
        /// that the framebuffer was created within is destroyed and there are no other
        /// shared contexts that can take over ownership of the framebuffer.</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the framebuffer object is currently bound to the
        /// current context, otherwise false is returned.</para>
        /// </summary>
        public bool IsBound
        {
            get
            {
                var __ret = Internal.IsBound_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Switches rendering back to the default, windowing system provided
        /// framebuffer. Returns true upon success, false otherwise.</para>
        /// <para>See also bind().</para>
        /// </summary>
        public bool Release
        {
            get
            {
                var __ret = Internal.Release_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the OpenGL GL_EXT_framebuffer_object extension is
        /// present on this system; otherwise returns false.</para>
        /// </summary>
        public static bool HasOpenGLFramebufferObjects
        {
            get
            {
                var __ret = Internal.HasOpenGLFramebufferObjects_0();
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the OpenGL GL_EXT_framebuffer_blit extension is
        /// present on this system; otherwise returns false.</para>
        /// <para>See also blitFramebuffer().</para>
        /// </summary>
        public static bool HasOpenGLFramebufferBlit
        {
            get
            {
                var __ret = Internal.HasOpenGLFramebufferBlit_0();
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QOpenGLFramebufferObject()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLFramebufferObject) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLFramebufferObjectFormat class specifies the format of
    /// an OpenGL framebuffer object.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A framebuffer object has several characteristics:</para>
    /// <para></para>
    /// <para>Number of samples per pixels.</para>
    /// <para>Depth and/or stencil attachments.</para>
    /// <para>Texture target.</para>
    /// <para>Internal texture format.</para>
    /// <para></para>
    /// <para>Note that the desired attachments or number of samples per pixels
    /// might not be supported by the hardware driver. Call
    /// QOpenGLFramebufferObject::format() after creating a
    /// QOpenGLFramebufferObject to find the exact format that was used to create
    /// the frame buffer object.</para>
    /// <para></para>
    /// <para>See also QOpenGLFramebufferObject.</para>
    /// </remarks>
    public unsafe partial class QOpenGLFramebufferObjectFormat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLFramebufferObjectFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLFramebufferObjectFormatC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLFramebufferObjectFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK30QOpenGLFramebufferObjectFormateqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK30QOpenGLFramebufferObjectFormatneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK30QOpenGLFramebufferObjectFormat7samplesEv")]
            internal static extern int Samples_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLFramebufferObjectFormat10setSamplesEi")]
            internal static extern void SetSamples_0(global::System.IntPtr instance, int samples);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK30QOpenGLFramebufferObjectFormat6mipmapEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Mipmap_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLFramebufferObjectFormat9setMipmapEb")]
            internal static extern void SetMipmap_0(global::System.IntPtr instance, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK30QOpenGLFramebufferObjectFormat10attachmentEv")]
            internal static extern QOpenGLFramebufferObject.Attachment Attachment_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN30QOpenGLFramebufferObjectFormat13setAttachmentEN24QOpenGLFramebufferObject10AttachmentE")]
            internal static extern void SetAttachment_0(global::System.IntPtr instance, QOpenGLFramebufferObject.Attachment attachment);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLFramebufferObjectFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFramebufferObjectFormat((QOpenGLFramebufferObjectFormat.Internal*) native);
        }

        public static QOpenGLFramebufferObjectFormat __CreateInstance(QOpenGLFramebufferObjectFormat.Internal native)
        {
            return new QOpenGLFramebufferObjectFormat(native);
        }

        private static QOpenGLFramebufferObjectFormat.Internal* __CopyValue(QOpenGLFramebufferObjectFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QOpenGLFramebufferObjectFormat.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLFramebufferObjectFormat.Internal*) ret;
        }

        private QOpenGLFramebufferObjectFormat(QOpenGLFramebufferObjectFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFramebufferObjectFormat(QOpenGLFramebufferObjectFormat.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a QOpenGLFramebufferObjectFormat object for specifying
        /// the format of an OpenGL framebuffer object.</para>
        /// <para>By default the format specifies a non-multisample framebuffer
        /// object with no attachments, texture target GL_TEXTURE_2D, and internal
        /// format GL_RGBA8. On OpenGL/ES systems, the default internal format is
        /// GL_RGBA.</para>
        /// <para>See also samples(), attachment(), and
        /// internalTextureFormat().</para>
        /// </summary>
        public QOpenGLFramebufferObjectFormat()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a copy of other.</para>
        /// </summary>
        public QOpenGLFramebufferObjectFormat(QOpenGLFramebufferObjectFormat other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if all the options of this framebuffer object format
        /// are the same as other; otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QOpenGLFramebufferObjectFormat __op, QOpenGLFramebufferObjectFormat other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QOpenGLFramebufferObjectFormat;
        }

        /// <summary>
        /// <para>Returns false if all the options of this framebuffer object
        /// format are the same as other; otherwise returns true.</para>
        /// </summary>
        public static bool operator !=(QOpenGLFramebufferObjectFormat __op, QOpenGLFramebufferObjectFormat other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the number of samples per pixel if a framebuffer object
        /// is a multisample framebuffer object. Otherwise, returns 0. The default
        /// value is 0.</para>
        /// <para>See also setSamples().</para>
        /// <para></para>
        /// <para>Sets the number of samples per pixel for a multisample
        /// framebuffer object to samples. The default sample count of 0 represents a
        /// regular non-multisample framebuffer object.</para>
        /// <para>If the desired amount of samples per pixel is not supported by
        /// the hardware then the maximum number of samples per pixel will be used.
        /// Note that multisample framebuffer objects can not be bound as textures.
        /// Also, the GL_EXT_framebuffer_multisample extension is required to create a
        /// framebuffer with more than one sample per pixel.</para>
        /// <para>See also samples().</para>
        /// </summary>
        public int Samples
        {
            get
            {
                var __ret = Internal.Samples_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSamples_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if mipmapping is enabled.</para>
        /// <para>See also setMipmap().</para>
        /// <para></para>
        /// <para>Enables mipmapping if enabled is true; otherwise disables
        /// it.</para>
        /// <para>Mipmapping is disabled by default.</para>
        /// <para>If mipmapping is enabled, additional memory will be allocated for
        /// the mipmap levels. The mipmap levels can be updated by binding the texture
        /// and calling glGenerateMipmap(). Mipmapping cannot be enabled for
        /// multisampled framebuffer objects.</para>
        /// <para>See also mipmap() and QOpenGLFramebufferObject::texture().</para>
        /// </summary>
        public bool Mipmap
        {
            get
            {
                var __ret = Internal.Mipmap_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMipmap_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the configuration of the depth and stencil buffers
        /// attached to a framebuffer object. The default is
        /// QOpenGLFramebufferObject::NoAttachment.</para>
        /// <para>See also setAttachment().</para>
        /// <para></para>
        /// <para>Sets the attachment configuration of a framebuffer object to
        /// attachment.</para>
        /// <para>See also attachment().</para>
        /// </summary>
        public QOpenGLFramebufferObject.Attachment Attachment
        {
            get
            {
                var __ret = Internal.Attachment_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetAttachment_0(__Instance, arg0);
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLFunctions class provides cross-platform access to the
    /// OpenGL ES 2.0 API.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>OpenGL ES 2.0 defines a subset of the OpenGL specification that
    /// is common across many desktop and embedded OpenGL implementations. However,
    /// it can be difficult to use the functions from that subset because they need
    /// to be resolved manually on desktop systems.</para>
    /// <para>QOpenGLFunctions provides a guaranteed API that is available on
    /// all OpenGL systems and takes care of function resolution on systems that
    /// need it. The recommended way to use QOpenGLFunctions is by direct
    /// inheritance:</para>
    /// <para>class MyGLWindow : public QWindow, protected
    /// QOpenGLFunctions</para>
    /// <para>{</para>
    /// <para>    Q_OBJECT</para>
    /// <para>public:</para>
    /// <para>    MyGLWindow(QScreen *screen = 0);</para>
    /// <para></para>
    /// <para>protected:</para>
    /// <para>    void initializeGL();</para>
    /// <para>    void paintGL();</para>
    /// <para></para>
    /// <para>    QOpenGLContext *m_context;</para>
    /// <para>};</para>
    /// <para></para>
    /// <para>MyGLWindow(QScreen *screen)</para>
    /// <para>  : QWindow(screen), QOpenGLWidget(parent)</para>
    /// <para>{</para>
    /// <para>    setSurfaceType(OpenGLSurface);</para>
    /// <para>    create();</para>
    /// <para></para>
    /// <para>    // Create an OpenGL context</para>
    /// <para>    m_context = new QOpenGLContext;</para>
    /// <para>    m_context-&gt;create();</para>
    /// <para></para>
    /// <para>    // Setup scene and render it</para>
    /// <para>    initializeGL();</para>
    /// <para>    paintGL()</para>
    /// <para>}</para>
    /// <para></para>
    /// <para>void MyGLWindow::initializeGL()</para>
    /// <para>{</para>
    /// <para>    m_context-&gt;makeCurrent(this);</para>
    /// <para>    initializeOpenGLFunctions();</para>
    /// <para>}</para>
    /// <para>The paintGL() function can then use any of the OpenGL ES 2.0
    /// functions without explicit resolution, such as glActiveTexture() in the
    /// following example:</para>
    /// <para>void MyGLWindow::paintGL()</para>
    /// <para>{</para>
    /// <para>    m_context-&gt;makeCurrent(this);</para>
    /// <para>    glActiveTexture(GL_TEXTURE1);</para>
    /// <para>    glBindTexture(GL_TEXTURE_2D, textureId);</para>
    /// <para>    ...</para>
    /// <para>    m_context-&gt;swapBuffers(this);</para>
    /// <para>    m_context-&gt;doneCurrent();</para>
    /// <para>}</para>
    /// <para>QOpenGLFunctions can also be used directly for ad-hoc invocation
    /// of OpenGL ES 2.0 functions on all platforms:</para>
    /// <para>QOpenGLFunctions
    /// glFuncs(QOpenGLContext::currentContext());</para>
    /// <para>glFuncs.glActiveTexture(GL_TEXTURE1);</para>
    /// <para>An alternative approach is to query the context's associated
    /// QOpenGLFunctions instance. This is somewhat faster than the previous
    /// approach due to avoiding the creation of a new instance, but the difference
    /// is fairly small since the internal data structures are shared, and function
    /// resolving happens only once for a given context, regardless of the number
    /// of QOpenGLFunctions instances initialized for it.</para>
    /// <para>QOpenGLFunctions *glFuncs =
    /// QOpenGLContext::currentContext()-&gt;functions();</para>
    /// <para>glFuncs-&gt;glActiveTexture(GL_TEXTURE1);</para>
    /// <para>QOpenGLFunctions provides wrappers for all OpenGL ES 2.0
    /// functions, including the common subset of OpenGL 1.x and ES 2.0. While such
    /// functions, for example glClear() or glDrawArrays(), can be called also
    /// directly, as long as the application links to the platform-specific OpenGL
    /// library, calling them via QOpenGLFunctions enables the possibility of
    /// dynamically loading the OpenGL implementation.</para>
    /// <para>The hasOpenGLFeature() and openGLFeatures() functions can be used
    /// to determine if the OpenGL implementation has a major OpenGL ES 2.0
    /// feature. For example, the following checks if non power of two textures are
    /// available:</para>
    /// <para>QOpenGLFunctions funcs(QOpenGLContext::currentContext());</para>
    /// <para>bool npot =
    /// funcs.hasOpenGLFeature(QOpenGLFunctions::NPOTTextures);</para>
    /// </remarks>
    public unsafe partial class QOpenGLFunctions : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QOpenGLFunctionsC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QOpenGLFunctionsC2EP14QOpenGLContext")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QOpenGLFunctionsC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QOpenGLFunctionsD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QOpenGLFunctions14openGLFeaturesEv")]
            internal static extern QOpenGLFunctions.OpenGLFeature OpenGLFeatures_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QOpenGLFunctions16hasOpenGLFeatureENS_13OpenGLFeatureE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasOpenGLFeature_0(global::System.IntPtr instance, QOpenGLFunctions.OpenGLFeature feature);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QOpenGLFunctions25initializeOpenGLFunctionsEv")]
            internal static extern void InitializeOpenGLFunctions_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum defines OpenGL and OpenGL ES features whose presence
        /// may depend on the implementation.</para>
        /// </summary>
        [Flags]
        public enum OpenGLFeature : uint
        {
            /// <summary>glActiveTexture() function is available.</summary>
            Multitexture = 0x1,
            /// <summary>Shader functions are available.</summary>
            Shaders = 0x2,
            /// <summary>Vertex and index buffer functions are available.</summary>
            Buffers = 0x4,
            /// <summary>Framebuffer object functions are available.</summary>
            Framebuffers = 0x8,
            /// <summary>glBlendColor() is available.</summary>
            BlendColor = 0x10,
            /// <summary>glBlendEquation() is available.</summary>
            BlendEquation = 0x20,
            /// <summary>glBlendEquationSeparate() is available.</summary>
            BlendEquationSeparate = 0x40,
            /// <summary>glBlendFuncSeparate() is available.</summary>
            BlendFuncSeparate = 0x80,
            /// <summary>Blend subtract mode is available.</summary>
            BlendSubtract = 0x100,
            /// <summary>Compressed texture functions are available.</summary>
            CompressedTextures = 0x200,
            /// <summary>glSampleCoverage() function is available.</summary>
            Multisample = 0x400,
            /// <summary>Separate stencil functions are available.</summary>
            StencilSeparate = 0x800,
            /// <summary>Non power of two textures are available.</summary>
            NPOTTextures = 0x1000,
            /// <summary>Non power of two textures can use GL_REPEAT as wrap parameter.</summary>
            NPOTTextureRepeat = 0x2000,
            /// <summary>The fixed function pipeline is available.</summary>
            FixedFunctionPipeline = 0x4000
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLFunctions __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLFunctions((QOpenGLFunctions.Internal*) native);
        }

        public static QOpenGLFunctions __CreateInstance(QOpenGLFunctions.Internal native)
        {
            return new QOpenGLFunctions(native);
        }

        private static QOpenGLFunctions.Internal* __CopyValue(QOpenGLFunctions.Internal native)
        {
            var ret = (QOpenGLFunctions.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QOpenGLFunctions(QOpenGLFunctions.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLFunctions(QOpenGLFunctions.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a default function resolver. The resolver cannot be
        /// used until initializeOpenGLFunctions() is called to specify the
        /// context.</para>
        /// <para>See also initializeOpenGLFunctions().</para>
        /// </summary>
        public QOpenGLFunctions()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a function resolver for context. If context is null,
        /// then the resolver will be created for the current QOpenGLContext.</para>
        /// <para>The context or another context in the group must be
        /// current.</para>
        /// <para>An object constructed in this way can only be used with context
        /// and other contexts that share with it. Use initializeOpenGLFunctions() to
        /// change the object's context association.</para>
        /// <para>See also initializeOpenGLFunctions().</para>
        /// </summary>
        public QOpenGLFunctions(QOpenGLContext context)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the set of features that are present on this system's
        /// OpenGL implementation.</para>
        /// <para>It is assumed that the QOpenGLContext associated with this
        /// function resolver is current.</para>
        /// <para>See also hasOpenGLFeature().</para>
        /// </summary>
        public QOpenGLFunctions.OpenGLFeature OpenGLFeatures()
        {
            var __ret = Internal.OpenGLFeatures_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if feature is present on this system's OpenGL
        /// implementation; false otherwise.</para>
        /// <para>It is assumed that the QOpenGLContext associated with this
        /// function resolver is current.</para>
        /// <para>See also openGLFeatures().</para>
        /// </summary>
        public bool HasOpenGLFeature(QOpenGLFunctions.OpenGLFeature feature)
        {
            var arg0 = feature;
            var __ret = Internal.HasOpenGLFeature_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Initializes OpenGL function resolution for the current
        /// context.</para>
        /// <para>After calling this function, the QOpenGLFunctions object can only
        /// be used with the current context and other contexts that share with it.
        /// Call initializeOpenGLFunctions() again to change the object's context
        /// association.</para>
        /// </summary>
        public void InitializeOpenGLFunctions()
        {
            Internal.InitializeOpenGLFunctions_0(__Instance);
        }
    }

    public unsafe partial class QOpenGLFunctionsPrivate
    {
        [StructLayout(LayoutKind.Explicit, Size = 576)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr BindTexture;

            [FieldOffset(4)]
            public global::System.IntPtr BlendFunc;

            [FieldOffset(8)]
            public global::System.IntPtr Clear;

            [FieldOffset(12)]
            public global::System.IntPtr ClearColor;

            [FieldOffset(16)]
            public global::System.IntPtr ClearDepthf;

            [FieldOffset(20)]
            public global::System.IntPtr ClearStencil;

            [FieldOffset(24)]
            public global::System.IntPtr ColorMask;

            [FieldOffset(28)]
            public global::System.IntPtr CopyTexImage2D;

            [FieldOffset(32)]
            public global::System.IntPtr CopyTexSubImage2D;

            [FieldOffset(36)]
            public global::System.IntPtr CullFace;

            [FieldOffset(40)]
            public global::System.IntPtr DeleteTextures;

            [FieldOffset(44)]
            public global::System.IntPtr DepthFunc;

            [FieldOffset(48)]
            public global::System.IntPtr DepthMask;

            [FieldOffset(52)]
            public global::System.IntPtr DepthRangef;

            [FieldOffset(56)]
            public global::System.IntPtr Disable;

            [FieldOffset(60)]
            public global::System.IntPtr DrawArrays;

            [FieldOffset(64)]
            public global::System.IntPtr DrawElements;

            [FieldOffset(68)]
            public global::System.IntPtr Enable;

            [FieldOffset(72)]
            public global::System.IntPtr Finish;

            [FieldOffset(76)]
            public global::System.IntPtr Flush;

            [FieldOffset(80)]
            public global::System.IntPtr FrontFace;

            [FieldOffset(84)]
            public global::System.IntPtr GenTextures;

            [FieldOffset(88)]
            public global::System.IntPtr GetBooleanv;

            [FieldOffset(92)]
            public global::System.IntPtr GetError;

            [FieldOffset(96)]
            public global::System.IntPtr GetFloatv;

            [FieldOffset(100)]
            public global::System.IntPtr GetIntegerv;

            [FieldOffset(104)]
            public global::System.IntPtr GetString;

            [FieldOffset(108)]
            public global::System.IntPtr GetTexParameterfv;

            [FieldOffset(112)]
            public global::System.IntPtr GetTexParameteriv;

            [FieldOffset(116)]
            public global::System.IntPtr Hint;

            [FieldOffset(120)]
            public global::System.IntPtr IsEnabled;

            [FieldOffset(124)]
            public global::System.IntPtr IsTexture;

            [FieldOffset(128)]
            public global::System.IntPtr LineWidth;

            [FieldOffset(132)]
            public global::System.IntPtr PixelStorei;

            [FieldOffset(136)]
            public global::System.IntPtr PolygonOffset;

            [FieldOffset(140)]
            public global::System.IntPtr ReadPixels;

            [FieldOffset(144)]
            public global::System.IntPtr Scissor;

            [FieldOffset(148)]
            public global::System.IntPtr StencilFunc;

            [FieldOffset(152)]
            public global::System.IntPtr StencilMask;

            [FieldOffset(156)]
            public global::System.IntPtr StencilOp;

            [FieldOffset(160)]
            public global::System.IntPtr TexImage2D;

            [FieldOffset(164)]
            public global::System.IntPtr TexParameterf;

            [FieldOffset(168)]
            public global::System.IntPtr TexParameterfv;

            [FieldOffset(172)]
            public global::System.IntPtr TexParameteri;

            [FieldOffset(176)]
            public global::System.IntPtr TexParameteriv;

            [FieldOffset(180)]
            public global::System.IntPtr TexSubImage2D;

            [FieldOffset(184)]
            public global::System.IntPtr Viewport;

            [FieldOffset(188)]
            public global::System.IntPtr ActiveTexture;

            [FieldOffset(192)]
            public global::System.IntPtr AttachShader;

            [FieldOffset(196)]
            public global::System.IntPtr BindAttribLocation;

            [FieldOffset(200)]
            public global::System.IntPtr BindBuffer;

            [FieldOffset(204)]
            public global::System.IntPtr BindFramebuffer;

            [FieldOffset(208)]
            public global::System.IntPtr BindRenderbuffer;

            [FieldOffset(212)]
            public global::System.IntPtr BlendColor;

            [FieldOffset(216)]
            public global::System.IntPtr BlendEquation;

            [FieldOffset(220)]
            public global::System.IntPtr BlendEquationSeparate;

            [FieldOffset(224)]
            public global::System.IntPtr BlendFuncSeparate;

            [FieldOffset(228)]
            public global::System.IntPtr BufferData;

            [FieldOffset(232)]
            public global::System.IntPtr BufferSubData;

            [FieldOffset(236)]
            public global::System.IntPtr CheckFramebufferStatus;

            [FieldOffset(240)]
            public global::System.IntPtr CompileShader;

            [FieldOffset(244)]
            public global::System.IntPtr CompressedTexImage2D;

            [FieldOffset(248)]
            public global::System.IntPtr CompressedTexSubImage2D;

            [FieldOffset(252)]
            public global::System.IntPtr CreateProgram;

            [FieldOffset(256)]
            public global::System.IntPtr CreateShader;

            [FieldOffset(260)]
            public global::System.IntPtr DeleteBuffers;

            [FieldOffset(264)]
            public global::System.IntPtr DeleteFramebuffers;

            [FieldOffset(268)]
            public global::System.IntPtr DeleteProgram;

            [FieldOffset(272)]
            public global::System.IntPtr DeleteRenderbuffers;

            [FieldOffset(276)]
            public global::System.IntPtr DeleteShader;

            [FieldOffset(280)]
            public global::System.IntPtr DetachShader;

            [FieldOffset(284)]
            public global::System.IntPtr DisableVertexAttribArray;

            [FieldOffset(288)]
            public global::System.IntPtr EnableVertexAttribArray;

            [FieldOffset(292)]
            public global::System.IntPtr FramebufferRenderbuffer;

            [FieldOffset(296)]
            public global::System.IntPtr FramebufferTexture2D;

            [FieldOffset(300)]
            public global::System.IntPtr GenBuffers;

            [FieldOffset(304)]
            public global::System.IntPtr GenerateMipmap;

            [FieldOffset(308)]
            public global::System.IntPtr GenFramebuffers;

            [FieldOffset(312)]
            public global::System.IntPtr GenRenderbuffers;

            [FieldOffset(316)]
            public global::System.IntPtr GetActiveAttrib;

            [FieldOffset(320)]
            public global::System.IntPtr GetActiveUniform;

            [FieldOffset(324)]
            public global::System.IntPtr GetAttachedShaders;

            [FieldOffset(328)]
            public global::System.IntPtr GetAttribLocation;

            [FieldOffset(332)]
            public global::System.IntPtr GetBufferParameteriv;

            [FieldOffset(336)]
            public global::System.IntPtr GetFramebufferAttachmentParameteriv;

            [FieldOffset(340)]
            public global::System.IntPtr GetProgramiv;

            [FieldOffset(344)]
            public global::System.IntPtr GetProgramInfoLog;

            [FieldOffset(348)]
            public global::System.IntPtr GetRenderbufferParameteriv;

            [FieldOffset(352)]
            public global::System.IntPtr GetShaderiv;

            [FieldOffset(356)]
            public global::System.IntPtr GetShaderInfoLog;

            [FieldOffset(360)]
            public global::System.IntPtr GetShaderPrecisionFormat;

            [FieldOffset(364)]
            public global::System.IntPtr GetShaderSource;

            [FieldOffset(368)]
            public global::System.IntPtr GetUniformfv;

            [FieldOffset(372)]
            public global::System.IntPtr GetUniformiv;

            [FieldOffset(376)]
            public global::System.IntPtr GetUniformLocation;

            [FieldOffset(380)]
            public global::System.IntPtr GetVertexAttribfv;

            [FieldOffset(384)]
            public global::System.IntPtr GetVertexAttribiv;

            [FieldOffset(388)]
            public global::System.IntPtr GetVertexAttribPointerv;

            [FieldOffset(392)]
            public global::System.IntPtr IsBuffer;

            [FieldOffset(396)]
            public global::System.IntPtr IsFramebuffer;

            [FieldOffset(400)]
            public global::System.IntPtr IsProgram;

            [FieldOffset(404)]
            public global::System.IntPtr IsRenderbuffer;

            [FieldOffset(408)]
            public global::System.IntPtr IsShader;

            [FieldOffset(412)]
            public global::System.IntPtr LinkProgram;

            [FieldOffset(416)]
            public global::System.IntPtr ReleaseShaderCompiler;

            [FieldOffset(420)]
            public global::System.IntPtr RenderbufferStorage;

            [FieldOffset(424)]
            public global::System.IntPtr SampleCoverage;

            [FieldOffset(428)]
            public global::System.IntPtr ShaderBinary;

            [FieldOffset(432)]
            public global::System.IntPtr ShaderSource;

            [FieldOffset(436)]
            public global::System.IntPtr StencilFuncSeparate;

            [FieldOffset(440)]
            public global::System.IntPtr StencilMaskSeparate;

            [FieldOffset(444)]
            public global::System.IntPtr StencilOpSeparate;

            [FieldOffset(448)]
            public global::System.IntPtr Uniform1f;

            [FieldOffset(452)]
            public global::System.IntPtr Uniform1fv;

            [FieldOffset(456)]
            public global::System.IntPtr Uniform1i;

            [FieldOffset(460)]
            public global::System.IntPtr Uniform1iv;

            [FieldOffset(464)]
            public global::System.IntPtr Uniform2f;

            [FieldOffset(468)]
            public global::System.IntPtr Uniform2fv;

            [FieldOffset(472)]
            public global::System.IntPtr Uniform2i;

            [FieldOffset(476)]
            public global::System.IntPtr Uniform2iv;

            [FieldOffset(480)]
            public global::System.IntPtr Uniform3f;

            [FieldOffset(484)]
            public global::System.IntPtr Uniform3fv;

            [FieldOffset(488)]
            public global::System.IntPtr Uniform3i;

            [FieldOffset(492)]
            public global::System.IntPtr Uniform3iv;

            [FieldOffset(496)]
            public global::System.IntPtr Uniform4f;

            [FieldOffset(500)]
            public global::System.IntPtr Uniform4fv;

            [FieldOffset(504)]
            public global::System.IntPtr Uniform4i;

            [FieldOffset(508)]
            public global::System.IntPtr Uniform4iv;

            [FieldOffset(512)]
            public global::System.IntPtr UniformMatrix2fv;

            [FieldOffset(516)]
            public global::System.IntPtr UniformMatrix3fv;

            [FieldOffset(520)]
            public global::System.IntPtr UniformMatrix4fv;

            [FieldOffset(524)]
            public global::System.IntPtr UseProgram;

            [FieldOffset(528)]
            public global::System.IntPtr ValidateProgram;

            [FieldOffset(532)]
            public global::System.IntPtr VertexAttrib1f;

            [FieldOffset(536)]
            public global::System.IntPtr VertexAttrib1fv;

            [FieldOffset(540)]
            public global::System.IntPtr VertexAttrib2f;

            [FieldOffset(544)]
            public global::System.IntPtr VertexAttrib2fv;

            [FieldOffset(548)]
            public global::System.IntPtr VertexAttrib3f;

            [FieldOffset(552)]
            public global::System.IntPtr VertexAttrib3fv;

            [FieldOffset(556)]
            public global::System.IntPtr VertexAttrib4f;

            [FieldOffset(560)]
            public global::System.IntPtr VertexAttrib4fv;

            [FieldOffset(564)]
            public global::System.IntPtr VertexAttribPointer;

            [FieldOffset(568)]
            public global::System.IntPtr ClearDepth;

            [FieldOffset(572)]
            public global::System.IntPtr DepthRange;
        }
    }

    /// <summary>
    /// <para>The QOpenGLPaintDevice class enables painting to an OpenGL
    /// context using QPainter.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QOpenGLPaintDevice uses the current QOpenGL context to render
    /// QPainter draw commands. The context is captured upon construction. It
    /// requires support for OpenGL (ES) 2.0 or higher.</para>
    /// <para></para>
    /// <para>Performance</para>
    /// <para>The QOpenGLPaintDevice is almost always hardware accelerated and
    /// has the potential of being much faster than software rasterization.
    /// However, it is more sensitive to state changes, and therefore requires the
    /// drawing commands to be carefully ordered to achieve optimal
    /// performance.</para>
    /// <para></para>
    /// <para>Antialiasing and Quality</para>
    /// <para>Antialiasing in the OpenGL paint engine is done using
    /// multisampling. Most hardware require significantly more memory to do
    /// multisampling and the resulting quality is not on par with the quality of
    /// the software paint engine. The OpenGL paint engine's strength lies in its
    /// performance, not its visual rendering quality.</para>
    /// <para></para>
    /// <para>State Changes</para>
    /// <para>When painting to a QOpenGLPaintDevice using QPainter, the state
    /// of the current OpenGL context will be altered by the paint engine to
    /// reflect its needs. Applications should not rely upon the OpenGL state being
    /// reset to its original conditions, particularly the current shader program,
    /// OpenGL viewport, texture units, and drawing modes.</para>
    /// <para></para>
    /// <para>Mixing QPainter and OpenGL</para>
    /// <para>When intermixing QPainter and OpenGL, it is important to notify
    /// QPainter that the OpenGL state may have been cluttered so it can restore
    /// its internal state. This is acheived by calling
    /// QPainter::beginNativePainting() before starting the OpenGL rendering and
    /// calling QPainter::endNativePainting() after finishing.</para>
    /// <para></para>
    /// <para>See also OpenGL Window Example.</para>
    /// </remarks>
    public unsafe partial class QOpenGLPaintDevice : QtGui.QPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            internal QScopedPointer.Internal d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLPaintDeviceC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLPaintDeviceC2Eii")]
            internal static extern void ctor_2(global::System.IntPtr instance, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLPaintDeviceC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLPaintDeviceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLPaintDevice18ensureActiveTargetEv")]
            internal static extern void EnsureActiveTarget_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLPaintDevice6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLPaintDevice12paintFlippedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool PaintFlipped_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLPaintDevice15setPaintFlippedEb")]
            internal static extern void SetPaintFlipped_0(global::System.IntPtr instance, bool flipped);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLPaintDevice11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLPaintDevice7contextEv")]
            internal static extern global::System.IntPtr Context_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLPaintDevice __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLPaintDevice((QOpenGLPaintDevice.Internal*) native);
        }

        public static QOpenGLPaintDevice __CreateInstance(QOpenGLPaintDevice.Internal native)
        {
            return new QOpenGLPaintDevice(native);
        }

        private static QOpenGLPaintDevice.Internal* __CopyValue(QOpenGLPaintDevice.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QOpenGLPaintDevice.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QOpenGLPaintDevice.Internal*) ret;
        }

        private QOpenGLPaintDevice(QOpenGLPaintDevice.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLPaintDevice(QOpenGLPaintDevice.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDevice.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a QOpenGLPaintDevice.</para>
        /// <para>The QOpenGLPaintDevice is only valid for the current
        /// context.</para>
        /// <para>See also QOpenGLContext::currentContext().</para>
        /// </summary>
        public QOpenGLPaintDevice()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QOpenGLPaintDevice with the given width and
        /// height.</para>
        /// <para>The QOpenGLPaintDevice is only valid for the current
        /// context.</para>
        /// <para>See also QOpenGLContext::currentContext().</para>
        /// </summary>
        public QOpenGLPaintDevice(int width, int height)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_2(__Instance, width, height);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>This virtual method is provided as a callback to allow re-binding
        /// a target frame buffer object or context when different QOpenGLPaintDevice
        /// instances are issuing draw calls alternately.</para>
        /// <para>beginNativePainting() will also trigger this method.</para>
        /// <para>The default implementation does nothing.</para>
        /// </summary>
        public virtual void EnsureActiveTarget()
        {
            Internal.EnsureActiveTarget_0(__Instance);
        }

        /// <summary>
        /// <para>Reimplemented from QPaintDevice::metric().</para>
        /// </summary>
        protected override int Metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if painting is flipped around the Y-axis.</para>
        /// <para>See also setPaintFlipped().</para>
        /// <para></para>
        /// <para>Sets whether painting should be flipped around the Y-axis or not
        /// to flipped.</para>
        /// <para>See also paintFlipped().</para>
        /// </summary>
        public bool PaintFlipped
        {
            get
            {
                var __ret = Internal.PaintFlipped_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetPaintFlipped_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QPaintDevice::paintEngine().</para>
        /// </summary>
        public override QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the OpenGL context associated with the paint
        /// device.</para>
        /// </summary>
        public QOpenGLContext Context
        {
            get
            {
                var __ret = Internal.Context_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QOpenGLContext.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // virtual ~QOpenGLPaintDevice()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLPaintDevice) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLPaintDevice) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(QPaintDevice::PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLPaintDevice) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLPaintDevice) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLPaintDevice) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // void ensureActiveTarget()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _EnsureActiveTarget_0Delegate(global::System.IntPtr instance);
        private static _EnsureActiveTarget_0Delegate _EnsureActiveTarget_0DelegateInstance;

        private static void _EnsureActiveTarget_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLPaintDevice) _References[instance].Target;
            target.EnsureActiveTarget();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
                _EnsureActiveTarget_0DelegateInstance += _EnsureActiveTarget_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EnsureActiveTarget_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
                *(void**)(vfptr0 + 32) = _Thunks[5];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLPixelTransferOptions class describes the pixel storage
    /// modes that affect the unpacking of pixels during texture upload.</para>
    /// </summary>
    public unsafe partial class QOpenGLPixelTransferOptions : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptionsC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptionsC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptionsD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions28setLeastSignificantByteFirstEb")]
            internal static extern void SetLeastSignificantByteFirst_0(global::System.IntPtr instance, bool lsbFirst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions9alignmentEv")]
            internal static extern int Alignment_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions12setAlignmentEi")]
            internal static extern void SetAlignment_0(global::System.IntPtr instance, int alignment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions10skipImagesEv")]
            internal static extern int SkipImages_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions13setSkipImagesEi")]
            internal static extern void SetSkipImages_0(global::System.IntPtr instance, int skipImages);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions8skipRowsEv")]
            internal static extern int SkipRows_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions11setSkipRowsEi")]
            internal static extern void SetSkipRows_0(global::System.IntPtr instance, int skipRows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions10skipPixelsEv")]
            internal static extern int SkipPixels_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions13setSkipPixelsEi")]
            internal static extern void SetSkipPixels_0(global::System.IntPtr instance, int skipPixels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions11imageHeightEv")]
            internal static extern int ImageHeight_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions14setImageHeightEi")]
            internal static extern void SetImageHeight_0(global::System.IntPtr instance, int imageHeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions9rowLengthEv")]
            internal static extern int RowLength_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions12setRowLengthEi")]
            internal static extern void SetRowLength_0(global::System.IntPtr instance, int rowLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions18isSwapBytesEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SwapBytesEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QOpenGLPixelTransferOptions19setSwapBytesEnabledEb")]
            internal static extern void SetSwapBytesEnabled_0(global::System.IntPtr instance, bool swapBytes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QOpenGLPixelTransferOptions26isLeastSignificantBitFirstEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsLeastSignificantBitFirst_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLPixelTransferOptions __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLPixelTransferOptions((QOpenGLPixelTransferOptions.Internal*) native);
        }

        public static QOpenGLPixelTransferOptions __CreateInstance(QOpenGLPixelTransferOptions.Internal native)
        {
            return new QOpenGLPixelTransferOptions(native);
        }

        private static QOpenGLPixelTransferOptions.Internal* __CopyValue(QOpenGLPixelTransferOptions.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QOpenGLPixelTransferOptions.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLPixelTransferOptions.Internal*) ret;
        }

        private QOpenGLPixelTransferOptions(QOpenGLPixelTransferOptions.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLPixelTransferOptions(QOpenGLPixelTransferOptions.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a new QOpenGLPixelTransferOptions instance with the
        /// default settings.</para>
        /// </summary>
        public QOpenGLPixelTransferOptions()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public QOpenGLPixelTransferOptions(QOpenGLPixelTransferOptions _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            Internal.cctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>lsbFirst specifies if bits within a byte are ordered from least
        /// to most significat. The default value is false, meaning that the first bit
        /// in each byte is the most significant one. This is significant for bitmap
        /// data only. Corresponds to GL_UNPACK_LSB_FIRST.</para>
        /// </summary>
        public void SetLeastSignificantByteFirst(bool lsbFirst)
        {
            Internal.SetLeastSignificantByteFirst_0(__Instance, lsbFirst);
        }

        /// <summary>
        /// <para>Returns the current alignment requirement for each pixel
        /// row.</para>
        /// <para>See also setAlignment().</para>
        /// <para></para>
        /// <para>Sets the alignment requirements for each pixel row. Corresponds
        /// to GL_UNPACK_ALIGNMENT. The default value is 4, as specified by
        /// OpenGL.</para>
        /// <para>See also alignment().</para>
        /// </summary>
        public int Alignment
        {
            get
            {
                var __ret = Internal.Alignment_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetAlignment_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of images that are skipped.</para>
        /// <para>See also setSkipImages().</para>
        /// <para></para>
        /// <para>Sets the number of images that are skipped to skipImages.
        /// Corresponds to GL_UNPACK_SKIP_IMAGES. Equivalent to incrementing the
        /// pointer passed to QOpenGLTexture::setData(). The default value is 0.</para>
        /// <para>See also skipImages().</para>
        /// </summary>
        public int SkipImages
        {
            get
            {
                var __ret = Internal.SkipImages_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSkipImages_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of rows that are skipped.</para>
        /// <para>See also setSkipRows().</para>
        /// <para></para>
        /// <para>Sets the number of rows that are skipped to skipRows. Corresponds
        /// to GL_UNPACK_SKIP_ROWS. Equivalent to incrementing the pointer passed to
        /// QOpenGLTexture::setData(). The default value is 0.</para>
        /// <para>See also skipRows().</para>
        /// </summary>
        public int SkipRows
        {
            get
            {
                var __ret = Internal.SkipRows_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSkipRows_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of pixels that are skipped.</para>
        /// <para>See also setSkipPixels().</para>
        /// <para></para>
        /// <para>Sets the number of pixels that are skipped to skipPixels.
        /// Corresponds to GL_UNPACK_SKIP_PIXELS. Equivalent to incrementing the
        /// pointer passed to QOpenGLTexture::setData(). The default value is 0.</para>
        /// <para>See also skipPixels().</para>
        /// </summary>
        public int SkipPixels
        {
            get
            {
                var __ret = Internal.SkipPixels_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSkipPixels_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the currently set image height.</para>
        /// <para>See also setImageHeight().</para>
        /// <para></para>
        /// <para>Sets the image height for 3D textures to imageHeight. Corresponds
        /// to GL_UNPACK_IMAGE_HEIGHT. The default value is 0.</para>
        /// <para>See also imageHeight().</para>
        /// </summary>
        public int ImageHeight
        {
            get
            {
                var __ret = Internal.ImageHeight_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetImageHeight_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the currently set row length.</para>
        /// <para>See also setRowLength().</para>
        /// <para></para>
        /// <para>Sets the number of pixels in a row to rowLength. Corresponds to
        /// GL_UNPACK_ROW_LENGTH. The default value is 0.</para>
        /// <para>See also rowLength().</para>
        /// </summary>
        public int RowLength
        {
            get
            {
                var __ret = Internal.RowLength_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRowLength_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if the byte ordering for multibyte components is
        /// reversed.</para>
        /// <para></para>
        /// <para>swapBytes specifies if the byte ordering for multibyte components
        /// is reversed. The default value is false. Corresponds to
        /// GL_UNPACK_SWAP_BYTES.</para>
        /// <para>See also isSwapBytesEnabled().</para>
        /// </summary>
        public bool SwapBytesEnabled
        {
            get
            {
                var __ret = Internal.SwapBytesEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSwapBytesEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if bits within a byte are ordered from least to most
        /// significant.</para>
        /// </summary>
        public bool IsLeastSignificantBitFirst
        {
            get
            {
                var __ret = Internal.IsLeastSignificantBitFirst_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLShader class allows OpenGL shaders to be
    /// compiled.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class supports shaders written in the OpenGL Shading
    /// Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).</para>
    /// <para>QOpenGLShader and QOpenGLShaderProgram shelter the programmer
    /// from the details of compiling and linking vertex and fragment
    /// shaders.</para>
    /// <para></para>
    /// <para>See also QOpenGLShaderProgram.</para>
    /// </remarks>
    public unsafe partial class QOpenGLShader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLShaderC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLShaderD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLShader17compileSourceCodeEPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CompileSourceCode_0(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLShader17compileSourceCodeERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CompileSourceCode1_0(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QOpenGLShader17compileSourceFileERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CompileSourceFile_0(global::System.IntPtr instance, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QOpenGLShader16hasOpenGLShadersE6QFlagsINS_13ShaderTypeBitEEP14QOpenGLContext")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasOpenGLShaders_0(QOpenGLShader.ShaderTypeBit type, global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLShader10shaderTypeEv")]
            internal static extern QOpenGLShader.ShaderTypeBit ShaderType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLShader10isCompiledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCompiled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QOpenGLShader3logEv")]
            internal static extern void Log_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum specifies the type of QOpenGLShader that is being
        /// created.</para>
        /// </summary>
        [Flags]
        public enum ShaderTypeBit : uint
        {
            /// <summary>Vertex shader written in the OpenGL Shading Language (GLSL).</summary>
            Vertex = 0x1,
            /// <summary>Fragment shader written in the OpenGL Shading Language (GLSL).</summary>
            Fragment = 0x2,
            /// <summary>Geometry shaders written in the OpenGL Shading Language (GLSL) based on the OpenGL core feature (requires OpenGL >= 3.2).</summary>
            Geometry = 0x4,
            /// <summary>Tessellation control shaders written in the OpenGL shading language (GLSL), based on the core feature (requires OpenGL >= 4.0).</summary>
            TessellationControl = 0x8,
            /// <summary>Tessellation evaluation shaders written in the OpenGL shading language (GLSL), based on the core feature (requires OpenGL >= 4.0).</summary>
            TessellationEvaluation = 0x10,
            /// <summary>Compute shaders written in the OpenGL shading language (GLSL), based on the core feature (requires OpenGL >= 4.3).</summary>
            Compute = 0x20
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLShader __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLShader((QOpenGLShader.Internal*) native);
        }

        public static QOpenGLShader __CreateInstance(QOpenGLShader.Internal native)
        {
            return new QOpenGLShader(native);
        }

        private static QOpenGLShader.Internal* __CopyValue(QOpenGLShader.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLShader.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLShader.Internal*) ret;
        }

        private QOpenGLShader(QOpenGLShader.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLShader(QOpenGLShader.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Sets the source code for this shader and compiles it. Returns
        /// true if the source was successfully compiled, false otherwise.</para>
        /// <para>See also compileSourceFile().</para>
        /// </summary>
        public bool CompileSourceCode(string source)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(source);
            var __ret = Internal.CompileSourceCode_0(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the source code for this shader and compiles it. Returns
        /// true if the source was successfully compiled, false otherwise.</para>
        /// <para>See also compileSourceFile().</para>
        /// </summary>
        public bool CompileSourceCode1(string source)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(source).ToPointer(), source.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.CompileSourceCode1_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the source code for this shader to the contents of fileName
        /// and compiles it. Returns true if the file could be opened and the source
        /// compiled, false otherwise.</para>
        /// <para>See also compileSourceCode().</para>
        /// </summary>
        public bool CompileSourceFile(string fileName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.CompileSourceFile_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if shader programs of type type are supported on
        /// this system; false otherwise.</para>
        /// <para>The context is used to resolve the GLSL extensions. If context is
        /// null, then QOpenGLContext::currentContext() is used.</para>
        /// </summary>
        public static bool HasOpenGLShaders(QOpenGLShader.ShaderTypeBit type, QOpenGLContext context = null)
        {
            var arg0 = type;
            var arg1 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            var __ret = Internal.HasOpenGLShaders_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the type of this shader.</para>
        /// </summary>
        public QOpenGLShader.ShaderTypeBit ShaderType
        {
            get
            {
                var __ret = Internal.ShaderType_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this shader has been compiled; false
        /// otherwise.</para>
        /// <para>See also compileSourceCode() and compileSourceFile().</para>
        /// </summary>
        public bool IsCompiled
        {
            get
            {
                var __ret = Internal.IsCompiled_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the errors and warnings that occurred during the last
        /// compile.</para>
        /// <para>See also compileSourceCode() and compileSourceFile().</para>
        /// </summary>
        public string Log
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Log_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        #region Virtual table interop

        // virtual ~QOpenGLShader()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLShader) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLShaderProgram class allows OpenGL shader programs to
    /// be linked and used.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para></para>
    /// <para>Introduction</para>
    /// <para>This class supports shader programs written in the OpenGL Shading
    /// Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).</para>
    /// <para>QOpenGLShader and QOpenGLShaderProgram shelter the programmer
    /// from the details of compiling and linking vertex and fragment
    /// shaders.</para>
    /// <para>The following example creates a vertex shader program using the
    /// supplied source code. Once compiled and linked, the shader program is
    /// activated in the current QOpenGLContext by calling
    /// QOpenGLShaderProgram::bind():</para>
    /// <para>QOpenGLShader shader(QOpenGLShader::Vertex);</para>
    /// <para>shader.compileSourceCode(code);</para>
    /// <para></para>
    /// <para>QOpenGLShaderProgram program(context);</para>
    /// <para>program.addShader(shader);</para>
    /// <para>program.link();</para>
    /// <para></para>
    /// <para>program.bind();</para>
    /// <para></para>
    /// <para>Writing Portable Shaders</para>
    /// <para>Shader programs can be difficult to reuse across OpenGL
    /// implementations because of varying levels of support for standard vertex
    /// attributes and uniform variables. In particular, GLSL/ES lacks all of the
    /// standard variables that are present on desktop OpenGL systems: gl_Vertex,
    /// gl_Normal, gl_Color, and so on. Desktop OpenGL lacks the variable
    /// qualifiers highp, mediump, and lowp.</para>
    /// <para>The QOpenGLShaderProgram class makes the process of writing
    /// portable shaders easier by prefixing all shader programs with the following
    /// lines on desktop OpenGL:</para>
    /// <para>#define highp</para>
    /// <para>#define mediump</para>
    /// <para>#define lowp</para>
    /// <para>This makes it possible to run most GLSL/ES shader programs on
    /// desktop systems. The programmer should restrict themselves to just features
    /// that are present in GLSL/ES, and avoid standard variable names that only
    /// work on the desktop.</para>
    /// <para></para>
    /// <para>Simple Shader Example</para>
    /// <para>program.addShaderFromSourceCode(QOpenGLShader::Vertex,</para>
    /// <para>    &quot;attribute highp vec4 vertex;\n&quot;</para>
    /// <para>    &quot;uniform highp mat4 matrix;\n&quot;</para>
    /// <para>    &quot;void main(void)\n&quot;</para>
    /// <para>    &quot;{\n&quot;</para>
    /// <para>    &quot;   gl_Position = matrix * vertex;\n&quot;</para>
    /// <para>    &quot;}&quot;);</para>
    /// <para>program.addShaderFromSourceCode(QOpenGLShader::Fragment,</para>
    /// <para>    &quot;uniform mediump vec4 color;\n&quot;</para>
    /// <para>    &quot;void main(void)\n&quot;</para>
    /// <para>    &quot;{\n&quot;</para>
    /// <para>    &quot;   gl_FragColor = color;\n&quot;</para>
    /// <para>    &quot;}&quot;);</para>
    /// <para>program.link();</para>
    /// <para>program.bind();</para>
    /// <para></para>
    /// <para>int vertexLocation =
    /// program.attributeLocation(&quot;vertex&quot;);</para>
    /// <para>int matrixLocation =
    /// program.uniformLocation(&quot;matrix&quot;);</para>
    /// <para>int colorLocation =
    /// program.uniformLocation(&quot;color&quot;);</para>
    /// <para>With the above shader program active, we can draw a green
    /// triangle as follows:</para>
    /// <para>static GLfloat const triangleVertices[] = {</para>
    /// <para>    60.0f,  10.0f,  0.0f,</para>
    /// <para>    110.0f, 110.0f, 0.0f,</para>
    /// <para>    10.0f,  110.0f, 0.0f</para>
    /// <para>};</para>
    /// <para></para>
    /// <para>QColor color(0, 255, 0, 255);</para>
    /// <para></para>
    /// <para>QMatrix4x4 pmvMatrix;</para>
    /// <para>pmvMatrix.ortho(rect());</para>
    /// <para></para>
    /// <para>program.enableAttributeArray(vertexLocation);</para>
    /// <para>program.setAttributeArray(vertexLocation, triangleVertices,
    /// 3);</para>
    /// <para>program.setUniformValue(matrixLocation, pmvMatrix);</para>
    /// <para>program.setUniformValue(colorLocation, color);</para>
    /// <para></para>
    /// <para>glDrawArrays(GL_TRIANGLES, 0, 3);</para>
    /// <para></para>
    /// <para>program.disableAttributeArray(vertexLocation);</para>
    /// <para></para>
    /// <para>Binary Shaders and Programs</para>
    /// <para>Binary shaders may be specified using glShaderBinary() on the
    /// return value from QOpenGLShader::shaderId(). The QOpenGLShader instance
    /// containing the binary can then be added to the shader program with
    /// addShader() and linked in the usual fashion with link().</para>
    /// <para>Binary programs may be specified using glProgramBinaryOES() on
    /// the return value from programId(). Then the application should call link(),
    /// which will notice that the program has already been specified and linked,
    /// allowing other operations to be performed on the shader program. The shader
    /// program's id can be explicitly created using the create() function.</para>
    /// <para></para>
    /// <para>See also QOpenGLShader.</para>
    /// </remarks>
    public unsafe partial class QOpenGLShaderProgram : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgramC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgramD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram9addShaderEP13QOpenGLShader")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AddShader_0(global::System.IntPtr instance, global::System.IntPtr shader);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram12removeShaderEP13QOpenGLShader")]
            internal static extern void RemoveShader_0(global::System.IntPtr instance, global::System.IntPtr shader);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram23addShaderFromSourceCodeE6QFlagsIN13QOpenGLShader13ShaderTypeBitEEPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AddShaderFromSourceCode_0(global::System.IntPtr instance, QOpenGLShader.ShaderTypeBit type, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram23addShaderFromSourceCodeE6QFlagsIN13QOpenGLShader13ShaderTypeBitEERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AddShaderFromSourceCode1_0(global::System.IntPtr instance, QOpenGLShader.ShaderTypeBit type, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram23addShaderFromSourceFileE6QFlagsIN13QOpenGLShader13ShaderTypeBitEERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AddShaderFromSourceFile_0(global::System.IntPtr instance, QOpenGLShader.ShaderTypeBit type, global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram16removeAllShadersEv")]
            internal static extern void RemoveAllShaders_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram4bindEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Bind_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram7releaseEv")]
            internal static extern void Release_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram21bindAttributeLocationEPKci")]
            internal static extern void BindAttributeLocation_0(global::System.IntPtr instance, global::System.IntPtr name, int location);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram21bindAttributeLocationERK7QStringi")]
            internal static extern void BindAttributeLocation1_0(global::System.IntPtr instance, global::System.IntPtr name, int location);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram17attributeLocationEPKc")]
            internal static extern int AttributeLocation_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram17attributeLocationERK7QString")]
            internal static extern int AttributeLocation1_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEiRK9QVector2D")]
            internal static extern void SetAttributeValue_4(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEiRK9QVector3D")]
            internal static extern void SetAttributeValue_5(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEiRK9QVector4D")]
            internal static extern void SetAttributeValue_6(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEiRK6QColor")]
            internal static extern void SetAttributeValue_7(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEPKcRK9QVector2D")]
            internal static extern void SetAttributeValue_13(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEPKcRK9QVector3D")]
            internal static extern void SetAttributeValue_14(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEPKcRK9QVector4D")]
            internal static extern void SetAttributeValue_15(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeValueEPKcRK6QColor")]
            internal static extern void SetAttributeValue_16(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeArrayEiPK9QVector2Di")]
            internal static extern void SetAttributeArray_1(global::System.IntPtr instance, int location, global::System.IntPtr values, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeArrayEiPK9QVector3Di")]
            internal static extern void SetAttributeArray_2(global::System.IntPtr instance, int location, global::System.IntPtr values, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeArrayEiPK9QVector4Di")]
            internal static extern void SetAttributeArray_3(global::System.IntPtr instance, int location, global::System.IntPtr values, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeArrayEPKcPK9QVector2Di")]
            internal static extern void SetAttributeArray_6(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeArrayEPKcPK9QVector3Di")]
            internal static extern void SetAttributeArray_7(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram17setAttributeArrayEPKcPK9QVector4Di")]
            internal static extern void SetAttributeArray_8(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20enableAttributeArrayEi")]
            internal static extern void EnableAttributeArray_0(global::System.IntPtr instance, int location);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20enableAttributeArrayEPKc")]
            internal static extern void EnableAttributeArray_1(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram21disableAttributeArrayEi")]
            internal static extern void DisableAttributeArray_0(global::System.IntPtr instance, int location);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram21disableAttributeArrayEPKc")]
            internal static extern void DisableAttributeArray_1(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram15uniformLocationEPKc")]
            internal static extern int UniformLocation_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram15uniformLocationERK7QString")]
            internal static extern int UniformLocation1_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEiRK9QVector2D")]
            internal static extern void SetUniformValue_6(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEiRK9QVector3D")]
            internal static extern void SetUniformValue_7(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEiRK9QVector4D")]
            internal static extern void SetUniformValue_8(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEiRK6QColor")]
            internal static extern void SetUniformValue_9(global::System.IntPtr instance, int location, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEiRK10QMatrix4x4")]
            internal static extern void SetUniformValue_22(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEiRK10QTransform")]
            internal static extern void SetUniformValue_24(global::System.IntPtr instance, int location, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEPKcRK9QVector2D")]
            internal static extern void SetUniformValue_31(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEPKcRK9QVector3D")]
            internal static extern void SetUniformValue_32(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEPKcRK9QVector4D")]
            internal static extern void SetUniformValue_33(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEPKcRK6QColor")]
            internal static extern void SetUniformValue_34(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEPKcRK10QMatrix4x4")]
            internal static extern void SetUniformValue_47(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram15setUniformValueEPKcRK10QTransform")]
            internal static extern void SetUniformValue_49(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEiPK9QVector2Di")]
            internal static extern void SetUniformValueArray_3(global::System.IntPtr instance, int location, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEiPK9QVector3Di")]
            internal static extern void SetUniformValueArray_4(global::System.IntPtr instance, int location, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEiPK9QVector4Di")]
            internal static extern void SetUniformValueArray_5(global::System.IntPtr instance, int location, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEiPK10QMatrix4x4i")]
            internal static extern void SetUniformValueArray_14(global::System.IntPtr instance, int location, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEPKcPK9QVector2Di")]
            internal static extern void SetUniformValueArray_18(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEPKcPK9QVector3Di")]
            internal static extern void SetUniformValueArray_19(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEPKcPK9QVector4Di")]
            internal static extern void SetUniformValueArray_20(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram20setUniformValueArrayEPKcPK10QMatrix4x4i")]
            internal static extern void SetUniformValueArray_29(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN20QOpenGLShaderProgram23hasOpenGLShaderProgramsEP14QOpenGLContext")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasOpenGLShaderPrograms_0(global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram16patchVertexCountEv")]
            internal static extern int PatchVertexCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram19setPatchVertexCountEi")]
            internal static extern void SetPatchVertexCount_0(global::System.IntPtr instance, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram7shadersEv")]
            internal static extern QList.Internal Shaders_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QOpenGLShaderProgram4linkEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Link_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram8isLinkedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsLinked_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram3logEv")]
            internal static extern void Log_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK20QOpenGLShaderProgram25maxGeometryOutputVerticesEv")]
            internal static extern int MaxGeometryOutputVertices_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLShaderProgram __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLShaderProgram((QOpenGLShaderProgram.Internal*) native);
        }

        public static QOpenGLShaderProgram __CreateInstance(QOpenGLShaderProgram.Internal native)
        {
            return new QOpenGLShaderProgram(native);
        }

        private static QOpenGLShaderProgram.Internal* __CopyValue(QOpenGLShaderProgram.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLShaderProgram.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLShaderProgram.Internal*) ret;
        }

        private QOpenGLShaderProgram(QOpenGLShaderProgram.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLShaderProgram(QOpenGLShaderProgram.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Adds a compiled shader to this shader program. Returns true if
        /// the shader could be added, or false otherwise.</para>
        /// <para>Ownership of the shader object remains with the caller. It will
        /// not be deleted when this QOpenGLShaderProgram instance is deleted. This
        /// allows the caller to add the same shader to multiple shader
        /// programs.</para>
        /// <para>See also addShaderFromSourceCode(), addShaderFromSourceFile(),
        /// removeShader(), link(), and removeAllShaders().</para>
        /// </summary>
        public bool AddShader(QOpenGLShader shader)
        {
            var arg0 = ReferenceEquals(shader, null) ? global::System.IntPtr.Zero : shader.__Instance;
            var __ret = Internal.AddShader_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Removes shader from this shader program. The object is not
        /// deleted.</para>
        /// <para>The shader program must be valid in the current
        /// QOpenGLContext.</para>
        /// <para>See also addShader(), link(), and removeAllShaders().</para>
        /// </summary>
        public void RemoveShader(QOpenGLShader shader)
        {
            var arg0 = ReferenceEquals(shader, null) ? global::System.IntPtr.Zero : shader.__Instance;
            Internal.RemoveShader_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Compiles source as a shader of the specified type and adds it to
        /// this shader program. Returns true if compilation was successful, false
        /// otherwise. The compilation errors and warnings will be made available via
        /// log().</para>
        /// <para>This function is intended to be a short-cut for quickly adding
        /// vertex and fragment shaders to a shader program without creating an
        /// instance of QOpenGLShader first.</para>
        /// <para>See also addShader(), addShaderFromSourceFile(), removeShader(),
        /// link(), log(), and removeAllShaders().</para>
        /// </summary>
        public bool AddShaderFromSourceCode(QOpenGLShader.ShaderTypeBit type, string source)
        {
            var arg0 = type;
            var arg1 = Marshal.StringToHGlobalAnsi(source);
            var __ret = Internal.AddShaderFromSourceCode_0(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Compiles source as a shader of the specified type and adds it to
        /// this shader program. Returns true if compilation was successful, false
        /// otherwise. The compilation errors and warnings will be made available via
        /// log().</para>
        /// <para>This function is intended to be a short-cut for quickly adding
        /// vertex and fragment shaders to a shader program without creating an
        /// instance of QOpenGLShader first.</para>
        /// <para>See also addShader(), addShaderFromSourceFile(), removeShader(),
        /// link(), log(), and removeAllShaders().</para>
        /// </summary>
        public bool AddShaderFromSourceCode1(QOpenGLShader.ShaderTypeBit type, string source)
        {
            var arg0 = type;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(source).ToPointer(), source.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.AddShaderFromSourceCode1_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Compiles the contents of fileName as a shader of the specified
        /// type and adds it to this shader program. Returns true if compilation was
        /// successful, false otherwise. The compilation errors and warnings will be
        /// made available via log().</para>
        /// <para>This function is intended to be a short-cut for quickly adding
        /// vertex and fragment shaders to a shader program without creating an
        /// instance of QOpenGLShader first.</para>
        /// <para>See also addShader() and addShaderFromSourceCode().</para>
        /// </summary>
        public bool AddShaderFromSourceFile(QOpenGLShader.ShaderTypeBit type, string fileName)
        {
            var arg0 = type;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.AddShaderFromSourceFile_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Removes all of the shaders that were added to this program
        /// previously. The QOpenGLShader objects for the shaders will not be deleted
        /// if they were constructed externally. QOpenGLShader objects that are
        /// constructed internally by QOpenGLShaderProgram will be deleted.</para>
        /// <para>See also addShader() and removeShader().</para>
        /// </summary>
        public void RemoveAllShaders()
        {
            Internal.RemoveAllShaders_0(__Instance);
        }

        /// <summary>
        /// <para>Binds this shader program to the active QOpenGLContext and makes
        /// it the current shader program. Any previously bound shader program is
        /// released. This is equivalent to calling glUseProgram() on programId().
        /// Returns true if the program was successfully bound; false otherwise. If the
        /// shader program has not yet been linked, or it needs to be re-linked, this
        /// function will call link().</para>
        /// <para>See also link() and release().</para>
        /// </summary>
        public bool Bind()
        {
            var __ret = Internal.Bind_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Releases the active shader program from the current
        /// QOpenGLContext. This is equivalent to calling glUseProgram(0).</para>
        /// <para>See also bind().</para>
        /// </summary>
        public void Release()
        {
            Internal.Release_0(__Instance);
        }

        /// <summary>
        /// <para>Requests the shader program's id to be created immediately.
        /// Returns true if successful; false otherwise.</para>
        /// <para>This function is primarily useful when combining
        /// QOpenGLShaderProgram with other OpenGL functions that operate directly on
        /// the shader program id, like GL_OES_get_program_binary.</para>
        /// <para>When the shader program is used normally, the shader program's id
        /// will be created on demand.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also programId().</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Binds the attribute name to the specified location. This function
        /// can be called before or after the program has been linked. Any attributes
        /// that have not been explicitly bound when the program is linked will be
        /// assigned locations automatically.</para>
        /// <para>When this function is called after the program has been linked,
        /// the program will need to be relinked for the change to take effect.</para>
        /// <para>See also attributeLocation().</para>
        /// </summary>
        public void BindAttributeLocation(string name, int location)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            Internal.BindAttributeLocation_0(__Instance, arg0, location);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Binds the attribute name to the specified location. This function
        /// can be called before or after the program has been linked. Any attributes
        /// that have not been explicitly bound when the program is linked will be
        /// assigned locations automatically.</para>
        /// <para>When this function is called after the program has been linked,
        /// the program will need to be relinked for the change to take effect.</para>
        /// <para>See also attributeLocation().</para>
        /// </summary>
        public void BindAttributeLocation1(string name, int location)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.BindAttributeLocation1_0(__Instance, arg0, location);
        }

        /// <summary>
        /// <para>Returns the location of the attribute name within this shader
        /// program's parameter list. Returns -1 if name is not a valid attribute for
        /// this shader program.</para>
        /// <para>See also uniformLocation() and bindAttributeLocation().</para>
        /// </summary>
        public int AttributeLocation(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = Internal.AttributeLocation_0(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the location of the attribute name within this shader
        /// program's parameter list. Returns -1 if name is not a valid attribute for
        /// this shader program.</para>
        /// <para>See also uniformLocation() and bindAttributeLocation().</para>
        /// </summary>
        public int AttributeLocation1(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.AttributeLocation1_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the attribute at location in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(int location, QVector2D value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_4(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the attribute at location in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(int location, QVector3D value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_5(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the attribute at location in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(int location, QVector4D value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_6(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the attribute at location in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(int location, QColor value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_7(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the attribute called name in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(string name, QVector2D value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_13(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the attribute called name in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(string name, QVector3D value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_14(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the attribute called name in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(string name, QVector4D value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_15(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the attribute called name in the current context to
        /// value.</para>
        /// <para>See also setUniformValue().</para>
        /// </summary>
        public void SetAttributeValue(string name, QColor value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetAttributeValue_16(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>Sets an array of 2D vertex values on the attribute at location in
        /// this shader program. The stride indicates the number of bytes between
        /// vertices. A default stride value of zero indicates that the vertices are
        /// densely packed in values.</para>
        /// <para>The array will become active when enableAttributeArray() is
        /// called on the location. Otherwise the value specified with
        /// setAttributeValue() for location will be used.</para>
        /// <para>See also setAttributeValue(), setUniformValue(),
        /// enableAttributeArray(), and disableAttributeArray().</para>
        /// </summary>
        public void SetAttributeArray(int location, QVector2D values, int stride = 0)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetAttributeArray_1(__Instance, location, arg1, stride);
        }

        /// <summary>
        /// <para>Sets an array of 3D vertex values on the attribute at location in
        /// this shader program. The stride indicates the number of bytes between
        /// vertices. A default stride value of zero indicates that the vertices are
        /// densely packed in values.</para>
        /// <para>The array will become active when enableAttributeArray() is
        /// called on the location. Otherwise the value specified with
        /// setAttributeValue() for location will be used.</para>
        /// <para>See also setAttributeValue(), setUniformValue(),
        /// enableAttributeArray(), and disableAttributeArray().</para>
        /// </summary>
        public void SetAttributeArray(int location, QVector3D values, int stride = 0)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetAttributeArray_2(__Instance, location, arg1, stride);
        }

        /// <summary>
        /// <para>Sets an array of 4D vertex values on the attribute at location in
        /// this shader program. The stride indicates the number of bytes between
        /// vertices. A default stride value of zero indicates that the vertices are
        /// densely packed in values.</para>
        /// <para>The array will become active when enableAttributeArray() is
        /// called on the location. Otherwise the value specified with
        /// setAttributeValue() for location will be used.</para>
        /// <para>See also setAttributeValue(), setUniformValue(),
        /// enableAttributeArray(), and disableAttributeArray().</para>
        /// </summary>
        public void SetAttributeArray(int location, QVector4D values, int stride = 0)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetAttributeArray_3(__Instance, location, arg1, stride);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets an array of 2D vertex values on the attribute called name in
        /// this shader program. The stride indicates the number of bytes between
        /// vertices. A default stride value of zero indicates that the vertices are
        /// densely packed in values.</para>
        /// <para>The array will become active when enableAttributeArray() is
        /// called on name. Otherwise the value specified with setAttributeValue() for
        /// name will be used.</para>
        /// <para>See also setAttributeValue(), setUniformValue(),
        /// enableAttributeArray(), and disableAttributeArray().</para>
        /// </summary>
        public void SetAttributeArray(string name, QVector2D values, int stride = 0)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetAttributeArray_6(__Instance, arg0, arg1, stride);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets an array of 3D vertex values on the attribute called name in
        /// this shader program. The stride indicates the number of bytes between
        /// vertices. A default stride value of zero indicates that the vertices are
        /// densely packed in values.</para>
        /// <para>The array will become active when enableAttributeArray() is
        /// called on name. Otherwise the value specified with setAttributeValue() for
        /// name will be used.</para>
        /// <para>See also setAttributeValue(), setUniformValue(),
        /// enableAttributeArray(), and disableAttributeArray().</para>
        /// </summary>
        public void SetAttributeArray(string name, QVector3D values, int stride = 0)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetAttributeArray_7(__Instance, arg0, arg1, stride);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets an array of 4D vertex values on the attribute called name in
        /// this shader program. The stride indicates the number of bytes between
        /// vertices. A default stride value of zero indicates that the vertices are
        /// densely packed in values.</para>
        /// <para>The array will become active when enableAttributeArray() is
        /// called on name. Otherwise the value specified with setAttributeValue() for
        /// name will be used.</para>
        /// <para>See also setAttributeValue(), setUniformValue(),
        /// enableAttributeArray(), and disableAttributeArray().</para>
        /// </summary>
        public void SetAttributeArray(string name, QVector4D values, int stride = 0)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetAttributeArray_8(__Instance, arg0, arg1, stride);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>Enables the vertex array at location in this shader program so
        /// that the value set by setAttributeArray() on location will be used by the
        /// shader program.</para>
        /// <para>See also disableAttributeArray(), setAttributeArray(),
        /// setAttributeValue(), and setUniformValue().</para>
        /// </summary>
        public void EnableAttributeArray(int location)
        {
            Internal.EnableAttributeArray_0(__Instance, location);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Enables the vertex array called name in this shader program so
        /// that the value set by setAttributeArray() on name will be used by the
        /// shader program.</para>
        /// <para>See also disableAttributeArray(), setAttributeArray(),
        /// setAttributeValue(), and setUniformValue().</para>
        /// </summary>
        public void EnableAttributeArray(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            Internal.EnableAttributeArray_1(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>Disables the vertex array at location in this shader program that
        /// was enabled by a previous call to enableAttributeArray().</para>
        /// <para>See also enableAttributeArray(), setAttributeArray(),
        /// setAttributeValue(), and setUniformValue().</para>
        /// </summary>
        public void DisableAttributeArray(int location)
        {
            Internal.DisableAttributeArray_0(__Instance, location);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Disables the vertex array called name in this shader program that
        /// was enabled by a previous call to enableAttributeArray().</para>
        /// <para>See also enableAttributeArray(), setAttributeArray(),
        /// setAttributeValue(), and setUniformValue().</para>
        /// </summary>
        public void DisableAttributeArray(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            Internal.DisableAttributeArray_1(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>Returns the location of the uniform variable name within this
        /// shader program's parameter list. Returns -1 if name is not a valid uniform
        /// variable for this shader program.</para>
        /// <para>See also attributeLocation().</para>
        /// </summary>
        public int UniformLocation(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = Internal.UniformLocation_0(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the location of the uniform variable name within this
        /// shader program's parameter list. Returns -1 if name is not a valid uniform
        /// variable for this shader program.</para>
        /// <para>See also attributeLocation().</para>
        /// </summary>
        public int UniformLocation1(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.UniformLocation1_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the uniform variable at location in the current context to
        /// value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(int location, QVector2D value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_6(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the uniform variable at location in the current context to
        /// value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(int location, QVector3D value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_7(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the uniform variable at location in the current context to
        /// value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(int location, QVector4D value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_8(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the uniform variable at location in the current context to
        /// the red, green, blue, and alpha components of color.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(int location, QColor color)
        {
            var arg1 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.SetUniformValue_9(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the uniform variable at location in the current context to a
        /// 4x4 matrix value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(int location, QMatrix4x4 value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_22(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>Sets the uniform variable at location in the current context to a
        /// 3x3 transformation matrix value that is specified as a QTransform
        /// value.</para>
        /// <para>To set a QTransform value as a 4x4 matrix in a shader, use
        /// setUniformValue(location, QMatrix4x4(value)).</para>
        /// </summary>
        public void SetUniformValue(int location, QTransform value)
        {
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_24(__Instance, location, arg1);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable called name in the current context to
        /// value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(string name, QVector2D value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_31(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable called name in the current context to
        /// value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(string name, QVector3D value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_32(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable called name in the current context to
        /// value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(string name, QVector4D value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_33(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable called name in the current context to
        /// the red, green, blue, and alpha components of color.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(string name, QColor color)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.SetUniformValue_34(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable called name in the current context to a
        /// 4x4 matrix value.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValue(string name, QMatrix4x4 value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_47(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable called name in the current context to a
        /// 3x3 transformation matrix value that is specified as a QTransform
        /// value.</para>
        /// <para>To set a QTransform value as a 4x4 matrix in a shader, use
        /// setUniformValue(name, QMatrix4x4(value)).</para>
        /// </summary>
        public void SetUniformValue(string name, QTransform value)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            Internal.SetUniformValue_49(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>Sets the uniform variable array at location in the current
        /// context to the count 2D vector elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(int location, QVector2D values, int count)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_3(__Instance, location, arg1, count);
        }

        /// <summary>
        /// <para>Sets the uniform variable array at location in the current
        /// context to the count 3D vector elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(int location, QVector3D values, int count)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_4(__Instance, location, arg1, count);
        }

        /// <summary>
        /// <para>Sets the uniform variable array at location in the current
        /// context to the count 4D vector elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(int location, QVector4D values, int count)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_5(__Instance, location, arg1, count);
        }

        /// <summary>
        /// <para>Sets the uniform variable array at location in the current
        /// context to the count 4x4 matrix elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(int location, QMatrix4x4 values, int count)
        {
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_14(__Instance, location, arg1, count);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable array called name in the current
        /// context to the count 2D vector elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(string name, QVector2D values, int count)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_18(__Instance, arg0, arg1, count);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable array called name in the current
        /// context to the count 3D vector elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(string name, QVector3D values, int count)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_19(__Instance, arg0, arg1, count);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable array called name in the current
        /// context to the count 4D vector elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(string name, QVector4D values, int count)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_20(__Instance, arg0, arg1, count);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the uniform variable array called name in the current
        /// context to the count 4x4 matrix elements of values.</para>
        /// <para>See also setAttributeValue().</para>
        /// </summary>
        public void SetUniformValueArray(string name, QMatrix4x4 values, int count)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(values, null) ? global::System.IntPtr.Zero : values.__Instance;
            Internal.SetUniformValueArray_29(__Instance, arg0, arg1, count);
            Marshal.FreeHGlobal(arg0);
        }

        /// <summary>
        /// <para>Returns true if shader programs written in the OpenGL Shading
        /// Language (GLSL) are supported on this system; false otherwise.</para>
        /// <para>The context is used to resolve the GLSL extensions. If context is
        /// null, then QOpenGLContext::currentContext() is used.</para>
        /// </summary>
        public static bool HasOpenGLShaderPrograms(QOpenGLContext context = null)
        {
            var arg0 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            var __ret = Internal.HasOpenGLShaderPrograms_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the number of vertices per-patch to be used when
        /// rendering.</para>
        /// <para>Note: This returns the global OpenGL state value. It is not
        /// specific to this QOpenGLShaderProgram instance.See also
        /// setPatchVertexCount().</para>
        /// <para></para>
        /// <para>Use this function to specify to OpenGL the number of vertices in
        /// a patch to count. A patch is a custom OpenGL primitive whose interpretation
        /// is entirely defined by the tessellation shader stages. Therefore, calling
        /// this function only makes sense when using a QOpenGLShaderProgram containing
        /// tessellation stage shaders. When using OpenGL tessellation, the only
        /// primitive that can be rendered with glDraw*() functions is
        /// GL_PATCHES.</para>
        /// <para>This is equivalent to calling
        /// glPatchParameteri(GL_PATCH_VERTICES, count).</para>
        /// <para>Note: This modifies global OpenGL state and is not specific to
        /// this QOpenGLShaderProgram instance. You should call this in your render
        /// function when needed, as QOpenGLShaderProgram will not apply this for you.
        /// This is purely a convenience function.See also patchVertexCount().</para>
        /// </summary>
        public int PatchVertexCount
        {
            get
            {
                var __ret = Internal.PatchVertexCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetPatchVertexCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns a list of all shaders that have been added to this shader
        /// program using addShader().</para>
        /// <para>See also addShader() and removeShader().</para>
        /// </summary>
        public System.Collections.Generic.IList<QOpenGLShader> Shaders
        {
            get
            {
                var __ret = Internal.Shaders_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QOpenGLShader>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QOpenGLShader.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>Links together the shaders that were added to this program with
        /// addShader(). Returns true if the link was successful or false otherwise. If
        /// the link failed, the error messages can be retrieved with log().</para>
        /// <para>Subclasses can override this function to initialize attributes
        /// and uniform variables for use in specific shader programs.</para>
        /// <para>If the shader program was already linked, calling this function
        /// again will force it to be re-linked.</para>
        /// <para>See also addShader() and log().</para>
        /// </summary>
        public virtual bool Link
        {
            get
            {
                var __ret = Internal.Link_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this shader program has been linked; false
        /// otherwise.</para>
        /// <para>See also link().</para>
        /// </summary>
        public bool IsLinked
        {
            get
            {
                var __ret = Internal.IsLinked_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the errors and warnings that occurred during the last
        /// link() or addShader() with explicitly specified source code.</para>
        /// <para>See also link().</para>
        /// </summary>
        public string Log
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Log_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the hardware limit for how many vertices a geometry
        /// shader can output.</para>
        /// </summary>
        public int MaxGeometryOutputVertices
        {
            get
            {
                var __ret = Internal.MaxGeometryOutputVertices_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~QOpenGLShaderProgram()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLShaderProgram) _References[instance].Target;
            target.Dispose();
        }

        // bool link()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _Link_0Delegate(global::System.IntPtr instance);
        private static _Link_0Delegate _Link_0DelegateInstance;

        private static bool _Link_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLShaderProgram) _References[instance].Target;
            var _ret = target.Link;
            return _ret;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Link_0DelegateInstance += _Link_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Link_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(12 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLTexture class encapsulates an OpenGL texture
    /// object.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QOpenGLTexture makes it easy to work with OpenGL textures and the
    /// myriad features and targets that they offer depending upon the capabilities
    /// of your OpenGL implementation.</para>
    /// <para>The typical usage pattern for QOpenGLTexture is</para>
    /// <para></para>
    /// <para>Instantiate the object specifying the texture target type</para>
    /// <para>Set properties that affect the storage requirements e.g. storage
    /// format, dimensions</para>
    /// <para>Allocate the server-side storage</para>
    /// <para>Optionally upload pixel data</para>
    /// <para>Optionally set any additional properties e.g. filtering and
    /// border options</para>
    /// <para>Render with texture or render to texture</para>
    /// <para></para>
    /// <para>In the common case of simply using a QImage as the source of
    /// texture pixel data most of the above steps are performed
    /// automatically.</para>
    /// <para>// Prepare texture</para>
    /// <para>QOpenGLTexture *texture = new
    /// QOpenGLTexture(QImage(fileName).mirrored());</para>
    ///
    /// <para>texture-&gt;setMinificationFilter(QOpenGLTexture::LinearMipMapLinear)
    /// ;</para>
    ///
    /// <para>texture-&gt;setMagnificationFilter(QOpenGLTexture::Linear);</para>
    /// <para>...</para>
    /// <para>// Render with texture</para>
    /// <para>texture-&gt;bind();</para>
    /// <para>glDrawArrays(...);</para>
    /// <para>Note that the QImage is mirrored vertically to account for the
    /// fact that OpenGL and QImage use opposite directions for the y axis. Another
    /// option would be to transform your texture coordinates.</para>
    /// </remarks>
    public unsafe partial class QOpenGLTexture : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QScopedPointer.Internal d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTextureC2ENS_6TargetE")]
            internal static extern void ctor_0(global::System.IntPtr instance, QOpenGLTexture.Target target);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTextureC2ERK6QImageNS_16MipMapGenerationE")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr image, QOpenGLTexture.MipMapGeneration genMipMaps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTextureC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTextureD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture4bindEv")]
            internal static extern void Bind_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7releaseEv")]
            internal static extern void Release_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture7isBoundEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsBound_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setSizeEiii")]
            internal static extern void SetSize_0(global::System.IntPtr instance, int width, int height, int depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture15allocateStorageEv")]
            internal static extern void AllocateStorage_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture17createTextureViewENS_6TargetENS_13TextureFormatEiiii")]
            internal static extern global::System.IntPtr CreateTextureView_0(global::System.IntPtr instance, QOpenGLTexture.Target target, QOpenGLTexture.TextureFormat viewFormat, int minimumMipmapLevel, int maximumMipmapLevel, int minimumLayer, int maximumLayer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataEiiNS_11CubeMapFaceENS_11PixelFormatENS_9PixelTypeEPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData_0(global::System.IntPtr instance, int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataEiiNS_11PixelFormatENS_9PixelTypeEPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData_1(global::System.IntPtr instance, int mipLevel, int layer, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataEiNS_11PixelFormatENS_9PixelTypeEPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData_2(global::System.IntPtr instance, int mipLevel, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataENS_11PixelFormatENS_9PixelTypeEPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData_3(global::System.IntPtr instance, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataEiiNS_11CubeMapFaceENS_11PixelFormatENS_9PixelTypeEPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData1_0(global::System.IntPtr instance, int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataEiiNS_11PixelFormatENS_9PixelTypeEPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData1_1(global::System.IntPtr instance, int mipLevel, int layer, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataEiNS_11PixelFormatENS_9PixelTypeEPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData1_2(global::System.IntPtr instance, int mipLevel, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataENS_11PixelFormatENS_9PixelTypeEPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetData1_3(global::System.IntPtr instance, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiiNS_11CubeMapFaceEiPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData_0(global::System.IntPtr instance, int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiiiPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData_1(global::System.IntPtr instance, int mipLevel, int layer, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiiPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData_2(global::System.IntPtr instance, int mipLevel, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiPvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData_3(global::System.IntPtr instance, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiiNS_11CubeMapFaceEiPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData1_0(global::System.IntPtr instance, int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiiiPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData1_1(global::System.IntPtr instance, int mipLevel, int layer, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiiPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData1_2(global::System.IntPtr instance, int mipLevel, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture17setCompressedDataEiPKvPK27QOpenGLPixelTransferOptions")]
            internal static extern void SetCompressedData1_3(global::System.IntPtr instance, int dataSize, global::System.IntPtr data, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture7setDataERK6QImageNS_16MipMapGenerationE")]
            internal static extern void SetData_4(global::System.IntPtr instance, global::System.IntPtr image, QOpenGLTexture.MipMapGeneration genMipMaps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14QOpenGLTexture10hasFeatureENS_7FeatureE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasFeature_0(QOpenGLTexture.Feature feature);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture16setMipLevelRangeEii")]
            internal static extern void SetMipLevelRange_0(global::System.IntPtr instance, int baseLevel, int maxLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture15generateMipMapsEv")]
            internal static extern void GenerateMipMaps_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture15generateMipMapsEib")]
            internal static extern void GenerateMipMaps_1(global::System.IntPtr instance, int baseLevel, bool resetBaseLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture14setSwizzleMaskENS_16SwizzleComponentENS_12SwizzleValueE")]
            internal static extern void SetSwizzleMask_0(global::System.IntPtr instance, QOpenGLTexture.SwizzleComponent component, QOpenGLTexture.SwizzleValue value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture14setSwizzleMaskENS_12SwizzleValueES0_S0_S0_")]
            internal static extern void SetSwizzleMask_1(global::System.IntPtr instance, QOpenGLTexture.SwizzleValue r, QOpenGLTexture.SwizzleValue g, QOpenGLTexture.SwizzleValue b, QOpenGLTexture.SwizzleValue a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture11swizzleMaskENS_16SwizzleComponentE")]
            internal static extern QOpenGLTexture.SwizzleValue SwizzleMask_0(global::System.IntPtr instance, QOpenGLTexture.SwizzleComponent component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture16setMinMagFiltersENS_6FilterES0_")]
            internal static extern void SetMinMagFilters_0(global::System.IntPtr instance, QOpenGLTexture.Filter minificationFilter, QOpenGLTexture.Filter magnificationFilter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture11setWrapModeENS_8WrapModeE")]
            internal static extern void SetWrapMode_0(global::System.IntPtr instance, QOpenGLTexture.WrapMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture11setWrapModeENS_19CoordinateDirectionENS_8WrapModeE")]
            internal static extern void SetWrapMode_1(global::System.IntPtr instance, QOpenGLTexture.CoordinateDirection direction, QOpenGLTexture.WrapMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture8wrapModeENS_19CoordinateDirectionE")]
            internal static extern QOpenGLTexture.WrapMode wrapMode_0(global::System.IntPtr instance, QOpenGLTexture.CoordinateDirection direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture14setBorderColorEffff")]
            internal static extern void SetBorderColor_1(global::System.IntPtr instance, float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture14setBorderColorEiiii")]
            internal static extern void SetBorderColor_2(global::System.IntPtr instance, int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture11borderColorEPf")]
            internal static extern void GetBorderColor_0(global::System.IntPtr instance, float* border);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture11borderColorEPi")]
            internal static extern void GetBorderColor_1(global::System.IntPtr instance, int* border);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture11borderColorEPj")]
            internal static extern void GetBorderColor_2(global::System.IntPtr instance, uint* border);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture21setLevelOfDetailRangeEff")]
            internal static extern void SetLevelOfDetailRange_0(global::System.IntPtr instance, float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture6formatEv")]
            internal static extern QOpenGLTexture.TextureFormat Format_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture9setFormatENS_13TextureFormatE")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, QOpenGLTexture.TextureFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture9mipLevelsEv")]
            internal static extern int MipLevels_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture12setMipLevelsEi")]
            internal static extern void SetMipLevels_0(global::System.IntPtr instance, int levels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture6layersEv")]
            internal static extern int Layers_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture9setLayersEi")]
            internal static extern void SetLayers_0(global::System.IntPtr instance, int layers);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture7samplesEv")]
            internal static extern int Samples_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture10setSamplesEi")]
            internal static extern void SetSamples_0(global::System.IntPtr instance, int samples);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture22isFixedSamplePositionsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool FixedSamplePositions_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture23setFixedSamplePositionsEb")]
            internal static extern void SetFixedSamplePositions_0(global::System.IntPtr instance, bool @fixed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture12mipBaseLevelEv")]
            internal static extern int MipBaseLevel_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture15setMipBaseLevelEi")]
            internal static extern void SetMipBaseLevel_0(global::System.IntPtr instance, int baseLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture11mipMaxLevelEv")]
            internal static extern int MipMaxLevel_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture14setMipMaxLevelEi")]
            internal static extern void SetMipMaxLevel_0(global::System.IntPtr instance, int maxLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture29isAutoMipMapGenerationEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AutoMipMapGenerationEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture30setAutoMipMapGenerationEnabledEb")]
            internal static extern void SetAutoMipMapGenerationEnabled_0(global::System.IntPtr instance, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture16depthStencilModeEv")]
            internal static extern QOpenGLTexture.DepthStencilMode depthStencilMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture19setDepthStencilModeENS_16DepthStencilModeE")]
            internal static extern void SetDepthStencilMode_0(global::System.IntPtr instance, QOpenGLTexture.DepthStencilMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture18minificationFilterEv")]
            internal static extern QOpenGLTexture.Filter MinificationFilter_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture21setMinificationFilterENS_6FilterE")]
            internal static extern void SetMinificationFilter_0(global::System.IntPtr instance, QOpenGLTexture.Filter filter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture19magnificationFilterEv")]
            internal static extern QOpenGLTexture.Filter MagnificationFilter_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture22setMagnificationFilterENS_6FilterE")]
            internal static extern void SetMagnificationFilter_0(global::System.IntPtr instance, QOpenGLTexture.Filter filter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture17maximumAnisotropyEv")]
            internal static extern float MaximumAnisotropy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture20setMaximumAnisotropyEf")]
            internal static extern void SetMaximumAnisotropy_0(global::System.IntPtr instance, float anisotropy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture11borderColorEv")]
            internal static extern void BorderColor_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture14setBorderColorE6QColor")]
            internal static extern void SetBorderColor_0(global::System.IntPtr instance, QColor.Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture20minimumLevelOfDetailEv")]
            internal static extern float MinimumLevelOfDetail_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture23setMinimumLevelOfDetailEf")]
            internal static extern void SetMinimumLevelOfDetail_0(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture20maximumLevelOfDetailEv")]
            internal static extern float MaximumLevelOfDetail_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture23setMaximumLevelOfDetailEf")]
            internal static extern void SetMaximumLevelOfDetail_0(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture17levelofDetailBiasEv")]
            internal static extern float LevelofDetailBias_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QOpenGLTexture20setLevelofDetailBiasEf")]
            internal static extern void SetLevelofDetailBias_0(global::System.IntPtr instance, float bias);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture6targetEv")]
            internal static extern QOpenGLTexture.Target target_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture9isCreatedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCreated_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture5widthEv")]
            internal static extern int Width_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture6heightEv")]
            internal static extern int Height_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture5depthEv")]
            internal static extern int Depth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture16maximumMipLevelsEv")]
            internal static extern int MaximumMipLevels_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture5facesEv")]
            internal static extern int Faces_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture18isStorageAllocatedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsStorageAllocated_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QOpenGLTexture13isTextureViewEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsTextureView_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum defines the texture target of a QOpenGLTexture
        /// object.</para>
        /// </summary>
        public enum Target : uint
        {
            /// <summary>A 1-dimensional texture. Equivalent to GL_TEXTURE_1D.</summary>
            Target1D = 0xde0,
            /// <summary>An array of 1-dimensional textures. Equivalent to GL_TEXTURE_1D_ARRAY</summary>
            Target1DArray = 0x8c18,
            /// <summary>A 2-dimensional texture. Equivalent to GL_TEXTURE_2D</summary>
            Target2D = 0xde1,
            /// <summary>An array of 1-dimensional textures. Equivalent to GL_TEXTURE_2D_ARRAY</summary>
            Target2DArray = 0x8c1a,
            /// <summary>A 3-dimensional texture. Equivalent to GL_TEXTURE_3D</summary>
            Target3D = 0x806f,
            /// <summary>A cubemap texture. Equivalent to GL_TEXTURE_CUBE_MAP</summary>
            TargetCubeMap = 0x8513,
            /// <summary>An array of cubemap textures. Equivalent to GL_TEXTURE_CUBE_MAP_ARRAY</summary>
            TargetCubeMapArray = 0x9009,
            /// <summary>A 2-dimensional texture with multisample support. Equivalent to GL_TEXTURE_2D_MULTISAMPLE</summary>
            Target2DMultisample = 0x9100,
            /// <summary>An array of 2-dimensional textures with multisample support. Equivalent to GL_TEXTURE_2D_MULTISAMPLE_ARRAY</summary>
            Target2DMultisampleArray = 0x9102,
            /// <summary>A rectangular 2-dimensional texture. Equivalent to GL_TEXTURE_RECTANGLE</summary>
            TargetRectangle = 0x84f5,
            /// <summary>A texture with data from an OpenGL buffer object. Equivalent to GL_TEXTURE_BUFFER</summary>
            TargetBuffer = 0x8c2a
        }

        /// <summary>
        /// <para>This enum defines the possible binding targets of texture
        /// units.</para>
        /// </summary>
        public enum BindingTarget : uint
        {
            /// <summary>Equivalent to GL_TEXTURE_BINDING_1D</summary>
            BindingTarget1D = 0x8068,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_1D_ARRAY</summary>
            BindingTarget1DArray = 0x8c1c,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_2D</summary>
            BindingTarget2D = 0x8069,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_2D_ARRAY</summary>
            BindingTarget2DArray = 0x8c1d,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_3D</summary>
            BindingTarget3D = 0x806a,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_CUBE_MAP</summary>
            BindingTargetCubeMap = 0x8514,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_CUBE_MAP_ARRAY</summary>
            BindingTargetCubeMapArray = 0x900a,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE</summary>
            BindingTarget2DMultisample = 0x9104,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY</summary>
            BindingTarget2DMultisampleArray = 0x9105,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_RECTANGLE</summary>
            BindingTargetRectangle = 0x84f6,
            /// <summary>Equivalent to GL_TEXTURE_BINDING_BUFFER</summary>
            BindingTargetBuffer = 0x8c2c
        }

        /// <summary>
        /// <para>This enum defines the options to control mipmap
        /// generation.</para>
        /// </summary>
        public enum MipMapGeneration : uint
        {
            /// <summary>Mipmaps should be generated</summary>
            GenerateMipMaps = 0,
            /// <summary>Mipmaps should not be generated</summary>
            DontGenerateMipMaps = 1
        }

        /// <summary>
        /// <para>This enum defines options ot control texture unit
        /// activation.</para>
        /// </summary>
        public enum TextureUnitReset : uint
        {
            /// <summary>The previous active texture unit will be reset</summary>
            ResetTextureUnit = 0,
            /// <summary>The previous active texture unit will not be rest</summary>
            DontResetTextureUnit = 1
        }

        /// <summary>
        /// <para>This enum defines the possible texture formats. Depending upon
        /// your OpenGL implementation only a subset of these may be supported.</para>
        /// </summary>
        public enum TextureFormat : uint
        {
            /// <summary>Equivalent to GL_NONE</summary>
            NoFormat = 0,
            /// <summary>Equivalent to GL_R8</summary>
            R8_UNorm = 0x8229,
            /// <summary>Equivalent to GL_RG8</summary>
            RG8_UNorm = 0x822b,
            /// <summary>Equivalent to GL_RGB8</summary>
            RGB8_UNorm = 0x8051,
            /// <summary>Equivalent to GL_RGBA8</summary>
            RGBA8_UNorm = 0x8058,
            /// <summary>Equivalent to GL_R16</summary>
            R16_UNorm = 0x822a,
            /// <summary>Equivalent to GL_RG16</summary>
            RG16_UNorm = 0x822c,
            /// <summary>Equivalent to GL_RGB16</summary>
            RGB16_UNorm = 0x8054,
            /// <summary>Equivalent to GL_RGBA16</summary>
            RGBA16_UNorm = 0x805b,
            /// <summary>Equivalent to GL_R8_SNORM</summary>
            R8_SNorm = 0x8f94,
            /// <summary>Equivalent to GL_RG8_SNORM</summary>
            RG8_SNorm = 0x8f95,
            /// <summary>Equivalent to GL_RGB8_SNORM</summary>
            RGB8_SNorm = 0x8f96,
            /// <summary>Equivalent to GL_RGBA8_SNORM</summary>
            RGBA8_SNorm = 0x8f97,
            /// <summary>Equivalent to GL_R16_SNORM</summary>
            R16_SNorm = 0x8f98,
            /// <summary>Equivalent to GL_RG16_SNORM</summary>
            RG16_SNorm = 0x8f99,
            /// <summary>Equivalent to GL_RGB16_SNORM</summary>
            RGB16_SNorm = 0x8f9a,
            /// <summary>Equivalent to GL_RGBA16_SNORM</summary>
            RGBA16_SNorm = 0x8f9b,
            /// <summary>Equivalent to GL_R8UI</summary>
            R8U = 0x8232,
            /// <summary>Equivalent to GL_RG8UI</summary>
            RG8U = 0x8238,
            /// <summary>Equivalent to GL_RGB8UI</summary>
            RGB8U = 0x8d7d,
            /// <summary>Equivalent to GL_RGBA8UI</summary>
            RGBA8U = 0x8d7c,
            /// <summary>Equivalent to GL_R16UI</summary>
            R16U = 0x8234,
            /// <summary>Equivalent to GL_RG16UI</summary>
            RG16U = 0x823a,
            /// <summary>Equivalent to GL_RGB16UI</summary>
            RGB16U = 0x8d77,
            /// <summary>Equivalent to GL_RGBA16UI</summary>
            RGBA16U = 0x8d76,
            /// <summary>Equivalent to GL_R32UI</summary>
            R32U = 0x8236,
            /// <summary>Equivalent to GL_RG32UI</summary>
            RG32U = 0x823c,
            /// <summary>Equivalent to GL_RGB32UI</summary>
            RGB32U = 0x8d71,
            /// <summary>Equivalent to GL_RGBA32UI</summary>
            RGBA32U = 0x8d70,
            /// <summary>Equivalent to GL_R8I</summary>
            R8I = 0x8231,
            /// <summary>Equivalent to GL_RG8I</summary>
            RG8I = 0x8237,
            /// <summary>Equivalent to GL_RGB8I</summary>
            RGB8I = 0x8d8f,
            /// <summary>Equivalent to GL_RGBA8I</summary>
            RGBA8I = 0x8d8e,
            /// <summary>Equivalent to GL_R16I</summary>
            R16I = 0x8233,
            /// <summary>Equivalent to GL_RG16I</summary>
            RG16I = 0x8239,
            /// <summary>Equivalent to GL_RGB16I</summary>
            RGB16I = 0x8d89,
            /// <summary>Equivalent to GL_RGBA16I</summary>
            RGBA16I = 0x8d88,
            /// <summary>Equivalent to GL_R32I</summary>
            R32I = 0x8235,
            /// <summary>Equivalent to GL_RG32I</summary>
            RG32I = 0x823b,
            /// <summary>Equivalent to GL_RGB32I</summary>
            RGB32I = 0x8d83,
            /// <summary>Equivalent to GL_RGBA32I</summary>
            RGBA32I = 0x8d82,
            /// <summary>Equivalent to GL_R16F</summary>
            R16F = 0x822d,
            /// <summary>Equivalent to GL_RG16F</summary>
            RG16F = 0x822f,
            /// <summary>Equivalent to GL_RGB16F</summary>
            RGB16F = 0x881b,
            /// <summary>Equivalent to GL_RGBA16F</summary>
            RGBA16F = 0x881a,
            /// <summary>Equivalent to GL_R32F</summary>
            R32F = 0x822e,
            /// <summary>Equivalent to GL_RG32F</summary>
            RG32F = 0x8230,
            /// <summary>Equivalent to GL_RGB32F</summary>
            RGB32F = 0x8815,
            /// <summary>Equivalent to GL_RGBA32F</summary>
            RGBA32F = 0x8814,
            /// <summary>Equivalent to GL_RGB9_E5</summary>
            RGB9E5 = 0x8c3d,
            /// <summary>Equivalent to GL_R11F_G11F_B10F</summary>
            RG11B10F = 0x8c3a,
            /// <summary>Equivalent to GL_R3_G3_B2</summary>
            RG3B2 = 0x2a10,
            /// <summary>Equivalent to GL_RGB565</summary>
            R5G6B5 = 0x8d62,
            /// <summary>Equivalent to GL_RGB5_A1</summary>
            RGB5A1 = 0x8057,
            /// <summary>Equivalent to GL_RGBA4</summary>
            RGBA4 = 0x8056,
            /// <summary>Equivalent to GL_RGB10_A2UI</summary>
            RGB10A2 = 0x906f,
            /// <summary>Equivalent to GL_DEPTH_COMPONENT16</summary>
            D16 = 0x81a5,
            /// <summary>Equivalent to GL_DEPTH_COMPONENT24</summary>
            D24 = 0x81a6,
            /// <summary>Equivalent to GL_DEPTH24_STENCIL8</summary>
            D24S8 = 0x88f0,
            /// <summary>Equivalent to GL_DEPTH_COMPONENT32</summary>
            D32 = 0x81a7,
            /// <summary>Equivalent to GL_DEPTH_COMPONENT32F</summary>
            D32F = 0x8cac,
            /// <summary>Equivalent to GL_DEPTH32F_STENCIL8</summary>
            D32FS8X24 = 0x8cad,
            /// <summary>Equivalent to GL_STENCIL_INDEX8. Introduced in Qt 5.4</summary>
            S8 = 0x8d48,
            /// <summary>Equivalent to GL_COMPRESSED_RGB_S3TC_DXT1_EXT</summary>
            RGB_DXT1 = 0x83f0,
            /// <summary>Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT1_EXT</summary>
            RGBA_DXT1 = 0x83f1,
            /// <summary>Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT3_EXT</summary>
            RGBA_DXT3 = 0x83f2,
            /// <summary>Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT5_EXT</summary>
            RGBA_DXT5 = 0x83f3,
            /// <summary>Equivalent to GL_COMPRESSED_RED_RGTC1</summary>
            R_ATI1N_UNorm = 0x8dbb,
            /// <summary>Equivalent to GL_COMPRESSED_SIGNED_RED_RGTC1</summary>
            R_ATI1N_SNorm = 0x8dbc,
            /// <summary>Equivalent to GL_COMPRESSED_RG_RGTC2</summary>
            RG_ATI2N_UNorm = 0x8dbd,
            /// <summary>Equivalent to GL_COMPRESSED_SIGNED_RG_RGTC2</summary>
            RG_ATI2N_SNorm = 0x8dbe,
            /// <summary>Equivalent to GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB</summary>
            RGB_BP_UNSIGNED_FLOAT = 0x8e8f,
            /// <summary>Equivalent to GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB</summary>
            RGB_BP_SIGNED_FLOAT = 0x8e8e,
            /// <summary>Equivalent to GL_COMPRESSED_RGBA_BPTC_UNORM_ARB</summary>
            RGB_BP_UNorm = 0x8e8c,
            /// <summary>Equivalent to GL_SRGB8</summary>
            SRGB8 = 0x8c41,
            /// <summary>Equivalent to GL_SRGB8_ALPHA8</summary>
            SRGB8_Alpha8 = 0x8c43,
            /// <summary>Equivalent to GL_COMPRESSED_SRGB_S3TC_DXT1_EXT</summary>
            SRGB_DXT1 = 0x8c4c,
            /// <summary>Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT</summary>
            SRGB_Alpha_DXT1 = 0x8c4d,
            /// <summary>Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT</summary>
            SRGB_Alpha_DXT3 = 0x8c4e,
            /// <summary>Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT</summary>
            SRGB_Alpha_DXT5 = 0x8c4f,
            /// <summary>Equivalent to GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB</summary>
            SRGB_BP_UNorm = 0x8e8d,
            /// <summary>Equivalent to GL_DEPTH_COMPONENT (OpenGL ES 2 only and when OES_depth_texture is present)</summary>
            DepthFormat = 0x1902,
            /// <summary>Equivalent to GL_ALPHA (OpenGL ES 2 only)</summary>
            AlphaFormat = 0x1906,
            /// <summary>Equivalent to GL_RGB (OpenGL ES 2 only)</summary>
            RGBFormat = 0x1907,
            /// <summary>Equivalent to GL_RGBA (OpenGL ES 2 only)</summary>
            RGBAFormat = 0x1908,
            /// <summary>Equivalent to GL_LUMINANCE (OpenGL ES 2 only)</summary>
            LuminanceFormat = 0x1909,
            /// <summary>Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)</summary>
            LuminanceAlphaFormat = 0x190a
        }

        public enum TextureFormatClass : uint
        {
            NoFormatClass = 0,
            FormatClass_128Bit = 1,
            FormatClass_96Bit = 2,
            FormatClass_64Bit = 3,
            FormatClass_48Bit = 4,
            FormatClass_32Bit = 5,
            FormatClass_24Bit = 6,
            FormatClass_16Bit = 7,
            FormatClass_8Bit = 8,
            FormatClass_RGTC1_R = 9,
            FormatClass_RGTC2_RG = 10,
            FormatClass_BPTC_Unorm = 11,
            FormatClass_BPTC_Float = 12,
            FormatClass_S3TC_DXT1_RGB = 13,
            FormatClass_S3TC_DXT1_RGBA = 14,
            FormatClass_S3TC_DXT3_RGBA = 15,
            FormatClass_S3TC_DXT5_RGBA = 16,
            FormatClass_Unique = 17
        }

        /// <summary>
        /// <para>This enum defines the possible CubeMap faces.</para>
        /// </summary>
        public enum CubeMapFace : uint
        {
            /// <summary>Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_X</summary>
            CubeMapPositiveX = 0x8515,
            /// <summary>Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_X</summary>
            CubeMapNegativeX = 0x8516,
            /// <summary>Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Y</summary>
            CubeMapPositiveY = 0x8517,
            /// <summary>Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</summary>
            CubeMapNegativeY = 0x8518,
            /// <summary>Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Z</summary>
            CubeMapPositiveZ = 0x8519,
            /// <summary>Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</summary>
            CubeMapNegativeZ = 0x851a
        }

        /// <summary>
        /// <para>This enum defines the possible client-side pixel formats for a
        /// pixel transfer operation.</para>
        /// </summary>
        public enum PixelFormat : uint
        {
            /// <summary>Equivalent to GL_NONE</summary>
            NoSourceFormat = 0,
            /// <summary>Equivalent to GL_RED</summary>
            Red = 0x1903,
            /// <summary>Equivalent to GL_RG</summary>
            RG = 0x8227,
            /// <summary>Equivalent to GL_RGB</summary>
            RGB = 0x1907,
            /// <summary>Equivalent to GL_BGR</summary>
            BGR = 0x80e0,
            /// <summary>Equivalent to GL_RGBA</summary>
            RGBA = 0x1908,
            /// <summary>Equivalent to GL_BGRA</summary>
            BGRA = 0x80e1,
            /// <summary>Equivalent to GL_RED_INTEGER</summary>
            Red_Integer = 0x8d94,
            /// <summary>Equivalent to GL_RG_INTEGER</summary>
            RG_Integer = 0x8228,
            /// <summary>Equivalent to GL_RGB_INTEGER</summary>
            RGB_Integer = 0x8d98,
            /// <summary>Equivalent to GL_BGR_INTEGER</summary>
            BGR_Integer = 0x8d9a,
            /// <summary>Equivalent to GL_RGBA_INTEGER</summary>
            RGBA_Integer = 0x8d99,
            /// <summary>Equivalent to GL_BGRA_INTEGER</summary>
            BGRA_Integer = 0x8d9b,
            /// <summary>Equivalent to GL_STENCIL_INDEX. Introduced in Qt 5.4</summary>
            Stencil = 0x1901,
            /// <summary>Equivalent to GL_DEPTH_COMPONENT</summary>
            Depth = 0x1902,
            /// <summary>Equivalent to GL_DEPTH_STENCIL</summary>
            DepthStencil = 0x84f9,
            /// <summary>Equivalent to GL_ALPHA (OpenGL ES 2 only)</summary>
            Alpha = 0x1906,
            /// <summary>Equivalent to GL_LUMINANCE (OpenGL ES 2 only)</summary>
            Luminance = 0x1909,
            /// <summary>Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)</summary>
            LuminanceAlpha = 0x190a
        }

        /// <summary>
        /// <para>This enum defines the possible pixel data types for a pixel
        /// transfer operation</para>
        /// </summary>
        public enum PixelType : uint
        {
            /// <summary>Equivalent to GL_NONE</summary>
            NoPixelType = 0,
            /// <summary>Equivalent to GL_BYTE</summary>
            Int8 = 0x1400,
            /// <summary>Equivalent to GL_UNSIGNED_BYTE</summary>
            UInt8 = 0x1401,
            /// <summary>Equivalent to GL_SHORT</summary>
            Int16 = 0x1402,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT</summary>
            UInt16 = 0x1403,
            /// <summary>Equivalent to GL_INT</summary>
            Int32 = 0x1404,
            /// <summary>Equivalent to GL_UNSIGNED_INT</summary>
            UInt32 = 0x1405,
            /// <summary>Equivalent to GL_HALF_FLOAT</summary>
            Float16 = 0x140b,
            /// <summary>Equivalent to GL_HALF_FLOAT_OES</summary>
            Float16OES = 0x8d61,
            /// <summary>Equivalent to GL_FLOAT</summary>
            Float32 = 0x1406,
            /// <summary>Equivalent to GL_UNSIGNED_INT_5_9_9_9_REV</summary>
            UInt32_RGB9_E5 = 0x8c3e,
            /// <summary>Equivalent to GL_UNSIGNED_INT_10F_11F_11F_REV</summary>
            UInt32_RG11B10F = 0x8c3b,
            /// <summary>Equivalent to GL_UNSIGNED_BYTE_3_3_2</summary>
            UInt8_RG3B2 = 0x8032,
            /// <summary>Equivalent to GL_UNSIGNED_BYTE_2_3_3_REV</summary>
            UInt8_RG3B2_Rev = 0x8362,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT_5_5_5_1</summary>
            UInt16_RGB5A1 = 0x8034,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT_1_5_5_5_REV</summary>
            UInt16_RGB5A1_Rev = 0x8366,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT_5_6_5</summary>
            UInt16_R5G6B5 = 0x8363,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT_5_6_5_REV</summary>
            UInt16_R5G6B5_Rev = 0x8364,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT_4_4_4_4</summary>
            UInt16_RGBA4 = 0x8033,
            /// <summary>Equivalent to GL_UNSIGNED_SHORT_4_4_4_4_REV</summary>
            UInt16_RGBA4_Rev = 0x8365,
            /// <summary>Equivalent to GL_UNSIGNED_INT_8_8_8_8</summary>
            UInt32_RGBA8 = 0x8035,
            /// <summary>Equivalent to GL_UNSIGNED_INT_8_8_8_8_REV</summary>
            UInt32_RGBA8_Rev = 0x8367,
            /// <summary>Equivalent to GL_UNSIGNED_INT_10_10_10_2</summary>
            UInt32_RGB10A2 = 0x8036,
            /// <summary>Equivalent to GL_UNSIGNED_INT_2_10_10_10_REV</summary>
            UInt32_RGB10A2_Rev = 0x8368,
            /// <summary>Equivalent to GL_UNSIGNED_INT_24_8. Introduced in Qt 5.4</summary>
            UInt32_D24S8 = 0x84fa,
            /// <summary>Equivalent to GL_FLOAT_32_UNSIGNED_INT_24_8_REV. Introduced in Qt 5.4</summary>
            Float32_D32_UInt32_S8_X24 = 0x8dad
        }

        /// <summary>
        /// <para>This enum defines the OpenGL texture-related features that can be
        /// tested for.</para>
        /// </summary>
        [Flags]
        public enum Feature : uint
        {
            /// <summary>Support for immutable texture storage</summary>
            ImmutableStorage = 0x1,
            /// <summary>Support for immutable texture storage with multisample targets</summary>
            ImmutableMultisampleStorage = 0x2,
            /// <summary>Support for the GL_TEXTURE_RECTANGLE target</summary>
            TextureRectangle = 0x4,
            /// <summary>Support for texture targets with array layers</summary>
            TextureArrays = 0x8,
            /// <summary>Support for the 3 dimensional texture target</summary>
            Texture3D = 0x10,
            /// <summary>Support for texture targets that have multisample capabilities</summary>
            TextureMultisample = 0x20,
            /// <summary>Support for textures that use OpenGL buffer objects as their data source</summary>
            TextureBuffer = 0x40,
            /// <summary>Support for cubemap array texture target</summary>
            TextureCubeMapArrays = 0x80,
            /// <summary>Support for texture component swizzle masks</summary>
            Swizzle = 0x100,
            /// <summary>Support for stencil texturing (i.e. looking up depth or stencil components of a combined depth/stencil format texture in GLSL shaders).</summary>
            StencilTexturing = 0x200,
            /// <summary>Support for anisotropic texture filtering</summary>
            AnisotropicFiltering = 0x400,
            /// <summary>Basic support for non-power-of-two textures</summary>
            NPOTTextures = 0x800,
            /// <summary>Full support for non-power-of-two textures including texture repeat modes</summary>
            NPOTTextureRepeat = 0x1000,
            /// <summary>Support for the 1 dimensional texture target</summary>
            Texture1D = 0x2000,
            MaxFeatureFlag = 0x4000
        }

        /// <summary>
        /// <para>This enum defines the texture color components that can be
        /// assigned a swizzle mask.</para>
        /// </summary>
        public enum SwizzleComponent : uint
        {
            /// <summary>The red component. Equivalent to GL_TEXTURE_SWIZZLE_R</summary>
            SwizzleRed = 0x8e42,
            /// <summary>The green component. Equivalent to GL_TEXTURE_SWIZZLE_G</summary>
            SwizzleGreen = 0x8e43,
            /// <summary>The blue component. Equivalent to GL_TEXTURE_SWIZZLE_B</summary>
            SwizzleBlue = 0x8e44,
            /// <summary>The alpha component. Equivalent to GL_TEXTURE_SWIZZLE_A</summary>
            SwizzleAlpha = 0x8e45
        }

        /// <summary>
        /// <para>This enum defines the possible mask values for texture
        /// swizzling.</para>
        /// </summary>
        public enum SwizzleValue : uint
        {
            /// <summary>Maps the component to the red channel. Equivalent to GL_RED</summary>
            RedValue = 0x1903,
            /// <summary>Maps the component to the green channel. Equivalent to GL_GREEN</summary>
            GreenValue = 0x1904,
            /// <summary>Maps the component to the blue channel. Equivalent to GL_BLUE</summary>
            BlueValue = 0x1905,
            /// <summary>Maps the component to the alpha channel. Equivalent to GL_ALPHA</summary>
            AlphaValue = 0x1906,
            /// <summary>Maps the component to a fixed value of 0. Equivalent to GL_ZERO</summary>
            ZeroValue = 0,
            /// <summary>Maps the component to a fixed value of 1. Equivalent to GL_ONE</summary>
            OneValue = 1
        }

        public enum DepthStencilMode : uint
        {
            DepthMode = 0x1902,
            StencilMode = 0x1901
        }

        /// <summary>
        /// <para>This enum defines the filtering parameters for a QOpenGLTexture
        /// object.</para>
        /// </summary>
        public enum Filter : uint
        {
            /// <summary>Equivalent to GL_NEAREST</summary>
            Nearest = 0x2600,
            /// <summary>Equivalent to GL_LINEAR</summary>
            Linear = 0x2601,
            /// <summary>Equivalent to GL_NEAREST_MIPMAP_NEAREST</summary>
            NearestMipMapNearest = 0x2700,
            /// <summary>Equivalent to GL_NEAREST_MIPMAP_LINEAR</summary>
            NearestMipMapLinear = 0x2702,
            /// <summary>Equivalent to GL_LINEAR_MIPMAP_NEAREST</summary>
            LinearMipMapNearest = 0x2701,
            /// <summary>Equivalent to GL_LINEAR_MIPMAP_LINEAR</summary>
            LinearMipMapLinear = 0x2703
        }

        /// <summary>
        /// <para>This enum defines the possible texture coordinate wrapping
        /// modes.</para>
        /// </summary>
        public enum WrapMode : uint
        {
            /// <summary>Texture coordinate is repeated. Equivalent to GL_REPEAT</summary>
            Repeat = 0x2901,
            /// <summary>Texture coordinate is reflected about 0 and 1. Equivalent to GL_MIRRORED_REPEAT</summary>
            MirroredRepeat = 0x8370,
            /// <summary>Clamps the texture coordinates to [0,1]. Equivalent to GL_CLAMP_TO_EDGE</summary>
            ClampToEdge = 0x812f,
            /// <summary>As for ClampToEdge but also blends samples at 0 and 1 with a fixed border color. Equivalent to GL_CLAMP_TO_BORDER</summary>
            ClampToBorder = 0x812d
        }

        /// <summary>
        /// <para>This enum defines the possible texture coordinate
        /// directions</para>
        /// </summary>
        public enum CoordinateDirection : uint
        {
            /// <summary>The horizontal direction. Equivalent to GL_TEXTURE_WRAP_S</summary>
            DirectionS = 0x2802,
            /// <summary>The vertical direction. Equivalent to GL_TEXTURE_WRAP_T</summary>
            DirectionT = 0x2803,
            /// <summary>The depth direction. Equivalent to GL_TEXTURE_WRAP_R</summary>
            DirectionR = 0x8072
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLTexture __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLTexture((QOpenGLTexture.Internal*) native);
        }

        public static QOpenGLTexture __CreateInstance(QOpenGLTexture.Internal native)
        {
            return new QOpenGLTexture(native);
        }

        private static QOpenGLTexture.Internal* __CopyValue(QOpenGLTexture.Internal native)
        {
            var ret = (QOpenGLTexture.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QOpenGLTexture(QOpenGLTexture.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLTexture(QOpenGLTexture.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a QOpenGLTexture object that can later be bound to
        /// target.</para>
        /// <para>This does not create the underlying OpenGL texture object.
        /// Therefore, construction using this constructor does not require a valid
        /// current OpenGL context.</para>
        /// </summary>
        public QOpenGLTexture(QOpenGLTexture.Target target)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = target;
            Internal.ctor_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Creates a QOpenGLTexture object that can later be bound to the 2D
        /// texture target and contains the pixel data contained in image. If you wish
        /// to have a chain of mipmaps generated then set genMipMaps to true (this is
        /// the default).</para>
        /// <para>This does create the underlying OpenGL texture object. Therefore,
        /// construction using this constructor does require a valid current OpenGL
        /// context.</para>
        /// </summary>
        public QOpenGLTexture(QImage image, QOpenGLTexture.MipMapGeneration genMipMaps = QOpenGLTexture.MipMapGeneration.GenerateMipMaps)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var arg1 = genMipMaps;
            Internal.ctor_1(__Instance, arg0, arg1);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Creates the underlying OpenGL texture object. This requires a
        /// current valid OpenGL context. If the texture object already exists, this
        /// function does nothing.</para>
        /// <para>Once the texture object is created you can obtain the object name
        /// from the textureId() function. This may be useful if you wish to make some
        /// raw OpenGL calls related to this texture.</para>
        /// <para>Normally it should not be necessary to call this function
        /// directly as all functions that set properties of the texture object
        /// implicitly call create() on your behalf.</para>
        /// <para>Returns true if the creation succeeded, otherwise returns
        /// false.</para>
        /// <para>See also destroy(), isCreated(), and textureId().</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Destroys the underlying OpenGL texture object. This requires a
        /// current valid OpenGL context.</para>
        /// <para>See also create(), isCreated(), and textureId().</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Binds this texture to the currently active texture unit ready for
        /// rendering. Note that you do not need to bind QOpenGLTexture objects in
        /// order to modify them as the implementation makes use of the
        /// EXT_direct_state_access extension where available and simulates it where it
        /// is not.</para>
        /// <para>See also release().</para>
        /// </summary>
        public void Bind()
        {
            Internal.Bind_0(__Instance);
        }

        /// <summary>
        /// <para>Unbinds this texture from the currently active texture
        /// unit.</para>
        /// <para>See also bind().</para>
        /// </summary>
        public void Release()
        {
            Internal.Release_0(__Instance);
        }

        /// <summary>
        /// <para>Returns true if this texture is bound to the corresponding target
        /// of the currently active texture unit.</para>
        /// <para>See also bind() and release().</para>
        /// </summary>
        public bool IsBound()
        {
            var __ret = Internal.IsBound_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the dimensions of this texture object to width, height, and
        /// depth. The default for each dimension is 1. The maximum allowable texture
        /// size is dependent upon your OpenGL implementation. Allocating storage for a
        /// texture less than the maximum size can still fail if your system is low on
        /// resources.</para>
        /// <para>See also width(), height(), and depth().</para>
        /// </summary>
        public void SetSize(int width, int height = 1, int depth = 1)
        {
            Internal.SetSize_0(__Instance, width, height, depth);
        }

        /// <summary>
        /// <para>Allocates server-side storage for this texture object taking into
        /// account, the format, dimensions, mipmap levels, array layers and cubemap
        /// faces.</para>
        /// <para>Once storage has been allocated it is no longer possible to
        /// change these properties.</para>
        /// <para>If supported QOpenGLTexture makes use of immutable texture
        /// storage.</para>
        /// <para>Once storage has been allocated for the texture then pixel data
        /// can be uploaded via one of the setData() overloads.</para>
        /// <para>See also isStorageAllocated() and setData().</para>
        /// </summary>
        public void AllocateStorage()
        {
            Internal.AllocateStorage_0(__Instance);
        }

        /// <summary>
        /// <para>Attempts to create a texture view onto this texture. A texture
        /// view is somewhat analogous to a view in SQL in that it presents a
        /// restricted or reinterpreted view of the original data. Texture views do not
        /// allocate any more server-side storage, insted relying on the storage buffer
        /// of the source texture.</para>
        /// <para>Texture views are only available when using immutable storage.
        /// For more information on texture views see
        /// http://www.opengl.org/wiki/Texture_Storage#Texture_views.</para>
        /// <para>The target argument specifies the target to use for the view.
        /// Only some targets can be used depending upon the target of the original
        /// target. For e.g. a view onto a Target1DArray texture can specify either
        /// Target1DArray or Target1D but for the latter the number of array layers
        /// specified with minimumLayer and maximumLayer must be exactly 1.</para>
        /// <para>Simpliar constraints apply for the viewFormat. See the above link
        /// and the specification for more details.</para>
        /// <para>The minimumMipmapLevel, maximumMipmapLevel, minimumLayer, and
        /// maximumLayer arguments serve to restrict the parts of the texture
        /// accessible by the texture view.</para>
        /// <para>If creation of the texture view fails this function will return
        /// 0. If the function succeeds it will return a pointer to a new
        /// QOpenGLTexture object that will return true from its isTextureView()
        /// function.</para>
        /// <para>See also isTextureView().</para>
        /// </summary>
        public QOpenGLTexture CreateTextureView(QOpenGLTexture.Target target, QOpenGLTexture.TextureFormat viewFormat, int minimumMipmapLevel, int maximumMipmapLevel, int minimumLayer, int maximumLayer)
        {
            var arg0 = target;
            var arg1 = viewFormat;
            var __ret = Internal.CreateTextureView_0(__Instance, arg0, arg1, minimumMipmapLevel, maximumMipmapLevel, minimumLayer, maximumLayer);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QOpenGLTexture.__CreateInstance(__ret);
        }

        public void SetData(int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = cubeFace;
            var arg3 = sourceFormat;
            var arg4 = sourceType;
            var arg5 = data;
            var arg6 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData_0(__Instance, mipLevel, layer, arg2, arg3, arg4, arg5, arg6);
        }

        public void SetData(int mipLevel, int layer, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = sourceFormat;
            var arg3 = sourceType;
            var arg4 = data;
            var arg5 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData_1(__Instance, mipLevel, layer, arg2, arg3, arg4, arg5);
        }

        public void SetData(int mipLevel, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg1 = sourceFormat;
            var arg2 = sourceType;
            var arg3 = data;
            var arg4 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData_2(__Instance, mipLevel, arg1, arg2, arg3, arg4);
        }

        public void SetData(QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg0 = sourceFormat;
            var arg1 = sourceType;
            var arg2 = data;
            var arg3 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData_3(__Instance, arg0, arg1, arg2, arg3);
        }

        public void SetData1(int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = cubeFace;
            var arg3 = sourceFormat;
            var arg4 = sourceType;
            var arg5 = data;
            var arg6 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData1_0(__Instance, mipLevel, layer, arg2, arg3, arg4, arg5, arg6);
        }

        public void SetData1(int mipLevel, int layer, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = sourceFormat;
            var arg3 = sourceType;
            var arg4 = data;
            var arg5 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData1_1(__Instance, mipLevel, layer, arg2, arg3, arg4, arg5);
        }

        public void SetData1(int mipLevel, QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg1 = sourceFormat;
            var arg2 = sourceType;
            var arg3 = data;
            var arg4 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData1_2(__Instance, mipLevel, arg1, arg2, arg3, arg4);
        }

        public void SetData1(QOpenGLTexture.PixelFormat sourceFormat, QOpenGLTexture.PixelType sourceType, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg0 = sourceFormat;
            var arg1 = sourceType;
            var arg2 = data;
            var arg3 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetData1_3(__Instance, arg0, arg1, arg2, arg3);
        }

        public void SetCompressedData(int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = cubeFace;
            var arg4 = data;
            var arg5 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData_0(__Instance, mipLevel, layer, arg2, dataSize, arg4, arg5);
        }

        public void SetCompressedData(int mipLevel, int layer, int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg3 = data;
            var arg4 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData_1(__Instance, mipLevel, layer, dataSize, arg3, arg4);
        }

        public void SetCompressedData(int mipLevel, int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = data;
            var arg3 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData_2(__Instance, mipLevel, dataSize, arg2, arg3);
        }

        public void SetCompressedData(int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg1 = data;
            var arg2 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData_3(__Instance, dataSize, arg1, arg2);
        }

        public void SetCompressedData1(int mipLevel, int layer, QOpenGLTexture.CubeMapFace cubeFace, int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = cubeFace;
            var arg4 = data;
            var arg5 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData1_0(__Instance, mipLevel, layer, arg2, dataSize, arg4, arg5);
        }

        public void SetCompressedData1(int mipLevel, int layer, int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg3 = data;
            var arg4 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData1_1(__Instance, mipLevel, layer, dataSize, arg3, arg4);
        }

        public void SetCompressedData1(int mipLevel, int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg2 = data;
            var arg3 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData1_2(__Instance, mipLevel, dataSize, arg2, arg3);
        }

        public void SetCompressedData1(int dataSize, global::System.IntPtr data, QOpenGLPixelTransferOptions options = null)
        {
            var arg1 = data;
            var arg2 = ReferenceEquals(options, null) ? global::System.IntPtr.Zero : options.__Instance;
            Internal.SetCompressedData1_3(__Instance, dataSize, arg1, arg2);
        }

        /// <summary>
        /// <para>This overload of setData() will allocate storage for you. The
        /// pixel data is contained in image. Mipmaps are generated by default. Set
        /// genMipMaps to DontGenerateMipMaps to turn off mipmap generation.</para>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public void SetData(QImage image, QOpenGLTexture.MipMapGeneration genMipMaps = QOpenGLTexture.MipMapGeneration.GenerateMipMaps)
        {
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var arg1 = genMipMaps;
            Internal.SetData_4(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Sets the range of mipmap levels that can be used for texture
        /// lookups with this texture to range from baseLevel to maxLevel.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also setMipBaseLevel(), setMipMaxLevel(), and mipLevelRange().</para>
        /// </summary>
        public void SetMipLevelRange(int baseLevel, int maxLevel)
        {
            Internal.SetMipLevelRange_0(__Instance, baseLevel, maxLevel);
        }

        /// <summary>
        /// <para>Generates mipmaps for this texture object from mipmap level 0. If
        /// you are using a texture target and filtering option that requires mipmaps
        /// and you have disabled automatic mipmap generation then you need to call
        /// this function or the overload to create the mipmap chain.</para>
        /// <para>See also setAutoMipMapGenerationEnabled(), setMipLevels(), and
        /// mipLevels().</para>
        /// </summary>
        public void GenerateMipMaps()
        {
            Internal.GenerateMipMaps_0(__Instance);
        }

        /// <summary>
        /// <para>Generates mipmaps for this texture object from mipmap level
        /// baseLevel. If you are using a texture target and filtering option that
        /// requires mipmaps and you have disabled automatic mipmap generation then you
        /// need to call this function or the overload to create the mipmap
        /// chain.</para>
        /// <para>The generation of mipmaps to above baseLevel is achieved by
        /// setting the mipmap base level to baseLevel and then generating the mipmap
        /// chain. If resetBaseLevel is true, then the baseLevel of the texture will be
        /// reset to its previous value.</para>
        /// <para>See also setAutoMipMapGenerationEnabled(), setMipLevels(), and
        /// mipLevels().</para>
        /// </summary>
        public void GenerateMipMaps(int baseLevel, bool resetBaseLevel = true)
        {
            Internal.GenerateMipMaps_1(__Instance, baseLevel, resetBaseLevel);
        }

        /// <summary>
        /// <para>GLSL shaders are able to reorder the components of the vec4
        /// returned by texture functions. It is also desirable to be able to control
        /// this reordering from CPU side code. This is made possible by swizzle masks
        /// since OpenGL 3.3.</para>
        /// <para>Each component of the texture can be mapped to one of the
        /// SwizzleValue options.</para>
        /// <para>This function maps component to the output value.</para>
        /// <para>Note: This function has no effect on Mac and Qt built for OpenGL
        /// ES 2.See also swizzleMask().</para>
        /// </summary>
        public void SetSwizzleMask(QOpenGLTexture.SwizzleComponent component, QOpenGLTexture.SwizzleValue value)
        {
            var arg0 = component;
            var arg1 = value;
            Internal.SetSwizzleMask_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Parameters r, g, b, and a are values used for setting the colors
        /// red, green, blue, and the alpha value. This is an overloaded
        /// function.</para>
        /// </summary>
        public void SetSwizzleMask(QOpenGLTexture.SwizzleValue r, QOpenGLTexture.SwizzleValue g, QOpenGLTexture.SwizzleValue b, QOpenGLTexture.SwizzleValue a)
        {
            var arg0 = r;
            var arg1 = g;
            var arg2 = b;
            var arg3 = a;
            Internal.SetSwizzleMask_1(__Instance, arg0, arg1, arg2, arg3);
        }

        /// <summary>
        /// <para>Returns the swizzle mask for texture component.</para>
        /// <para>See also setSwizzleMask().</para>
        /// </summary>
        public QOpenGLTexture.SwizzleValue SwizzleMask(QOpenGLTexture.SwizzleComponent component)
        {
            var arg0 = component;
            var __ret = Internal.SwizzleMask_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the minification filter to minificationFilter and the
        /// magnification filter to magnificationFilter.</para>
        /// <para>See also minMagFilters(), setMinificationFilter(), and
        /// setMagnificationFilter().</para>
        /// </summary>
        public void SetMinMagFilters(QOpenGLTexture.Filter minificationFilter, QOpenGLTexture.Filter magnificationFilter)
        {
            var arg0 = minificationFilter;
            var arg1 = magnificationFilter;
            Internal.SetMinMagFilters_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Sets the wrap (or repeat mode) for all texture dimentions to
        /// mode.</para>
        /// <para>See also wrapMode().</para>
        /// </summary>
        public void SetWrapMode(QOpenGLTexture.WrapMode mode)
        {
            var arg0 = mode;
            Internal.SetWrapMode_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Holds the texture dimension direction. This is an overloaded
        /// function.</para>
        /// </summary>
        public void SetWrapMode(QOpenGLTexture.CoordinateDirection direction, QOpenGLTexture.WrapMode mode)
        {
            var arg0 = direction;
            var arg1 = mode;
            Internal.SetWrapMode_1(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Returns the wrap mode for the texture dimension direction.</para>
        /// <para>See also setWrapMode().</para>
        /// </summary>
        public QOpenGLTexture.WrapMode wrapMode(QOpenGLTexture.CoordinateDirection direction)
        {
            var arg0 = direction;
            var __ret = Internal.wrapMode_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the color red to r, green to g, blue to b, and a to the
        /// alpha value. This is an overloaded function.</para>
        /// </summary>
        public void SetBorderColor(float r, float g, float b, float a)
        {
            Internal.SetBorderColor_1(__Instance, r, g, b, a);
        }

        /// <summary>
        /// <para>Sets the color red to r, green to g, blue to b, and the alpha
        /// value to a. This is an overloaded function.</para>
        /// </summary>
        public void SetBorderColor(int r, int g, int b, int a)
        {
            Internal.SetBorderColor_2(__Instance, r, g, b, a);
        }

        /// <summary>
        /// <para>Writes the texture border color into the first four elements of
        /// the array pointed to by border.</para>
        /// <para>See also setBorderColor().</para>
        /// </summary>
        public void GetBorderColor(float* border)
        {
            var arg0 = border;
            Internal.GetBorderColor_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Writes the texture border color into the first four elements of
        /// the array pointed to by border.</para>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public void GetBorderColor(int* border)
        {
            var arg0 = border;
            Internal.GetBorderColor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Writes the texture border color into the first four elements of
        /// the array pointed to by border.</para>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public void GetBorderColor(uint* border)
        {
            var arg0 = border;
            Internal.GetBorderColor_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>Sets the minimum level of detail parameters to min and the
        /// maximum level to max.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also levelOfDetailRange(), setMinimumLevelOfDetail(), and
        /// setMaximumLevelOfDetail().</para>
        /// </summary>
        public void SetLevelOfDetailRange(float min, float max)
        {
            Internal.SetLevelOfDetailRange_0(__Instance, min, max);
        }

        /// <summary>
        /// <para>Returns true if your OpenGL implementation and version supports
        /// the texture feature feature.</para>
        /// </summary>
        public static bool HasFeature(QOpenGLTexture.Feature feature)
        {
            var arg0 = feature;
            var __ret = Internal.HasFeature_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the format of this texture object.</para>
        /// <para>See also setFormat().</para>
        /// <para></para>
        /// <para>Sets the format of this texture object to format. This function
        /// must be called before texture storage is allocated.</para>
        /// <para>Note that all formats may not be supported. The exact set of
        /// supported formats is dependent upon your OpenGL implementation and
        /// version.</para>
        /// <para>See also format() and allocateStorage().</para>
        /// </summary>
        public QOpenGLTexture.TextureFormat Format
        {
            get
            {
                var __ret = Internal.Format_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the number of mipmap levels for this texture. If storage
        /// has not yet been allocated for this texture it returns the requested number
        /// of mipmap levels.</para>
        /// <para>See also setMipLevels(), maximumMipLevels(), and
        /// isStorageAllocated().</para>
        /// <para></para>
        /// <para>For texture targets that support mipmaps, this function sets the
        /// requested number of mipmap levels to allocate storage for. This function
        /// should be called before storage is allocated for the texture.</para>
        /// <para>If the texture target does not support mipmaps this function has
        /// no effect.</para>
        /// <para>See also mipLevels(), maximumMipLevels(), and
        /// isStorageAllocated().</para>
        /// </summary>
        public int MipLevels
        {
            get
            {
                var __ret = Internal.MipLevels_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMipLevels_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of array layers for this texture. If storage
        /// has not yet been allocated for this texture then this function returns the
        /// requested number of array layers.</para>
        /// <para>For texture targets that do not support array layers this will
        /// return 1.</para>
        /// <para>See also setLayers() and isStorageAllocated().</para>
        /// <para></para>
        /// <para>Sets the number of array layers to allocate storage for. This
        /// function should be called before storage is allocated for the
        /// texture.</para>
        /// <para>For targets that do not support array layers this function has no
        /// effect.</para>
        /// <para>See also layers() and isStorageAllocated().</para>
        /// </summary>
        public int Layers
        {
            get
            {
                var __ret = Internal.Layers_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetLayers_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of multisample sample points for this texture.
        /// If storage has not yet been allocated for this texture then this function
        /// returns the requested number of samples.</para>
        /// <para>For texture targets that do not support multisampling this will
        /// return 0.</para>
        /// <para>See also setSamples() and isStorageAllocated().</para>
        /// <para></para>
        /// <para>Sets the number of samples to allocate storage for when rendering
        /// to a multisample capable texture target. This function should be called
        /// before storage is allocated for the texture.</para>
        /// <para>For targets that do not support multisampling this function has
        /// no effect.</para>
        /// <para>See also samples() and isStorageAllocated().</para>
        /// </summary>
        public int Samples
        {
            get
            {
                var __ret = Internal.Samples_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSamples_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns whether this texture uses a fixed pattern of multisample
        /// samples. If storage has not yet been allocated for this texture then this
        /// function returns the requested fixed sample position setting.</para>
        /// <para>For texture targets that do not support multisampling this will
        /// return true.</para>
        /// <para>See also setFixedSamplePositions() and
        /// isStorageAllocated().</para>
        /// <para></para>
        /// <para>Sets whether the sample positions and number of samples used with
        /// a multisample capable texture target to fixed. If set to true the sample
        /// positions and number of samples used are the same for all texels in the
        /// image and will not depend upon the image size or internal format. This
        /// function should be called before storage is allocated for the
        /// texture.</para>
        /// <para>For targets that do not support multisampling this function has
        /// no effect.</para>
        /// <para>The default value is true.</para>
        /// <para>See also isFixedSamplePositions() and
        /// isStorageAllocated().</para>
        /// </summary>
        public bool FixedSamplePositions
        {
            get
            {
                var __ret = Internal.FixedSamplePositions_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetFixedSamplePositions_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the mipmap base level used for all texture lookups with
        /// this texture. The default is 0.</para>
        /// <para>See also setMipBaseLevel(), mipMaxLevel(), and
        /// mipLevelRange().</para>
        /// <para></para>
        /// <para>Sets the base mipmap level used for all texture lookups with this
        /// texture to baseLevel.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also mipBaseLevel(), setMipMaxLevel(), and setMipLevelRange().</para>
        /// </summary>
        public int MipBaseLevel
        {
            get
            {
                var __ret = Internal.MipBaseLevel_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMipBaseLevel_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the mipmap maximum level used for all texture lookups
        /// with this texture.</para>
        /// <para>See also setMipMaxLevel(), mipBaseLevel(), and
        /// mipLevelRange().</para>
        /// <para></para>
        /// <para>Sets the maximum mipmap level used for all texture lookups with
        /// this texture to maxLevel.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also mipMaxLevel(), setMipBaseLevel(), and setMipLevelRange().</para>
        /// </summary>
        public int MipMaxLevel
        {
            get
            {
                var __ret = Internal.MipMaxLevel_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMipMaxLevel_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns whether auto mipmap generation is enabled for this
        /// texture object.</para>
        /// <para>See also setAutoMipMapGenerationEnabled() and
        /// generateMipMaps().</para>
        /// <para></para>
        /// <para>If enabled is true, enables automatic mipmap generation for this
        /// texture object to occur whenever the level 0 mipmap data is set via
        /// setData().</para>
        /// <para>The automatic mipmap generation is enabled by default.</para>
        /// <para>See also isAutoMipMapGenerationEnabled() and
        /// generateMipMaps().</para>
        /// </summary>
        public bool AutoMipMapGenerationEnabled
        {
            get
            {
                var __ret = Internal.AutoMipMapGenerationEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetAutoMipMapGenerationEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the depth stencil mode for textures using a combined
        /// depth/stencil format.</para>
        /// <para>See also setDepthStencilMode().</para>
        /// <para></para>
        /// <para>If using a texture that has a combined depth/stencil format this
        /// function sets which component of the texture is accessed to mode.</para>
        /// <para>When the parameter is set to DepthMode, then accessing it from
        /// the shader will access the depth component as a single float, as normal.
        /// But when the parameter is set to StencilMode, the shader will access the
        /// stencil component.</para>
        /// <para>Note: This function has no effect on Mac and Qt built for OpenGL
        /// ES 2.See also depthStencilMode().</para>
        /// </summary>
        public QOpenGLTexture.DepthStencilMode depthStencilMode
        {
            get
            {
                var __ret = Internal.depthStencilMode_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetDepthStencilMode_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the minification filter.</para>
        /// <para>See also setMinificationFilter().</para>
        /// <para></para>
        /// <para>Sets the filter used for minification to filter.</para>
        /// <para>See also minificationFilter(), setMagnificationFilter(), and
        /// setMinMagFilters().</para>
        /// </summary>
        public QOpenGLTexture.Filter MinificationFilter
        {
            get
            {
                var __ret = Internal.MinificationFilter_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetMinificationFilter_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the magnification filter.</para>
        /// <para>See also setMagnificationFilter().</para>
        /// <para></para>
        /// <para>Sets the magnification filter to filter.</para>
        /// <para>See also magnificationFilter(), setMinificationFilter(), and
        /// setMinMagFilters().</para>
        /// </summary>
        public QOpenGLTexture.Filter MagnificationFilter
        {
            get
            {
                var __ret = Internal.MagnificationFilter_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetMagnificationFilter_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the maximum level of anisotropy to be accounted for when
        /// performing texture lookups. This requires the
        /// GL_EXT_texture_filter_anisotropic extension.</para>
        /// <para>See also setMaximumAnisotropy().</para>
        /// <para></para>
        /// <para>If your OpenGL implementation supports the
        /// GL_EXT_texture_filter_anisotropic extension this function sets the maximum
        /// anisotropy level to anisotropy.</para>
        /// <para>See also maximumAnisotropy().</para>
        /// </summary>
        public float MaximumAnisotropy
        {
            get
            {
                var __ret = Internal.MaximumAnisotropy_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMaximumAnisotropy_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the borderColor of this texture.</para>
        /// <para>See also setBorderColor().</para>
        /// <para></para>
        /// <para>Sets the border color of the texture to color.</para>
        /// <para>Note: This function has no effect on Mac and Qt built for OpenGL
        /// ES 2.See also borderColor().</para>
        /// </summary>
        public QColor BorderColor
        {
            get
            {
                var __ret = new QtGui.QColor.Internal();
                Internal.BorderColor_0(new IntPtr(&__ret), __Instance);
                return QColor.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? new QColor.Internal() : *(QColor.Internal*) (value.__Instance);
                Internal.SetBorderColor_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the minimum level of detail parameter.</para>
        /// <para>See also setMinimumLevelOfDetail(), maximumLevelOfDetail(), and
        /// levelOfDetailRange().</para>
        /// <para></para>
        /// <para>Sets the minimum level of detail to value. This limits the
        /// selection of highest resolution mipmap (lowest mipmap level). The default
        /// value is -1000.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also minimumLevelOfDetail(), setMaximumLevelOfDetail(), and
        /// setLevelOfDetailRange().</para>
        /// </summary>
        public float MinimumLevelOfDetail
        {
            get
            {
                var __ret = Internal.MinimumLevelOfDetail_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMinimumLevelOfDetail_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the maximum level of detail parameter.</para>
        /// <para>See also setMaximumLevelOfDetail(), minimumLevelOfDetail(), and
        /// levelOfDetailRange().</para>
        /// <para></para>
        /// <para>Sets the maximum level of detail to value. This limits the
        /// selection of lowest resolution mipmap (highest mipmap level). The default
        /// value is 1000.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also maximumLevelOfDetail(), setMinimumLevelOfDetail(), and
        /// setLevelOfDetailRange().</para>
        /// </summary>
        public float MaximumLevelOfDetail
        {
            get
            {
                var __ret = Internal.MaximumLevelOfDetail_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMaximumLevelOfDetail_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the level of detail bias parameter.</para>
        /// <para>See also setLevelofDetailBias().</para>
        /// <para></para>
        /// <para>Sets the level of detail bias to bias. Level of detail bias
        /// affects the point at which mipmapping levels change. Increasing values for
        /// level of detail bias makes the overall images blurrier or smoother.
        /// Decreasing values make the overall images sharper.</para>
        /// <para>Note: This function has no effect on Qt built for OpenGL ES 2.See
        /// also levelofDetailBias().</para>
        /// </summary>
        public float LevelofDetailBias
        {
            get
            {
                var __ret = Internal.LevelofDetailBias_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetLevelofDetailBias_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the binding target of this texture.</para>
        /// <para>This function was introduced in  Qt 5.4.</para>
        /// </summary>
        public QOpenGLTexture.Target target
        {
            get
            {
                var __ret = Internal.target_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the underlying OpenGL texture object has been
        /// created.</para>
        /// <para>See also create(), destroy(), and textureId().</para>
        /// </summary>
        public bool IsCreated
        {
            get
            {
                var __ret = Internal.IsCreated_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the width of a 1D, 2D or 3D texture.</para>
        /// <para>See also height(), depth(), and setSize().</para>
        /// </summary>
        public int Width
        {
            get
            {
                var __ret = Internal.Width_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the height of a 2D or 3D texture.</para>
        /// <para>See also width(), depth(), and setSize().</para>
        /// </summary>
        public int Height
        {
            get
            {
                var __ret = Internal.Height_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the depth of a 3D texture.</para>
        /// <para>See also width(), height(), and setSize().</para>
        /// </summary>
        public int Depth
        {
            get
            {
                var __ret = Internal.Depth_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the maximum number of mipmap levels that this texture can
        /// have given the current dimensions.</para>
        /// <para>See also setMipLevels(), mipLevels(), and setSize().</para>
        /// </summary>
        public int MaximumMipLevels
        {
            get
            {
                var __ret = Internal.MaximumMipLevels_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of faces for this texture. For cubemap and
        /// cubemap array type targets this will be 6.</para>
        /// <para>For non-cubemap type targets this will return 1.</para>
        /// </summary>
        public int Faces
        {
            get
            {
                var __ret = Internal.Faces_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if server-side storage for this texture as been
        /// allocated.</para>
        /// <para>The texture format, dimensions, mipmap levels and array layers
        /// cannot be altered once storage ihas been allocated.</para>
        /// <para>See also allocateStorage(), setSize(), setMipLevels(),
        /// setLayers(), and setFormat().</para>
        /// </summary>
        public bool IsStorageAllocated
        {
            get
            {
                var __ret = Internal.IsStorageAllocated_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if this texture object is actually a view onto
        /// another texture object.</para>
        /// <para>See also createTextureView().</para>
        /// </summary>
        public bool IsTextureView
        {
            get
            {
                var __ret = Internal.IsTextureView_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QOpenGLTimerQuery class wraps an OpenGL timer query
    /// object.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>OpenGL timer query objects are OpenGL managed resources to
    /// measure the execution times of sequences of OpenGL commands on the
    /// GPU.</para>
    /// <para>OpenGL offers various levels of support for timer queries,
    /// depending on the version of OpenGL you have and the presence of the
    /// ARB_timer_query or EXT_timer_query extensions. The support can be
    /// summarized as:</para>
    /// <para></para>
    /// <para>OpenGL &gt;=3.3 offers full support for all timer query
    /// functionality.</para>
    /// <para>OpenGL 3.2 with the ARB_timer_query extension offers full support
    /// for all timer query functionality.</para>
    /// <para>OpenGL &lt;=3.2 with the EXT_timer_query extension offers limited
    /// support in that the timestamp of the GPU cannot be queried. Places where
    /// this impacts functions provided by Qt classes will be highlighted in the
    /// function documentation.</para>
    /// <para>OpenGL ES 2 (and OpenGL ES 3) do not provide any support for
    /// OpenGL timer queries.</para>
    /// <para></para>
    /// <para>OpenGL represents time with a granularity of 1 nanosecond (1e-9
    /// seconds). As a consequence of this, 32-bit integers would only give a total
    /// possible duration of approximately 4 seconds, which would not be difficult
    /// to exceed in poorly performing or lengthy operations. OpenGL therefore uses
    /// 64 bit integer types to represent times. A GLuint64 variable has enough
    /// width to contain a duration of hundreds of years, which is plenty for
    /// real-time rendering needs.</para>
    /// <para>As with the other Qt OpenGL classes, QOpenGLTimerQuery has a
    /// create() function to create the underlying OpenGL object. This is to allow
    /// the developer to ensure that there is a valid current OpenGL context at the
    /// time.</para>
    /// <para>Once created, timer queries can be issued in one of several ways.
    /// The simplest method is to delimit a block of commands with calls to begin()
    /// and end(). This instructs OpenGL to measure the time taken from completing
    /// all commands issued prior to begin() until the completion of all commands
    /// issued prior to end().</para>
    /// <para>At the end of a frame we can retrieve the results by calling
    /// waitForResult(). As this function's name implies, it blocks CPU execution
    /// until OpenGL notifies that the timer query result is available. To avoid
    /// blocking, you can check if the query result is available by calling
    /// isResultAvailable(). Note that modern GPUs are deeply pipelined and query
    /// results may not become available for between 1-5 frames after they were
    /// issued.</para>
    /// <para>Note that OpenGL does not permit nesting or interleaving of
    /// multiple timer queries using begin() and end(). Using multiple timer
    /// queries and recordTimestamp() avoids this limitation. When using
    /// recordTimestamp() the result can be obtained at some later time using
    /// isResultAvailable() and waitForResult(). Qt provides the convenience class
    /// QOpenGLTimeMonitor that helps with using multiple query objects.</para>
    /// <para></para>
    /// <para>See also QOpenGLTimeMonitor.</para>
    /// </remarks>
    public unsafe partial class QOpenGLTimerQuery : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQueryC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQueryD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQuery6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQuery7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQuery5beginEv")]
            internal static extern void Begin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQuery3endEv")]
            internal static extern void End_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QOpenGLTimerQuery15recordTimestampEv")]
            internal static extern void RecordTimestamp_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOpenGLTimerQuery9isCreatedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCreated_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QOpenGLTimerQuery17isResultAvailableEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsResultAvailable_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLTimerQuery __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLTimerQuery((QOpenGLTimerQuery.Internal*) native);
        }

        public static QOpenGLTimerQuery __CreateInstance(QOpenGLTimerQuery.Internal native)
        {
            return new QOpenGLTimerQuery(native);
        }

        private static QOpenGLTimerQuery.Internal* __CopyValue(QOpenGLTimerQuery.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLTimerQuery.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLTimerQuery.Internal*) ret;
        }

        private QOpenGLTimerQuery(QOpenGLTimerQuery.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLTimerQuery(QOpenGLTimerQuery.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Creates the underlying OpenGL timer query object. There must be a
        /// valid OpenGL context that supports query objects current for this function
        /// to succeed.</para>
        /// <para>Returns true if the OpenGL timer query object was successfully
        /// created.</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Destroys the underlying OpenGL timer query object. The context
        /// that was current when create() was called must be current when calling this
        /// function.</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Marks the start point in the OpenGL command queue for a sequence
        /// of commands to be timed by this query object.</para>
        /// <para>This is useful for simple use-cases. Usually it is better to use
        /// recordTimestamp().</para>
        /// <para>See also end(), isResultAvailable(), waitForResult(), and
        /// recordTimestamp().</para>
        /// </summary>
        public void Begin()
        {
            Internal.Begin_0(__Instance);
        }

        /// <summary>
        /// <para>Marks the end point in the OpenGL command queue for a sequence of
        /// commands to be timed by this query object.</para>
        /// <para>This is useful for simple use-cases. Usually it is better to use
        /// recordTimestamp().</para>
        /// <para>See also begin(), isResultAvailable(), waitForResult(), and
        /// recordTimestamp().</para>
        /// </summary>
        public void End()
        {
            Internal.End_0(__Instance);
        }

        /// <summary>
        /// <para>Places a marker in the OpenGL command queue for the GPU to record
        /// the timestamp when this marker is reached by the GPU. This function is
        /// non-blocking and the result will become available at some later
        /// time.</para>
        /// <para>The availability of the result can be checked with
        /// isResultAvailable(). The result can be fetched with waitForResult() which
        /// will block if the result is not yet available.</para>
        /// <para>See also waitForResult(), isResultAvailable(), begin(), and
        /// end().</para>
        /// </summary>
        public void RecordTimestamp()
        {
            Internal.RecordTimestamp_0(__Instance);
        }

        /// <summary>
        /// <para>Returns true if the underlying OpenGL query object has been
        /// created. If this returns true and the associated OpenGL context is current,
        /// then you are able to issue queries with this object.</para>
        /// </summary>
        public bool IsCreated
        {
            get
            {
                var __ret = Internal.IsCreated_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the OpenGL timer query result is
        /// available.</para>
        /// <para>This function is non-blocking and ideally should be used to check
        /// for the availability of the query result before calling
        /// waitForResult().</para>
        /// <para>See also waitForResult().</para>
        /// </summary>
        public bool IsResultAvailable
        {
            get
            {
                var __ret = Internal.IsResultAvailable_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QOpenGLTimerQuery()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLTimerQuery) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLTimeMonitor class wraps a sequence of OpenGL timer
    /// query objects.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QOpenGLTimeMonitor class is a convenience wrapper around a
    /// collection of OpenGL timer query objects used to measure intervals of time
    /// on the GPU to the level of granularity required by your rendering
    /// application.</para>
    /// <para>The OpenGL timer queries objects are queried in sequence to
    /// record the GPU timestamps at positions of interest in your rendering code.
    /// Once the results for all issues timer queries become available, the results
    /// can be fetched and QOpenGLTimerMonitor will calculate the recorded time
    /// intervals for you.</para>
    /// <para>The typical use case of this class is to either profile your
    /// application's rendering algorithms or to adjust those algorithms in
    /// real-time for dynamic performance/quality balancing.</para>
    /// <para>Prior to using QOpenGLTimeMonitor in your rendering function you
    /// should set the required number of sample points that you wish to record by
    /// calling setSamples(). Note that measuring N sample points will produce N-1
    /// time intervals. Once you have set the number of sample points, call the
    /// create() function with a valid current OpenGL context to create the
    /// necessary query timer objects. These steps are usually performed just once
    /// in an initialization function.</para>
    /// <para>Use the recordSample() function to delimit blocks of code
    /// containing OpenGL commands that you wish to time. You can check
    /// availability of the resulting time samples and time intervals with
    /// isResultAvailable(). The calculated time intervals and the raw timestamp
    /// samples can be retrieved with the blocking waitForIntervals() and
    /// waitForSamples() functions respectively.</para>
    /// <para>After retrieving the results and before starting a new round of
    /// taking samples (for example, in the next frame) be sure to call the reset()
    /// function which will clear the cached results and reset the timer index back
    /// to the first timer object.</para>
    /// <para></para>
    /// <para>See also QOpenGLTimerQuery.</para>
    /// </remarks>
    public unsafe partial class QOpenGLTimeMonitor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitorC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitor6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitor7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitor5resetEv")]
            internal static extern void Reset_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLTimeMonitor11sampleCountEv")]
            internal static extern int SampleCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitor14setSampleCountEi")]
            internal static extern void SetSampleCount_0(global::System.IntPtr instance, int sampleCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLTimeMonitor9isCreatedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCreated_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QOpenGLTimeMonitor12recordSampleEv")]
            internal static extern int RecordSample_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QOpenGLTimeMonitor17isResultAvailableEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsResultAvailable_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLTimeMonitor __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLTimeMonitor((QOpenGLTimeMonitor.Internal*) native);
        }

        public static QOpenGLTimeMonitor __CreateInstance(QOpenGLTimeMonitor.Internal native)
        {
            return new QOpenGLTimeMonitor(native);
        }

        private static QOpenGLTimeMonitor.Internal* __CopyValue(QOpenGLTimeMonitor.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLTimeMonitor.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLTimeMonitor.Internal*) ret;
        }

        private QOpenGLTimeMonitor(QOpenGLTimeMonitor.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLTimeMonitor(QOpenGLTimeMonitor.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Instantiate sampleCount() OpenGL timer query objects that will be
        /// used to track the amount of time taken to execute OpenGL commands between
        /// successive calls to recordSample().</para>
        /// <para>Returns true if the OpenGL timer query objects could be
        /// created.</para>
        /// <para>See also destroy(), setSampleCount(), and recordSample().</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Destroys any OpenGL timer query objects used within this
        /// instance.</para>
        /// <para>See also create().</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Resets the time monitor ready for use in another frame of
        /// rendering. Call this once you have obtained the previous results and before
        /// calling recordSample() for the first time on the next frame.</para>
        /// <para>See also recordSample().</para>
        /// </summary>
        public void Reset()
        {
            Internal.Reset_0(__Instance);
        }

        /// <summary>
        /// <para>Returns the number of sample points that have been requested with
        /// setSampleCount(). If create was successfully called following
        /// setSampleCount(), then the value returned will be the actual number of
        /// sample points that can be used.</para>
        /// <para>The default value for sample count is 2, leading to the
        /// measurement of a single interval.</para>
        /// <para>See also setSampleCount().</para>
        /// <para></para>
        /// <para>Sets the number of sample points to sampleCount. After setting
        /// the number of samples with this function, you must call create() to
        /// instantiate the underlying OpenGL timer query objects.</para>
        /// <para>The new sampleCount must be at least 2.</para>
        /// <para>See also sampleCount(), create(), and recordSample().</para>
        /// </summary>
        public int SampleCount
        {
            get
            {
                var __ret = Internal.SampleCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetSampleCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if the underlying OpenGL query objects have been
        /// created. If this returns true and the associated OpenGL context is current,
        /// then you are able to record time samples with this object.</para>
        /// </summary>
        public bool IsCreated
        {
            get
            {
                var __ret = Internal.IsCreated_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Issues an OpenGL timer query at this point in the OpenGL command
        /// queue. Calling this function in a sequence in your application's rendering
        /// function, will build up details of the GPU time taken to execute the OpenGL
        /// commands between successive calls to this function.</para>
        /// <para>See also setSampleCount(), isResultAvailable(), waitForSamples(),
        /// and waitForIntervals().</para>
        /// </summary>
        public int RecordSample
        {
            get
            {
                var __ret = Internal.RecordSample_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the OpenGL timer query results are
        /// available.</para>
        /// <para>See also waitForSamples() and waitForIntervals().</para>
        /// </summary>
        public bool IsResultAvailable
        {
            get
            {
                var __ret = Internal.IsResultAvailable_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QOpenGLTimeMonitor()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLTimeMonitor) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QOpenGLVertexArrayObject class wraps an OpenGL Vertex Array
    /// Object.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A Vertex Array Object (VAO) is an OpenGL container object that
    /// encapsulates the state needed to specify per-vertex attribute data to the
    /// OpenGL pipeline. To put it another way, a VAO remembers the states of
    /// buffer objects (see QOpenGLBuffer) and their associated state (e.g. vertex
    /// attribute divisors). This allows a very easy and efficient method of
    /// switching between OpenGL buffer states for rendering different
    /// &quot;objects&quot; in a scene. The QOpenGLVertexArrayObject class is a
    /// thin wrapper around an OpenGL VAO.</para>
    /// <para>For the desktop, VAOs are supported as a core feature in OpenGL
    /// 3.0 or newer and by the GL_ARB_vertex_array_object for older versions. On
    /// OpenGL ES 2, VAOs are provided by the optional GL_OES_vertex_array_object
    /// extension. You can check the version of OpenGL with
    /// QOpenGLContext::surfaceFormat() and check for the presence of extensions
    /// with QOpenGLContext::hasExtension().</para>
    /// <para>As with the other Qt OpenGL classes, QOpenGLVertexArrayObject has
    /// a create() function to create the underlying OpenGL object. This is to
    /// allow the developer to ensure that there is a valid current OpenGL context
    /// at the time.</para>
    /// <para>Once you have successfully created a VAO the typical usage
    /// pattern is:</para>
    /// <para></para>
    /// <para>In scene initialization function, for each visual object:</para>
    /// <para>Bind the VAO</para>
    /// <para>Set vertex data state for this visual object (vertices, normals,
    /// texture coordinates etc.)</para>
    /// <para>Unbind (release()) the VAO</para>
    /// </remarks>
    public unsafe partial class QOpenGLVertexArrayObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLVertexArrayObjectC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLVertexArrayObjectD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLVertexArrayObject6createEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Create_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLVertexArrayObject7destroyEv")]
            internal static extern void Destroy_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLVertexArrayObject4bindEv")]
            internal static extern void Bind_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN24QOpenGLVertexArrayObject7releaseEv")]
            internal static extern void Release_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK24QOpenGLVertexArrayObject9isCreatedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCreated_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public unsafe partial class Binder : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vao;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN24QOpenGLVertexArrayObject6BinderC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN24QOpenGLVertexArrayObject6BinderD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Binder __CreateInstance(global::System.IntPtr native)
            {
                return new Binder((Binder.Internal*) native);
            }

            public static Binder __CreateInstance(Binder.Internal native)
            {
                return new Binder(native);
            }

            private static Binder.Internal* __CopyValue(Binder.Internal native)
            {
                var ret = (Binder.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private Binder(Binder.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Binder(Binder.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QOpenGLVertexArrayObject __CreateInstance(global::System.IntPtr native)
        {
            return new QOpenGLVertexArrayObject((QOpenGLVertexArrayObject.Internal*) native);
        }

        public static QOpenGLVertexArrayObject __CreateInstance(QOpenGLVertexArrayObject.Internal native)
        {
            return new QOpenGLVertexArrayObject(native);
        }

        private static QOpenGLVertexArrayObject.Internal* __CopyValue(QOpenGLVertexArrayObject.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QOpenGLVertexArrayObject.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QOpenGLVertexArrayObject.Internal*) ret;
        }

        private QOpenGLVertexArrayObject(QOpenGLVertexArrayObject.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QOpenGLVertexArrayObject(QOpenGLVertexArrayObject.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Creates the underlying OpenGL vertex array object. There must be
        /// a valid OpenGL context that supports vertex array objects current for this
        /// function to succeed.</para>
        /// <para>Returns true if the OpenGL vertex array object was successfully
        /// created.</para>
        /// <para>When the return value is false, vertex array object support is
        /// not available. This is not an error: on systems with OpenGL 2.x or OpenGL
        /// ES 2.0 vertex array objects may not be supported. The application is free
        /// to continue execution in this case, but it then has to be prepared to
        /// operate in a VAO-less manner too. This means that instead of merely calling
        /// bind(), the value of isCreated() must be checked and the vertex arrays has
        /// to be initialized in the traditional way when there is no vertex array
        /// object present.</para>
        /// <para>See also isCreated().</para>
        /// </summary>
        public bool Create()
        {
            var __ret = Internal.Create_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Destroys the underlying OpenGL vertex array object. There must be
        /// a valid OpenGL context that supports vertex array objects current for this
        /// function to succeed.</para>
        /// </summary>
        public void Destroy()
        {
            Internal.Destroy_0(__Instance);
        }

        /// <summary>
        /// <para>Binds this vertex array object to the OpenGL binding point. From
        /// this point on and until release() is called or another vertex array object
        /// is bound, any modifications made to vertex data state are stored inside
        /// this vertex array object.</para>
        /// <para>If another vertex array object is then bound you can later
        /// restore the set of state associated with this object by calling bind() on
        /// this object once again. This allows efficient changes between vertex data
        /// states in rendering functions.</para>
        /// </summary>
        public void Bind()
        {
            Internal.Bind_0(__Instance);
        }

        /// <summary>
        /// <para>Unbinds this vertex array object by binding the default vertex
        /// array object (id = 0).</para>
        /// </summary>
        public void Release()
        {
            Internal.Release_0(__Instance);
        }

        /// <summary>
        /// <para>Returns true is the underlying OpenGL vertex array object has
        /// been created. If this returns true and the associated OpenGL context is
        /// current, then you are able to bind() this object.</para>
        /// </summary>
        public bool IsCreated
        {
            get
            {
                var __ret = Internal.IsCreated_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QOpenGLVertexArrayObject()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QOpenGLVertexArrayObject) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QBackingStore class provides a drawing area for
    /// QWindow.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QBackingStore enables the use of QPainter to paint on a QWindow
    /// with type RasterSurface. The other way of rendering to a QWindow is through
    /// the use of OpenGL with QOpenGLContext.</para>
    /// <para>A QBackingStore contains a buffered representation of the window
    /// contents, and thus supports partial updates by using QPainter to only
    /// update a sub region of the window contents.</para>
    /// <para>QBackingStore might be used by an application that wants to use
    /// QPainter without OpenGL acceleration and without the extra overhead of
    /// using the QWidget or QGraphicsView UI stacks. For an example of how to use
    /// QBackingStore see the Raster Window Example.</para>
    /// </remarks>
    public unsafe partial class QBackingStore : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QScopedPointer.Internal d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStoreC2EP7QWindow")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStoreC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStoreD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStore6scrollERK7QRegionii")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Scroll_0(global::System.IntPtr instance, global::System.IntPtr area, int dx, int dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStore10beginPaintERK7QRegion")]
            internal static extern void BeginPaint_0(global::System.IntPtr instance, global::System.IntPtr region);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStore8endPaintEv")]
            internal static extern void EndPaint_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QBackingStore14staticContentsEv")]
            internal static extern void StaticContents_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStore17setStaticContentsERK7QRegion")]
            internal static extern void SetStaticContents_0(global::System.IntPtr instance, global::System.IntPtr region);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QBackingStore6windowEv")]
            internal static extern global::System.IntPtr Window_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QBackingStore11paintDeviceEv")]
            internal static extern global::System.IntPtr PaintDevice_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QBackingStore17hasStaticContentsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasStaticContents_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QBackingStore __CreateInstance(global::System.IntPtr native)
        {
            return new QBackingStore((QBackingStore.Internal*) native);
        }

        public static QBackingStore __CreateInstance(QBackingStore.Internal native)
        {
            return new QBackingStore(native);
        }

        private static QBackingStore.Internal* __CopyValue(QBackingStore.Internal native)
        {
            var ret = (QBackingStore.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QBackingStore(QBackingStore.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QBackingStore(QBackingStore.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty surface for the given top-level
        /// window.</para>
        /// </summary>
        public QBackingStore(QWindow window)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            Internal.ctor_0(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Scrolls the given area dx pixels to the right and dy downward;
        /// both dx and dy may be negative.</para>
        /// <para>Returns true if the area was scrolled successfully; false
        /// otherwise.</para>
        /// </summary>
        public bool Scroll(QRegion area, int dx, int dy)
        {
            var arg0 = ReferenceEquals(area, null) ? global::System.IntPtr.Zero : area.__Instance;
            var __ret = Internal.Scroll_0(__Instance, arg0, dx, dy);
            return __ret;
        }

        /// <summary>
        /// <para>This function is called before painting onto the surface begins,
        /// with the region in which the painting will occur.</para>
        /// <para>See also endPaint() and paintDevice().</para>
        /// </summary>
        public void BeginPaint(QRegion region)
        {
            var arg0 = ReferenceEquals(region, null) ? global::System.IntPtr.Zero : region.__Instance;
            Internal.BeginPaint_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This function is called after painting onto the surface has
        /// ended.</para>
        /// <para>See also beginPaint() and paintDevice().</para>
        /// </summary>
        public void EndPaint()
        {
            Internal.EndPaint_0(__Instance);
        }

        /// <summary>
        /// <para>See also setStaticContents().</para>
        /// <para></para>
        /// <para>See also staticContents().</para>
        /// </summary>
        public QRegion StaticContents
        {
            get
            {
                var __ret = new QtGui.QRegion.Internal();
                Internal.StaticContents_0(new IntPtr(&__ret), __Instance);
                return QRegion.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetStaticContents_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the top-level window associated with this
        /// surface.</para>
        /// </summary>
        public QWindow Window
        {
            get
            {
                var __ret = Internal.Window_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QWindow.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Implement this function to return the appropriate paint
        /// device.</para>
        /// </summary>
        public QPaintDevice PaintDevice
        {
            get
            {
                var __ret = Internal.PaintDevice_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintDeviceInternal.__CreateInstance(__ret);
            }
        }

        public bool HasStaticContents
        {
            get
            {
                var __ret = Internal.HasStaticContents_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QPageSize class describes the size and name of a defined page
    /// size</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>This class implements support for the set of standard page sizes
    /// as defined in the Adobe Postscript PPD Standard v4.3. It defines the
    /// standard set of page sizes in points, millimeters and inches and ensures
    /// these sizes are consistently used. Other size units can be used but will be
    /// calculated results and so may not always be consistent. The defined point
    /// sizes are always a integer, all other sizes can be fractions of a
    /// unit.</para>
    /// <para>The defined size is always in width x height order with no
    /// implied page orientation. Note that it is possible for page sizes to be
    /// defined where the width is greater than the height, such as
    /// QPageSize::Ledger, so you cannot rely on comparing the width and height
    /// values to determine page orientation.</para>
    /// <para>For example, A4 is defined by the standard as 210mm x 297mm,
    /// 8.27in x 11.69in, or 595pt x 842pt.</para>
    /// <para>You can also define custom page sizes with custom names in any
    /// units you want and this unit size will be preserved and used as the base
    /// for all other unit size calculations.</para>
    /// <para>When creating a QPageSize using a custom QSize you can choose if
    /// you want QPageSize to try match the size to a standard page size. By
    /// default QPaperSize uses a FuzzyMatch mode where it will match a given page
    /// size to a standard page size if it falls within 3 postscript points of a
    /// defined standard size. You can override this to request only an exact match
    /// but this is not recommended as conversions between units can easily lose 3
    /// points and result in incorrect page sizes.</para>
    /// <para>A QPageSize instance may also be obtained by querying the
    /// supported page sizes for a print device. In this case the localized name
    /// returned is that defined by the printer itself. Note that the print device
    /// may not support the current default locale language.</para>
    /// <para>The class also provides convenience methods for converting page
    /// size IDs to and from various unit sizes.</para>
    /// <para></para>
    /// <para>See also QPagedPaintDevice and QPdfWriter.</para>
    /// </remarks>
    public unsafe partial class QPageSize : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPageSizeC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPageSizeC2ENS_10PageSizeIdE")]
            internal static extern void ctor_1(global::System.IntPtr instance, QPageSize.PageSizeId pageSizeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPageSizeC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QPageSizeD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize14isEquivalentToERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEquivalentTo_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize3keyEv")]
            internal static extern void Key_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize4nameEv")]
            internal static extern void Name_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize2idEv")]
            internal static extern QPageSize.PageSizeId Id_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize9windowsIdEv")]
            internal static extern int WindowsId_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize15definitionUnitsEv")]
            internal static extern QPageSize.Unit DefinitionUnits_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QPageSize3keyENS_10PageSizeIdE")]
            internal static extern void Key_1(global::System.IntPtr @return, QPageSize.PageSizeId pageSizeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QPageSize4nameENS_10PageSizeIdE")]
            internal static extern void Name_1(global::System.IntPtr @return, QPageSize.PageSizeId pageSizeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QPageSize2idEi")]
            internal static extern QPageSize.PageSizeId Id_3(int windowsId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QPageSize9windowsIdENS_10PageSizeIdE")]
            internal static extern int WindowsId_1(QPageSize.PageSizeId pageSizeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9QPageSize15definitionUnitsENS_10PageSizeIdE")]
            internal static extern QPageSize.Unit DefinitionUnits_1(QPageSize.PageSizeId pageSizeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZeqRK9QPageSizeS1_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr lhs, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QPageSize7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type lists the available page sizes as defined in the
        /// Postscript PPD standard. These values are duplicated in QPagedPaintDevice
        /// and QPrinter.</para>
        /// <para>The defined sizes are:</para>
        /// <para>Due to historic reasons QPageSize::Executive is not the same as
        /// the standard Postscript and Windows Executive size, use
        /// QPageSize::ExecutiveStandard instead.</para>
        /// <para>The Postscript standard size QPageSize::Folio is different to the
        /// Windows DMPAPER_FOLIO size, use the Postscript standard size
        /// QPageSize::FanFoldGermanLegal if needed.</para>
        /// </summary>
        public enum PageSizeId : uint
        {
            /// <summary>210 x 297 mm, 8.26 x 11.69 inches</summary>
            A4 = 0,
            /// <summary>176 x 250 mm, 6.93 x 9.84 inches</summary>
            B5 = 1,
            /// <summary>8.5 x 11 inches, 215.9 x 279.4 mm</summary>
            Letter = 2,
            /// <summary>8.5 x 14 inches, 215.9 x 355.6 mm</summary>
            Legal = 3,
            /// <summary>7.5 x 10 inches, 190.5 x 254 mm</summary>
            Executive = 4,
            /// <summary>841 x 1189 mm</summary>
            A0 = 5,
            /// <summary>594 x 841 mm</summary>
            A1 = 6,
            /// <summary>420 x 594 mm</summary>
            A2 = 7,
            /// <summary>297 x 420 mm</summary>
            A3 = 8,
            /// <summary>148 x 210 mm</summary>
            A5 = 9,
            /// <summary>105 x 148 mm</summary>
            A6 = 10,
            /// <summary>74 x 105 mm</summary>
            A7 = 11,
            /// <summary>52 x 74 mm</summary>
            A8 = 12,
            /// <summary>37 x 52 mm</summary>
            A9 = 13,
            /// <summary>1000 x 1414 mm</summary>
            B0 = 14,
            /// <summary>707 x 1000 mm</summary>
            B1 = 15,
            /// <summary>31 x 44 mm</summary>
            B10 = 16,
            /// <summary>500 x 707 mm</summary>
            B2 = 17,
            /// <summary>353 x 500 mm</summary>
            B3 = 18,
            /// <summary>250 x 353 mm</summary>
            B4 = 19,
            /// <summary>125 x 176 mm</summary>
            B6 = 20,
            /// <summary>88 x 125 mm</summary>
            B7 = 21,
            /// <summary>62 x 88 mm</summary>
            B8 = 22,
            /// <summary>44 x 62 mm</summary>
            B9 = 23,
            /// <summary>163 x 229 mm</summary>
            C5E = 24,
            /// <summary>105 x 241 mm, U.S. Common 10 Envelope</summary>
            Comm10E = 25,
            /// <summary>110 x 220 mm</summary>
            DLE = 26,
            /// <summary>210 x 330 mm</summary>
            Folio = 27,
            /// <summary>431.8 x 279.4 mm</summary>
            Ledger = 28,
            /// <summary>279.4 x 431.8 mm</summary>
            Tabloid = 29,
            /// <summary>Unknown, or a user defined size.</summary>
            Custom = 30,
            A10 = 31,
            A3Extra = 32,
            A4Extra = 33,
            A4Plus = 34,
            A4Small = 35,
            A5Extra = 36,
            B5Extra = 37,
            JisB0 = 38,
            JisB1 = 39,
            JisB2 = 40,
            JisB3 = 41,
            JisB4 = 42,
            JisB5 = 43,
            /// <summary>,</summary>
            JisB6 = 44,
            JisB7 = 45,
            JisB8 = 46,
            JisB9 = 47,
            JisB10 = 48,
            AnsiC = 49,
            AnsiD = 50,
            AnsiE = 51,
            LegalExtra = 52,
            LetterExtra = 53,
            LetterPlus = 54,
            LetterSmall = 55,
            TabloidExtra = 56,
            ArchA = 57,
            ArchB = 58,
            ArchC = 59,
            ArchD = 60,
            ArchE = 61,
            Imperial7x9 = 62,
            Imperial8x10 = 63,
            Imperial9x11 = 64,
            Imperial9x12 = 65,
            Imperial10x11 = 0x42,
            Imperial10x13 = 0x43,
            Imperial10x14 = 0x44,
            Imperial12x11 = 69,
            Imperial15x11 = 70,
            ExecutiveStandard = 71,
            Note = 72,
            Quarto = 73,
            Statement = 74,
            SuperA = 75,
            SuperB = 76,
            Postcard = 77,
            DoublePostcard = 78,
            Prc16K = 79,
            Prc32K = 80,
            Prc32KBig = 81,
            FanFoldUS = 82,
            FanFoldGerman = 83,
            FanFoldGermanLegal = 84,
            EnvelopeB4 = 85,
            EnvelopeB5 = 86,
            EnvelopeB6 = 87,
            EnvelopeC0 = 88,
            EnvelopeC1 = 89,
            EnvelopeC2 = 90,
            EnvelopeC3 = 91,
            EnvelopeC4 = 92,
            EnvelopeC6 = 93,
            EnvelopeC65 = 94,
            EnvelopeC7 = 95,
            Envelope9 = 96,
            Envelope11 = 97,
            Envelope12 = 98,
            Envelope14 = 99,
            EnvelopeMonarch = 100,
            EnvelopePersonal = 101,
            EnvelopeChou3 = 102,
            EnvelopeChou4 = 103,
            EnvelopeInvite = 104,
            EnvelopeItalian = 105,
            EnvelopeKaku2 = 106,
            EnvelopeKaku3 = 107,
            EnvelopePrc1 = 108,
            EnvelopePrc2 = 109,
            EnvelopePrc3 = 110,
            EnvelopePrc4 = 111,
            EnvelopePrc5 = 112,
            EnvelopePrc6 = 113,
            EnvelopePrc7 = 114,
            EnvelopePrc8 = 115,
            EnvelopePrc9 = 116,
            EnvelopePrc10 = 117,
            EnvelopeYou4 = 118,
            /// <summary>= EnvelopeYou4</summary>
            LastPageSize = 118,
            NPageSize = 118,
            NPaperSize = 118,
            /// <summary>= Letter</summary>
            AnsiA = 2,
            /// <summary>= Ledger</summary>
            AnsiB = 28,
            /// <summary>= C5E</summary>
            EnvelopeC5 = 24,
            /// <summary>= DLE</summary>
            EnvelopeDL = 26,
            /// <summary>= Comm10E</summary>
            Envelope10 = 25
        }

        /// <summary>
        /// <para>This enum type is used to specify the measurement unit for page
        /// sizes.</para>
        /// </summary>
        public enum Unit : uint
        {
            Millimeter = 0,
            /// <summary>1/72th of an inch</summary>
            Point = 1,
            Inch = 2,
            /// <summary>1/72th of a foot, 1/6th of an inch, 12 Points</summary>
            Pica = 3,
            /// <summary>1/72th of a French inch, 0.375 mm</summary>
            Didot = 4,
            /// <summary>1/6th of a French inch, 12 Didot, 4.5mm</summary>
            Cicero = 5
        }

        public enum SizeMatchPolicy : uint
        {
            /// <summary>Match to a standard page size if within the margin of tolerance.</summary>
            FuzzyMatch = 0,
            /// <summary>Match to a standard page size if within the margin of tolerance regardless of orientation.</summary>
            FuzzyOrientationMatch = 1,
            /// <summary>Only match to a standard page size if the sizes match exactly.</summary>
            ExactMatch = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPageSize __CreateInstance(global::System.IntPtr native)
        {
            return new QPageSize((QPageSize.Internal*) native);
        }

        public static QPageSize __CreateInstance(QPageSize.Internal native)
        {
            return new QPageSize(native);
        }

        private static QPageSize.Internal* __CopyValue(QPageSize.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QPageSize.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QPageSize.Internal*) ret;
        }

        private QPageSize(QPageSize.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPageSize(QPageSize.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a null QPageSize.</para>
        /// </summary>
        public QPageSize()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a QPageSize of the standard pageSize.</para>
        /// <para>If pageSize is QPageSize::Custom then the resulting QPageSize
        /// will not be valid. Use the custom size constructor instead.</para>
        /// </summary>
        public QPageSize(QPageSize.PageSizeId pageSizeId)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = pageSizeId;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Copy constructor, copies other to this.</para>
        /// </summary>
        public QPageSize(QPageSize other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_4(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if this page is equivalent to the other page, i.e.
        /// if the page has the same size regardless of other attributes like
        /// name.</para>
        /// </summary>
        public bool IsEquivalentTo(QPageSize other)
        {
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.IsEquivalentTo_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the unique key of the page size.</para>
        /// <para>By default this is the PPD standard mediaOption keyword for the
        /// page size, or the PPD custom format key. If the QPageSize instance was
        /// obtained from a print device then this will be the key provided by the
        /// print device and may differ from the standard key.</para>
        /// <para>If the QPageSize is invalid then the key will be an empty
        /// string.</para>
        /// <para>This key should never be shown to end users, it is an internal
        /// key only. For a human-readable name use name().</para>
        /// <para>See also name().</para>
        /// </summary>
        public string Key()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.Key_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns a localized human-readable name for the page size.</para>
        /// <para>If the QPageSize instance was obtained from a print device then
        /// the name used is that provided by the print device. Note that a print
        /// device may not support the current default locale language.</para>
        /// <para>If the QPageSize is invalid then the name will be an empty
        /// string.</para>
        /// </summary>
        public string Name()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.Name_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the standard QPageSize::PageSizeId of the page, or
        /// QPageSize::Custom.</para>
        /// <para>If the QPageSize is invalid then the ID will be
        /// QPageSize::Custom.</para>
        /// </summary>
        public QPageSize.PageSizeId Id()
        {
            var __ret = Internal.Id_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the Windows DMPAPER enum value for the page size.</para>
        /// <para>Not all valid PPD page sizes have a Windows equivalent, in which
        /// case 0 will be returned.</para>
        /// <para>If the QPageSize is invalid then the Windows ID will be 0.</para>
        /// <para>See also id().</para>
        /// </summary>
        public int WindowsId()
        {
            var __ret = Internal.WindowsId_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the definition units of the page size.</para>
        /// <para>For a standard page size this will be the units as defined in the
        /// relevant standard, i.e. ISO A4 will be defined in millimeters while ANSI
        /// Letter will be defined in inches.</para>
        /// <para>For a custom page size this will be the original units used to
        /// create the page size object.</para>
        /// <para>If the QPageSize is invalid then the QPageSize::Unit will be
        /// invalid.</para>
        /// <para>See also definitionSize().</para>
        /// </summary>
        public QPageSize.Unit DefinitionUnits()
        {
            var __ret = Internal.DefinitionUnits_0(__Instance);
            return __ret;
        }

        public static bool operator !=(QPageSize lhs, QPageSize rhs)
        {
            return !(lhs == rhs);
        }

        /// <summary>
        /// <para>Returns the PPD mediaOption keyword of the standard
        /// pageSizeId.</para>
        /// <para>If the QPageSize is invalid then the key will be empty.</para>
        /// </summary>
        public static string Key(QPageSize.PageSizeId pageSizeId)
        {
            var arg0 = pageSizeId;
            var __ret = new QtCore.QString.Internal();
            Internal.Key_1(new IntPtr(&__ret), arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the localized name of the standard pageSizeId.</para>
        /// <para>If the QPageSize is invalid then the name will be empty.</para>
        /// </summary>
        public static string Name(QPageSize.PageSizeId pageSizeId)
        {
            var arg0 = pageSizeId;
            var __ret = new QtCore.QString.Internal();
            Internal.Name_1(new IntPtr(&__ret), arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the PageSizeId for the given Windows DMPAPER enum value
        /// windowsId.</para>
        /// <para>If there is no matching PageSizeId then QPageSize::Custom is
        /// returned.</para>
        /// </summary>
        public static QPageSize.PageSizeId Id(int windowsId)
        {
            var __ret = Internal.Id_3(windowsId);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the Windows DMPAPER enum value of the standard
        /// pageSizeId.</para>
        /// <para>Not all valid PPD page sizes have a Windows equivalent, in which
        /// case 0 will be returned.</para>
        /// </summary>
        public static int WindowsId(QPageSize.PageSizeId pageSizeId)
        {
            var arg0 = pageSizeId;
            var __ret = Internal.WindowsId_1(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the definition units of the standard pageSizeId.</para>
        /// <para>To obtain the definition size, call
        /// QPageSize::definitionSize().</para>
        /// </summary>
        public static QPageSize.Unit DefinitionUnits(QPageSize.PageSizeId pageSizeId)
        {
            var arg0 = pageSizeId;
            var __ret = Internal.DefinitionUnits_1(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if page size lhs is equal to page size rhs, i.e. if
        /// the page sizes have the same attributes. Current attributes are size and
        /// name.</para>
        /// </summary>
        public static bool operator ==(QPageSize lhs, QPageSize rhs)
        {
            bool lhsNull = ReferenceEquals(lhs, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (lhsNull || rhsNull)
                return lhsNull && rhsNull;
            var arg0 = lhs.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QPageSize;
        }

        /// <summary>
        /// <para>Returns true if this page size is valid.</para>
        /// <para>The page size may be invalid if created with an invalid
        /// PageSizeId, or a negative or invalid QSize or QSizeF, or the null
        /// constructor.</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class QPageLayout : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPageLayoutC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPageLayoutC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPageLayoutD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QPageLayout14isEquivalentToERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEquivalentTo_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZeqRK11QPageLayoutS1_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr lhs, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QPageLayout4modeEv")]
            internal static extern QPageLayout.Mode mode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPageLayout7setModeENS_4ModeE")]
            internal static extern void SetMode_0(global::System.IntPtr instance, QPageLayout.Mode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QPageLayout11orientationEv")]
            internal static extern QPageLayout.Orientation orientation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPageLayout14setOrientationENS_11OrientationE")]
            internal static extern void SetOrientation_0(global::System.IntPtr instance, QPageLayout.Orientation orientation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QPageLayout5unitsEv")]
            internal static extern QPageLayout.Unit Units_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QPageLayout8setUnitsENS_4UnitE")]
            internal static extern void SetUnits_0(global::System.IntPtr instance, QPageLayout.Unit units);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QPageLayout7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QPageLayout8pageSizeEv")]
            internal static extern void PageSize_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type is used to specify the measurement unit for page
        /// layout and margins.</para>
        /// </summary>
        public enum Unit : uint
        {
            Millimeter = 0,
            /// <summary>1/72th of an inch</summary>
            Point = 1,
            Inch = 2,
            /// <summary>1/72th of a foot, 1/6th of an inch, 12 Points</summary>
            Pica = 3,
            /// <summary>1/72th of a French inch, 0.375 mm</summary>
            Didot = 4,
            /// <summary>1/6th of a French inch, 12 Didot, 4.5mm</summary>
            Cicero = 5
        }

        /// <summary>
        /// <para>This enum type defines the page orientation</para>
        /// <para>Note that some standard page sizes are defined with a width
        /// larger than their height, hence the orientation is defined relative to the
        /// standard page size and not using the relative page dimensions.</para>
        /// </summary>
        public enum Orientation : uint
        {
            /// <summary>The page size is used in its default orientation</summary>
            Portrait = 0,
            /// <summary>The page size is rotated through 90 degrees</summary>
            Landscape = 1
        }

        /// <summary>
        /// <para>Defines the page layout mode</para>
        /// </summary>
        public enum Mode : uint
        {
            /// <summary>Paint Rect includes margins, margins must fall between the minimum and maximum.</summary>
            StandardMode = 0,
            /// <summary>Paint Rect excludes margins, margins can be any value and must be managed manually.</summary>
            FullPageMode = 1
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPageLayout __CreateInstance(global::System.IntPtr native)
        {
            return new QPageLayout((QPageLayout.Internal*) native);
        }

        public static QPageLayout __CreateInstance(QPageLayout.Internal native)
        {
            return new QPageLayout(native);
        }

        private static QPageLayout.Internal* __CopyValue(QPageLayout.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QPageLayout.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QPageLayout.Internal*) ret;
        }

        private QPageLayout(QPageLayout.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPageLayout(QPageLayout.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates an invalid QPageLayout.</para>
        /// </summary>
        public QPageLayout()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Copy constructor, copies other to this.</para>
        /// </summary>
        public QPageLayout(QPageLayout other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if this page layout is equivalent to the other page
        /// layout, i.e. if the page has the same size, margins and orientation.</para>
        /// </summary>
        public bool IsEquivalentTo(QPageLayout other)
        {
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.IsEquivalentTo_0(__Instance, arg0);
            return __ret;
        }

        public static bool operator !=(QPageLayout lhs, QPageLayout rhs)
        {
            return !(lhs == rhs);
        }

        /// <summary>
        /// <para>Returns true if page layout lhs is equal to page layout rhs, i.e.
        /// if all the attributes are exactly equal.</para>
        /// <para>Note that this is a strict equality, especially for page size
        /// where the QPageSize ID, name and size must exactly match, and the margins
        /// where the units must match.</para>
        /// <para>See also QPageLayout::isEquivalentTo().</para>
        /// </summary>
        public static bool operator ==(QPageLayout lhs, QPageLayout rhs)
        {
            bool lhsNull = ReferenceEquals(lhs, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (lhsNull || rhsNull)
                return lhsNull && rhsNull;
            var arg0 = lhs.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QPageLayout;
        }

        /// <summary>
        /// <para>Returns the page layout mode.</para>
        /// <para>See also setMode().</para>
        /// <para></para>
        /// <para>Sets a page layout mode to mode.</para>
        /// <para>See also mode().</para>
        /// </summary>
        public QPageLayout.Mode mode
        {
            get
            {
                var __ret = Internal.mode_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetMode_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the page orientation of the page layout.</para>
        /// <para>See also setOrientation().</para>
        /// <para></para>
        /// <para>Sets the page orientation of the page layout to
        /// orientation.</para>
        /// <para>Changing the orientation does not affect the current margins or
        /// the minimum margins.</para>
        /// <para>See also orientation().</para>
        /// </summary>
        public QPageLayout.Orientation orientation
        {
            get
            {
                var __ret = Internal.orientation_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetOrientation_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the units the page layout is currently defined in.</para>
        /// <para>See also setUnits().</para>
        /// <para></para>
        /// <para>Sets the units used to define the page layout.</para>
        /// <para>See also units().</para>
        /// </summary>
        public QPageLayout.Unit Units
        {
            get
            {
                var __ret = Internal.Units_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetUnits_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if this page layout is valid.</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the page size of the page layout.</para>
        /// <para>Note that the QPageSize is always defined in a Portrait
        /// orientation. To obtain a size that takes the set orientation into account
        /// you must use fullRect().</para>
        /// <para>See also setPageSize().</para>
        /// </summary>
        public QPageSize PageSize
        {
            get
            {
                var __ret = new QtGui.QPageSize.Internal();
                Internal.PageSize_0(new IntPtr(&__ret), __Instance);
                return QPageSize.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QPagedPaintDevice class is a represents a paintdevice that
    /// supports multiple pages.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Paged paint devices are used to generate output for printing or
    /// for formats like PDF. QPdfWriter and QPrinter inherit from it.</para>
    /// </remarks>
    public unsafe abstract partial class QPagedPaintDevice : QtGui.QPaintDevice, QtGui.IQPagedPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            public global::System.IntPtr d;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDeviceC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDeviceC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDeviceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice13setPageLayoutERK11QPageLayout")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetPageLayout_0(global::System.IntPtr instance, global::System.IntPtr pageLayout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice11setPageSizeERK9QPageSize")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetPageSize_0(global::System.IntPtr instance, global::System.IntPtr pageSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice18setPageOrientationEN11QPageLayout11OrientationE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetPageOrientation_0(global::System.IntPtr instance, QPageLayout.Orientation orientation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPagedPaintDevice8pageSizeEv")]
            internal static extern QPagedPaintDevice.PageSize pageSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice11setPageSizeENS_8PageSizeE")]
            internal static extern void SetPageSize_1(global::System.IntPtr instance, QPagedPaintDevice.PageSize size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPagedPaintDevice7marginsEv")]
            internal static extern void margins_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice10setMarginsERKNS_7MarginsE")]
            internal static extern void SetMargins_0(global::System.IntPtr instance, global::System.IntPtr margins);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPagedPaintDevice10pageLayoutEv")]
            internal static extern void PageLayout_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice16devicePageLayoutEv")]
            internal static extern global::System.IntPtr DevicePageLayout_1(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum type lists the available page sizes as defined in the
        /// Postscript PPD standard. These values are duplicated in QPageSize and
        /// QPrinter.</para>
        /// <para>The defined sizes are:</para>
        /// <para>Due to historic reasons QPageSize::Executive is not the same as
        /// the standard Postscript and Windows Executive size, use
        /// QPageSize::ExecutiveStandard instead.</para>
        /// <para>The Postscript standard size QPageSize::Folio is different to the
        /// Windows DMPAPER_FOLIO size, use the Postscript standard size
        /// QPageSize::FanFoldGermanLegal if needed.</para>
        /// </summary>
        public enum PageSize : uint
        {
            /// <summary>210 x 297 mm, 8.26 x 11.69 inches</summary>
            A4 = 0,
            /// <summary>176 x 250 mm, 6.93 x 9.84 inches</summary>
            B5 = 1,
            /// <summary>8.5 x 11 inches, 215.9 x 279.4 mm</summary>
            Letter = 2,
            /// <summary>8.5 x 14 inches, 215.9 x 355.6 mm</summary>
            Legal = 3,
            /// <summary>7.5 x 10 inches, 190.5 x 254 mm</summary>
            Executive = 4,
            /// <summary>841 x 1189 mm</summary>
            A0 = 5,
            /// <summary>594 x 841 mm</summary>
            A1 = 6,
            /// <summary>420 x 594 mm</summary>
            A2 = 7,
            /// <summary>297 x 420 mm</summary>
            A3 = 8,
            /// <summary>148 x 210 mm</summary>
            A5 = 9,
            /// <summary>105 x 148 mm</summary>
            A6 = 10,
            /// <summary>74 x 105 mm</summary>
            A7 = 11,
            /// <summary>52 x 74 mm</summary>
            A8 = 12,
            /// <summary>37 x 52 mm</summary>
            A9 = 13,
            /// <summary>1000 x 1414 mm</summary>
            B0 = 14,
            /// <summary>707 x 1000 mm</summary>
            B1 = 15,
            /// <summary>31 x 44 mm</summary>
            B10 = 16,
            /// <summary>500 x 707 mm</summary>
            B2 = 17,
            /// <summary>353 x 500 mm</summary>
            B3 = 18,
            /// <summary>250 x 353 mm</summary>
            B4 = 19,
            /// <summary>125 x 176 mm</summary>
            B6 = 20,
            /// <summary>88 x 125 mm</summary>
            B7 = 21,
            /// <summary>62 x 88 mm</summary>
            B8 = 22,
            /// <summary>33 x 62 mm</summary>
            B9 = 23,
            /// <summary>163 x 229 mm</summary>
            C5E = 24,
            /// <summary>105 x 241 mm, U.S. Common 10 Envelope</summary>
            Comm10E = 25,
            /// <summary>110 x 220 mm</summary>
            DLE = 26,
            /// <summary>210 x 330 mm</summary>
            Folio = 27,
            /// <summary>431.8 x 279.4 mm</summary>
            Ledger = 28,
            /// <summary>279.4 x 431.8 mm</summary>
            Tabloid = 29,
            /// <summary>Unknown, or a user defined size.</summary>
            Custom = 30,
            A10 = 31,
            A3Extra = 32,
            A4Extra = 33,
            A4Plus = 34,
            A4Small = 35,
            A5Extra = 36,
            B5Extra = 37,
            JisB0 = 38,
            JisB1 = 39,
            JisB2 = 40,
            JisB3 = 41,
            JisB4 = 42,
            JisB5 = 43,
            /// <summary>,</summary>
            JisB6 = 44,
            JisB7 = 45,
            JisB8 = 46,
            JisB9 = 47,
            JisB10 = 48,
            AnsiC = 49,
            AnsiD = 50,
            AnsiE = 51,
            LegalExtra = 52,
            LetterExtra = 53,
            LetterPlus = 54,
            LetterSmall = 55,
            TabloidExtra = 56,
            ArchA = 57,
            ArchB = 58,
            ArchC = 59,
            ArchD = 60,
            ArchE = 61,
            Imperial7x9 = 62,
            Imperial8x10 = 63,
            Imperial9x11 = 64,
            Imperial9x12 = 65,
            Imperial10x11 = 0x42,
            Imperial10x13 = 0x43,
            Imperial10x14 = 0x44,
            Imperial12x11 = 69,
            Imperial15x11 = 70,
            ExecutiveStandard = 71,
            Note = 72,
            Quarto = 73,
            Statement = 74,
            SuperA = 75,
            SuperB = 76,
            Postcard = 77,
            DoublePostcard = 78,
            Prc16K = 79,
            Prc32K = 80,
            Prc32KBig = 81,
            FanFoldUS = 82,
            FanFoldGerman = 83,
            FanFoldGermanLegal = 84,
            EnvelopeB4 = 85,
            EnvelopeB5 = 86,
            EnvelopeB6 = 87,
            EnvelopeC0 = 88,
            EnvelopeC1 = 89,
            EnvelopeC2 = 90,
            EnvelopeC3 = 91,
            EnvelopeC4 = 92,
            EnvelopeC6 = 93,
            EnvelopeC65 = 94,
            EnvelopeC7 = 95,
            Envelope9 = 96,
            Envelope11 = 97,
            Envelope12 = 98,
            Envelope14 = 99,
            EnvelopeMonarch = 100,
            EnvelopePersonal = 101,
            EnvelopeChou3 = 102,
            EnvelopeChou4 = 103,
            EnvelopeInvite = 104,
            EnvelopeItalian = 105,
            EnvelopeKaku2 = 106,
            EnvelopeKaku3 = 107,
            EnvelopePrc1 = 108,
            EnvelopePrc2 = 109,
            EnvelopePrc3 = 110,
            EnvelopePrc4 = 111,
            EnvelopePrc5 = 112,
            EnvelopePrc6 = 113,
            EnvelopePrc7 = 114,
            EnvelopePrc8 = 115,
            EnvelopePrc9 = 116,
            EnvelopePrc10 = 117,
            EnvelopeYou4 = 118,
            /// <summary>= EnvelopeYou4</summary>
            LastPageSize = 118,
            NPageSize = 118,
            NPaperSize = 118,
            /// <summary>= Letter</summary>
            AnsiA = 2,
            /// <summary>= Ledger</summary>
            AnsiB = 28,
            /// <summary>= C5E</summary>
            EnvelopeC5 = 24,
            /// <summary>= DLE</summary>
            EnvelopeDL = 26,
            /// <summary>= Comm10E</summary>
            Envelope10 = 25
        }

        public unsafe partial class Margins : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public double left;

                [FieldOffset(8)]
                public double right;

                [FieldOffset(16)]
                public double top;

                [FieldOffset(24)]
                public double bottom;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN17QPagedPaintDevice7MarginsC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Margins __CreateInstance(global::System.IntPtr native)
            {
                return new Margins((Margins.Internal*) native);
            }

            public static Margins __CreateInstance(Margins.Internal native)
            {
                return new Margins(native);
            }

            private static Margins.Internal* __CopyValue(Margins.Internal native)
            {
                var ret = (Margins.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private Margins(Margins.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Margins(Margins.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }
        }

        private readonly bool __ownsNativeInstance;

        protected QPagedPaintDevice(QPagedPaintDevice.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintDevice.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new paged paint device.</para>
        /// </summary>
        protected QPagedPaintDevice()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Starts a new page. Returns true on success.</para>
        /// </summary>
        public abstract bool NewPage();

        /// <summary>
        /// <para>Sets the page layout to newPageLayout.</para>
        /// <para>You should call this before calling QPainter::begin(), or
        /// immediately before calling newPage() to apply the new page layout to a new
        /// page. You should not call any painting methods between a call to
        /// setPageLayout() and newPage() as the wrong paint metrics may be
        /// used.</para>
        /// <para>Returns true if the page layout was successfully set to
        /// newPageLayout.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also pageLayout().</para>
        /// </summary>
        public bool SetPageLayout(QPageLayout pageLayout)
        {
            var arg0 = ReferenceEquals(pageLayout, null) ? global::System.IntPtr.Zero : pageLayout.__Instance;
            var __ret = Internal.SetPageLayout_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the page size to pageSize.</para>
        /// <para>To get the current QPageSize use pageLayout().pageSize().</para>
        /// <para>You should call this before calling QPainter::begin(), or
        /// immediately before calling newPage() to apply the new page size to a new
        /// page. You should not call any painting methods between a call to
        /// setPageSize() and newPage() as the wrong paint metrics may be used.</para>
        /// <para>Returns true if the page size was successfully set to
        /// pageSize.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also pageSize() and pageLayout().</para>
        /// </summary>
        public bool SetPageSize(QPageSize pageSize)
        {
            var arg0 = ReferenceEquals(pageSize, null) ? global::System.IntPtr.Zero : pageSize.__Instance;
            var __ret = Internal.SetPageSize_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the page orientation.</para>
        /// <para>The page orientation is used to define the orientation of the
        /// page size when obtaining the page rect.</para>
        /// <para>You should call this before calling QPainter::begin(), or
        /// immediately before calling newPage() to apply the new orientation to a new
        /// page. You should not call any painting methods between a call to
        /// setPageOrientation() and newPage() as the wrong paint metrics may be
        /// used.</para>
        /// <para>To get the current QPageLayout::Orientation use
        /// pageLayout().pageOrientation().</para>
        /// <para>Returns true if the page orientation was successfully set to
        /// orientation.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also pageLayout().</para>
        /// </summary>
        public bool SetPageOrientation(QPageLayout.Orientation orientation)
        {
            var arg0 = orientation;
            var __ret = Internal.SetPageOrientation_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the currently used page size.</para>
        /// <para>See also setPageSize().</para>
        /// <para></para>
        /// <para>Sets the size of the a page to size.</para>
        /// <para>See also setPageSizeMM().</para>
        /// </summary>
        public virtual QPagedPaintDevice.PageSize pageSize
        {
            get
            {
                var __ret = Internal.pageSize_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetPageSize_1(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the current margins of the paint device. The default is
        /// 0.</para>
        /// <para>Margins are specified in millimeters.</para>
        /// <para>See also setMargins().</para>
        /// <para></para>
        /// <para>Sets the margins to be used to margins.</para>
        /// <para>Margins are specified in millimeters.</para>
        /// <para>The margins are purely a hint to the drawing method. They don't
        /// affect the coordinate system or clipping.</para>
        /// <para>See also margins().</para>
        /// </summary>
        public virtual QPagedPaintDevice.Margins margins
        {
            get
            {
                var __ret = new QtGui.QPagedPaintDevice.Margins.Internal();
                Internal.margins_0(new IntPtr(&__ret), __Instance);
                return QPagedPaintDevice.Margins.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetMargins_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the current page layout. Use this method to access the
        /// current QPageSize, QPageLayout::Orientation, QMarginsF, fullRect() and
        /// paintRect().</para>
        /// <para>Note that you cannot use the setters on the returned object, you
        /// must either call the individual QPagedPaintDevice setters or use
        /// setPageLayout().</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also setPageLayout(), setPageSize(), setPageOrientation(),
        /// and setPageMargins().</para>
        /// </summary>
        public QPageLayout PageLayout
        {
            get
            {
                var __ret = new QtGui.QPageLayout.Internal();
                Internal.PageLayout_0(new IntPtr(&__ret), __Instance);
                return QPageLayout.__CreateInstance(__ret);
            }
        }

        public QPageLayout DevicePageLayout
        {
            get
            {
                var __ret = Internal.DevicePageLayout_1(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPageLayout.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QPagedPaintDevice()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            target.Dispose();
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric metric)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            var _ret = target.Metric(metric);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // bool newPage()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _NewPage_0Delegate(global::System.IntPtr instance);
        private static _NewPage_0Delegate _NewPage_0DelegateInstance;

        private static bool _NewPage_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            var _ret = target.NewPage();
            return _ret;
        }

        // void setPageSize(PageSize size)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetPageSize_1Delegate(global::System.IntPtr instance, QPagedPaintDevice.PageSize size);
        private static _SetPageSize_1Delegate _SetPageSize_1DelegateInstance;

        private static void _SetPageSize_1DelegateHook(global::System.IntPtr instance, QPagedPaintDevice.PageSize size)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            target.SetPageSize(size);
        }

        // void setMargins(const Margins &margins)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetMargins_0Delegate(global::System.IntPtr instance, global::System.IntPtr margins);
        private static _SetMargins_0Delegate _SetMargins_0DelegateInstance;

        private static void _SetMargins_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr margins)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPagedPaintDevice) _References[instance].Target;
            target.margins = (margins == IntPtr.Zero) ? null : QPagedPaintDevice.Margins.__CreateInstance(margins);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
                _NewPage_0DelegateInstance += _NewPage_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NewPage_0DelegateInstance).ToPointer();
                _SetPageSize_1DelegateInstance += _SetPageSize_1DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetPageSize_1DelegateInstance).ToPointer();
                _SetMargins_0DelegateInstance += _SetMargins_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_SetMargins_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 12) = _Thunks[1];
                *(void**)(vfptr0 + 16) = _Thunks[2];
                *(void**)(vfptr0 + 20) = _Thunks[3];
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = _Thunks[4];
                *(void**)(vfptr0 + 32) = _Thunks[5];
                *(void**)(vfptr0 + 36) = _Thunks[6];
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = _Thunks[7];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QPagedPaintDeviceInternal : QtGui.QPagedPaintDevice, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QPagedPaintDeviceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QPagedPaintDeviceInternal((QPagedPaintDevice.Internal*) native);
        }

        public static QPagedPaintDevice __CreateInstance(QPagedPaintDevice.Internal native)
        {
            return new QPagedPaintDeviceInternal(native);
        }

        private static QPagedPaintDevice.Internal* __CopyValue(QPagedPaintDevice.Internal native)
        {
            var ret = (QPagedPaintDevice.Internal*) Marshal.AllocHGlobal(16);
            *ret = native;
            return ret;
        }

        private QPagedPaintDeviceInternal(QPagedPaintDevice.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPagedPaintDeviceInternal(QPagedPaintDevice.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPagedPaintDevice.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override bool NewPage()
        {
            void* slot = *(void**) (((QPagedPaintDevice.Internal*) __Instance)->vfptr0 + 8 * 4);
            var ___NewPage_0Delegate = (_NewPage_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_NewPage_0Delegate));
            var __ret = ___NewPage_0Delegate(__Instance);
            return __ret;
        }

        public override QPaintEngine PaintEngine
        {
            get
            {
                void* slot = *(void**) (((QPagedPaintDevice.Internal*) __Instance)->vfptr0 + 3 * 4);
                var ___PaintEngine_0Delegate = (_PaintEngine_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_PaintEngine_0Delegate));
                var __ret = ___PaintEngine_0Delegate(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial interface IQPagedPaintDevice : QtGui.IQPaintDevice
    {
        bool NewPage();

        bool SetPageLayout(QPageLayout pageLayout);

        bool SetPageSize(QPageSize pageSize);

        bool SetPageOrientation(QPageLayout.Orientation orientation);

        QPagedPaintDevice.PageSize PageSize { get; set; }

        QPagedPaintDevice.Margins Margins { get; set; }

        QPageLayout PageLayout { get; }

        QPageLayout DevicePageLayout { get; }
    }

    /// <summary>
    /// <para>The QTextOption class provides a description of general rich text
    /// properties.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QTextOption is used to encapsulate common rich text properties in
    /// a single object. It contains information about text alignment, layout
    /// direction, word wrapping, and other standard properties associated with
    /// text rendering and layout.</para>
    /// <para></para>
    /// <para>See also QTextEdit, QTextDocument, and QTextCursor.</para>
    /// </remarks>
    public unsafe partial class QTextOption : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public uint align;

            [FieldOffset(1)]
            public uint wordWrap;

            [FieldOffset(1)]
            public uint design;

            [FieldOffset(1)]
            public uint direction;

            [FieldOffset(1)]
            public uint unused;

            [FieldOffset(4)]
            public uint unused2;

            [FieldOffset(8)]
            public uint f;

            [FieldOffset(16)]
            public double tab;

            [FieldOffset(24)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextOptionC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextOptionC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr o);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextOptionD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextOption4tabsEv")]
            internal static extern QList.Internal Tabs_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextOption7setTabsERK5QListINS_3TabEE")]
            internal static extern void SetTabs_0(global::System.IntPtr instance, global::System.IntPtr tabStops);
        }

        /// <summary>
        /// <para>This enum holds the different types of tabulator</para>
        /// <para>This enum was introduced or modified in  Qt 4.4.</para>
        /// </summary>
        public enum TabType : uint
        {
            /// <summary>A left-tab</summary>
            LeftTab = 0,
            /// <summary>A right-tab</summary>
            RightTab = 1,
            /// <summary>A centered-tab</summary>
            CenterTab = 2,
            /// <summary>A tab stopping at a certain delimiter-character</summary>
            DelimiterTab = 3
        }

        /// <summary>
        /// <para>This enum describes how text is wrapped in a document.</para>
        /// </summary>
        public enum WrapMode : uint
        {
            /// <summary>Text is not wrapped at all.</summary>
            NoWrap = 0,
            /// <summary>Text is wrapped at word boundaries.</summary>
            WordWrap = 1,
            /// <summary>Same as QTextOption::NoWrap</summary>
            ManualWrap = 2,
            /// <summary>Text can be wrapped at any point on a line, even if it occurs in the middle of a word.</summary>
            WrapAnywhere = 3,
            /// <summary>If possible, wrapping occurs at a word boundary; otherwise it will occur at the appropriate point on the line, even in the middle of a word.</summary>
            WrapAtWordBoundaryOrAnywhere = 4
        }

        [Flags]
        public enum Flag : uint
        {
            /// <summary>Visualize spaces with little dots, and tabs with little arrows.</summary>
            ShowTabsAndSpaces = 0x1,
            /// <summary>Visualize line and paragraph separators with appropriate symbol characters.</summary>
            ShowLineAndParagraphSeparators = 0x2,
            /// <summary>While determining the line-break positions take into account the space added for drawing a separator character.</summary>
            AddSpaceForLineAndParagraphSeparators = 0x4,
            /// <summary>Suppress all color changes in the character formats (except the main selection).</summary>
            SuppressColors = 0x8,
            /// <summary>When this option is set, QTextLine::naturalTextWidth() and naturalTextRect() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</summary>
            IncludeTrailingSpaces = 0x80000000
        }

        public unsafe partial class Tab : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public double position;

                [FieldOffset(8)]
                public QTextOption.TabType type;

                [FieldOffset(12)]
                internal QtCore.QChar.Internal delimiter;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTextOption3TabC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Tab __CreateInstance(global::System.IntPtr native)
            {
                return new Tab((Tab.Internal*) native);
            }

            public static Tab __CreateInstance(Tab.Internal native)
            {
                return new Tab(native);
            }

            private static Tab.Internal* __CopyValue(Tab.Internal native)
            {
                var ret = (Tab.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private Tab(Tab.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Tab(Tab.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public QTextOption.TabType Type
            {
                get
                {
                    return ((Internal*) __Instance)->type;
                }

                set
                {
                    ((Internal*) __Instance)->type = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextOption __CreateInstance(global::System.IntPtr native)
        {
            return new QTextOption((QTextOption.Internal*) native);
        }

        public static QTextOption __CreateInstance(QTextOption.Internal native)
        {
            return new QTextOption(native);
        }

        private static QTextOption.Internal* __CopyValue(QTextOption.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QTextOption.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextOption.Internal*) ret;
        }

        private QTextOption(QTextOption.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextOption(QTextOption.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a text option with default properties for text. The
        /// text alignment property is set to Qt::AlignLeft. The word wrap property is
        /// set to QTextOption::WordWrap. The using of design metrics flag is set to
        /// false.</para>
        /// </summary>
        public QTextOption()
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Construct a copy of the other text option.</para>
        /// </summary>
        public QTextOption(QTextOption o)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(o, null) ? global::System.IntPtr.Zero : o.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns a list of tab positions defined for the text
        /// layout.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also tabStop(), setTabs(), and setTabStop().</para>
        /// <para></para>
        /// <para>Set the Tab properties to tabStops.</para>
        /// <para>See also tabStop() and tabs().</para>
        /// </summary>
        public System.Collections.Generic.IList<QTextOption.Tab> Tabs
        {
            get
            {
                var __ret = Internal.Tabs_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTextOption.Tab>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTextOption.Tab.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }

            set
            {
                var __qList = new QtCore.QList.Internal();
                var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
                __qlistDataData->alloc = value.Count;
                __qlistDataData->begin = 0;
                __qlistDataData->end = value.Count;
                fixed (void** __v = new void*[value.Count])
                {
                    __qlistDataData->array = __v;
                }

                for (int i = 0; i < value.Count; i++)
                {
                    __qlistDataData->array[i] = (void*) value[i].__Instance;
                }
                var arg0 = new global::System.IntPtr(&__qList);
                Internal.SetTabs_0(__Instance, arg0);
            }
        }
    }

    /// <summary>
    /// <para>The QPen class defines how a QPainter should draw lines and
    /// outlines of shapes.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A pen has a style(), width(), brush(), capStyle() and
    /// joinStyle().</para>
    /// <para>The pen style defines the line type. The brush is used to fill
    /// strokes generated with the pen. Use the QBrush class to specify fill
    /// styles. The cap style determines the line end caps that can be drawn using
    /// QPainter, while the join style describes how joins between two lines are
    /// drawn. The pen width can be specified in both integer (width()) and
    /// floating point (widthF()) precision. A line width of zero indicates a
    /// cosmetic pen. This means that the pen width is always drawn one pixel wide,
    /// independent of the transformation set on the painter.</para>
    /// <para>The various settings can easily be modified using the
    /// corresponding setStyle(), setWidth(), setBrush(), setCapStyle() and
    /// setJoinStyle() functions (note that the painter's pen must be reset when
    /// altering the pen's properties).</para>
    /// <para>For example:</para>
    /// <para>QPainter painter(this);</para>
    /// <para>QPen pen(Qt::green, 3, Qt::DashDotLine, Qt::RoundCap,
    /// Qt::RoundJoin);</para>
    /// <para>painter.setPen(pen);</para>
    /// <para>which is equivalent to</para>
    /// <para>QPainter painter(this);</para>
    /// <para>QPen pen;  // creates a default pen</para>
    /// <para></para>
    /// <para>pen.setStyle(Qt::DashDotLine);</para>
    /// <para>pen.setWidth(3);</para>
    /// <para>pen.setBrush(Qt::green);</para>
    /// <para>pen.setCapStyle(Qt::RoundCap);</para>
    /// <para>pen.setJoinStyle(Qt::RoundJoin);</para>
    /// <para></para>
    /// <para>painter.setPen(pen);</para>
    /// <para>The default pen is a solid black brush with 1 width, square cap
    /// style (Qt::SquareCap), and bevel join style (Qt::BevelJoin).</para>
    /// <para>In addition QPen provides the color() and setColor() convenience
    /// functions to extract and set the color of the pen's brush, respectively.
    /// Pens may also be compared and streamed.</para>
    /// <para>For more information about painting in general, see the Paint
    /// System documentation.</para>
    /// <para></para>
    /// <para>Pen Style</para>
    /// <para>Qt provides several built-in styles represented by the
    /// Qt::PenStyle enum:</para>
    /// <para></para>
    /// <para> 	</para>
    /// <para>Qt::SolidLine	Qt::DashLine	Qt::DotLine</para>
    /// <para>	</para>
    /// <para>Qt::DashDotLine	Qt::DashDotDotLine	Qt::CustomDashLine</para>
    /// <para></para>
    /// <para>Simply use the setStyle() function to convert the pen style to
    /// either of the built-in styles, except the Qt::CustomDashLine style which we
    /// will come back to shortly. Setting the style to Qt::NoPen tells the painter
    /// to not draw lines or outlines. The default pen style is
    /// Qt::SolidLine.</para>
    /// <para>Since Qt 4.1 it is also possible to specify a custom dash pattern
    /// using the setDashPattern() function which implicitly converts the style of
    /// the pen to Qt::CustomDashLine. The pattern argument, a QVector, must be
    /// specified as an even number of qreal entries where the entries 1, 3, 5...
    /// are the dashes and 2, 4, 6... are the spaces. For example, the custom
    /// pattern shown above is created using the following code:</para>
    /// <para>QPen pen;</para>
    /// <para>QVector&lt;qreal&gt; dashes;</para>
    /// <para>qreal space = 4;</para>
    /// <para></para>
    /// <para>dashes &lt;&lt; 1 &lt;&lt; space &lt;&lt; 3 &lt;&lt; space
    /// &lt;&lt; 9 &lt;&lt; space</para>
    /// <para>           &lt;&lt; 27 &lt;&lt; space &lt;&lt; 9 &lt;&lt;
    /// space;</para>
    /// <para></para>
    /// <para>pen.setDashPattern(dashes);</para>
    /// <para>Note that the dash pattern is specified in units of the pens
    /// width, e.g. a dash of length 5 in width 10 is 50 pixels long.</para>
    /// <para>The currently set dash pattern can be retrieved using the
    /// dashPattern() function. Use the isSolid() function to determine whether the
    /// pen has a solid fill, or not.</para>
    /// <para></para>
    /// <para>Cap Style</para>
    /// <para>The cap style defines how the end points of lines are drawn using
    /// QPainter. The cap style only apply to wide lines, i.e. when the width is 1
    /// or greater. The Qt::PenCapStyle enum provides the following styles:</para>
    /// <para></para>
    /// <para> 	</para>
    /// <para>Qt::SquareCap	Qt::FlatCap	Qt::RoundCap</para>
    /// <para></para>
    /// <para>The Qt::SquareCap style is a square line end that covers the end
    /// point and extends beyond it by half the line width. The Qt::FlatCap style
    /// is a square line end that does not cover the end point of the line. And the
    /// Qt::RoundCap style is a rounded line end covering the end point.</para>
    /// <para>The default is Qt::SquareCap.</para>
    /// <para>Whether or not end points are drawn when the pen width is 0 or 1
    /// depends on the cap style. Using Qt::SquareCap or Qt::RoundCap they are
    /// drawn, using Qt::FlatCap they are not drawn.</para>
    /// <para></para>
    /// <para>Join Style</para>
    /// <para>The join style defines how joins between two connected lines can
    /// be drawn using QPainter. The join style only apply to wide lines, i.e. when
    /// the width is 1 or greater. The Qt::PenJoinStyle enum provides the following
    /// styles:</para>
    /// <para></para>
    /// <para> 	</para>
    /// <para>Qt::BevelJoin	Qt::MiterJoin	Qt::RoundJoin</para>
    /// <para></para>
    /// <para>The Qt::BevelJoin style fills the triangular notch between the
    /// two lines. The Qt::MiterJoin style extends the lines to meet at an angle.
    /// And the Qt::RoundJoin style fills a circular arc between the two
    /// lines.</para>
    /// <para>The default is Qt::BevelJoin.</para>
    /// <para>When the Qt::MiterJoin style is applied, it is possible to use
    /// the setMiterLimit() function to specify how far the miter join can extend
    /// from the join point. The miterLimit() is used to reduce artifacts between
    /// line joins where the lines are close to parallel.</para>
    /// <para>The miterLimit() must be specified in units of the pens width,
    /// e.g. a miter limit of 5 in width 10 is 50 pixels long. The default miter
    /// limit is 2, i.e. twice the pen width in pixels.</para>
    /// <para></para>
    /// <para> 	The Path Stroking ExampleThe Path Stroking example shows Qt's
    /// built-in dash patterns and shows how custom patterns can be used to extend
    /// the range of available patterns.</para>
    /// </remarks>
    public unsafe partial class QPen : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPenC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPenC2ERK6QColor")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPenC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr pen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPenD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK4QPeneqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK4QPen5widthEv")]
            internal static extern int Width_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPen8setWidthEi")]
            internal static extern void SetWidth_0(global::System.IntPtr instance, int width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK4QPen5colorEv")]
            internal static extern void Color_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPen8setColorERK6QColor")]
            internal static extern void SetColor_0(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK4QPen5brushEv")]
            internal static extern void Brush_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPen8setBrushERK6QBrush")]
            internal static extern void SetBrush_0(global::System.IntPtr instance, global::System.IntPtr brush);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK4QPen10isCosmeticEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Cosmetic_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPen11setCosmeticEb")]
            internal static extern void SetCosmetic_0(global::System.IntPtr instance, bool cosmetic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK4QPen7isSolidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSolid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN4QPen10isDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPen __CreateInstance(global::System.IntPtr native)
        {
            return new QPen((QPen.Internal*) native);
        }

        public static QPen __CreateInstance(QPen.Internal native)
        {
            return new QPen(native);
        }

        private static QPen.Internal* __CopyValue(QPen.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QPen.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return (QPen.Internal*) ret;
        }

        private QPen(QPen.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPen(QPen.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a default black solid line pen with 1 width.</para>
        /// </summary>
        public QPen()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a solid line pen with 1 width and the given
        /// color.</para>
        /// <para>See also setBrush() and setColor().</para>
        /// </summary>
        public QPen(QColor color)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.ctor_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a pen that is a copy of the given pen.</para>
        /// </summary>
        public QPen(QPen pen)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(pen, null) ? global::System.IntPtr.Zero : pen.__Instance;
            Internal.cctor_4(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public static bool operator !=(QPen __op, QPen p)
        {
            return !(__op == p);
        }

        /// <summary>
        /// <para>Returns true if the pen is equal to the given pen; otherwise
        /// false. Two pens are equal if they have equal styles, widths and
        /// colors.</para>
        /// <para>See also operator!=().</para>
        /// </summary>
        public static bool operator ==(QPen __op, QPen p)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool pNull = ReferenceEquals(p, null);
            if (__opNull || pNull)
                return __opNull && pNull;
            var arg0 = __op.__Instance;
            var arg1 = p.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QPen;
        }

        /// <summary>
        /// <para>Returns the pen width with integer precision.</para>
        /// <para>See also setWidth() and widthF().</para>
        /// <para></para>
        /// <para>Sets the pen width to the given width in pixels with integer
        /// precision.</para>
        /// <para>A line width of zero indicates a cosmetic pen. This means that
        /// the pen width is always drawn one pixel wide, independent of the
        /// transformation set on the painter.</para>
        /// <para>Setting a pen width with a negative value is not
        /// supported.</para>
        /// <para>See also setWidthF() and width().</para>
        /// </summary>
        public int Width
        {
            get
            {
                var __ret = Internal.Width_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetWidth_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the color of this pen's brush.</para>
        /// <para>See also brush() and setColor().</para>
        /// <para></para>
        /// <para>Sets the color of this pen's brush to the given color.</para>
        /// <para>See also setBrush() and color().</para>
        /// </summary>
        public QColor Color
        {
            get
            {
                var __ret = new QtGui.QColor.Internal();
                Internal.Color_0(new IntPtr(&__ret), __Instance);
                return QColor.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetColor_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the brush used to fill strokes generated with this
        /// pen.</para>
        /// <para>See also setBrush().</para>
        /// <para></para>
        /// <para>Sets the brush used to fill strokes generated with this pen to
        /// the given brush.</para>
        /// <para>See also brush() and setColor().</para>
        /// </summary>
        public QBrush Brush
        {
            get
            {
                var __ret = new QtGui.QBrush.Internal();
                Internal.Brush_0(new IntPtr(&__ret), __Instance);
                return QBrush.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBrush_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if the pen is cosmetic; otherwise returns
        /// false.</para>
        /// <para>Cosmetic pens are used to draw strokes that have a constant width
        /// regardless of any transformations applied to the QPainter they are used
        /// with. Drawing a shape with a cosmetic pen ensures that its outline will
        /// have the same thickness at different scale factors.</para>
        /// <para>A zero width pen is cosmetic by default.</para>
        /// <para>See also setCosmetic() and widthF().</para>
        /// <para></para>
        /// <para>Sets this pen to cosmetic or non-cosmetic, depending on the value
        /// of cosmetic.</para>
        /// <para>See also isCosmetic().</para>
        /// </summary>
        public bool Cosmetic
        {
            get
            {
                var __ret = Internal.Cosmetic_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetCosmetic_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if the pen has a solid fill, otherwise false.</para>
        /// <para>See also style() and dashPattern().</para>
        /// </summary>
        public bool IsSolid
        {
            get
            {
                var __ret = Internal.IsSolid_0(__Instance);
                return __ret;
            }
        }

        public bool IsDetached
        {
            get
            {
                var __ret = Internal.IsDetached_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QFontInfo class provides general information about
    /// fonts.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QFontInfo class provides the same access functions as QFont,
    /// e.g. family(), pointSize(), italic(), weight(), fixedPitch(), styleHint()
    /// etc. But whilst the QFont access functions return the values that were set,
    /// a QFontInfo object returns the values that apply to the font that will
    /// actually be used to draw the text.</para>
    /// <para>For example, when the program asks for a 25pt Courier font on a
    /// machine that has a non-scalable 24pt Courier font, QFont will (normally)
    /// use the 24pt Courier for rendering. In this case, QFont::pointSize()
    /// returns 25 and QFontInfo::pointSize() returns 24.</para>
    /// <para>There are three ways to create a QFontInfo object.</para>
    /// <para></para>
    /// <para>Calling the QFontInfo constructor with a QFont creates a font
    /// info object for a screen-compatible font, i.e. the font cannot be a printer
    /// font. If the font is changed later, the font info object is not
    /// updated.(Note: If you use a printer font the values returned may be
    /// inaccurate. Printer fonts are not always accessible so the nearest screen
    /// font is used if a printer font is supplied.)</para>
    /// <para></para>
    /// <para>QWidget::fontInfo() returns the font info for a widget's font.
    /// This is equivalent to calling QFontInfo(widget-&gt;font()). If the widget's
    /// font is changed later, the font info object is not updated.</para>
    /// <para>QPainter::fontInfo() returns the font info for a painter's
    /// current font. If the painter's font is changed later, the font info object
    /// is not updated.</para>
    /// </remarks>
    public unsafe partial class QFontInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QFontInfoC2ERK5QFont")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QFontInfoC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr fi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QFontInfoD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo10exactMatchEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool ExactMatch_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo6familyEv")]
            internal static extern void Family_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo9styleNameEv")]
            internal static extern void StyleName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo9pixelSizeEv")]
            internal static extern int PixelSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo9pointSizeEv")]
            internal static extern int PointSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo6italicEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Italic_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo5styleEv")]
            internal static extern QFont.Style Style_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo6weightEv")]
            internal static extern int Weight_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo9underlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Underline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo8overlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Overline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo9strikeOutEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool StrikeOut_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo10fixedPitchEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool FixedPitch_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo9styleHintEv")]
            internal static extern QFont.StyleHint StyleHint_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QFontInfo7rawModeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RawMode_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFontInfo __CreateInstance(global::System.IntPtr native)
        {
            return new QFontInfo((QFontInfo.Internal*) native);
        }

        public static QFontInfo __CreateInstance(QFontInfo.Internal native)
        {
            return new QFontInfo(native);
        }

        private static QFontInfo.Internal* __CopyValue(QFontInfo.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QFontInfo.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QFontInfo.Internal*) ret;
        }

        private QFontInfo(QFontInfo.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFontInfo(QFontInfo.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a font info object for font.</para>
        /// <para>The font must be screen-compatible, i.e. a font you use when
        /// drawing text in widgets or pixmaps, not QPicture or QPrinter.</para>
        /// <para>The font info object holds the information for the font that is
        /// passed in the constructor at the time it is created, and is not updated if
        /// the font's attributes are changed later.</para>
        /// <para>Use QPainter::fontInfo() to get the font info when painting. This
        /// will give correct results also when painting on paint device that is not
        /// screen-compatible.</para>
        /// </summary>
        public QFontInfo(QFont font)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            Internal.ctor_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a copy of fi.</para>
        /// </summary>
        public QFontInfo(QFontInfo fi)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fi, null) ? global::System.IntPtr.Zero : fi.__Instance;
            Internal.cctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if the matched window system font is exactly the
        /// same as the one specified by the font; otherwise returns false.</para>
        /// <para>See also QFont::exactMatch().</para>
        /// </summary>
        public bool ExactMatch()
        {
            var __ret = Internal.ExactMatch_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the family name of the matched window system font.</para>
        /// <para>See also QFont::family().</para>
        /// </summary>
        public string Family
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Family_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the style name of the matched window system font on
        /// systems that support it.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// <para>See also QFont::styleName().</para>
        /// </summary>
        public string StyleName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.StyleName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the pixel size of the matched window system font.</para>
        /// <para>See also QFont::pointSize().</para>
        /// </summary>
        public int PixelSize
        {
            get
            {
                var __ret = Internal.PixelSize_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the point size of the matched window system font.</para>
        /// <para>See also pointSizeF() and QFont::pointSize().</para>
        /// </summary>
        public int PointSize
        {
            get
            {
                var __ret = Internal.PointSize_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the italic value of the matched window system
        /// font.</para>
        /// <para>See also QFont::italic().</para>
        /// </summary>
        public bool Italic
        {
            get
            {
                var __ret = Internal.Italic_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the style value of the matched window system font.</para>
        /// <para>See also QFont::style().</para>
        /// </summary>
        public QFont.Style Style
        {
            get
            {
                var __ret = Internal.Style_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the weight of the matched window system font.</para>
        /// <para>See also QFont::weight() and bold().</para>
        /// </summary>
        public int Weight
        {
            get
            {
                var __ret = Internal.Weight_0(__Instance);
                return __ret;
            }
        }

        public bool Underline
        {
            get
            {
                var __ret = Internal.Underline_0(__Instance);
                return __ret;
            }
        }

        public bool Overline
        {
            get
            {
                var __ret = Internal.Overline_0(__Instance);
                return __ret;
            }
        }

        public bool StrikeOut
        {
            get
            {
                var __ret = Internal.StrikeOut_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the fixed pitch value of the matched window system
        /// font.</para>
        /// <para>See also QFont::fixedPitch().</para>
        /// </summary>
        public bool FixedPitch
        {
            get
            {
                var __ret = Internal.FixedPitch_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the style of the matched window system font.</para>
        /// <para>Currently only returns the style hint set in QFont.</para>
        /// <para>See also QFont::styleHint() and QFont::StyleHint.</para>
        /// </summary>
        public QFont.StyleHint StyleHint
        {
            get
            {
                var __ret = Internal.StyleHint_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the font is a raw mode font; otherwise returns
        /// false.</para>
        /// <para>If it is a raw mode font, all other functions in QFontInfo will
        /// return the same values set in the QFont, regardless of the font actually
        /// used.</para>
        /// <para>See also QFont::rawMode().</para>
        /// </summary>
        public bool RawMode
        {
            get
            {
                var __ret = Internal.RawMode_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QFontMetrics class provides font metrics information.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QFontMetrics functions calculate the size of characters and
    /// strings for a given font. There are three ways you can create a
    /// QFontMetrics object:</para>
    /// <para></para>
    /// <para>Calling the QFontMetrics constructor with a QFont creates a font
    /// metrics object for a screen-compatible font, i.e. the font cannot be a
    /// printer font. If the font is changed later, the font metrics object is not
    /// updated.(Note: If you use a printer font the values returned may be
    /// inaccurate. Printer fonts are not always accessible so the nearest screen
    /// font is used if a printer font is supplied.)</para>
    /// <para></para>
    /// <para>QWidget::fontMetrics() returns the font metrics for a widget's
    /// font. This is equivalent to QFontMetrics(widget-&gt;font()). If the
    /// widget's font is changed later, the font metrics object is not
    /// updated.</para>
    /// <para>QPainter::fontMetrics() returns the font metrics for a painter's
    /// current font. If the painter's font is changed later, the font metrics
    /// object is not updated.</para>
    /// <para></para>
    /// <para>Once created, the object provides functions to access the
    /// individual metrics of the font, its characters, and for strings rendered in
    /// the font.</para>
    /// <para>There are several functions that operate on the font: ascent(),
    /// descent(), height(), leading() and lineSpacing() return the basic size
    /// properties of the font. The underlinePos(), overlinePos(), strikeOutPos()
    /// and lineWidth() functions, return the properties of the line that
    /// underlines, overlines or strikes out the characters. These functions are
    /// all fast.</para>
    /// <para>There are also some functions that operate on the set of glyphs
    /// in the font: minLeftBearing(), minRightBearing() and maxWidth(). These are
    /// by necessity slow, and we recommend avoiding them if possible.</para>
    /// <para>For each character, you can get its width(), leftBearing() and
    /// rightBearing() and find out whether it is in the font using inFont(). You
    /// can also treat the character as a string, and use the string functions on
    /// it.</para>
    /// <para>The string functions include width(), to return the width of a
    /// string in pixels (or points, for a printer), boundingRect(), to return a
    /// rectangle large enough to contain the rendered string, and size(), to
    /// return the size of that rectangle.</para>
    /// <para>Example:</para>
    /// <para>QFont font(&quot;times&quot;, 24);</para>
    /// <para>QFontMetrics fm(font);</para>
    /// <para>int pixelsWide = fm.width(&quot;What's the width of this
    /// text?&quot;);</para>
    /// <para>int pixelsHigh = fm.height();</para>
    /// <para></para>
    /// <para>See also QFont, QFontInfo, QFontDatabase, and Character Map
    /// Example.</para>
    /// </remarks>
    public unsafe partial class QFontMetrics : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QFontMetricsC2ERK5QFont")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QFontMetricsC2ERK5QFontP12QPaintDevice")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr font, global::System.IntPtr pd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QFontMetricsC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr fm);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QFontMetricsD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics5widthERK7QStringi")]
            internal static extern int Width_0(global::System.IntPtr instance, global::System.IntPtr text, int len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics5widthERK7QStringii")]
            internal static extern int Width_1(global::System.IntPtr instance, global::System.IntPtr _0, int len, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics9charWidthERK7QStringi")]
            internal static extern int CharWidth_0(global::System.IntPtr instance, global::System.IntPtr str, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetricseqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics6ascentEv")]
            internal static extern int Ascent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics7descentEv")]
            internal static extern int Descent_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics6heightEv")]
            internal static extern int Height_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics7leadingEv")]
            internal static extern int Leading_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics11lineSpacingEv")]
            internal static extern int LineSpacing_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics14minLeftBearingEv")]
            internal static extern int MinLeftBearing_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics15minRightBearingEv")]
            internal static extern int MinRightBearing_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics8maxWidthEv")]
            internal static extern int MaxWidth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics7xHeightEv")]
            internal static extern int XHeight_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics16averageCharWidthEv")]
            internal static extern int AverageCharWidth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics12underlinePosEv")]
            internal static extern int UnderlinePos_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics11overlinePosEv")]
            internal static extern int OverlinePos_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics12strikeOutPosEv")]
            internal static extern int StrikeOutPos_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QFontMetrics9lineWidthEv")]
            internal static extern int LineWidth_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFontMetrics __CreateInstance(global::System.IntPtr native)
        {
            return new QFontMetrics((QFontMetrics.Internal*) native);
        }

        public static QFontMetrics __CreateInstance(QFontMetrics.Internal native)
        {
            return new QFontMetrics(native);
        }

        private static QFontMetrics.Internal* __CopyValue(QFontMetrics.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QFontMetrics.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QFontMetrics.Internal*) ret;
        }

        private QFontMetrics(QFontMetrics.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFontMetrics(QFontMetrics.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a font metrics object for font.</para>
        /// <para>The font metrics will be compatible with the paintdevice used to
        /// create font.</para>
        /// <para>The font metrics object holds the information for the font that
        /// is passed in the constructor at the time it is created, and is not updated
        /// if the font's attributes are changed later.</para>
        /// <para>Use QFontMetrics(const QFont &amp;, QPaintDevice *) to get the
        /// font metrics that are compatible with a certain paint device.</para>
        /// </summary>
        public QFontMetrics(QFont font)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            Internal.ctor_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a font metrics object for font and paintdevice.</para>
        /// <para>The font metrics will be compatible with the paintdevice passed.
        /// If the paintdevice is 0, the metrics will be screen-compatible, ie. the
        /// metrics you get if you use the font for drawing text on a widgets or
        /// pixmaps, not on a QPicture or QPrinter.</para>
        /// <para>The font metrics object holds the information for the font that
        /// is passed in the constructor at the time it is created, and is not updated
        /// if the font's attributes are changed later.</para>
        /// </summary>
        public QFontMetrics(QFont font, QPaintDevice pd)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var arg1 = ReferenceEquals(pd, null) ? global::System.IntPtr.Zero : pd.__Instance;
            Internal.ctor_1(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a copy of fm.</para>
        /// </summary>
        public QFontMetrics(QFontMetrics fm)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fm, null) ? global::System.IntPtr.Zero : fm.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the width in pixels of the first len characters of text.
        /// If len is negative (the default), the entire string is used.</para>
        /// <para>Note that this value is not equal to boundingRect().width();
        /// boundingRect() returns a rectangle describing the pixels this string will
        /// cover whereas width() returns the distance to where the next string should
        /// be drawn.</para>
        /// <para>See also boundingRect().</para>
        /// </summary>
        public int Width(string text, int len = -1)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.Width_0(__Instance, arg0, len);
            return __ret;
        }

        public int Width(string _0, int len, int flags)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_0).ToPointer(), _0.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.Width_1(__Instance, arg0, len, flags);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the width of the character at position pos in the string
        /// text.</para>
        /// <para>The whole string is needed, as the glyph drawn may change
        /// depending on the context (the letter before and after the current one) for
        /// some languages (e.g. Arabic).</para>
        /// <para>This function also takes non spacing marks and ligatures into
        /// account.</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public int CharWidth(string str, int pos)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(str).ToPointer(), str.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.CharWidth_0(__Instance, arg0, pos);
            return __ret;
        }

        public static bool operator !=(QFontMetrics __op, QFontMetrics other)
        {
            return !(__op == other);
        }

        /// <summary>
        /// <para>Returns true if other is equal to this object; otherwise returns
        /// false.</para>
        /// <para>Two font metrics are considered equal if they were constructed
        /// from the same QFont and the paint devices they were constructed for are
        /// considered compatible.</para>
        /// <para>See also operator!=().</para>
        /// </summary>
        public static bool operator ==(QFontMetrics __op, QFontMetrics other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QFontMetrics;
        }

        /// <summary>
        /// <para>Returns the ascent of the font.</para>
        /// <para>The ascent of a font is the distance from the baseline to the
        /// highest position characters extend to. In practice, some font designers
        /// break this rule, e.g. when they put more than one accent on top of a
        /// character, or to accommodate an unusual character in an exotic language, so
        /// it is possible (though rare) that this value will be too small.</para>
        /// <para>See also descent().</para>
        /// </summary>
        public int Ascent
        {
            get
            {
                var __ret = Internal.Ascent_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the descent of the font.</para>
        /// <para>The descent is the distance from the base line to the lowest
        /// point characters extend to. In practice, some font designers break this
        /// rule, e.g. to accommodate an unusual character in an exotic language, so it
        /// is possible (though rare) that this value will be too small.</para>
        /// <para>See also ascent().</para>
        /// </summary>
        public int Descent
        {
            get
            {
                var __ret = Internal.Descent_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the height of the font.</para>
        /// <para>This is always equal to ascent()+descent().</para>
        /// <para>See also leading() and lineSpacing().</para>
        /// </summary>
        public int Height
        {
            get
            {
                var __ret = Internal.Height_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the leading of the font.</para>
        /// <para>This is the natural inter-line spacing.</para>
        /// <para>See also height() and lineSpacing().</para>
        /// </summary>
        public int Leading
        {
            get
            {
                var __ret = Internal.Leading_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the distance from one base line to the next.</para>
        /// <para>This value is always equal to leading()+height().</para>
        /// <para>See also height() and leading().</para>
        /// </summary>
        public int LineSpacing
        {
            get
            {
                var __ret = Internal.LineSpacing_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the minimum left bearing of the font.</para>
        /// <para>This is the smallest leftBearing(char) of all characters in the
        /// font.</para>
        /// <para>Note that this function can be very slow if the font is
        /// large.</para>
        /// <para>See also minRightBearing() and leftBearing().</para>
        /// </summary>
        public int MinLeftBearing
        {
            get
            {
                var __ret = Internal.MinLeftBearing_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the minimum right bearing of the font.</para>
        /// <para>This is the smallest rightBearing(char) of all characters in the
        /// font.</para>
        /// <para>Note that this function can be very slow if the font is
        /// large.</para>
        /// <para>See also minLeftBearing() and rightBearing().</para>
        /// </summary>
        public int MinRightBearing
        {
            get
            {
                var __ret = Internal.MinRightBearing_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the width of the widest character in the font.</para>
        /// </summary>
        public int MaxWidth
        {
            get
            {
                var __ret = Internal.MaxWidth_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the 'x' height of the font. This is often but not always
        /// the same as the height of the character 'x'.</para>
        /// </summary>
        public int XHeight
        {
            get
            {
                var __ret = Internal.XHeight_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the average width of glyphs in the font.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public int AverageCharWidth
        {
            get
            {
                var __ret = Internal.AverageCharWidth_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the distance from the base line to where an underscore
        /// should be drawn.</para>
        /// <para>See also overlinePos(), strikeOutPos(), and lineWidth().</para>
        /// </summary>
        public int UnderlinePos
        {
            get
            {
                var __ret = Internal.UnderlinePos_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the distance from the base line to where an overline
        /// should be drawn.</para>
        /// <para>See also underlinePos(), strikeOutPos(), and lineWidth().</para>
        /// </summary>
        public int OverlinePos
        {
            get
            {
                var __ret = Internal.OverlinePos_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the distance from the base line to where the strikeout
        /// line should be drawn.</para>
        /// <para>See also underlinePos(), overlinePos(), and lineWidth().</para>
        /// </summary>
        public int StrikeOutPos
        {
            get
            {
                var __ret = Internal.StrikeOutPos_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the width of the underline and strikeout lines, adjusted
        /// for the point size of the font.</para>
        /// <para>See also underlinePos(), overlinePos(), and
        /// strikeOutPos().</para>
        /// </summary>
        public int LineWidth
        {
            get
            {
                var __ret = Internal.LineWidth_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QFontMetricsF class provides font metrics information.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QFontMetricsF functions calculate the size of characters and
    /// strings for a given font. You can construct a QFontMetricsF object with an
    /// existing QFont to obtain metrics for that font. If the font is changed
    /// later, the font metrics object is not updated.</para>
    /// <para>Once created, the object provides functions to access the
    /// individual metrics of the font, its characters, and for strings rendered in
    /// the font.</para>
    /// <para>There are several functions that operate on the font: ascent(),
    /// descent(), height(), leading() and lineSpacing() return the basic size
    /// properties of the font. The underlinePos(), overlinePos(), strikeOutPos()
    /// and lineWidth() functions, return the properties of the line that
    /// underlines, overlines or strikes out the characters. These functions are
    /// all fast.</para>
    /// <para>There are also some functions that operate on the set of glyphs
    /// in the font: minLeftBearing(), minRightBearing() and maxWidth(). These are
    /// by necessity slow, and we recommend avoiding them if possible.</para>
    /// <para>For each character, you can get its width(), leftBearing() and
    /// rightBearing() and find out whether it is in the font using inFont(). You
    /// can also treat the character as a string, and use the string functions on
    /// it.</para>
    /// <para>The string functions include width(), to return the width of a
    /// string in pixels (or points, for a printer), boundingRect(), to return a
    /// rectangle large enough to contain the rendered string, and size(), to
    /// return the size of that rectangle.</para>
    /// <para>Example:</para>
    /// <para>QFont font(&quot;times&quot;, 24);</para>
    /// <para>QFontMetricsF fm(font);</para>
    /// <para>qreal pixelsWide = fm.width(&quot;What's the width of this
    /// text?&quot;);</para>
    /// <para>qreal pixelsHigh = fm.height();</para>
    /// <para></para>
    /// <para>See also QFont, QFontInfo, and QFontDatabase.</para>
    /// </remarks>
    public unsafe partial class QFontMetricsF : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontMetricsFC2ERK5QFont")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontMetricsFC2ERK5QFontP12QPaintDevice")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr font, global::System.IntPtr pd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontMetricsFC2ERK12QFontMetrics")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr fontMetrics);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontMetricsFC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr fm);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontMetricsFD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontMetricsFeqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFontMetricsF __CreateInstance(global::System.IntPtr native)
        {
            return new QFontMetricsF((QFontMetricsF.Internal*) native);
        }

        public static QFontMetricsF __CreateInstance(QFontMetricsF.Internal native)
        {
            return new QFontMetricsF(native);
        }

        private static QFontMetricsF.Internal* __CopyValue(QFontMetricsF.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QFontMetricsF.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QFontMetricsF.Internal*) ret;
        }

        private QFontMetricsF(QFontMetricsF.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFontMetricsF(QFontMetricsF.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a font metrics object for font.</para>
        /// <para>The font metrics will be compatible with the paintdevice used to
        /// create font.</para>
        /// <para>The font metrics object holds the information for the font that
        /// is passed in the constructor at the time it is created, and is not updated
        /// if the font's attributes are changed later.</para>
        /// <para>Use QFontMetricsF(const QFont &amp;, QPaintDevice *) to get the
        /// font metrics that are compatible with a certain paint device.</para>
        /// </summary>
        public QFontMetricsF(QFont font)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            Internal.ctor_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a font metrics object for font and paintdevice.</para>
        /// <para>The font metrics will be compatible with the paintdevice passed.
        /// If the paintdevice is 0, the metrics will be screen-compatible, ie. the
        /// metrics you get if you use the font for drawing text on a widgets or
        /// pixmaps, not on a QPicture or QPrinter.</para>
        /// <para>The font metrics object holds the information for the font that
        /// is passed in the constructor at the time it is created, and is not updated
        /// if the font's attributes are changed later.</para>
        /// </summary>
        public QFontMetricsF(QFont font, QPaintDevice pd)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var arg1 = ReferenceEquals(pd, null) ? global::System.IntPtr.Zero : pd.__Instance;
            Internal.ctor_1(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Constructs a font metrics object with floating point precision
        /// from the given fontMetrics object.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public QFontMetricsF(QFontMetrics fontMetrics)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fontMetrics, null) ? global::System.IntPtr.Zero : fontMetrics.__Instance;
            Internal.ctor_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a copy of fm.</para>
        /// </summary>
        public QFontMetricsF(QFontMetricsF fm)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fm, null) ? global::System.IntPtr.Zero : fm.__Instance;
            Internal.cctor_3(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public static bool operator !=(QFontMetricsF __op, QFontMetricsF other)
        {
            return !(__op == other);
        }

        /// <summary>
        /// <para>Returns true if the font metrics are equal to the other font
        /// metrics; otherwise returns false.</para>
        /// <para>Two font metrics are considered equal if they were constructed
        /// from the same QFont and the paint devices they were constructed for are
        /// considered to be compatible.</para>
        /// </summary>
        public static bool operator ==(QFontMetricsF __op, QFontMetricsF other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QFontMetricsF;
        }
    }

    /// <summary>
    /// <para>The QPainter class performs low-level painting on widgets and
    /// other paint devices.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QPainter provides highly optimized functions to do most of the
    /// drawing GUI programs require. It can draw everything from simple lines to
    /// complex shapes like pies and chords. It can also draw aligned text and
    /// pixmaps. Normally, it draws in a &quot;natural&quot; coordinate system, but
    /// it can also do view and world transformation. QPainter can operate on any
    /// object that inherits the QPaintDevice class.</para>
    /// <para>The common use of QPainter is inside a widget's paint event:
    /// Construct and customize (e.g. set the pen or the brush) the painter. Then
    /// draw. Remember to destroy the QPainter object after drawing. For
    /// example:</para>
    /// <para>void SimpleExampleWidget::paintEvent(QPaintEvent *)</para>
    /// <para>{</para>
    /// <para>    QPainter painter(this);</para>
    /// <para>    painter.setPen(Qt::blue);</para>
    /// <para>    painter.setFont(QFont(&quot;Arial&quot;, 30));</para>
    /// <para>    painter.drawText(rect(), Qt::AlignCenter,
    /// &quot;Qt&quot;);</para>
    /// <para>}</para>
    /// <para>The core functionality of QPainter is drawing, but the class also
    /// provide several functions that allows you to customize QPainter's settings
    /// and its rendering quality, and others that enable clipping. In addition you
    /// can control how different shapes are merged together by specifying the
    /// painter's composition mode.</para>
    /// <para>The isActive() function indicates whether the painter is active.
    /// A painter is activated by the begin() function and the constructor that
    /// takes a QPaintDevice argument. The end() function, and the destructor,
    /// deactivates it.</para>
    /// <para>Together with the QPaintDevice and QPaintEngine classes, QPainter
    /// form the basis for Qt's paint system. QPainter is the class used to perform
    /// drawing operations. QPaintDevice represents a device that can be painted on
    /// using a QPainter. QPaintEngine provides the interface that the painter uses
    /// to draw onto different types of devices. If the painter is active, device()
    /// returns the paint device on which the painter paints, and paintEngine()
    /// returns the paint engine that the painter is currently operating on. For
    /// more information, see the Paint System.</para>
    /// <para>Sometimes it is desirable to make someone else paint on an
    /// unusual QPaintDevice. QPainter supports a static function to do this,
    /// setRedirected().</para>
    /// <para>Warning: When the paintdevice is a widget, QPainter can only be
    /// used inside a paintEvent() function or in a function called by
    /// paintEvent().</para>
    /// <para></para>
    /// <para>Settings</para>
    /// <para>There are several settings that you can customize to make
    /// QPainter draw according to your preferences:</para>
    /// <para></para>
    /// <para>font() is the font used for drawing text. If the painter
    /// isActive(), you can retrieve information about the currently set font, and
    /// its metrics, using the fontInfo() and fontMetrics() functions
    /// respectively.</para>
    /// <para>brush() defines the color or pattern that is used for filling
    /// shapes.</para>
    /// <para>pen() defines the color or stipple that is used for drawing lines
    /// or boundaries.</para>
    /// <para>backgroundMode() defines whether there is a background() or not,
    /// i.e it is either Qt::OpaqueMode or Qt::TransparentMode.</para>
    /// <para>background() only applies when backgroundMode() is Qt::OpaqueMode
    /// and pen() is a stipple. In that case, it describes the color of the
    /// background pixels in the stipple.</para>
    /// <para>brushOrigin() defines the origin of the tiled brushes, normally
    /// the origin of widget's background.</para>
    /// <para>viewport(), window(), worldTransform() make up the painter's
    /// coordinate transformation system. For more information, see the Coordinate
    /// Transformations section and the Coordinate System documentation.</para>
    /// <para>hasClipping() tells whether the painter clips at all. (The paint
    /// device clips, too.) If the painter clips, it clips to clipRegion().</para>
    /// <para>layoutDirection() defines the layout direction used by the
    /// painter when drawing text.</para>
    /// <para>worldMatrixEnabled() tells whether world transformation is
    /// enabled.</para>
    /// <para>viewTransformEnabled() tells whether view transformation is
    /// enabled.</para>
    /// <para></para>
    /// <para>Note that some of these settings mirror settings in some paint
    /// devices, e.g. QWidget::font(). The QPainter::begin() function (or
    /// equivalently the QPainter constructor) copies these attributes from the
    /// paint device.</para>
    /// <para>You can at any time save the QPainter's state by calling the
    /// save() function which saves all the available settings on an internal
    /// stack. The restore() function pops them back.</para>
    /// <para></para>
    /// <para>Drawing</para>
    /// <para>QPainter provides functions to draw most primitives: drawPoint(),
    /// drawPoints(), drawLine(), drawRect(), drawRoundedRect(), drawEllipse(),
    /// drawArc(), drawPie(), drawChord(), drawPolyline(), drawPolygon(),
    /// drawConvexPolygon() and drawCubicBezier(). The two convenience functions,
    /// drawRects() and drawLines(), draw the given number of rectangles or lines
    /// in the given array of QRects or QLines using the current pen and
    /// brush.</para>
    /// <para>The QPainter class also provides the fillRect() function which
    /// fills the given QRect, with the given QBrush, and the eraseRect() function
    /// that erases the area inside the given rectangle.</para>
    /// <para>All of these functions have both integer and floating point
    /// versions.</para>
    /// <para></para>
    /// <para> 	Basic Drawing ExampleThe Basic Drawing example shows how to
    /// display basic graphics primitives in a variety of styles using the QPainter
    /// class.</para>
    /// </remarks>
    public unsafe partial class QPainter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QScopedPointer.Internal d_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainterC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainterC2EP12QPaintDevice")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainterC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainterD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter5beginEP12QPaintDevice")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Begin_0(global::System.IntPtr instance, global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter3endEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool End_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter8initFromEPK12QPaintDevice")]
            internal static extern void InitFrom_0(global::System.IntPtr instance, global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter6setPenERK6QColor")]
            internal static extern void SetPen_0(global::System.IntPtr instance, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter11setClippingEb")]
            internal static extern void SetClipping_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter4saveEv")]
            internal static extern void Save_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter7restoreEv")]
            internal static extern void Restore_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter9setMatrixERK7QMatrixb")]
            internal static extern void SetMatrix_0(global::System.IntPtr instance, global::System.IntPtr matrix, bool combine);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter11resetMatrixEv")]
            internal static extern void ResetMatrix_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter12setTransformERK10QTransformb")]
            internal static extern void SetTransform_0(global::System.IntPtr instance, global::System.IntPtr transform, bool combine);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter14resetTransformEv")]
            internal static extern void ResetTransform_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter14setWorldMatrixERK7QMatrixb")]
            internal static extern void SetWorldMatrix_0(global::System.IntPtr instance, global::System.IntPtr matrix, bool combine);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter17setWorldTransformERK10QTransformb")]
            internal static extern void SetWorldTransform_0(global::System.IntPtr instance, global::System.IntPtr matrix, bool combine);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter10strokePathERK12QPainterPathRK4QPen")]
            internal static extern void StrokePath_0(global::System.IntPtr instance, global::System.IntPtr path, global::System.IntPtr pen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter8fillPathERK12QPainterPathRK6QBrush")]
            internal static extern void FillPath_0(global::System.IntPtr instance, global::System.IntPtr path, global::System.IntPtr brush);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter8drawPathERK12QPainterPath")]
            internal static extern void DrawPath_0(global::System.IntPtr instance, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter19drawPixmapFragmentsEPKNS_14PixmapFragmentEiRK7QPixmap6QFlagsINS_18PixmapFragmentHintEE")]
            internal static extern void DrawPixmapFragments_0(global::System.IntPtr instance, global::System.IntPtr fragments, int fragmentCount, global::System.IntPtr pixmap, QPainter.PixmapFragmentHint hints);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter13setRenderHintENS_10RenderHintEb")]
            internal static extern void SetRenderHint_0(global::System.IntPtr instance, QPainter.RenderHint hint, bool on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter14setRenderHintsE6QFlagsINS_10RenderHintEEb")]
            internal static extern void SetRenderHints_0(global::System.IntPtr instance, QPainter.RenderHint hints, bool on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8QPainter17restoreRedirectedEPK12QPaintDevice")]
            internal static extern void RestoreRedirected_0(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter19beginNativePaintingEv")]
            internal static extern void BeginNativePainting_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter17endNativePaintingEv")]
            internal static extern void EndNativePainting_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter15compositionModeEv")]
            internal static extern QPainter.CompositionMode compositionMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter18setCompositionModeENS_15CompositionModeE")]
            internal static extern void SetCompositionMode_0(global::System.IntPtr instance, QPainter.CompositionMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter4fontEv")]
            internal static extern global::System.IntPtr Font_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter7setFontERK5QFont")]
            internal static extern void SetFont_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter3penEv")]
            internal static extern global::System.IntPtr Pen_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter6setPenERK4QPen")]
            internal static extern void SetPen_1(global::System.IntPtr instance, global::System.IntPtr pen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter5brushEv")]
            internal static extern global::System.IntPtr Brush_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter8setBrushERK6QBrush")]
            internal static extern void SetBrush_0(global::System.IntPtr instance, global::System.IntPtr brush);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter10backgroundEv")]
            internal static extern global::System.IntPtr Background_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter13setBackgroundERK6QBrush")]
            internal static extern void SetBackground_0(global::System.IntPtr instance, global::System.IntPtr bg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter13matrixEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool MatrixEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter16setMatrixEnabledEb")]
            internal static extern void SetMatrixEnabled_0(global::System.IntPtr instance, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter18worldMatrixEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool WorldMatrixEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter21setWorldMatrixEnabledEb")]
            internal static extern void SetWorldMatrixEnabled_0(global::System.IntPtr instance, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter20viewTransformEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool ViewTransformEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QPainter23setViewTransformEnabledEb")]
            internal static extern void SetViewTransformEnabled_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter6matrixEv")]
            internal static extern global::System.IntPtr Matrix_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter9transformEv")]
            internal static extern global::System.IntPtr Transform_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter11worldMatrixEv")]
            internal static extern global::System.IntPtr WorldMatrix_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter14worldTransformEv")]
            internal static extern global::System.IntPtr WorldTransform_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter11renderHintsEv")]
            internal static extern QPainter.RenderHint RenderHints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter6deviceEv")]
            internal static extern global::System.IntPtr Device_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter8isActiveEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsActive_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter11fontMetricsEv")]
            internal static extern void FontMetrics_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter8fontInfoEv")]
            internal static extern void FontInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter10clipRegionEv")]
            internal static extern void ClipRegion_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter8clipPathEv")]
            internal static extern void ClipPath_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter11hasClippingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasClipping_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter12deviceMatrixEv")]
            internal static extern global::System.IntPtr DeviceMatrix_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter15deviceTransformEv")]
            internal static extern global::System.IntPtr DeviceTransform_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter14combinedMatrixEv")]
            internal static extern void CombinedMatrix_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter17combinedTransformEv")]
            internal static extern void CombinedTransform_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QPainter11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Renderhints are used to specify flags to QPainter that may or may
        /// not be respected by any given engine.</para>
        /// <para></para>
        /// <para>See also renderHints(), setRenderHint(), Rendering Quality, and
        /// Concentric Circles Example.</para>
        /// </summary>
        [Flags]
        public enum RenderHint : uint
        {
            /// <summary>Indicates that the engine should antialias edges of primitives if possible.</summary>
            Antialiasing = 0x1,
            /// <summary>Indicates that the engine should antialias text if possible. To forcibly disable antialiasing for text, do not use this hint. Instead, set QFont::NoAntialias on your font's style strategy.</summary>
            TextAntialiasing = 0x2,
            /// <summary>Indicates that the engine should use a smooth pixmap transformation algorithm (such as bilinear) rather than nearest neighbor.</summary>
            SmoothPixmapTransform = 0x4,
            /// <summary>This value is obsolete and will be ignored, use the Antialiasing render hint instead.</summary>
            HighQualityAntialiasing = 0x8,
            /// <summary>This value is obsolete, the default for QPen is now non-cosmetic.</summary>
            NonCosmeticDefaultPen = 0x10,
            /// <summary>Compatibility hint telling the engine to use the same X11 based fill rules as in Qt 4, where aliased rendering is offset by slightly less than half a pixel. Also will treat default constructed pens as cosmetic. Potentially useful when porting a Qt 4 application to Qt 5.</summary>
            Qt4CompatiblePainting = 0x20
        }

        /// <summary>
        /// <para>This enum was introduced or modified in  Qt 4.7.</para>
        /// <para></para>
        /// <para>See also QPainter::drawPixmapFragments() and
        /// QPainter::PixmapFragment.</para>
        /// </summary>
        public enum PixmapFragmentHint : uint
        {
            /// <summary>Indicates that the pixmap fragments to be drawn are opaque. Opaque fragments are potentially faster to draw.</summary>
            OpaqueHint = 0x1
        }

        /// <summary>
        /// <para>Defines the modes supported for digital image compositing.
        /// Composition modes are used to specify how the pixels in one image, the
        /// source, are merged with the pixel in another image, the destination.</para>
        /// <para>Please note that the bitwise raster operation modes, denoted with
        /// a RasterOp prefix, are only natively supported in the X11 and raster paint
        /// engines. This means that the only way to utilize these modes on the Mac is
        /// via a QImage. The RasterOp denoted blend modes are not supported for pens
        /// and brushes with alpha components. Also, turning on the
        /// QPainter::Antialiasing render hint will effectively disable the RasterOp
        /// modes.</para>
        /// <para>The most common type is SourceOver (often referred to as just
        /// alpha blending) where the source pixel is blended on top of the destination
        /// pixel in such a way that the alpha component of the source defines the
        /// translucency of the pixel.</para>
        /// <para>When the paint device is a QImage, the image format must be set
        /// to Format_ARGB32_Premultiplied or Format_ARGB32 for the composition modes
        /// to have any effect. For performance the premultiplied version is the
        /// preferred format.</para>
        /// <para>When a composition mode is set it applies to all painting
        /// operator, pens, brushes, gradients and pixmap/image drawing.</para>
        /// <para>See also compositionMode(), setCompositionMode(), Composition
        /// Modes, and Image Composition Example.</para>
        /// </summary>
        public enum CompositionMode : uint
        {
            /// <summary>This is the default mode. The alpha of the source is used to blend the pixel on top of the destination.</summary>
            CompositionMode_SourceOver = 0,
            /// <summary>The alpha of the destination is used to blend it on top of the source pixels. This mode is the inverse of CompositionMode_SourceOver.</summary>
            CompositionMode_DestinationOver = 1,
            /// <summary>The pixels in the destination are cleared (set to fully transparent) independent of the source.</summary>
            CompositionMode_Clear = 2,
            /// <summary>The output is the source pixel. (This means a basic copy operation and is identical to SourceOver when the source pixel is opaque).</summary>
            CompositionMode_Source = 3,
            /// <summary>The output is the destination pixel. This means that the blending has no effect. This mode is the inverse of CompositionMode_Source.</summary>
            CompositionMode_Destination = 4,
            /// <summary>The output is the source, where the alpha is reduced by that of the destination.</summary>
            CompositionMode_SourceIn = 5,
            /// <summary>The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse of CompositionMode_SourceIn.</summary>
            CompositionMode_DestinationIn = 6,
            /// <summary>The output is the source, where the alpha is reduced by the inverse of destination.</summary>
            CompositionMode_SourceOut = 7,
            /// <summary>The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse of CompositionMode_SourceOut.</summary>
            CompositionMode_DestinationOut = 8,
            /// <summary>The source pixel is blended on top of the destination, with the alpha of the source pixel reduced by the alpha of the destination pixel.</summary>
            CompositionMode_SourceAtop = 9,
            /// <summary>The destination pixel is blended on top of the source, with the alpha of the destination pixel is reduced by the alpha of the destination pixel. This mode is the inverse of CompositionMode_SourceAtop.</summary>
            CompositionMode_DestinationAtop = 10,
            /// <summary>The source, whose alpha is reduced with the inverse of the destination alpha, is merged with the destination, whose alpha is reduced by the inverse of the source alpha. CompositionMode_Xor is not the same as the bitwise Xor.</summary>
            CompositionMode_Xor = 11,
            /// <summary>Both the alpha and color of the source and destination pixels are added together.</summary>
            CompositionMode_Plus = 12,
            /// <summary>The output is the source color multiplied by the destination. Multiplying a color with white leaves the color unchanged, while multiplying a color with black produces black.</summary>
            CompositionMode_Multiply = 13,
            /// <summary>The source and destination colors are inverted and then multiplied. Screening a color with white produces white, whereas screening a color with black leaves the color unchanged.</summary>
            CompositionMode_Screen = 14,
            /// <summary>Multiplies or screens the colors depending on the destination color. The destination color is mixed with the source color to reflect the lightness or darkness of the destination.</summary>
            CompositionMode_Overlay = 15,
            /// <summary>The darker of the source and destination colors is selected.</summary>
            CompositionMode_Darken = 16,
            /// <summary>The lighter of the source and destination colors is selected.</summary>
            CompositionMode_Lighten = 17,
            /// <summary>The destination color is brightened to reflect the source color. A black source color leaves the destination color unchanged.</summary>
            CompositionMode_ColorDodge = 18,
            /// <summary>The destination color is darkened to reflect the source color. A white source color leaves the destination color unchanged.</summary>
            CompositionMode_ColorBurn = 19,
            /// <summary>Multiplies or screens the colors depending on the source color. A light source color will lighten the destination color, whereas a dark source color will darken the destination color.</summary>
            CompositionMode_HardLight = 20,
            /// <summary>Darkens or lightens the colors depending on the source color. Similar to CompositionMode_HardLight.</summary>
            CompositionMode_SoftLight = 21,
            /// <summary>Subtracts the darker of the colors from the lighter. Painting with white inverts the destination color, whereas painting with black leaves the destination color unchanged.</summary>
            CompositionMode_Difference = 22,
            /// <summary>Similar to CompositionMode_Difference, but with a lower contrast. Painting with white inverts the destination color, whereas painting with black leaves the destination color unchanged.</summary>
            CompositionMode_Exclusion = 23,
            /// <summary>Does a bitwise OR operation on the source and destination pixels (src OR dst).</summary>
            RasterOp_SourceOrDestination = 24,
            /// <summary>Does a bitwise AND operation on the source and destination pixels (src AND dst).</summary>
            RasterOp_SourceAndDestination = 25,
            /// <summary>Does a bitwise XOR operation on the source and destination pixels (src XOR dst).</summary>
            RasterOp_SourceXorDestination = 26,
            /// <summary>Does a bitwise NOR operation on the source and destination pixels ((NOT src) AND (NOT dst)).</summary>
            RasterOp_NotSourceAndNotDestination = 27,
            /// <summary>Does a bitwise NAND operation on the source and destination pixels ((NOT src) OR (NOT dst)).</summary>
            RasterOp_NotSourceOrNotDestination = 28,
            /// <summary>Does a bitwise operation where the source pixels are inverted and then XOR'ed with the destination ((NOT src) XOR dst).</summary>
            RasterOp_NotSourceXorDestination = 29,
            /// <summary>Does a bitwise operation where the source pixels are inverted (NOT src).</summary>
            RasterOp_NotSource = 30,
            /// <summary>Does a bitwise operation where the source is inverted and then AND'ed with the destination ((NOT src) AND dst).</summary>
            RasterOp_NotSourceAndDestination = 31,
            /// <summary>Does a bitwise operation where the source is AND'ed with the inverted destination pixels (src AND (NOT dst)).</summary>
            RasterOp_SourceAndNotDestination = 32,
            /// <summary>Does a bitwise operation where the source is inverted and then OR'ed with the destination ((NOT src) OR dst).</summary>
            RasterOp_NotSourceOrDestination = 33,
            /// <summary>Does a bitwise operation where the source is OR'ed with the inverted destination pixels (src OR (NOT dst)).</summary>
            RasterOp_SourceOrNotDestination = 34,
            /// <summary>The pixels in the destination are cleared (set to 0) independent of the source.</summary>
            RasterOp_ClearDestination = 35,
            /// <summary>The pixels in the destination are set (set to 1) independent of the source.</summary>
            RasterOp_SetDestination = 36,
            /// <summary>Does a bitwise operation where the destination pixels are inverted (NOT dst).</summary>
            RasterOp_NotDestination = 37
        }

        /// <summary>
        /// <para>This class is used in conjunction with the
        /// QPainter::drawPixmapFragments() function to specify how a pixmap, or
        /// sub-rect of a pixmap, is drawn.</para>
        /// </summary>
        /// <remarks>
        /// <para></para>
        /// <para>The sourceLeft, sourceTop, width and height variables are used as
        /// a source rectangle within the pixmap passed into the
        /// QPainter::drawPixmapFragments() function. The variables x, y, width and
        /// height are used to calculate the target rectangle that is drawn. x and y
        /// denotes the center of the target rectangle. The width and height in the
        /// target rectangle is scaled by the scaleX and scaleY values. The resulting
        /// target rectangle is then rotated rotation degrees around the x, y center
        /// point.</para>
        /// <para></para>
        /// <para>See also QPainter::drawPixmapFragments().</para>
        /// </remarks>
        public unsafe partial class PixmapFragment : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public double x;

                [FieldOffset(8)]
                public double y;

                [FieldOffset(16)]
                public double sourceLeft;

                [FieldOffset(24)]
                public double sourceTop;

                [FieldOffset(32)]
                public double width;

                [FieldOffset(40)]
                public double height;

                [FieldOffset(48)]
                public double scaleX;

                [FieldOffset(56)]
                public double scaleY;

                [FieldOffset(64)]
                public double rotation;

                [FieldOffset(72)]
                public double opacity;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN8QPainter14PixmapFragmentC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static PixmapFragment __CreateInstance(global::System.IntPtr native)
            {
                return new PixmapFragment((PixmapFragment.Internal*) native);
            }

            public static PixmapFragment __CreateInstance(PixmapFragment.Internal native)
            {
                return new PixmapFragment(native);
            }

            private static PixmapFragment.Internal* __CopyValue(PixmapFragment.Internal native)
            {
                var ret = (PixmapFragment.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private PixmapFragment(PixmapFragment.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected PixmapFragment(PixmapFragment.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPainter __CreateInstance(global::System.IntPtr native)
        {
            return new QPainter((QPainter.Internal*) native);
        }

        public static QPainter __CreateInstance(QPainter.Internal native)
        {
            return new QPainter(native);
        }

        private static QPainter.Internal* __CopyValue(QPainter.Internal native)
        {
            var ret = (QPainter.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QPainter(QPainter.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPainter(QPainter.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a painter.</para>
        /// <para>See also begin() and end().</para>
        /// </summary>
        public QPainter()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a painter that begins painting the paint device
        /// immediately.</para>
        /// <para>This constructor is convenient for short-lived painters, e.g. in
        /// a QWidget::paintEvent() and should be used only once. The constructor calls
        /// begin() for you and the QPainter destructor automatically calls
        /// end().</para>
        /// <para>Here's an example using begin() and end():</para>
        /// <para>void MyWidget::paintEvent(QPaintEvent *)</para>
        /// <para>{</para>
        /// <para>    QPainter p;</para>
        /// <para>    p.begin(this);</para>
        /// <para>    p.drawLine(...);        // drawing code</para>
        /// <para>    p.end();</para>
        /// <para>}</para>
        /// <para>The same example using this constructor:</para>
        /// <para>void MyWidget::paintEvent(QPaintEvent *)</para>
        /// <para>{</para>
        /// <para>    QPainter p(this);</para>
        /// <para>    p.drawLine(...);        // drawing code</para>
        /// <para>}</para>
        /// <para>Since the constructor cannot provide feedback when the
        /// initialization of the painter failed you should rather use begin() and
        /// end() to paint on external devices, e.g. printers.</para>
        /// <para>See also begin() and end().</para>
        /// </summary>
        public QPainter(QPaintDevice device)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Begins painting the paint device and returns true if successful;
        /// otherwise returns false.</para>
        /// <para>Notice that all painter settings (setPen(), setBrush() etc.) are
        /// reset to default values when begin() is called.</para>
        /// <para>The errors that can occur are serious problems, such as
        /// these:</para>
        /// <para>painter-&gt;begin(0); // impossible - paint device cannot be
        /// 0</para>
        /// <para></para>
        /// <para>QPixmap image(0, 0);</para>
        /// <para>painter-&gt;begin(&amp;image); // impossible - image.isNull() ==
        /// true;</para>
        /// <para></para>
        /// <para>painter-&gt;begin(myWidget);</para>
        /// <para>painter2-&gt;begin(myWidget); // impossible - only one painter at
        /// a time</para>
        /// <para>Note that most of the time, you can use one of the constructors
        /// instead of begin(), and that end() is automatically done at
        /// destruction.</para>
        /// <para>Warning: A paint device can only be painted by one painter at a
        /// time.</para>
        /// <para>Warning: Painting on a QImage with the format
        /// QImage::Format_Indexed8 is not supported.</para>
        /// <para>See also end() and QPainter().</para>
        /// </summary>
        public bool Begin(QPaintDevice device)
        {
            var arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = Internal.Begin_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Ends painting. Any resources used while painting are released.
        /// You don't normally need to call this since it is called by the
        /// destructor.</para>
        /// <para>Returns true if the painter is no longer active; otherwise
        /// returns false.</para>
        /// <para>See also begin() and isActive().</para>
        /// </summary>
        public bool End()
        {
            var __ret = Internal.End_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Initializes the painters pen, background and font to the same as
        /// the given device.</para>
        /// <para>See also begin() and Settings.</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public void InitFrom(QPaintDevice device)
        {
            var arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            Internal.InitFrom_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the painter's pen to have style Qt::SolidLine, width 1 and
        /// the specified color.</para>
        /// </summary>
        public void SetPen(QColor color)
        {
            var arg0 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.SetPen_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Enables clipping if enable is true, or disables clipping if
        /// enable is false.</para>
        /// <para>See also hasClipping() and Clipping.</para>
        /// </summary>
        public void SetClipping(bool enable)
        {
            Internal.SetClipping_0(__Instance, enable);
        }

        /// <summary>
        /// <para>Saves the current painter state (pushes the state onto a stack).
        /// A save() must be followed by a corresponding restore(); the end() function
        /// unwinds the stack.</para>
        /// <para>See also restore().</para>
        /// </summary>
        public void Save()
        {
            Internal.Save_0(__Instance);
        }

        /// <summary>
        /// <para>Restores the current painter state (pops a saved state off the
        /// stack).</para>
        /// <para>See also save().</para>
        /// </summary>
        public void Restore()
        {
            Internal.Restore_0(__Instance);
        }

        /// <summary>
        /// <para>Use setWorldTransform() instead.</para>
        /// <para>See also matrix() and setWorldTransform().</para>
        /// </summary>
        [System.ObsoleteAttribute("Use setWorldTransform() instead.")]
        public void SetMatrix(QMatrix matrix, bool combine = false)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            Internal.SetMatrix_0(__Instance, arg0, combine);
        }

        /// <summary>
        /// <para>Resets any transformations that were made using translate(),
        /// scale(), shear(), rotate(), setWorldMatrix(), setViewport() and
        /// setWindow().</para>
        /// <para>It is advisable to use resetTransform() instead of this function
        /// to preserve the properties of perspective transformations.</para>
        /// <para>See also Coordinate Transformations.</para>
        /// </summary>
        [System.ObsoleteAttribute("It is advisable to use resetTransform() instead of this function to preserve the properties of perspective transformations.")]
        public void ResetMatrix()
        {
            Internal.ResetMatrix_0(__Instance);
        }

        /// <summary>
        /// <para>Sets the world transformation matrix. If combine is true, the
        /// specified transform is combined with the current matrix; otherwise it
        /// replaces the current matrix.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also transform() and setWorldTransform().</para>
        /// </summary>
        public void SetTransform(QTransform transform, bool combine = false)
        {
            var arg0 = ReferenceEquals(transform, null) ? global::System.IntPtr.Zero : transform.__Instance;
            Internal.SetTransform_0(__Instance, arg0, combine);
        }

        /// <summary>
        /// <para>Resets any transformations that were made using translate(),
        /// scale(), shear(), rotate(), setWorldTransform(), setViewport() and
        /// setWindow().</para>
        /// <para>See also Coordinate Transformations.</para>
        /// </summary>
        public void ResetTransform()
        {
            Internal.ResetTransform_0(__Instance);
        }

        /// <summary>
        /// <para>Sets the transformation matrix to matrix and enables
        /// transformations.</para>
        /// <para>Note: It is advisable to use setWorldTransform() instead of this
        /// function to preserve the properties of perspective transformations.If
        /// combine is true, then matrix is combined with the current transformation
        /// matrix; otherwise matrix replaces the current transformation matrix.</para>
        /// <para>If matrix is the identity matrix and combine is false, this
        /// function calls setWorldMatrixEnabled(false). (The identity matrix is the
        /// matrix where QMatrix::m11() and QMatrix::m22() are 1.0 and the rest are
        /// 0.0.)</para>
        /// <para>The following functions can transform the coordinate system
        /// without using a QMatrix:</para>
        /// <para></para>
        /// <para>translate()</para>
        /// <para>scale()</para>
        /// <para>shear()</para>
        /// <para>rotate()</para>
        /// <para></para>
        /// <para>They operate on the painter's worldMatrix() and are implemented
        /// like this:</para>
        /// <para>void QPainter::rotate(qreal angle)</para>
        /// <para>{</para>
        /// <para>    QMatrix matrix;</para>
        /// <para>    matrix.rotate(angle);</para>
        /// <para>    setWorldMatrix(matrix, true);</para>
        /// <para>}</para>
        /// <para>Note that when using setWorldMatrix() function you should always
        /// have combine be true when you are drawing into a QPicture. Otherwise it may
        /// not be possible to replay the picture with additional transformations;
        /// using the translate(), scale(), etc. convenience functions is safe.</para>
        /// <para>For more information about the coordinate system, transformations
        /// and window-viewport conversion, see Coordinate System.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also worldMatrix(), setWorldTransform(), and
        /// QTransform.</para>
        /// </summary>
        [System.ObsoleteAttribute("Note: It is advisable to use setWorldTransform() instead of this function to preserve the properties of perspective transformations.If combine is true, then matrix is combined with the current transformation matrix; otherwise matrix replaces the current transformation matrix.")]
        public void SetWorldMatrix(QMatrix matrix, bool combine = false)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            Internal.SetWorldMatrix_0(__Instance, arg0, combine);
        }

        /// <summary>
        /// <para>Sets the world transformation matrix. If combine is true, the
        /// specified matrix is combined with the current matrix; otherwise it replaces
        /// the current matrix.</para>
        /// <para>See also worldTransform(), transform(), and
        /// setTransform().</para>
        /// </summary>
        public void SetWorldTransform(QTransform matrix, bool combine = false)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            Internal.SetWorldTransform_0(__Instance, arg0, combine);
        }

        /// <summary>
        /// <para>Draws the outline (strokes) the path path with the pen specified
        /// by pen</para>
        /// <para>See also fillPath() and Drawing.</para>
        /// </summary>
        public void StrokePath(QPainterPath path, QPen pen)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var arg1 = ReferenceEquals(pen, null) ? global::System.IntPtr.Zero : pen.__Instance;
            Internal.StrokePath_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Fills the given path using the given brush. The outline is not
        /// drawn.</para>
        /// <para>Alternatively, you can specify a QColor instead of a QBrush; the
        /// QBrush constructor (taking a QColor argument) will automatically create a
        /// solid pattern brush.</para>
        /// <para>See also drawPath().</para>
        /// </summary>
        public void FillPath(QPainterPath path, QBrush brush)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var arg1 = ReferenceEquals(brush, null) ? global::System.IntPtr.Zero : brush.__Instance;
            Internal.FillPath_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Draws the given painter path using the current pen for outline
        /// and the current brush for filling.</para>
        /// <para></para>
        /// <para> 	QPainterPath path;</para>
        /// <para>path.moveTo(20, 80);</para>
        /// <para>path.lineTo(20, 30);</para>
        /// <para>path.cubicTo(80, 0, 50, 50, 80, 80);</para>
        /// <para></para>
        /// <para>QPainter painter(this);</para>
        /// <para>painter.drawPath(path);</para>
        /// </summary>
        public void DrawPath(QPainterPath path)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            Internal.DrawPath_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This function is used to draw pixmap, or a sub-rectangle of
        /// pixmap, at multiple positions with different scale, rotation and opacity.
        /// fragments is an array of fragmentCount elements specifying the parameters
        /// used to draw each pixmap fragment. The hints parameter can be used to pass
        /// in drawing hints.</para>
        /// <para>This function is potentially faster than multiple calls to
        /// drawPixmap(), since the backend can optimize state changes.</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also QPainter::PixmapFragment and
        /// QPainter::PixmapFragmentHint.</para>
        /// </summary>
        public void DrawPixmapFragments(QPainter.PixmapFragment fragments, int fragmentCount, QPixmap pixmap, QPainter.PixmapFragmentHint hints = 0)
        {
            var arg0 = ReferenceEquals(fragments, null) ? global::System.IntPtr.Zero : fragments.__Instance;
            var arg2 = ReferenceEquals(pixmap, null) ? global::System.IntPtr.Zero : pixmap.__Instance;
            var arg3 = hints;
            Internal.DrawPixmapFragments_0(__Instance, arg0, fragmentCount, arg2, arg3);
        }

        /// <summary>
        /// <para>Sets the given render hint on the painter if on is true;
        /// otherwise clears the render hint.</para>
        /// <para>See also setRenderHints(), renderHints(), and Rendering
        /// Quality.</para>
        /// </summary>
        public void SetRenderHint(QPainter.RenderHint hint, bool on = true)
        {
            var arg0 = hint;
            Internal.SetRenderHint_0(__Instance, arg0, on);
        }

        /// <summary>
        /// <para>Sets the given render hints on the painter if on is true;
        /// otherwise clears the render hints.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setRenderHint(), renderHints(), and Rendering
        /// Quality.</para>
        /// </summary>
        public void SetRenderHints(QPainter.RenderHint hints, bool on = true)
        {
            var arg0 = hints;
            Internal.SetRenderHints_0(__Instance, arg0, on);
        }

        /// <summary>
        /// <para>Flushes the painting pipeline and prepares for the user issuing
        /// commands directly to the underlying graphics context. Must be followed by a
        /// call to endNativePainting().</para>
        /// <para>Note that only the states the underlying paint engine changes
        /// will be reset to their respective default states. The states we reset may
        /// change from release to release. The following states are currently reset in
        /// the OpenGL 2 engine:</para>
        /// <para></para>
        /// <para>blending is disabled</para>
        /// <para>the depth, stencil and scissor tests are disabled</para>
        /// <para>the active texture unit is reset to 0</para>
        /// <para>the depth mask, depth function and the clear depth are reset to
        /// their default values</para>
        /// <para>the stencil mask, stencil operation and stencil function are
        /// reset to their default values</para>
        /// <para>the current color is reset to solid white</para>
        /// <para></para>
        /// <para>If, for example, the OpenGL polygon mode is changed by the user
        /// inside a beginNativePaint()/endNativePainting() block, it will not be reset
        /// to the default state by endNativePainting(). Here is an example that shows
        /// intermixing of painter commands and raw OpenGL commands:</para>
        /// <para>QPainter painter(this);</para>
        /// <para>painter.fillRect(0, 0, 128, 128, Qt::green);</para>
        /// <para>painter.beginNativePainting();</para>
        /// <para></para>
        /// <para>glEnable(GL_SCISSOR_TEST);</para>
        /// <para>glScissor(0, 0, 64, 64);</para>
        /// <para></para>
        /// <para>glClearColor(1, 0, 0, 1);</para>
        /// <para>glClear(GL_COLOR_BUFFER_BIT);</para>
        /// <para></para>
        /// <para>glDisable(GL_SCISSOR_TEST);</para>
        /// <para></para>
        /// <para>painter.endNativePainting();</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also endNativePainting().</para>
        /// </summary>
        public void BeginNativePainting()
        {
            Internal.BeginNativePainting_0(__Instance);
        }

        /// <summary>
        /// <para>Restores the painter after manually issuing native painting
        /// commands. Lets the painter restore any native state that it relies on
        /// before calling any other painter commands.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also beginNativePainting().</para>
        /// </summary>
        public void EndNativePainting()
        {
            Internal.EndNativePainting_0(__Instance);
        }

        /// <summary>
        /// <para>Using QWidget::render() obsoletes the use of this
        /// function.</para>
        /// <para>Restores the previous redirection for the given device after a
        /// call to setRedirected().</para>
        /// <para>Warning: Making use of redirections in the QPainter API implies
        /// that QPainter::begin() and QPaintDevice destructors need to hold a mutex
        /// for a short period. This can impact performance. Use of QWidget::render is
        /// strongly encouraged.</para>
        /// <para>Note: This function is thread-safe.</para>
        /// <para>See also redirected().</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public static void RestoreRedirected(QPaintDevice device)
        {
            var arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            Internal.RestoreRedirected_0(arg0);
        }

        /// <summary>
        /// <para>Returns the current composition mode.</para>
        /// <para>See also CompositionMode and setCompositionMode().</para>
        /// <para></para>
        /// <para>Sets the composition mode to the given mode.</para>
        /// <para>Warning: Only a QPainter operating on a QImage fully supports all
        /// composition modes. The RasterOp modes are supported for X11 as described in
        /// compositionMode().</para>
        /// <para>See also compositionMode().</para>
        /// </summary>
        public QPainter.CompositionMode compositionMode
        {
            get
            {
                var __ret = Internal.compositionMode_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetCompositionMode_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the currently set font used for drawing text.</para>
        /// <para>See also setFont(), drawText(), and Settings.</para>
        /// <para></para>
        /// <para>Sets the painter's font to the given font.</para>
        /// <para>This font is used by subsequent drawText() functions. The text
        /// color is the same as the pen color.</para>
        /// <para>If you set a font that isn't available, Qt finds a close match.
        /// font() will return what you set using setFont() and fontInfo() returns the
        /// font actually being used (which may be the same).</para>
        /// <para>See also font(), drawText(), and Settings.</para>
        /// </summary>
        public QFont Font
        {
            get
            {
                var __ret = Internal.Font_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QFont.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFont_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the painter's current pen.</para>
        /// <para>See also setPen() and Settings.</para>
        /// <para></para>
        /// <para>Sets the painter's pen to be the given pen.</para>
        /// <para>The pen defines how to draw lines and outlines, and it also
        /// defines the text color.</para>
        /// <para>See also pen() and Settings.</para>
        /// </summary>
        public QPen Pen
        {
            get
            {
                var __ret = Internal.Pen_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPen.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetPen_1(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the painter's current brush.</para>
        /// <para>See also QPainter::setBrush() and Settings.</para>
        /// <para></para>
        /// <para>Sets the painter's brush to the given brush.</para>
        /// <para>The painter's brush defines how shapes are filled.</para>
        /// <para>See also brush() and Settings.</para>
        /// </summary>
        public QBrush Brush
        {
            get
            {
                var __ret = Internal.Brush_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QBrush.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBrush_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the current background brush.</para>
        /// <para>See also setBackground() and Settings.</para>
        /// <para></para>
        /// <para>Sets the background brush of the painter to the given
        /// brush.</para>
        /// <para>The background brush is the brush that is filled in when drawing
        /// opaque text, stippled lines and bitmaps. The background brush has no effect
        /// in transparent background mode (which is the default).</para>
        /// <para>See also background(), setBackgroundMode(), and Settings.</para>
        /// </summary>
        public QBrush Background
        {
            get
            {
                var __ret = Internal.Background_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QBrush.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBackground_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Use worldMatrixEnabled() instead</para>
        /// <para>See also setMatrixEnabled() and worldMatrixEnabled().</para>
        /// <para></para>
        /// <para>Use setWorldMatrixEnabled() instead.</para>
        /// <para>See also matrixEnabled() and setWorldMatrixEnabled().</para>
        /// </summary>
        public bool MatrixEnabled
        {
            get
            {
                var __ret = Internal.MatrixEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMatrixEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if world transformation is enabled; otherwise
        /// returns false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setWorldMatrixEnabled(), worldTransform(), and
        /// Coordinate System.</para>
        /// <para></para>
        /// <para>Enables transformations if enable is true, or disables
        /// transformations if enable is false. The world transformation matrix is not
        /// changed.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also worldMatrixEnabled(), worldTransform(), and Coordinate
        /// Transformations.</para>
        /// </summary>
        public bool WorldMatrixEnabled
        {
            get
            {
                var __ret = Internal.WorldMatrixEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetWorldMatrixEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if view transformation is enabled; otherwise returns
        /// false.</para>
        /// <para>See also setViewTransformEnabled() and worldTransform().</para>
        /// <para></para>
        /// <para>Enables view transformations if enable is true, or disables view
        /// transformations if enable is false.</para>
        /// <para>See also viewTransformEnabled() and Window-Viewport
        /// Conversion.</para>
        /// </summary>
        public bool ViewTransformEnabled
        {
            get
            {
                var __ret = Internal.ViewTransformEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetViewTransformEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Use worldTransform() instead.</para>
        /// <para>See also setMatrix() and worldTransform().</para>
        /// </summary>
        public QMatrix Matrix
        {
            get
            {
                var __ret = Internal.Matrix_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QMatrix.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the world transformation matrix.</para>
        /// <para>See also setTransform() and worldTransform().</para>
        /// </summary>
        public QTransform Transform
        {
            get
            {
                var __ret = Internal.Transform_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTransform.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the world transformation matrix.</para>
        /// <para>It is advisable to use worldTransform() because worldMatrix()
        /// does not preserve the properties of perspective transformations.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setWorldMatrix(), Coordinate Transformations, and
        /// Coordinate System.</para>
        /// </summary>
        public QMatrix WorldMatrix
        {
            get
            {
                var __ret = Internal.WorldMatrix_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QMatrix.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the world transformation matrix.</para>
        /// <para>See also setWorldTransform().</para>
        /// </summary>
        public QTransform WorldTransform
        {
            get
            {
                var __ret = Internal.WorldTransform_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTransform.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns a flag that specifies the rendering hints that are set
        /// for this painter.</para>
        /// <para>See also setRenderHints(), testRenderHint(), and Rendering
        /// Quality.</para>
        /// </summary>
        public QPainter.RenderHint RenderHints
        {
            get
            {
                var __ret = Internal.RenderHints_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the paint device on which this painter is currently
        /// painting, or 0 if the painter is not active.</para>
        /// <para>See also isActive().</para>
        /// </summary>
        public QPaintDevice Device
        {
            get
            {
                var __ret = Internal.Device_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintDeviceInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if begin() has been called and end() has not yet
        /// been called; otherwise returns false.</para>
        /// <para>See also begin() and QPaintDevice::paintingActive().</para>
        /// </summary>
        public bool IsActive
        {
            get
            {
                var __ret = Internal.IsActive_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the font metrics for the painter if the painter is
        /// active. Otherwise, the return value is undefined.</para>
        /// <para>See also font(), isActive(), and Settings.</para>
        /// </summary>
        public QFontMetrics FontMetrics
        {
            get
            {
                var __ret = new QtGui.QFontMetrics.Internal();
                Internal.FontMetrics_0(new IntPtr(&__ret), __Instance);
                return QFontMetrics.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the font info for the painter if the painter is active.
        /// Otherwise, the return value is undefined.</para>
        /// <para>See also font(), isActive(), and Settings.</para>
        /// </summary>
        public QFontInfo FontInfo
        {
            get
            {
                var __ret = new QtGui.QFontInfo.Internal();
                Internal.FontInfo_0(new IntPtr(&__ret), __Instance);
                return QFontInfo.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the currently set clip region. Note that the clip region
        /// is given in logical coordinates.</para>
        /// <para>Warning: QPainter does not store the combined clip explicitly as
        /// this is handled by the underlying QPaintEngine, so the path is recreated on
        /// demand and transformed to the current logical coordinate system. This is
        /// potentially an expensive operation.</para>
        /// <para>See also setClipRegion(), clipPath(), and setClipping().</para>
        /// </summary>
        public QRegion ClipRegion
        {
            get
            {
                var __ret = new QtGui.QRegion.Internal();
                Internal.ClipRegion_0(new IntPtr(&__ret), __Instance);
                return QRegion.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the current clip path in logical coordinates.</para>
        /// <para>Warning: QPainter does not store the combined clip explicitly as
        /// this is handled by the underlying QPaintEngine, so the path is recreated on
        /// demand and transformed to the current logical coordinate system. This is
        /// potentially an expensive operation.</para>
        /// <para>See also setClipPath(), clipRegion(), and setClipping().</para>
        /// </summary>
        public QPainterPath ClipPath
        {
            get
            {
                var __ret = new QtGui.QPainterPath.Internal();
                Internal.ClipPath_0(new IntPtr(&__ret), __Instance);
                return QPainterPath.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if clipping has been set; otherwise returns
        /// false.</para>
        /// <para>See also setClipping() and Clipping.</para>
        /// </summary>
        public bool HasClipping
        {
            get
            {
                var __ret = Internal.HasClipping_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the matrix that transforms from logical coordinates to
        /// device coordinates of the platform dependent paint device.</para>
        /// <para>Note: It is advisable to use deviceTransform() instead of this
        /// function to preserve the properties of perspective transformations.This
        /// function is only needed when using platform painting commands on the
        /// platform dependent handle (Qt::HANDLE), and the platform does not do
        /// transformations nativly.</para>
        /// <para>The QPaintEngine::PaintEngineFeature enum can be queried to
        /// determine whether the platform performs the transformations or not.</para>
        /// <para>See also worldMatrix() and QPaintEngine::hasFeature().</para>
        /// </summary>
        public QMatrix DeviceMatrix
        {
            get
            {
                var __ret = Internal.DeviceMatrix_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QMatrix.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the matrix that transforms from logical coordinates to
        /// device coordinates of the platform dependent paint device.</para>
        /// <para>This function is only needed when using platform painting
        /// commands on the platform dependent handle (Qt::HANDLE), and the platform
        /// does not do transformations nativly.</para>
        /// <para>The QPaintEngine::PaintEngineFeature enum can be queried to
        /// determine whether the platform performs the transformations or not.</para>
        /// <para>See also worldTransform() and QPaintEngine::hasFeature().</para>
        /// </summary>
        public QTransform DeviceTransform
        {
            get
            {
                var __ret = Internal.DeviceTransform_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTransform.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the transformation matrix combining the current
        /// window/viewport and world transformation.</para>
        /// <para>It is advisable to use combinedTransform() instead of this
        /// function to preserve the properties of perspective transformations.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also setWorldTransform(), setWindow(), and
        /// setViewport().</para>
        /// </summary>
        public QMatrix CombinedMatrix
        {
            get
            {
                var __ret = new QtGui.QMatrix.Internal();
                Internal.CombinedMatrix_0(new IntPtr(&__ret), __Instance);
                return QMatrix.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the transformation matrix combining the current
        /// window/viewport and world transformation.</para>
        /// <para>See also setWorldTransform(), setWindow(), and
        /// setViewport().</para>
        /// </summary>
        public QTransform CombinedTransform
        {
            get
            {
                var __ret = new QtGui.QTransform.Internal();
                Internal.CombinedTransform_0(new IntPtr(&__ret), __Instance);
                return QTransform.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the paint engine that the painter is currently operating
        /// on if the painter is active; otherwise 0.</para>
        /// <para>See also isActive().</para>
        /// </summary>
        public QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QTextItem class provides all the information required to draw
    /// text in a custom paint engine.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>When you reimplement your own paint engine, you must reimplement
    /// QPaintEngine::drawTextItem(), a function that takes a QTextItem as one of
    /// its arguments.</para>
    /// </remarks>
    public unsafe partial class QTextItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextItemC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextItem11renderFlagsEv")]
            internal static extern QTextItem.RenderFlag RenderFlags_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextItem4textEv")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextItem4fontEv")]
            internal static extern void Font_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public enum RenderFlag : uint
        {
            /// <summary>Render the text from right to left.</summary>
            RightToLeft = 0x1,
            /// <summary>Paint a line above the text.</summary>
            Overline = 0x10,
            /// <summary>Paint a line under the text.</summary>
            Underline = 0x20,
            /// <summary>Paint a line through the text.</summary>
            StrikeOut = 0x40,
            Dummy = 0xffffffff
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextItem __CreateInstance(global::System.IntPtr native)
        {
            return new QTextItem((QTextItem.Internal*) native);
        }

        public static QTextItem __CreateInstance(QTextItem.Internal native)
        {
            return new QTextItem(native);
        }

        private static QTextItem.Internal* __CopyValue(QTextItem.Internal native)
        {
            var ret = (QTextItem.Internal*) Marshal.AllocHGlobal(1);
            *ret = native;
            return ret;
        }

        private QTextItem(QTextItem.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextItem(QTextItem.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the render flags used.</para>
        /// </summary>
        public QTextItem.RenderFlag RenderFlags
        {
            get
            {
                var __ret = Internal.RenderFlags_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the text that should be drawn.</para>
        /// </summary>
        public string Text
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Text_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the font that should be used to draw the text.</para>
        /// </summary>
        public QFont Font
        {
            get
            {
                var __ret = new QtGui.QFont.Internal();
                Internal.Font_0(new IntPtr(&__ret), __Instance);
                return QFont.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QPaintEngine class provides an abstract definition of how
    /// QPainter draws to a given device on a given platform.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Qt provides several premade implementations of QPaintEngine for
    /// the different painter backends we support. The primary paint engine
    /// provided is the raster paint engine, which contains a software rasterizer
    /// which supports the full feature set on all supported platforms. This is the
    /// default for painting on QWidget-based classes in e.g. on Windows, X11 and
    /// Mac OS X, it is the backend for painting on QImage and it is used as a
    /// fallback for paint engines that do not support a certain capability. In
    /// addition we provide QPaintEngine implementations for OpenGL (accessible
    /// through QGLWidget) and printing (which allows using QPainter to draw on a
    /// QPrinter object).</para>
    /// <para>If one wants to use QPainter to draw to a different backend, one
    /// must subclass QPaintEngine and reimplement all its virtual functions. The
    /// QPaintEngine implementation is then made available by subclassing
    /// QPaintDevice and reimplementing the virtual function
    /// QPaintDevice::paintEngine().</para>
    /// <para>QPaintEngine is created and owned by the QPaintDevice that
    /// created it.</para>
    /// <para></para>
    /// <para>See also QPainter, QPaintDevice::paintEngine(), and Paint
    /// System.</para>
    /// </remarks>
    public unsafe abstract partial class QPaintEngine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr state;

            [FieldOffset(8)]
            internal QPaintEngine.PaintEngineFeature gccaps;

            [FieldOffset(12)]
            public uint active;

            [FieldOffset(12)]
            public uint selfDestruct;

            [FieldOffset(12)]
            public uint extended;

            [FieldOffset(16)]
            internal QScopedPointer.Internal d_ptr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngineC2E6QFlagsINS_18PaintEngineFeatureEE")]
            internal static extern void ctor_0(global::System.IntPtr instance, QPaintEngine.PaintEngineFeature features);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngineC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngineD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngine8drawPathERK12QPainterPath")]
            internal static extern void DrawPath_0(global::System.IntPtr instance, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngine9syncStateEv")]
            internal static extern void SyncState_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintEngine11paintDeviceEv")]
            internal static extern global::System.IntPtr PaintDevice_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngine14setPaintDeviceEP12QPaintDevice")]
            internal static extern void SetPaintDevice_0(global::System.IntPtr instance, global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintEngine10systemClipEv")]
            internal static extern void SystemClip_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN12QPaintEngine13setSystemClipERK7QRegion")]
            internal static extern void SetSystemClip_0(global::System.IntPtr instance, global::System.IntPtr baseClip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintEngine7painterEv")]
            internal static extern global::System.IntPtr Painter_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum is used to describe the features or capabilities that
        /// the paint engine has. If a feature is not supported by the engine, QPainter
        /// will do a best effort to emulate that feature through other means and pass
        /// on an alpha blended QImage to the engine with the emulated results. Some
        /// features cannot be emulated: AlphaBlend and PorterDuff.</para>
        /// </summary>
        public enum PaintEngineFeature : uint
        {
            /// <summary>The engine has support for transforming drawing primitives.</summary>
            PrimitiveTransform = 0x1,
            /// <summary>The engine has support for transforming brush patterns.</summary>
            PatternTransform = 0x2,
            /// <summary>The engine can transform pixmaps, including rotation and shearing.</summary>
            PixmapTransform = 0x4,
            /// <summary>The engine is capable of rendering brushes with the brush patterns specified in Qt::BrushStyle.</summary>
            PatternBrush = 0x8,
            /// <summary>The engine supports linear gradient fills.</summary>
            LinearGradientFill = 0x10,
            /// <summary>The engine supports radial gradient fills.</summary>
            RadialGradientFill = 0x20,
            /// <summary>The engine supports conical gradient fills.</summary>
            ConicalGradientFill = 0x40,
            /// <summary>The engine can alpha blend primitives.</summary>
            AlphaBlend = 0x80,
            /// <summary>The engine supports Porter-Duff operations</summary>
            PorterDuff = 0x100,
            /// <summary>The engine has path support.</summary>
            PainterPaths = 0x200,
            /// <summary>The engine can use antialising to improve the appearance of rendered primitives.</summary>
            Antialiasing = 0x400,
            /// <summary>The engine supports drawing strokes that contain brushes as fills, not just solid colors (e.g. a dashed gradient line of width 2).</summary>
            BrushStroke = 0x800,
            /// <summary>The engine supports the feature provided by QPainter::setOpacity().</summary>
            ConstantOpacity = 0x1000,
            /// <summary>The engine is capable of rendering brushes that has a texture with an alpha channel or a mask.</summary>
            MaskedBrush = 0x2000,
            /// <summary>The engine has support for performing perspective transformations on primitives.</summary>
            PerspectiveTransform = 0x4000,
            /// <summary>The engine supports blending modes.</summary>
            BlendModes = 0x8000,
            /// <summary>The engine has native support for gradients with coordinate mode QGradient::ObjectBoundingMode. Otherwise, if QPaintEngine::PatternTransform is supported, object bounding mode gradients are converted to gradients with coordinate mode QGradient::LogicalMode and a brush transform for the coordinate mapping.</summary>
            ObjectBoundingModeGradients = 0x10000,
            /// <summary>The engine supports bitwise raster operations.</summary>
            RasterOpModes = 0x20000,
            /// <summary>The engine is capable of painting outside of paint events.</summary>
            PaintOutsidePaintEvent = 0x20000000,
            /// <summary>All of the above features. This enum value is usually used as a bit mask.</summary>
            AllFeatures = 0xffffffff
        }

        /// <summary>
        /// <para>These types are used by QPainter to trigger lazy updates of the
        /// various states in the QPaintEngine using
        /// QPaintEngine::updateState().</para>
        /// <para>A paint engine must update every dirty state.</para>
        /// </summary>
        public enum DirtyFlag : uint
        {
            /// <summary>The pen is dirty and needs to be updated.</summary>
            DirtyPen = 0x1,
            /// <summary>The brush is dirty and needs to be updated.</summary>
            DirtyBrush = 0x2,
            /// <summary>The brush origin is dirty and needs to updated.</summary>
            DirtyBrushOrigin = 0x4,
            /// <summary>The font is dirty and needs to be updated.</summary>
            DirtyFont = 0x8,
            /// <summary>The background is dirty and needs to be updated.</summary>
            DirtyBackground = 0x10,
            /// <summary>The background mode is dirty and needs to be updated.</summary>
            DirtyBackgroundMode = 0x20,
            /// <summary>The transform is dirty and needs to be updated.</summary>
            DirtyTransform = 0x40,
            /// <summary>The clip region is dirty and needs to be updated.</summary>
            DirtyClipRegion = 0x80,
            /// <summary>The clip path is dirty and needs to be updated.</summary>
            DirtyClipPath = 0x100,
            /// <summary>The render hints is dirty and needs to be updated.</summary>
            DirtyHints = 0x200,
            /// <summary>The composition mode is dirty and needs to be updated.</summary>
            DirtyCompositionMode = 0x400,
            /// <summary>Whether clipping is enabled or not is dirty and needs to be updated.</summary>
            DirtyClipEnabled = 0x800,
            /// <summary>The constant opacity has changed and needs to be updated as part of the state change in QPaintEngine::updateState().</summary>
            DirtyOpacity = 0x1000,
            /// <summary>Convenience enum used internally.</summary>
            AllDirty = 0xffff
        }

        public enum PolygonDrawMode : uint
        {
            /// <summary>The polygon should be drawn using OddEven fill rule.</summary>
            OddEvenMode = 0,
            /// <summary>The polygon should be drawn using Winding fill rule.</summary>
            WindingMode = 1,
            /// <summary>The polygon is a convex polygon and can be drawn using specialized algorithms where available.</summary>
            ConvexMode = 2,
            /// <summary>Only the outline of the polygon should be drawn.</summary>
            PolylineMode = 3
        }

        public enum Type : uint
        {
            X11 = 0,
            Windows = 1,
            /// <summary>Mac OS X's QuickDraw</summary>
            QuickDraw = 2,
            /// <summary>Mac OS X's Quartz2D (CoreGraphics)</summary>
            CoreGraphics = 3,
            MacPrinter = 4,
            /// <summary>Qt for Embedded Linux</summary>
            QWindowSystem = 5,
            /// <summary>(No longer supported)</summary>
            PostScript = 6,
            OpenGL = 7,
            /// <summary>QPicture format</summary>
            Picture = 8,
            /// <summary>Scalable Vector Graphics XML format</summary>
            SVG = 9,
            Raster = 10,
            /// <summary>Windows only, Direct3D based engine</summary>
            Direct3D = 11,
            /// <summary>Portable Document Format</summary>
            Pdf = 12,
            OpenVG = 13,
            OpenGL2 = 14,
            PaintBuffer = 15,
            Blitter = 16,
            /// <summary>Windows only, Direct2D based engine</summary>
            Direct2D = 17,
            /// <summary>First user type ID</summary>
            User = 50,
            /// <summary>Last user type ID</summary>
            MaxUser = 100
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QPaintEngine(QPaintEngine.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates a paint engine with the featureset specified by
        /// caps.</para>
        /// </summary>
        protected QPaintEngine(QPaintEngine.PaintEngineFeature features = 0)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            var arg0 = features;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Reimplement this function to initialise your paint engine when
        /// painting is to start on the paint device pdev. Return true if the
        /// initialization was successful; otherwise return false.</para>
        /// <para>See also end() and isActive().</para>
        /// </summary>
        public abstract bool Begin(QPaintDevice pdev);

        /// <summary>
        /// <para>Reimplement this function to finish painting on the current paint
        /// device. Return true if painting was finished successfully; otherwise return
        /// false.</para>
        /// <para>See also begin() and isActive().</para>
        /// </summary>
        public abstract bool End();

        /// <summary>
        /// <para>Reimplement this function to update the state of a paint
        /// engine.</para>
        /// <para>When implemented, this function is responsible for checking the
        /// paint engine's current state and update the properties that are changed.
        /// Use the QPaintEngineState::state() function to find out which properties
        /// that must be updated, then use the corresponding get function to retrieve
        /// the current values for the given properties.</para>
        /// <para>See also QPaintEngineState.</para>
        /// </summary>
        public abstract void UpdateState(QPaintEngineState state);

        /// <summary>
        /// <para>The default implementation ignores the path and does
        /// nothing.</para>
        /// </summary>
        public virtual void DrawPath(QPainterPath path)
        {
            var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            Internal.DrawPath_0(__Instance, arg0);
        }

        public void SyncState()
        {
            Internal.SyncState_0(__Instance);
        }

        protected QPaintEngineState State
        {
            get
            {
                return (((Internal*) __Instance)->state == IntPtr.Zero) ? null : QPaintEngineState.__CreateInstance(((Internal*) __Instance)->state);
            }

            set
            {
                ((Internal*) __Instance)->state = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected QPaintEngine.PaintEngineFeature Gccaps
        {
            get
            {
                return ((Internal*) __Instance)->gccaps;
            }

            set
            {
                ((Internal*) __Instance)->gccaps = value;
            }
        }

        /// <summary>
        /// <para>Returns the device that this engine is painting on, if painting
        /// is active; otherwise returns 0.</para>
        /// </summary>
        public QPaintDevice PaintDevice
        {
            get
            {
                var __ret = Internal.PaintDevice_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintDeviceInternal.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetPaintDevice_0(__Instance, arg0);
            }
        }

        public QRegion SystemClip
        {
            get
            {
                var __ret = new QtGui.QRegion.Internal();
                Internal.SystemClip_0(new IntPtr(&__ret), __Instance);
                return QRegion.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetSystemClip_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Reimplement this function to return the paint engine Type.</para>
        /// </summary>
        public abstract QPaintEngine.Type type
        {
            get;
        }

        /// <summary>
        /// <para>Returns the paint engine's painter.</para>
        /// </summary>
        public QPainter Painter
        {
            get
            {
                var __ret = Internal.Painter_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPainter.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // virtual ~QPaintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEngine) _References[instance].Target;
            target.Dispose();
        }

        // bool begin(QPaintDevice *pdev)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _Begin_0Delegate(global::System.IntPtr instance, global::System.IntPtr pdev);
        private static _Begin_0Delegate _Begin_0DelegateInstance;

        private static bool _Begin_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr pdev)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEngine) _References[instance].Target;
            var _ret = target.Begin((pdev == IntPtr.Zero) ? null : QPaintDeviceInternal.__CreateInstance(pdev));
            return _ret;
        }

        // bool end()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _End_0Delegate(global::System.IntPtr instance);
        private static _End_0Delegate _End_0DelegateInstance;

        private static bool _End_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEngine) _References[instance].Target;
            var _ret = target.End();
            return _ret;
        }

        // void updateState(const QPaintEngineState &state)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _UpdateState_0Delegate(global::System.IntPtr instance, global::System.IntPtr state);
        private static _UpdateState_0Delegate _UpdateState_0DelegateInstance;

        private static void _UpdateState_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr state)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEngine) _References[instance].Target;
            target.UpdateState((state == IntPtr.Zero) ? null : QPaintEngineState.__CreateInstance(state));
        }

        // void drawPath(const QPainterPath &path)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _DrawPath_0Delegate(global::System.IntPtr instance, global::System.IntPtr path);
        private static _DrawPath_0Delegate _DrawPath_0DelegateInstance;

        private static void _DrawPath_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr path)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEngine) _References[instance].Target;
            target.DrawPath((path == IntPtr.Zero) ? null : QPainterPath.__CreateInstance(path));
        }

        // Type type()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QPaintEngine.Type _type_0Delegate(global::System.IntPtr instance);
        private static _type_0Delegate _type_0DelegateInstance;

        private static QPaintEngine.Type _type_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPaintEngine) _References[instance].Target;
            var _ret = target.type;
            return _ret;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Begin_0DelegateInstance += _Begin_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Begin_0DelegateInstance).ToPointer();
                _End_0DelegateInstance += _End_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_End_0DelegateInstance).ToPointer();
                _UpdateState_0DelegateInstance += _UpdateState_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_UpdateState_0DelegateInstance).ToPointer();
                _DrawPath_0DelegateInstance += _DrawPath_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DrawPath_0DelegateInstance).ToPointer();
                _type_0DelegateInstance += _type_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_type_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(21 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = _Thunks[1];
                *(void**)(vfptr0 + 12) = _Thunks[2];
                *(void**)(vfptr0 + 16) = _Thunks[3];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = _Thunks[4];
                *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
                *(void**)(vfptr0 + 52) = *(void**)(native->vfptr0 + 52);
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = *(void**)(native->vfptr0 + 68);
                *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                *(void**)(vfptr0 + 76) = *(void**)(native->vfptr0 + 76);
                *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                *(void**)(vfptr0 + 84) = _Thunks[5];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QPaintEngineState class provides information about the active
    /// paint engine's current state.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QPaintEngineState records which properties that have changed
    /// since the last time the paint engine was updated, as well as their current
    /// value.</para>
    /// <para>Which properties that have changed can at any time be retrieved
    /// using the state() function. This function returns an instance of the
    /// QPaintEngine::DirtyFlags type which stores an OR combination of
    /// QPaintEngine::DirtyFlag values. The QPaintEngine::DirtyFlag enum defines
    /// whether a property has changed since the last update or not.</para>
    /// <para>If a property is marked with a dirty flag, its current value can
    /// be retrieved using the corresponding get function:</para>
    /// <para></para>
    /// <para> Property FlagCurrent Property Value</para>
    /// <para>QPaintEngine::DirtyBackground	backgroundBrush()</para>
    /// <para>QPaintEngine::DirtyBackgroundMode	backgroundMode()</para>
    /// <para>QPaintEngine::DirtyBrush	brush()</para>
    /// <para>QPaintEngine::DirtyBrushOrigin	brushOrigin()</para>
    /// <para>QPaintEngine::DirtyClipRegion or QPaintEngine::DirtyClipPath
    /// clipOperation()</para>
    /// <para>QPaintEngine::DirtyClipPath	clipPath()</para>
    /// <para>QPaintEngine::DirtyClipRegion	clipRegion()</para>
    /// <para>QPaintEngine::DirtyCompositionMode	compositionMode()</para>
    /// <para>QPaintEngine::DirtyFont	font()</para>
    /// <para>QPaintEngine::DirtyTransform	transform()</para>
    /// <para>QPaintEngine::DirtyClipEnabled	isClipEnabled()</para>
    /// <para>QPaintEngine::DirtyPen	pen()</para>
    /// <para>QPaintEngine::DirtyHints	renderHints()</para>
    /// <para></para>
    /// <para>The QPaintEngineState class also provide the painter() function
    /// which returns a pointer to the painter that is currently updating the paint
    /// engine.</para>
    /// <para>An instance of this class, representing the current state of the
    /// active paint engine, is passed as argument to the
    /// QPaintEngine::updateState() function. The only situation in which you will
    /// have to use this class directly is when implementing your own paint
    /// engine.</para>
    /// <para></para>
    /// <para>See also QPaintEngine.</para>
    /// </remarks>
    public unsafe partial class QPaintEngineState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QPaintEngine.DirtyFlag dirtyFlags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPaintEngineStateC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState3penEv")]
            internal static extern void Pen_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState5brushEv")]
            internal static extern void Brush_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState15backgroundBrushEv")]
            internal static extern void BackgroundBrush_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState4fontEv")]
            internal static extern void Font_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState6matrixEv")]
            internal static extern void Matrix_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState9transformEv")]
            internal static extern void Transform_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState10clipRegionEv")]
            internal static extern void ClipRegion_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState8clipPathEv")]
            internal static extern void ClipPath_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState13isClipEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsClipEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState11renderHintsEv")]
            internal static extern QPainter.RenderHint RenderHints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState15compositionModeEv")]
            internal static extern QPainter.CompositionMode CompositionMode_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState7painterEv")]
            internal static extern global::System.IntPtr Painter_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState19brushNeedsResolvingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool BrushNeedsResolving_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPaintEngineState17penNeedsResolvingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool PenNeedsResolving_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPaintEngineState __CreateInstance(global::System.IntPtr native)
        {
            return new QPaintEngineState((QPaintEngineState.Internal*) native);
        }

        public static QPaintEngineState __CreateInstance(QPaintEngineState.Internal native)
        {
            return new QPaintEngineState(native);
        }

        private static QPaintEngineState.Internal* __CopyValue(QPaintEngineState.Internal native)
        {
            var ret = (QPaintEngineState.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QPaintEngineState(QPaintEngineState.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPaintEngineState(QPaintEngineState.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        protected QPaintEngine.DirtyFlag DirtyFlags
        {
            get
            {
                return ((Internal*) __Instance)->dirtyFlags;
            }

            set
            {
                ((Internal*) __Instance)->dirtyFlags = value;
            }
        }

        /// <summary>
        /// <para>Returns the pen in the current paint engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyPen flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QPen Pen
        {
            get
            {
                var __ret = new QtGui.QPen.Internal();
                Internal.Pen_0(new IntPtr(&__ret), __Instance);
                return QPen.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the brush in the current paint engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyBrush flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QBrush Brush
        {
            get
            {
                var __ret = new QtGui.QBrush.Internal();
                Internal.Brush_0(new IntPtr(&__ret), __Instance);
                return QBrush.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the background brush in the current paint engine
        /// state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyBackground flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QBrush BackgroundBrush
        {
            get
            {
                var __ret = new QtGui.QBrush.Internal();
                Internal.BackgroundBrush_0(new IntPtr(&__ret), __Instance);
                return QBrush.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the font in the current paint engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyFont flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QFont Font
        {
            get
            {
                var __ret = new QtGui.QFont.Internal();
                Internal.Font_0(new IntPtr(&__ret), __Instance);
                return QFont.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the matrix in the current paint engine state.</para>
        /// <para>Note: It is advisable to use transform() instead of this function
        /// to preserve the properties of perspective transformations.This variable
        /// should only be used when the state() returns a combination which includes
        /// the QPaintEngine::DirtyTransform flag.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QMatrix Matrix
        {
            get
            {
                var __ret = new QtGui.QMatrix.Internal();
                Internal.Matrix_0(new IntPtr(&__ret), __Instance);
                return QMatrix.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the matrix in the current paint engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyTransform flag.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QTransform Transform
        {
            get
            {
                var __ret = new QtGui.QTransform.Internal();
                Internal.Transform_0(new IntPtr(&__ret), __Instance);
                return QTransform.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the clip region in the current paint engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyClipRegion flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QRegion ClipRegion
        {
            get
            {
                var __ret = new QtGui.QRegion.Internal();
                Internal.ClipRegion_0(new IntPtr(&__ret), __Instance);
                return QRegion.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the clip path in the current paint engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyClipPath flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QPainterPath ClipPath
        {
            get
            {
                var __ret = new QtGui.QPainterPath.Internal();
                Internal.ClipPath_0(new IntPtr(&__ret), __Instance);
                return QPainterPath.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns whether clipping is enabled or not in the current paint
        /// engine state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyClipEnabled flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public bool IsClipEnabled
        {
            get
            {
                var __ret = Internal.IsClipEnabled_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the render hints in the current paint engine
        /// state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyHints flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QPainter.RenderHint RenderHints
        {
            get
            {
                var __ret = Internal.RenderHints_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the composition mode in the current paint engine
        /// state.</para>
        /// <para>This variable should only be used when the state() returns a
        /// combination which includes the QPaintEngine::DirtyCompositionMode
        /// flag.</para>
        /// <para>See also state() and QPaintEngine::updateState().</para>
        /// </summary>
        public QPainter.CompositionMode CompositionMode
        {
            get
            {
                var __ret = Internal.CompositionMode_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the painter currently updating the paint
        /// engine.</para>
        /// </summary>
        public QPainter Painter
        {
            get
            {
                var __ret = Internal.Painter_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPainter.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns whether the coordinate of the fill have been specified as
        /// bounded by the current rendering operation and have to be resolved (about
        /// the currently rendered primitive).</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public bool BrushNeedsResolving
        {
            get
            {
                var __ret = Internal.BrushNeedsResolving_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns whether the coordinate of the stroke have been specified
        /// as bounded by the current rendering operation and have to be resolved
        /// (about the currently rendered primitive).</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public bool PenNeedsResolving
        {
            get
            {
                var __ret = Internal.PenNeedsResolving_0(__Instance);
                return __ret;
            }
        }
    }

    internal unsafe partial class QPaintEngineInternal : QtGui.QPaintEngine, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QPaintEngineInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QPaintEngineInternal((QPaintEngine.Internal*) native);
        }

        public static QPaintEngine __CreateInstance(QPaintEngine.Internal native)
        {
            return new QPaintEngineInternal(native);
        }

        private static QPaintEngine.Internal* __CopyValue(QPaintEngine.Internal native)
        {
            var ret = (QPaintEngine.Internal*) Marshal.AllocHGlobal(20);
            *ret = native;
            return ret;
        }

        private QPaintEngineInternal(QPaintEngine.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPaintEngineInternal(QPaintEngine.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QPaintEngine.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override bool Begin(QPaintDevice pdev)
        {
            void* slot = *(void**) (((QPaintEngine.Internal*) __Instance)->vfptr0 + 2 * 4);
            var ___Begin_0Delegate = (_Begin_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Begin_0Delegate));
            var arg0 = ReferenceEquals(pdev, null) ? global::System.IntPtr.Zero : pdev.__Instance;
            var __ret = ___Begin_0Delegate(__Instance, arg0);
            return __ret;
        }

        public override bool End()
        {
            void* slot = *(void**) (((QPaintEngine.Internal*) __Instance)->vfptr0 + 3 * 4);
            var ___End_0Delegate = (_End_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_End_0Delegate));
            var __ret = ___End_0Delegate(__Instance);
            return __ret;
        }

        public override void UpdateState(QPaintEngineState state)
        {
            void* slot = *(void**) (((QPaintEngine.Internal*) __Instance)->vfptr0 + 4 * 4);
            var ___UpdateState_0Delegate = (_UpdateState_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_UpdateState_0Delegate));
            var arg0 = ReferenceEquals(state, null) ? global::System.IntPtr.Zero : state.__Instance;
            ___UpdateState_0Delegate(__Instance, arg0);
        }

        public override QPaintEngine.Type Type
        {
            get
            {
                void* slot = *(void**) (((QPaintEngine.Internal*) __Instance)->vfptr0 + 21 * 4);
                var ___type_0Delegate = (_type_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_type_0Delegate));
                var __ret = ___type_0Delegate(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QPdfWriter class is a class to generate PDFs that can be used
    /// as a paint device.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QPdfWriter generates PDF out of a series of drawing commands
    /// using QPainter. The newPage() method can be used to create several
    /// pages.</para>
    /// </remarks>
    public unsafe partial class QPdfWriter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public ushort painters;

            [FieldOffset(8)]
            public global::System.IntPtr reserved;

            [FieldOffset(12)]
            public global::System.IntPtr d;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriterC2ERK7QString")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriterC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriterD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriter7newPageEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool NewPage_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPdfWriter6metricEN12QPaintDevice17PaintDeviceMetricE")]
            internal static extern int Metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice13setPageLayoutERK11QPageLayout")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetPageLayout_0(global::System.IntPtr instance, global::System.IntPtr pageLayout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice11setPageSizeERK9QPageSize")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetPageSize_1(global::System.IntPtr instance, global::System.IntPtr pageSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice18setPageOrientationEN11QPageLayout11OrientationE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetPageOrientation_0(global::System.IntPtr instance, QPageLayout.Orientation orientation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice11setPageSizeENS_8PageSizeE")]
            internal static extern void setPageSize_0(global::System.IntPtr instance, QPagedPaintDevice.PageSize size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice10setMarginsERKNS_7MarginsE")]
            internal static extern void setMargins_0(global::System.IntPtr instance, global::System.IntPtr margins);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice11initPainterEP8QPainter")]
            internal static extern void InitPainter_0(global::System.IntPtr instance, global::System.IntPtr painter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice11initPainterEP8QPainter")]
            internal static extern void initPainter_0(global::System.IntPtr instance, global::System.IntPtr painter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice6metricENS_17PaintDeviceMetricE")]
            internal static extern int metric_0(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric metric);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPdfWriter5titleEv")]
            internal static extern void Title_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriter8setTitleERK7QString")]
            internal static extern void SetTitle_0(global::System.IntPtr instance, global::System.IntPtr title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPdfWriter7creatorEv")]
            internal static extern void Creator_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriter10setCreatorERK7QString")]
            internal static extern void SetCreator_0(global::System.IntPtr instance, global::System.IntPtr creator);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPdfWriter10resolutionEv")]
            internal static extern int Resolution_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriter13setResolutionEi")]
            internal static extern void SetResolution_0(global::System.IntPtr instance, int resolution);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPagedPaintDevice8pageSizeEv")]
            internal static extern QPagedPaintDevice.PageSize PageSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriter11setPageSizeEN17QPagedPaintDevice8PageSizeE")]
            internal static extern void SetPageSize_0(global::System.IntPtr instance, QPagedPaintDevice.PageSize size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPagedPaintDevice7marginsEv")]
            internal static extern void Margins_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QPdfWriter10setMarginsERKN17QPagedPaintDevice7MarginsE")]
            internal static extern void SetMargins_0(global::System.IntPtr instance, global::System.IntPtr m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QPdfWriter11paintEngineEv")]
            internal static extern global::System.IntPtr PaintEngine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QPagedPaintDevice10pageLayoutEv")]
            internal static extern void PageLayout_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QPagedPaintDevice16devicePageLayoutEv")]
            internal static extern global::System.IntPtr DevicePageLayout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK12QPaintDevice13sharedPainterEv")]
            internal static extern global::System.IntPtr SharedPainter_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QPdfWriter __CreateInstance(global::System.IntPtr native)
        {
            return new QPdfWriter((QPdfWriter.Internal*) native);
        }

        public static QPdfWriter __CreateInstance(QPdfWriter.Internal native)
        {
            return new QPdfWriter(native);
        }

        private static QPdfWriter.Internal* __CopyValue(QPdfWriter.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            QtGui.QPdfWriter.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QPdfWriter.Internal*) ret;
        }

        private QPdfWriter(QPdfWriter.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QPdfWriter(QPdfWriter.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a PDF writer that will write the pdf to
        /// filename.</para>
        /// </summary>
        public QPdfWriter(string filename)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(filename).ToPointer(), filename.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QPagedPaintDevice::newPage().</para>
        /// </summary>
        public override bool NewPage()
        {
            var __ret = Internal.NewPage_0(__Instance);
            return __ret;
        }

        protected override int Metric(QPaintDevice.PaintDeviceMetric id)
        {
            var arg0 = id;
            var __ret = Internal.Metric_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Reimplemented from QPagedPaintDevice::newPage().</para>
        /// </summary>
        public abstract bool newPage();

        /// <summary>
        /// <para>Sets the PDF page layout to newPageLayout.</para>
        /// <para>You should call this before calling QPainter::begin(), or
        /// immediately before calling newPage() to apply the new page layout to a new
        /// page. You should not call any painting methods between a call to
        /// setPageLayout() and newPage() as the wrong paint metrics may be
        /// used.</para>
        /// <para>Returns true if the page layout was successfully set to
        /// newPageLayout.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also pageLayout().</para>
        /// </summary>
        public bool SetPageLayout(QPageLayout pageLayout)
        {
            var arg0 = ReferenceEquals(pageLayout, null) ? global::System.IntPtr.Zero : pageLayout.__Instance;
            var __ret = Internal.SetPageLayout_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the PDF page size to pageSize.</para>
        /// <para>To get the current QPageSize use pageLayout().pageSize().</para>
        /// <para>You should call this before calling QPainter::begin(), or
        /// immediately before calling newPage() to apply the new page size to a new
        /// page. You should not call any painting methods between a call to
        /// setPageSize() and newPage() as the wrong paint metrics may be used.</para>
        /// <para>Returns true if the page size was successfully set to
        /// pageSize.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also pageLayout().</para>
        /// </summary>
        public bool SetPageSize(QPageSize pageSize)
        {
            var arg0 = ReferenceEquals(pageSize, null) ? global::System.IntPtr.Zero : pageSize.__Instance;
            var __ret = Internal.SetPageSize_1(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the PDF page orientation.</para>
        /// <para>The page orientation is used to define the orientation of the
        /// page size when obtaining the page rect.</para>
        /// <para>You should call this before calling QPainter::begin(), or
        /// immediately before calling newPage() to apply the new orientation to a new
        /// page. You should not call any painting methods between a call to
        /// setPageOrientation() and newPage() as the wrong paint metrics may be
        /// used.</para>
        /// <para>To get the current QPageLayout::Orientation use
        /// pageLayout().pageOrientation().</para>
        /// <para>Returns true if the page orientation was successfully set to
        /// orientation.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also pageLayout().</para>
        /// </summary>
        public bool SetPageOrientation(QPageLayout.Orientation orientation)
        {
            var arg0 = orientation;
            var __ret = Internal.SetPageOrientation_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Reimplemented from QPagedPaintDevice::setPageSize().</para>
        /// <para>See also setPageSize().</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public void setPageSize(QPagedPaintDevice.PageSize size)
        {
            var arg0 = size;
            Internal.setPageSize_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Reimplemented from QPagedPaintDevice::setMargins().</para>
        /// <para>See also setPageMargins().</para>
        /// </summary>
        [System.ObsoleteAttribute("")]
        public void setMargins(QPagedPaintDevice.Margins margins)
        {
            var arg0 = ReferenceEquals(margins, null) ? global::System.IntPtr.Zero : margins.__Instance;
            Internal.setMargins_0(__Instance, arg0);
        }

        protected void InitPainter(QPainter painter)
        {
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            Internal.InitPainter_0(__Instance, arg0);
        }

        protected void initPainter(QPainter painter)
        {
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            Internal.initPainter_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Reimplemented from QPaintDevice::paintEngine().</para>
        /// </summary>
        public abstract QPaintEngine paintEngine();

        protected int metric(QPaintDevice.PaintDeviceMetric metric)
        {
            var arg0 = metric;
            var __ret = Internal.metric_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the title of the document.</para>
        /// <para>See also setTitle().</para>
        /// <para></para>
        /// <para>Sets the title of the document being created to title.</para>
        /// <para>See also title().</para>
        /// </summary>
        public string Title
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Title_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetTitle_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the creator of the document.</para>
        /// <para>See also setCreator().</para>
        /// <para></para>
        /// <para>Sets the creator of the document to creator.</para>
        /// <para>See also creator().</para>
        /// </summary>
        public string Creator
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Creator_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetCreator_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the resolution of the PDF in DPI.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also setResolution().</para>
        /// <para></para>
        /// <para>Sets the PDF resolution in DPI.</para>
        /// <para>This setting affects the coordinate system as returned by, for
        /// example QPainter::viewport().</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also resolution().</para>
        /// </summary>
        public int Resolution
        {
            get
            {
                var __ret = Internal.Resolution_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetResolution_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QPagedPaintDevice::setPageSize().</para>
        /// <para>See also setPageSize().</para>
        /// </summary>
        public override QPagedPaintDevice.PageSize PageSize
        {
            get
            {
                var __ret = Internal.PageSize_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetPageSize_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QPagedPaintDevice::setMargins().</para>
        /// <para>See also setPageMargins().</para>
        /// </summary>
        public override QPagedPaintDevice.Margins Margins
        {
            get
            {
                var __ret = new QtGui.QPagedPaintDevice.Margins.Internal();
                Internal.Margins_0(new IntPtr(&__ret), __Instance);
                return QPagedPaintDevice.Margins.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetMargins_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Reimplemented from QPaintDevice::paintEngine().</para>
        /// </summary>
        public override QPaintEngine PaintEngine
        {
            get
            {
                var __ret = Internal.PaintEngine_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintEngineInternal.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the current page layout. Use this method to access the
        /// current QPageSize, QPageLayout::Orientation, QMarginsF, fullRect() and
        /// paintRect().</para>
        /// <para>Note that you cannot use the setters on the returned object, you
        /// must either call the individual QPdfWriter methods or use
        /// setPageLayout().</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also setPageLayout(), setPageSize(), setPageOrientation(),
        /// and setPageMargins().</para>
        /// </summary>
        public QPageLayout PageLayout
        {
            get
            {
                var __ret = new QtGui.QPageLayout.Internal();
                Internal.PageLayout_0(new IntPtr(&__ret), __Instance);
                return QPageLayout.__CreateInstance(__ret);
            }
        }

        public QPageLayout DevicePageLayout
        {
            get
            {
                var __ret = Internal.DevicePageLayout_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPageLayout.__CreateInstance(__ret);
            }
        }

        public QPainter SharedPainter
        {
            get
            {
                var __ret = Internal.SharedPainter_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPainter.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QPdfWriter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            target.Dispose();
        }

        // bool newPage()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate bool _NewPage_0Delegate(global::System.IntPtr instance);
        private static _NewPage_0Delegate _NewPage_0DelegateInstance;

        private static bool _NewPage_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            var _ret = target.NewPage();
            return _ret;
        }

        // void setPageSize(PageSize size)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetPageSize_0Delegate(global::System.IntPtr instance, QPagedPaintDevice.PageSize size);
        private static _SetPageSize_0Delegate _SetPageSize_0DelegateInstance;

        private static void _SetPageSize_0DelegateHook(global::System.IntPtr instance, QPagedPaintDevice.PageSize size)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            target.PageSize = size;
        }

        // void setMargins(const Margins &m)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetMargins_0Delegate(global::System.IntPtr instance, global::System.IntPtr m);
        private static _SetMargins_0Delegate _SetMargins_0DelegateInstance;

        private static void _SetMargins_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr m)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            target.Margins = (m == IntPtr.Zero) ? null : QPagedPaintDevice.Margins.__CreateInstance(m);
        }

        // QPaintEngine *paintEngine()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _PaintEngine_0Delegate(global::System.IntPtr instance);
        private static _PaintEngine_0Delegate _PaintEngine_0DelegateInstance;

        private static global::System.IntPtr _PaintEngine_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            var _ret = target.PaintEngine;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        // int metric(PaintDeviceMetric id)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _Metric_0Delegate(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric id);
        private static _Metric_0Delegate _Metric_0DelegateInstance;

        private static int _Metric_0DelegateHook(global::System.IntPtr instance, QPaintDevice.PaintDeviceMetric id)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            var _ret = target.Metric(id);
            return _ret;
        }

        // void initPainter(QPainter *painter)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _InitPainter_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter);
        private static _InitPainter_0Delegate _InitPainter_0DelegateInstance;

        private static void _InitPainter_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            target.InitPainter((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter));
        }

        // QPainter *sharedPainter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _SharedPainter_0Delegate(global::System.IntPtr instance);
        private static _SharedPainter_0Delegate _SharedPainter_0DelegateInstance;

        private static global::System.IntPtr _SharedPainter_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QPdfWriter) _References[instance].Target;
            var _ret = target.SharedPainter;
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _NewPage_0DelegateInstance += _NewPage_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_NewPage_0DelegateInstance).ToPointer();
                _SetPageSize_0DelegateInstance += _SetPageSize_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetPageSize_0DelegateInstance).ToPointer();
                _SetMargins_0DelegateInstance += _SetMargins_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetMargins_0DelegateInstance).ToPointer();
                _PaintEngine_0DelegateInstance += _PaintEngine_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_PaintEngine_0DelegateInstance).ToPointer();
                _Metric_0DelegateInstance += _Metric_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Metric_0DelegateInstance).ToPointer();
                _InitPainter_0DelegateInstance += _InitPainter_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_InitPainter_0DelegateInstance).ToPointer();
                _SharedPainter_0DelegateInstance += _SharedPainter_0DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_SharedPainter_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(28 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[3];
                *(void**)(vfptr0 + 64) = _Thunks[4];
                *(void**)(vfptr0 + 68) = _Thunks[5];
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 88) = *(void**)(native->vfptr0 + 88);
                *(void**)(vfptr0 + 64) = _Thunks[4];
                *(void**)(vfptr0 + 68) = _Thunks[5];
                *(void**)(vfptr0 + 100) = _Thunks[6];
                *(void**)(vfptr0 + 104) = *(void**)(native->vfptr0 + 104);
                *(void**)(vfptr0 + 108) = _Thunks[7];
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                *(void**)(vfptr0 + 60) = _Thunks[3];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextLength class encapsulates the different types of length
    /// used in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>When we specify a value for the length of an element in a text
    /// document, we often need to provide some other information so that the
    /// length is used in the way we expect. For example, when we specify a table
    /// width, the value can represent a fixed number of pixels, or it can be a
    /// percentage value. This information changes both the meaning of the value
    /// and the way it is used.</para>
    /// <para>Generally, this class is used to specify table widths. These can
    /// be specified either as a fixed amount of pixels, as a percentage of the
    /// containing frame's width, or by a variable width that allows it to take up
    /// just the space it requires.</para>
    /// <para></para>
    /// <para>See also QTextTable.</para>
    /// </remarks>
    public unsafe partial class QTextLength : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public QTextLength.Type lengthType;

            [FieldOffset(8)]
            public double fixedValueOrPercentage;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLengthC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        /// <summary>
        /// <para>This enum describes the different types a length object can
        /// have.</para>
        /// <para>See also type().</para>
        /// </summary>
        public enum Type : uint
        {
            /// <summary>The width of the object is variable</summary>
            VariableLength = 0,
            /// <summary>The width of the object is fixed</summary>
            FixedLength = 1,
            /// <summary>The width of the object is in percentage of the maximum width</summary>
            PercentageLength = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextLength __CreateInstance(global::System.IntPtr native)
        {
            return new QTextLength((QTextLength.Internal*) native);
        }

        public static QTextLength __CreateInstance(QTextLength.Internal native)
        {
            return new QTextLength(native);
        }

        private static QTextLength.Internal* __CopyValue(QTextLength.Internal native)
        {
            var ret = (QTextLength.Internal*) Marshal.AllocHGlobal(16);
            *ret = native;
            return ret;
        }

        private QTextLength(QTextLength.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextLength(QTextLength.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    /// <summary>
    /// <para>The QTextFormat class provides formatting information for a
    /// QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A QTextFormat is a generic class used for describing the format
    /// of parts of a QTextDocument. The derived classes QTextCharFormat,
    /// QTextBlockFormat, QTextListFormat, and QTextTableFormat are usually more
    /// useful, and describe the formatting that is applied to specific parts of
    /// the document.</para>
    /// <para>A format has a FormatType which specifies the kinds of text item
    /// it can format; e.g. a block of text, a list, a table, etc. A format also
    /// has various properties (some specific to particular format types), as
    /// described by the Property enum. Every property has a corresponding
    /// Property.</para>
    /// <para>The format type is given by type(), and the format can be tested
    /// with isCharFormat(), isBlockFormat(), isListFormat(), isTableFormat(),
    /// isFrameFormat(), and isImageFormat(). If the type is determined, it can be
    /// retrieved with toCharFormat(), toBlockFormat(), toListFormat(),
    /// toTableFormat(), toFrameFormat(), and toImageFormat().</para>
    /// <para>A format's properties can be set with the setProperty()
    /// functions, and retrieved with boolProperty(), intProperty(),
    /// doubleProperty(), and stringProperty() as appropriate. All the property IDs
    /// used in the format can be retrieved with allPropertyIds(). One format can
    /// be merged into another using merge().</para>
    /// <para>A format's object index can be set with setObjectIndex(), and
    /// retrieved with objectIndex(). These methods can be used to associate the
    /// format with a QTextObject. It is used to represent lists, frames, and
    /// tables inside the document.</para>
    /// <para></para>
    /// <para>See also Rich Text Processing.</para>
    /// </remarks>
    public unsafe partial class QTextFormat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormatC2Ei")]
            internal static extern void ctor_1(global::System.IntPtr instance, int type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormatC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormat5mergeERKS_")]
            internal static extern void Merge_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormat13clearPropertyEi")]
            internal static extern void ClearProperty_0(global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat11hasPropertyEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasProperty_0(global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat12boolPropertyEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool BoolProperty_0(global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat11intPropertyEi")]
            internal static extern int IntProperty_0(global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat14stringPropertyEi")]
            internal static extern void StringProperty_0(global::System.IntPtr @return, global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13colorPropertyEi")]
            internal static extern void ColorProperty_0(global::System.IntPtr @return, global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat11penPropertyEi")]
            internal static extern void PenProperty_0(global::System.IntPtr @return, global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13brushPropertyEi")]
            internal static extern void BrushProperty_0(global::System.IntPtr @return, global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat14lengthPropertyEi")]
            internal static extern void LengthProperty_0(global::System.IntPtr @return, global::System.IntPtr instance, int propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13toBlockFormatEv")]
            internal static extern void ToBlockFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat12toCharFormatEv")]
            internal static extern void ToCharFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat12toListFormatEv")]
            internal static extern void ToListFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13toTableFormatEv")]
            internal static extern void ToTableFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13toFrameFormatEv")]
            internal static extern void ToFrameFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13toImageFormatEv")]
            internal static extern void ToImageFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat17toTableCellFormatEv")]
            internal static extern void ToTableCellFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormateqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat11objectIndexEv")]
            internal static extern int ObjectIndex_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextFormat14setObjectIndexEi")]
            internal static extern void SetObjectIndex_0(global::System.IntPtr instance, int @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat4typeEv")]
            internal static extern int Type_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextFormat13propertyCountEv")]
            internal static extern int PropertyCount_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the text item a QTextFormat object is
        /// formatting.</para>
        /// <para>See also QTextCharFormat, QTextBlockFormat, QTextListFormat,
        /// QTextTableFormat, and type().</para>
        /// </summary>
        public enum FormatType
        {
            /// <summary>An invalid format as created by the default constructor</summary>
            InvalidFormat = -1,
            /// <summary>The object formats a text block</summary>
            BlockFormat = 1,
            /// <summary>The object formats a single character</summary>
            CharFormat = 2,
            /// <summary>The object formats a list Unused Value, a table's FormatType is FrameFormat.</summary>
            ListFormat = 3,
            TableFormat = 4,
            /// <summary>The object formats a frame</summary>
            FrameFormat = 5,
            UserFormat = 100
        }

        /// <summary>
        /// <para>This enum describes the different properties a format can
        /// have.</para>
        /// <para>Paragraph and character properties</para>
        /// <para>Paragraph properties</para>
        /// <para>Character properties</para>
        /// <para>List properties</para>
        /// <para>Table and frame properties</para>
        /// <para>Table cell properties</para>
        /// <para>Image properties</para>
        /// <para>Selection properties</para>
        /// <para>Page break properties</para>
        /// <para>See also property() and setProperty().</para>
        /// </summary>
        public enum Property : uint
        {
            /// <summary>The index of the formatted object. See objectIndex().</summary>
            ObjectIndex = 0x0,
            /// <summary>How a frame is located relative to the surrounding text</summary>
            CssFloat = 0x800,
            /// <summary>The layout direction of the text in the document (Qt::LayoutDirection).</summary>
            LayoutDirection = 0x801,
            OutlinePen = 0x810,
            BackgroundBrush = 0x820,
            ForegroundBrush = 0x821,
            BackgroundImageUrl = 0x823,
            BlockAlignment = 0x1010,
            BlockTopMargin = 0x1030,
            BlockBottomMargin = 0x1031,
            BlockLeftMargin = 0x1032,
            BlockRightMargin = 0x1033,
            TextIndent = 0x1034,
            /// <summary>Specifies the tab positions. The tab positions are structs of QTextOption::Tab which are stored in a QList (internally, in a QList<QVariant>).</summary>
            TabPositions = 0x1035,
            BlockIndent = 0x1040,
            LineHeight = 0x1048,
            LineHeightType = 0x1049,
            BlockNonBreakableLines = 0x1050,
            /// <summary>The width of a horizontal ruler element.</summary>
            BlockTrailingHorizontalRulerWidth = 0x1060,
            FirstFontProperty = 0x1fe0,
            /// <summary>Specifies the capitalization type that is to be applied to the text.</summary>
            FontCapitalization = 8160,
            /// <summary>Specifies the meaning of the FontLetterSpacing property. The default is QFont::PercentageSpacing.</summary>
            FontLetterSpacingType = 0x2033,
            /// <summary>Changes the default spacing between individual letters in the font. The value is specified as a percentage or absolute value, depending on FontLetterSpacingType. The default value is 100%.</summary>
            FontLetterSpacing = 0x1fe1,
            /// <summary>Changes the default spacing between individual words. A positive value increases the word spacing by the corresponding pixels; a negative value decreases the spacing.</summary>
            FontWordSpacing = 0x1fe2,
            /// <summary>Corresponds to the QFont::Stretch property</summary>
            FontStretch = 0x2034,
            /// <summary>Corresponds to the QFont::StyleHint property</summary>
            FontStyleHint = 0x1fe3,
            /// <summary>Corresponds to the QFont::StyleStrategy property</summary>
            FontStyleStrategy = 0x1fe4,
            /// <summary>Specifies whether the font has kerning turned on.</summary>
            FontKerning = 0x1fe5,
            /// <summary>Controls the use of hinting according to values of the QFont::HintingPreference enum.</summary>
            FontHintingPreference = 0x1fe6,
            FontFamily = 0x2000,
            FontPointSize = 0x2001,
            /// <summary>Specifies the change in size given to the fontsize already set using FontPointSize or FontPixelSize.</summary>
            FontSizeAdjustment = 0x2002,
            FontSizeIncrement = 8194,
            FontWeight = 0x2003,
            FontItalic = 0x2004,
            /// <summary>This property has been deprecated. Use QTextFormat::TextUnderlineStyle instead.</summary>
            FontUnderline = 0x2005,
            FontOverline = 0x2006,
            FontStrikeOut = 0x2007,
            FontFixedPitch = 0x2008,
            FontPixelSize = 0x2009,
            LastFontProperty = 8201,
            TextUnderlineColor = 0x2010,
            TextVerticalAlignment = 0x2021,
            TextOutline = 0x2022,
            TextUnderlineStyle = 0x2023,
            /// <summary>Specifies the (optional) tool tip to be displayed for a fragment of text.</summary>
            TextToolTip = 0x2024,
            IsAnchor = 0x2030,
            AnchorHref = 0x2031,
            AnchorName = 0x2032,
            ObjectType = 0x2f00,
            /// <summary>Specifies the style used for the items in a list, described by values of the QTextListFormat::Style enum.</summary>
            ListStyle = 0x3000,
            /// <summary>Specifies the amount of indentation used for a list.</summary>
            ListIndent = 0x3001,
            /// <summary>Defines the text which is prepended to item numbers in numeric lists.</summary>
            ListNumberPrefix = 0x3002,
            /// <summary>Defines the text which is appended to item numbers in numeric lists.</summary>
            ListNumberSuffix = 0x3003,
            FrameBorder = 0x4000,
            FrameMargin = 0x4001,
            FramePadding = 0x4002,
            FrameWidth = 0x4003,
            FrameHeight = 0x4004,
            FrameTopMargin = 0x4005,
            FrameBottomMargin = 0x4006,
            FrameLeftMargin = 0x4007,
            FrameRightMargin = 0x4008,
            FrameBorderBrush = 0x4009,
            /// <summary>See the BorderStyle enum.</summary>
            FrameBorderStyle = 0x4010,
            TableColumns = 0x4100,
            TableColumnWidthConstraints = 0x4101,
            TableCellSpacing = 0x4102,
            TableCellPadding = 0x4103,
            TableHeaderRowCount = 0x4104,
            TableCellRowSpan = 0x4810,
            TableCellColumnSpan = 0x4811,
            TableCellTopPadding = 0x4812,
            TableCellBottomPadding = 0x4813,
            TableCellLeftPadding = 0x4814,
            TableCellRightPadding = 0x4815,
            ImageName = 0x5000,
            ImageWidth = 0x5010,
            ImageHeight = 0x5011,
            /// <summary>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</summary>
            FullWidthSelection = 0x6000,
            /// <summary>Specifies how pages are broken. See the PageBreakFlag enum.</summary>
            PageBreakPolicy = 0x7000,
            UserProperty = 0x100000
        }

        /// <summary>
        /// <para>This enum describes what kind of QTextObject this format is
        /// associated with.</para>
        /// <para>See also QTextObject, QTextTable, and
        /// QTextObject::format().</para>
        /// </summary>
        public enum ObjectTypes : uint
        {
            NoObject = 0,
            ImageObject = 1,
            TableObject = 2,
            TableCellObject = 3,
            /// <summary>The first object that can be used for application-specific purposes.</summary>
            UserObject = 0x1000
        }

        /// <summary>
        /// <para>This enum describes how page breaking is performed when printing.
        /// It maps to the corresponding css properties.</para>
        /// <para>This enum was introduced or modified in  Qt 4.2.</para>
        /// <para></para>
        /// <para>See also QTextBlockFormat::pageBreakPolicy(),
        /// QTextFrameFormat::pageBreakPolicy(), and PageBreakPolicy.</para>
        /// </summary>
        [Flags]
        public enum PageBreakFlag : uint
        {
            /// <summary>The page break is determined automatically depending on the available space on the current page</summary>
            PageBreak_Auto = 0,
            /// <summary>The page is always broken before the paragraph/table</summary>
            PageBreak_AlwaysBefore = 0x1,
            /// <summary>A new page is always started after the paragraph/table</summary>
            PageBreak_AlwaysAfter = 0x10
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextFormat((QTextFormat.Internal*) native);
        }

        public static QTextFormat __CreateInstance(QTextFormat.Internal native)
        {
            return new QTextFormat(native);
        }

        private static QTextFormat.Internal* __CopyValue(QTextFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextFormat.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextFormat.Internal*) ret;
        }

        private QTextFormat(QTextFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextFormat(QTextFormat.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a new text format with an InvalidFormat.</para>
        /// <para>See also FormatType.</para>
        /// </summary>
        public QTextFormat()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a new text format of the given type.</para>
        /// <para>See also FormatType.</para>
        /// </summary>
        public QTextFormat(int type)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_1(__Instance, type);
        }

        /// <summary>
        /// <para>Creates a new text format with the same attributes as the other
        /// text format.</para>
        /// </summary>
        public QTextFormat(QTextFormat rhs)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Merges the other format with this format; where there are
        /// conflicts the other format takes precedence.</para>
        /// </summary>
        public void Merge(QTextFormat other)
        {
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.Merge_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Clears the value of the property given by propertyId</para>
        /// <para>See also Property.</para>
        /// </summary>
        public void ClearProperty(int propertyId)
        {
            Internal.ClearProperty_0(__Instance, propertyId);
        }

        /// <summary>
        /// <para>Returns true if the text format has a property with the given
        /// propertyId; otherwise returns false.</para>
        /// <para>See also properties() and Property.</para>
        /// </summary>
        public bool HasProperty(int propertyId)
        {
            var __ret = Internal.HasProperty_0(__Instance, propertyId);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the value of the property specified by propertyId. If the
        /// property isn't of QTextFormat::Bool type, false is returned instead.</para>
        /// <para>See also setProperty(), intProperty(), doubleProperty(),
        /// stringProperty(), colorProperty(), lengthProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public bool BoolProperty(int propertyId)
        {
            var __ret = Internal.BoolProperty_0(__Instance, propertyId);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the value of the property specified by propertyId. If the
        /// property is not of QTextFormat::Integer type, 0 is returned instead.</para>
        /// <para>See also setProperty(), boolProperty(), doubleProperty(),
        /// stringProperty(), colorProperty(), lengthProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public int IntProperty(int propertyId)
        {
            var __ret = Internal.IntProperty_0(__Instance, propertyId);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the value of the property given by propertyId; if the
        /// property isn't of QVariant::String type, an empty string is returned
        /// instead.</para>
        /// <para>See also setProperty(), boolProperty(), intProperty(),
        /// doubleProperty(), colorProperty(), lengthProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public string StringProperty(int propertyId)
        {
            var __ret = new QtCore.QString.Internal();
            Internal.StringProperty_0(new IntPtr(&__ret), __Instance, propertyId);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns the value of the property given by propertyId; if the
        /// property isn't of QVariant::Color type, an invalid color is returned
        /// instead.</para>
        /// <para>See also setProperty(), boolProperty(), intProperty(),
        /// doubleProperty(), stringProperty(), lengthProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public QColor ColorProperty(int propertyId)
        {
            var __ret = new QtGui.QColor.Internal();
            Internal.ColorProperty_0(new IntPtr(&__ret), __Instance, propertyId);
            return QColor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the value of the property given by propertyId; if the
        /// property isn't of QVariant::Pen type, Qt::NoPen is returned instead.</para>
        /// <para>See also setProperty(), boolProperty(), intProperty(),
        /// doubleProperty(), stringProperty(), lengthProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public QPen PenProperty(int propertyId)
        {
            var __ret = new QtGui.QPen.Internal();
            Internal.PenProperty_0(new IntPtr(&__ret), __Instance, propertyId);
            return QPen.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the value of the property given by propertyId; if the
        /// property isn't of QVariant::Brush type, Qt::NoBrush is returned
        /// instead.</para>
        /// <para>See also setProperty(), boolProperty(), intProperty(),
        /// doubleProperty(), stringProperty(), lengthProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public QBrush BrushProperty(int propertyId)
        {
            var __ret = new QtGui.QBrush.Internal();
            Internal.BrushProperty_0(new IntPtr(&__ret), __Instance, propertyId);
            return QBrush.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the value of the property given by propertyId.</para>
        /// <para>See also setProperty(), boolProperty(), intProperty(),
        /// doubleProperty(), stringProperty(), colorProperty(),
        /// lengthVectorProperty(), and Property.</para>
        /// </summary>
        public QTextLength LengthProperty(int propertyId)
        {
            var __ret = new QtGui.QTextLength.Internal();
            Internal.LengthProperty_0(new IntPtr(&__ret), __Instance, propertyId);
            return QTextLength.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as a block format.</para>
        /// </summary>
        public QTextBlockFormat ToBlockFormat()
        {
            var __ret = new QtGui.QTextBlockFormat.Internal();
            Internal.ToBlockFormat_0(new IntPtr(&__ret), __Instance);
            return QTextBlockFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as a character format.</para>
        /// </summary>
        public QTextCharFormat ToCharFormat()
        {
            var __ret = new QtGui.QTextCharFormat.Internal();
            Internal.ToCharFormat_0(new IntPtr(&__ret), __Instance);
            return QTextCharFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as a list format.</para>
        /// </summary>
        public QTextListFormat ToListFormat()
        {
            var __ret = new QtGui.QTextListFormat.Internal();
            Internal.ToListFormat_0(new IntPtr(&__ret), __Instance);
            return QTextListFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as a table format.</para>
        /// </summary>
        public QTextTableFormat ToTableFormat()
        {
            var __ret = new QtGui.QTextTableFormat.Internal();
            Internal.ToTableFormat_0(new IntPtr(&__ret), __Instance);
            return QTextTableFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as a frame format.</para>
        /// </summary>
        public QTextFrameFormat ToFrameFormat()
        {
            var __ret = new QtGui.QTextFrameFormat.Internal();
            Internal.ToFrameFormat_0(new IntPtr(&__ret), __Instance);
            return QTextFrameFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as an image format.</para>
        /// </summary>
        public QTextImageFormat ToImageFormat()
        {
            var __ret = new QtGui.QTextImageFormat.Internal();
            Internal.ToImageFormat_0(new IntPtr(&__ret), __Instance);
            return QTextImageFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns this format as a table cell format.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public QTextTableCellFormat ToTableCellFormat()
        {
            var __ret = new QtGui.QTextTableCellFormat.Internal();
            Internal.ToTableCellFormat_0(new IntPtr(&__ret), __Instance);
            return QTextTableCellFormat.__CreateInstance(__ret);
        }

        public static bool operator !=(QTextFormat __op, QTextFormat rhs)
        {
            return !(__op == rhs);
        }

        /// <summary>
        /// <para>Returns true if this text format is the same as the other text
        /// format.</para>
        /// </summary>
        public static bool operator ==(QTextFormat __op, QTextFormat rhs)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (__opNull || rhsNull)
                return __opNull && rhsNull;
            var arg0 = __op.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QTextFormat;
        }

        /// <summary>
        /// <para>Returns the index of the format object, or -1 if the format
        /// object is invalid.</para>
        /// <para>See also setObjectIndex().</para>
        /// <para></para>
        /// <para>Sets the format object's object index.</para>
        /// <para>See also objectIndex().</para>
        /// </summary>
        public int ObjectIndex
        {
            get
            {
                var __ret = Internal.ObjectIndex_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetObjectIndex_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the type of this format.</para>
        /// <para>See also FormatType.</para>
        /// </summary>
        public int Type
        {
            get
            {
                var __ret = Internal.Type_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of properties stored in the format.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public int PropertyCount
        {
            get
            {
                var __ret = Internal.PropertyCount_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QTextCharFormat class provides formatting information for
    /// characters in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The character format of text in a document specifies the visual
    /// properties of the text, as well as information about its role in a
    /// hypertext document.</para>
    /// <para>The font used can be set by supplying a font to the setFont()
    /// function, and each aspect of its appearance can be adjusted to give the
    /// desired effect. setFontFamily() and setFontPointSize() define the font's
    /// family (e.g. Times) and printed size; setFontWeight() and setFontItalic()
    /// provide control over the style of the font. setFontUnderline(),
    /// setFontOverline(), setFontStrikeOut(), and setFontFixedPitch() provide
    /// additional effects for text.</para>
    /// <para>The color is set with setForeground(). If the text is intended to
    /// be used as an anchor (for hyperlinks), this can be enabled with
    /// setAnchor(). The setAnchorHref() and setAnchorNames() functions are used to
    /// specify the information about the hyperlink's destination and the anchor's
    /// name.</para>
    /// <para></para>
    /// <para>See also QTextFormat, QTextBlockFormat, QTextTableFormat, and
    /// QTextListFormat.</para>
    /// </remarks>
    public unsafe partial class QTextCharFormat : QtGui.QTextFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormatC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormat7setFontERK5QFontNS_33FontPropertiesInheritanceBehaviorE")]
            internal static extern void SetFont_0(global::System.IntPtr instance, global::System.IntPtr font, QTextCharFormat.FontPropertiesInheritanceBehavior behavior);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormat17setUnderlineStyleENS_14UnderlineStyleE")]
            internal static extern void SetUnderlineStyle_0(global::System.IntPtr instance, QTextCharFormat.UnderlineStyle style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QTextCharFormat4fontEv")]
            internal static extern void Font_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextCharFormat7setFontERK5QFont")]
            internal static extern void SetFont_1(global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QTextCharFormat13fontUnderlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool FontUnderline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QTextCharFormat10anchorNameEv")]
            internal static extern void AnchorName_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the ways that adjacent characters can be
        /// vertically aligned.</para>
        /// </summary>
        public enum VerticalAlignment : uint
        {
            /// <summary>Adjacent characters are positioned in the standard way for text in the writing system in use.</summary>
            AlignNormal = 0,
            /// <summary>Characters are placed above the base line for normal text.</summary>
            AlignSuperScript = 1,
            /// <summary>Characters are placed below the base line for normal text.</summary>
            AlignSubScript = 2,
            /// <summary>The center of the object is vertically aligned with the base line. Currently, this is only implemented for inline objects.</summary>
            AlignMiddle = 3,
            /// <summary>The top edge of the object is vertically aligned with the base line.</summary>
            AlignTop = 4,
            /// <summary>The bottom edge of the object is vertically aligned with the base line.</summary>
            AlignBottom = 5,
            /// <summary>The base lines of the characters are aligned.</summary>
            AlignBaseline = 6
        }

        /// <summary>
        /// <para>This enum describes the different ways drawing underlined
        /// text.</para>
        /// <para>See also Qt::PenStyle.</para>
        /// </summary>
        public enum UnderlineStyle : uint
        {
            /// <summary>Text is draw without any underlining decoration.</summary>
            NoUnderline = 0,
            /// <summary>A line is drawn using Qt::SolidLine.</summary>
            SingleUnderline = 1,
            /// <summary>Dashes are drawn using Qt::DashLine.</summary>
            DashUnderline = 2,
            /// <summary>Dots are drawn using Qt::DotLine;</summary>
            DotLine = 3,
            /// <summary>Dashs and dots are drawn using Qt::DashDotLine.</summary>
            DashDotLine = 4,
            /// <summary>Underlines draw drawn using Qt::DashDotDotLine.</summary>
            DashDotDotLine = 5,
            /// <summary>The text is underlined using a wave shaped line.</summary>
            WaveUnderline = 6,
            /// <summary>The underline is drawn depending on the QStyle::SH_SpellCeckUnderlineStyle style hint of the QApplication style. By default this is mapped to WaveUnderline, on Mac OS X it is mapped to DashDotLine.</summary>
            SpellCheckUnderline = 7
        }

        /// <summary>
        /// <para>This enum specifies how the setFont() function should behave with
        /// respect to unset font properties.</para>
        /// <para>This enum was introduced or modified in  Qt 5.3.</para>
        /// <para>See also setFont().</para>
        /// </summary>
        public enum FontPropertiesInheritanceBehavior : uint
        {
            /// <summary>If a property is not explicitly set, do not change the text format's property value.</summary>
            FontPropertiesSpecifiedOnly = 0,
            /// <summary>If a property is not explicitly set, override the text format's property with a default value.</summary>
            FontPropertiesAll = 1
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextCharFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextCharFormat((QTextCharFormat.Internal*) native);
        }

        public static QTextCharFormat __CreateInstance(QTextCharFormat.Internal native)
        {
            return new QTextCharFormat(native);
        }

        private static QTextCharFormat.Internal* __CopyValue(QTextCharFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextCharFormat.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QTextCharFormat.Internal*) ret;
        }

        private QTextCharFormat(QTextCharFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextCharFormat(QTextCharFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new character format object.</para>
        /// </summary>
        public QTextCharFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextCharFormat(QTextFormat fmt)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Sets the text format's font.</para>
        /// <para>If behavior is QTextCharFormat::FontPropertiesAll, the font
        /// property that has not been explicitly set is treated like as it were set
        /// with default value; If behavior is QTextCharFormat::FontPropertiesAll, the
        /// font property that has not been explicitly set is ignored and the
        /// respective property value remains unchanged.</para>
        /// <para>This function was introduced in  Qt 5.3.</para>
        /// <para>See also font().</para>
        /// </summary>
        public void SetFont(QFont font, QTextCharFormat.FontPropertiesInheritanceBehavior behavior)
        {
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var arg1 = behavior;
            Internal.SetFont_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Sets the style of underlining the text to style.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also underlineStyle().</para>
        /// </summary>
        public void SetUnderlineStyle(QTextCharFormat.UnderlineStyle style)
        {
            var arg0 = style;
            Internal.SetUnderlineStyle_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns the font for this character format.</para>
        /// <para>See also setFont().</para>
        /// <para></para>
        /// <para>This is an overloaded function.</para>
        /// <para>Sets the text format's font.</para>
        /// <para>See also font().</para>
        /// </summary>
        public QFont Font
        {
            get
            {
                var __ret = new QtGui.QFont.Internal();
                Internal.Font_0(new IntPtr(&__ret), __Instance);
                return QFont.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFont_1(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if the text format's font is underlined; otherwise
        /// returns false.</para>
        /// <para>See also setFontUnderline() and font().</para>
        /// </summary>
        public bool FontUnderline
        {
            get
            {
                var __ret = Internal.FontUnderline_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This function is deprecated. Use anchorNames() instead.</para>
        /// <para>Returns the anchor name associated with this text format, or an
        /// empty string if none has been set. If the anchor name is set, text with
        /// this format can be the destination of a hypertext link.</para>
        /// <para>See also setAnchorName().</para>
        /// </summary>
        public string AnchorName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.AnchorName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    /// <summary>
    /// <para>The QTextBlockFormat class provides formatting information for
    /// blocks of text in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A document is composed of a list of blocks, represented by
    /// QTextBlock objects. Each block can contain an item of some kind, such as a
    /// paragraph of text, a table, a list, or an image. Every block has an
    /// associated QTextBlockFormat that specifies its characteristics.</para>
    /// <para>To cater for left-to-right and right-to-left languages you can
    /// set a block's direction with setDirection(). Paragraph alignment is set
    /// with setAlignment(). Margins are controlled by setTopMargin(),
    /// setBottomMargin(), setLeftMargin(), setRightMargin(). Overall indentation
    /// is set with setIndent(), the indentation of the first line with
    /// setTextIndent().</para>
    /// <para>Line spacing is set with setLineHeight() and retrieved via
    /// lineHeight() and lineHeightType(). The types of line spacing available are
    /// in the LineHeightTypes enum.</para>
    /// <para>Line breaking can be enabled and disabled with
    /// setNonBreakableLines().</para>
    /// <para>The brush used to paint the paragraph's background is set with
    /// setBackground(), and other aspects of the text's appearance can be
    /// customized by using the setProperty() function with the OutlinePen,
    /// ForegroundBrush, and BackgroundBrush QTextFormat::Property values.</para>
    /// <para>If a text block is part of a list, it can also have a list format
    /// that is accessible with the listFormat() function.</para>
    /// <para></para>
    /// <para>See also QTextBlock and QTextCharFormat.</para>
    /// </remarks>
    public unsafe partial class QTextBlockFormat : QtGui.QTextFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextBlockFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextBlockFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextBlockFormatC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextBlockFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QTextBlockFormat12tabPositionsEv")]
            internal static extern QList.Internal TabPositions_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextBlockFormat15setTabPositionsERK5QListIN11QTextOption3TabEE")]
            internal static extern void SetTabPositions_0(global::System.IntPtr instance, global::System.IntPtr tabs);
        }

        /// <summary>
        /// <para>This enum describes the various types of line spacing support
        /// paragraphs can have.</para>
        /// <para>This enum was introduced or modified in  Qt 4.8.</para>
        /// <para>See also lineHeight(), lineHeightType(), and
        /// setLineHeight().</para>
        /// </summary>
        public enum LineHeightTypes : uint
        {
            /// <summary>This is the default line height: single spacing.</summary>
            SingleHeight = 0,
            /// <summary>This sets the spacing proportional to the line (in percentage). For example, set to 200 for double spacing.</summary>
            ProportionalHeight = 1,
            /// <summary>This sets the line height to a fixed line height (in pixels).</summary>
            FixedHeight = 2,
            /// <summary>This sets the minimum line height (in pixels).</summary>
            MinimumHeight = 3,
            /// <summary>This adds the specified height between lines (in pixels).</summary>
            LineDistanceHeight = 4
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextBlockFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextBlockFormat((QTextBlockFormat.Internal*) native);
        }

        public static QTextBlockFormat __CreateInstance(QTextBlockFormat.Internal native)
        {
            return new QTextBlockFormat(native);
        }

        private static QTextBlockFormat.Internal* __CopyValue(QTextBlockFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextBlockFormat.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QTextBlockFormat.Internal*) ret;
        }

        private QTextBlockFormat(QTextBlockFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextBlockFormat(QTextBlockFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new QTextBlockFormat.</para>
        /// </summary>
        public QTextBlockFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextBlockFormat(QTextFormat fmt)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Returns a list of tab positions defined for the text
        /// block.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setTabPositions().</para>
        /// <para></para>
        /// <para>Sets the tab positions for the text block to those specified by
        /// tabs.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also tabPositions().</para>
        /// </summary>
        public System.Collections.Generic.IList<QTextOption.Tab> TabPositions
        {
            get
            {
                var __ret = Internal.TabPositions_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTextOption.Tab>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTextOption.Tab.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }

            set
            {
                var __qList = new QtCore.QList.Internal();
                var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
                __qlistDataData->alloc = value.Count;
                __qlistDataData->begin = 0;
                __qlistDataData->end = value.Count;
                fixed (void** __v = new void*[value.Count])
                {
                    __qlistDataData->array = __v;
                }

                for (int i = 0; i < value.Count; i++)
                {
                    __qlistDataData->array[i] = (void*) value[i].__Instance;
                }
                var arg0 = new global::System.IntPtr(&__qList);
                Internal.SetTabPositions_0(__Instance, arg0);
            }
        }
    }

    /// <summary>
    /// <para>The QTextListFormat class provides formatting information for
    /// lists in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A list is composed of one or more items, represented as text
    /// blocks. The list's format specifies the appearance of items in the list. In
    /// particular, it determines the indentation and the style of each
    /// item.</para>
    /// <para>The indentation of the items is an integer value that causes each
    /// item to be offset from the left margin by a certain amount. This value is
    /// read with indent() and set with setIndent().</para>
    /// <para>The style used to decorate each item is set with setStyle() and
    /// can be read with the style() function. The style controls the type of
    /// bullet points and numbering scheme used for items in the list. Note that
    /// lists that use the decimal numbering scheme begin counting at 1 rather than
    /// 0.</para>
    /// <para>Style properties can be set to further configure the appearance
    /// of list items; for example, the ListNumberPrefix and ListNumberSuffix
    /// properties can be used to customize the numbers used in an ordered list so
    /// that they appear as (1), (2), (3), etc.:</para>
    /// <para>QTextListFormat listFormat;</para>
    /// <para></para>
    /// <para>listFormat.setStyle(QTextListFormat::ListDecimal);</para>
    /// <para>listFormat.setNumberPrefix(&quot;(&quot;);</para>
    /// <para>listFormat.setNumberSuffix(&quot;)&quot;);</para>
    /// <para></para>
    /// <para>cursor.insertList(listFormat);</para>
    /// <para></para>
    /// <para>See also QTextList.</para>
    /// </remarks>
    public unsafe partial class QTextListFormat : QtGui.QTextFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextListFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextListFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextListFormatC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextListFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the symbols used to decorate list
        /// items:</para>
        /// </summary>
        public enum Style
        {
            /// <summary>a filled circle</summary>
            ListDisc = -1,
            /// <summary>an empty circle</summary>
            ListCircle = -2,
            /// <summary>a filled square</summary>
            ListSquare = -3,
            /// <summary>decimal values in ascending order</summary>
            ListDecimal = -4,
            /// <summary>lower case Latin characters in alphabetical order</summary>
            ListLowerAlpha = -5,
            /// <summary>upper case Latin characters in alphabetical order</summary>
            ListUpperAlpha = -6,
            /// <summary>lower case roman numerals (supports up to 4999 items only)</summary>
            ListLowerRoman = -7,
            /// <summary>upper case roman numerals (supports up to 4999 items only)</summary>
            ListUpperRoman = -8,
            ListStyleUndefined = 0
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextListFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextListFormat((QTextListFormat.Internal*) native);
        }

        public static QTextListFormat __CreateInstance(QTextListFormat.Internal native)
        {
            return new QTextListFormat(native);
        }

        private static QTextListFormat.Internal* __CopyValue(QTextListFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextListFormat.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QTextListFormat.Internal*) ret;
        }

        private QTextListFormat(QTextListFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextListFormat(QTextListFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new list format object.</para>
        /// </summary>
        public QTextListFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextListFormat(QTextFormat fmt)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QTextImageFormat class provides formatting information for
    /// images in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Inline images are represented by an object replacement character
    /// (0xFFFC in Unicode) which has an associated QTextImageFormat. The image
    /// format specifies a name with setName() that is used to locate the image.
    /// The size of the rectangle that the image will occupy is specified using
    /// setWidth() and setHeight().</para>
    /// <para>Images can be supplied in any format for which Qt has an image
    /// reader, so SVG drawings can be included alongside PNG, TIFF and other
    /// bitmap formats.</para>
    /// <para></para>
    /// <para>See also QImage and QImageReader.</para>
    /// </remarks>
    public unsafe partial class QTextImageFormat : QtGui.QTextCharFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextImageFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextImageFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextImageFormatC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextImageFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextImageFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextImageFormat((QTextImageFormat.Internal*) native);
        }

        public static QTextImageFormat __CreateInstance(QTextImageFormat.Internal native)
        {
            return new QTextImageFormat(native);
        }

        private static QTextImageFormat.Internal* __CopyValue(QTextImageFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextImageFormat.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextImageFormat.Internal*) ret;
        }

        private QTextImageFormat(QTextImageFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextImageFormat(QTextImageFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextCharFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Creates a new image format object.</para>
        /// </summary>
        public QTextImageFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextImageFormat(QTextFormat format)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QTextFrameFormat class provides formatting information for
    /// frames in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A text frame groups together one or more blocks of text,
    /// providing a layer of structure larger than the paragraph. The format of a
    /// frame specifies how it is rendered and positioned on the screen. It does
    /// not directly specify the behavior of the text formatting within, but
    /// provides constraints on the layout of its children.</para>
    /// <para>The frame format defines the width() and height() of the frame on
    /// the screen. Each frame can have a border() that surrounds its contents with
    /// a rectangular box. The border is surrounded by a margin() around the frame,
    /// and the contents of the frame are kept separate from the border by the
    /// frame's padding(). This scheme is similar to the box model used by
    /// Cascading Style Sheets for HTML pages.</para>
    /// <para>The position() of a frame is set using setPosition() and
    /// determines how it is located relative to the surrounding text.</para>
    /// <para>The validity of a QTextFrameFormat object can be determined with
    /// the isValid() function.</para>
    /// <para></para>
    /// <para>See also QTextFrame and QTextBlockFormat.</para>
    /// </remarks>
    public unsafe partial class QTextFrameFormat : QtGui.QTextFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextFrameFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextFrameFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextFrameFormatC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextFrameFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes how a frame is located relative to the
        /// surrounding text.</para>
        /// <para>See also position() and CssFloat.</para>
        /// </summary>
        public enum Position : uint
        {
            InFlow = 0,
            FloatLeft = 1,
            FloatRight = 2
        }

        /// <summary>
        /// <para>This enum describes different border styles for the text
        /// frame.</para>
        /// <para>This enum was introduced or modified in  Qt 4.3.</para>
        /// <para>See also borderStyle() and FrameBorderStyle.</para>
        /// </summary>
        public enum BorderStyle : uint
        {
            BorderStyle_None = 0,
            BorderStyle_Dotted = 1,
            BorderStyle_Dashed = 2,
            BorderStyle_Solid = 3,
            BorderStyle_Double = 4,
            BorderStyle_DotDash = 5,
            BorderStyle_DotDotDash = 6,
            BorderStyle_Groove = 7,
            BorderStyle_Ridge = 8,
            BorderStyle_Inset = 9,
            BorderStyle_Outset = 10
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextFrameFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextFrameFormat((QTextFrameFormat.Internal*) native);
        }

        public static QTextFrameFormat __CreateInstance(QTextFrameFormat.Internal native)
        {
            return new QTextFrameFormat(native);
        }

        private static QTextFrameFormat.Internal* __CopyValue(QTextFrameFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextFrameFormat.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QTextFrameFormat.Internal*) ret;
        }

        private QTextFrameFormat(QTextFrameFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextFrameFormat(QTextFrameFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a text frame format object with the default
        /// properties.</para>
        /// </summary>
        public QTextFrameFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextFrameFormat(QTextFormat fmt)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QTextTableFormat class provides formatting information for
    /// tables in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A table is a group of cells ordered into rows and columns. Each
    /// table contains at least one row and one column. Each cell contains a block.
    /// Tables in rich text documents are formatted using the properties defined in
    /// this class.</para>
    /// <para>Tables are horizontally justified within their parent frame
    /// according to the table's alignment. This can be read with the alignment()
    /// function and set with setAlignment().</para>
    /// <para>Cells within the table are separated by cell spacing. The number
    /// of pixels between cells is set with setCellSpacing() and read with
    /// cellSpacing(). The contents of each cell is surrounded by cell padding. The
    /// number of pixels between each cell edge and its contents is set with
    /// setCellPadding() and read with cellPadding().</para>
    /// <para>The table's background color can be read with the background()
    /// function, and can be specified with setBackground(). The background color
    /// of each cell can be set independently, and will control the color of the
    /// cell within the padded area.</para>
    /// <para>The table format also provides a way to constrain the widths of
    /// the columns in the table. Columns can be assigned a fixed width, a variable
    /// width, or a percentage of the available width (see QTextLength). The
    /// columns() function returns the number of columns with constraints, and the
    /// columnWidthConstraints() function returns the constraints defined for the
    /// table. These quantities can also be set by calling
    /// setColumnWidthConstraints() with a vector containing new constraints. If no
    /// constraints are required, clearColumnWidthConstraints() can be used to
    /// remove them.</para>
    /// <para></para>
    /// <para>See also QTextTable, QTextTableCell, and QTextLength.</para>
    /// </remarks>
    public unsafe partial class QTextTableFormat : QtGui.QTextFrameFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextTableFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextTableFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextTableFormatC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QTextTableFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextTableFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextTableFormat((QTextTableFormat.Internal*) native);
        }

        public static QTextTableFormat __CreateInstance(QTextTableFormat.Internal native)
        {
            return new QTextTableFormat(native);
        }

        private static QTextTableFormat.Internal* __CopyValue(QTextTableFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextTableFormat.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextTableFormat.Internal*) ret;
        }

        private QTextTableFormat(QTextTableFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextTableFormat(QTextTableFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextFrameFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new table format object.</para>
        /// </summary>
        public QTextTableFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextTableFormat(QTextFormat fmt)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QTextTableCellFormat class provides formatting information
    /// for table cells in a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The table cell format of a table cell in a document specifies the
    /// visual properties of the table cell.</para>
    /// <para>The padding properties of a table cell are controlled by
    /// setLeftPadding(), setRightPadding(), setTopPadding(), and
    /// setBottomPadding(). All the paddings can be set at once using
    /// setPadding().</para>
    /// <para></para>
    /// <para>See also QTextFormat, QTextBlockFormat, QTextTableFormat, and
    /// QTextCharFormat.</para>
    /// </remarks>
    public unsafe partial class QTextTableCellFormat : QtGui.QTextCharFormat, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [FieldOffset(4)]
            public int format_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextTableCellFormatC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextTableCellFormatC2ERK11QTextFormat")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextTableCellFormatC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextTableCellFormatD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextTableCellFormat __CreateInstance(global::System.IntPtr native)
        {
            return new QTextTableCellFormat((QTextTableCellFormat.Internal*) native);
        }

        public static QTextTableCellFormat __CreateInstance(QTextTableCellFormat.Internal native)
        {
            return new QTextTableCellFormat(native);
        }

        private static QTextTableCellFormat.Internal* __CopyValue(QTextTableCellFormat.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextTableCellFormat.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextTableCellFormat.Internal*) ret;
        }

        private QTextTableCellFormat(QTextTableCellFormat.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextTableCellFormat(QTextTableCellFormat.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextCharFormat.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Constructs a new table cell format object.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public QTextTableCellFormat()
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        protected QTextTableCellFormat(QTextFormat fmt)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(fmt, null) ? global::System.IntPtr.Zero : fmt.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QFontDatabase class provides information about the fonts
    /// available in the underlying window system.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The most common uses of this class are to query the database for
    /// the list of font families() and for the pointSizes() and styles() that are
    /// available for each family. An alternative to pointSizes() is smoothSizes()
    /// which returns the sizes at which a given family and style will look
    /// attractive.</para>
    /// <para>If the font family is available from two or more foundries the
    /// foundry name is included in the family name; for example: &quot;Helvetica
    /// [Adobe]&quot; and &quot;Helvetica [Cronyx]&quot;. When you specify a
    /// family, you can either use the old hyphenated &quot;foundry-family&quot;
    /// format or the bracketed &quot;family [foundry]&quot; format; for example:
    /// &quot;Cronyx-Helvetica&quot; or &quot;Helvetica [Cronyx]&quot;. If the
    /// family has a foundry it is always returned using the bracketed format, as
    /// is the case with the value returned by families().</para>
    /// <para>The font() function returns a QFont given a family, style and
    /// point size.</para>
    /// <para>A family and style combination can be checked to see if it is
    /// italic() or bold(), and to retrieve its weight(). Similarly we can call
    /// isBitmapScalable(), isSmoothlyScalable(), isScalable() and
    /// isFixedPitch().</para>
    /// <para>Use the styleString() to obtain a text version of a style.</para>
    /// <para>The QFontDatabase class also supports some static functions, for
    /// example, standardSizes(). You can retrieve the description of a writing
    /// system using writingSystemName(), and a sample of characters in a writing
    /// system with writingSystemSample().</para>
    /// <para>Example:</para>
    /// <para>    QFontDatabase database;</para>
    /// <para>    QTreeWidget fontTree;</para>
    /// <para>    fontTree.setColumnCount(2);</para>
    /// <para>    fontTree.setHeaderLabels(QStringList() &lt;&lt;
    /// &quot;Font&quot; &lt;&lt; &quot;Smooth Sizes&quot;);</para>
    /// <para></para>
    /// <para>    foreach (const QString &amp;family, database.families())
    /// {</para>
    /// <para>        QTreeWidgetItem *familyItem = new
    /// QTreeWidgetItem(&amp;fontTree);</para>
    /// <para>        familyItem-&gt;setText(0, family);</para>
    /// <para></para>
    /// <para>        foreach (const QString &amp;style,
    /// database.styles(family)) {</para>
    /// <para>            QTreeWidgetItem *styleItem = new
    /// QTreeWidgetItem(familyItem);</para>
    /// <para>            styleItem-&gt;setText(0, style);</para>
    /// <para></para>
    /// <para>            QString sizes;</para>
    /// <para>            foreach (int points, database.smoothSizes(family,
    /// style))</para>
    /// <para>                sizes += QString::number(points) + &quot;
    /// &quot;;</para>
    /// <para></para>
    /// <para>            styleItem-&gt;setText(1, sizes.trimmed());</para>
    /// <para>        }</para>
    /// <para>    }</para>
    /// <para>This example gets the list of font families, the list of styles
    /// for each family, and the point sizes that are available for each
    /// combination of family and style, displaying this information in a tree
    /// view.</para>
    /// <para></para>
    /// <para>See also QFont, QFontInfo, QFontMetrics, and Character Map
    /// Example.</para>
    /// </remarks>
    public unsafe partial class QFontDatabase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontDatabaseC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontDatabaseC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase14writingSystemsEv")]
            internal static extern QList.Internal WritingSystems_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase14writingSystemsERK7QString")]
            internal static extern QList.Internal WritingSystems_1(global::System.IntPtr instance, global::System.IntPtr family);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontDatabase10pointSizesERK7QStringS2_")]
            internal static extern QList.Internal PointSizes_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontDatabase11smoothSizesERK7QStringS2_")]
            internal static extern QList.Internal SmoothSizes_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontDatabase11styleStringERK5QFont")]
            internal static extern void StyleString_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QFontDatabase11styleStringERK9QFontInfo")]
            internal static extern void StyleString_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr fontInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase4fontERK7QStringS2_i")]
            internal static extern void Font_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style, int pointSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase16isBitmapScalableERK7QStringS2_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsBitmapScalable_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase18isSmoothlyScalableERK7QStringS2_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSmoothlyScalable_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase10isScalableERK7QStringS2_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsScalable_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase12isFixedPitchERK7QStringS2_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsFixedPitch_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase6italicERK7QStringS2_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Italic_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase4boldERK7QStringS2_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Bold_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase6weightERK7QStringS2_")]
            internal static extern int Weight_0(global::System.IntPtr instance, global::System.IntPtr family, global::System.IntPtr style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QFontDatabase9hasFamilyERK7QString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasFamily_0(global::System.IntPtr instance, global::System.IntPtr family);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase17writingSystemNameENS_13WritingSystemE")]
            internal static extern void WritingSystemName_0(global::System.IntPtr @return, QFontDatabase.WritingSystem writingSystem);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase19writingSystemSampleENS_13WritingSystemE")]
            internal static extern void WritingSystemSample_0(global::System.IntPtr @return, QFontDatabase.WritingSystem writingSystem);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase18addApplicationFontERK7QString")]
            internal static extern int AddApplicationFont_0(global::System.IntPtr fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase21removeApplicationFontEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RemoveApplicationFont_0(int id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase10systemFontENS_10SystemFontE")]
            internal static extern void systemFont_0(global::System.IntPtr @return, QFontDatabase.SystemFont type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase13standardSizesEv")]
            internal static extern QList.Internal StandardSizes_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase25removeAllApplicationFontsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RemoveAllApplicationFonts_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13QFontDatabase29supportsThreadedFontRenderingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SupportsThreadedFontRendering_0();
        }

        public enum WritingSystem : uint
        {
            Any = 0,
            Latin = 1,
            Greek = 2,
            Cyrillic = 3,
            Armenian = 4,
            Hebrew = 5,
            Arabic = 6,
            Syriac = 7,
            Thaana = 8,
            Devanagari = 9,
            Bengali = 10,
            Gurmukhi = 11,
            Gujarati = 12,
            Oriya = 13,
            Tamil = 14,
            Telugu = 15,
            Kannada = 16,
            Malayalam = 17,
            Sinhala = 18,
            Thai = 19,
            Lao = 20,
            Tibetan = 21,
            Myanmar = 22,
            Georgian = 23,
            Khmer = 24,
            SimplifiedChinese = 25,
            TraditionalChinese = 26,
            Japanese = 27,
            Korean = 28,
            Vietnamese = 29,
            Symbol = 30,
            /// <summary>(the same as Symbol)</summary>
            Other = 30,
            Ogham = 31,
            Runic = 32,
            Nko = 33,
            WritingSystemsCount = 34
        }

        /// <summary>
        /// <para>This enum was introduced or modified in  Qt 5.2.</para>
        /// </summary>
        public enum SystemFont : uint
        {
            /// <summary>The default system font.</summary>
            GeneralFont = 0,
            /// <summary>The fixed font that the system recommends.</summary>
            FixedFont = 1,
            /// <summary>The system standard font for titles.</summary>
            TitleFont = 2,
            /// <summary>The smallest readable system font.</summary>
            SmallestReadableFont = 3
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QFontDatabase __CreateInstance(global::System.IntPtr native)
        {
            return new QFontDatabase((QFontDatabase.Internal*) native);
        }

        public static QFontDatabase __CreateInstance(QFontDatabase.Internal native)
        {
            return new QFontDatabase(native);
        }

        private static QFontDatabase.Internal* __CopyValue(QFontDatabase.Internal native)
        {
            var ret = (QFontDatabase.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QFontDatabase(QFontDatabase.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QFontDatabase(QFontDatabase.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Creates a font database object.</para>
        /// </summary>
        public QFontDatabase()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns a sorted list of the available writing systems. This is
        /// list generated from information about all installed fonts on the
        /// system.</para>
        /// <para>See also families().</para>
        /// </summary>
        public System.Collections.Generic.IList<QFontDatabase.WritingSystem> WritingSystems()
        {
            var __ret = Internal.WritingSystems_0(__Instance);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QFontDatabase.WritingSystem>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(*(QFontDatabase.WritingSystem*) __qlistData.At(i));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns a sorted list of the writing systems supported by a given
        /// font family.</para>
        /// <para>See also families().</para>
        /// </summary>
        public System.Collections.Generic.IList<QFontDatabase.WritingSystem> WritingSystems(string family)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.WritingSystems_1(__Instance, arg0);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QFontDatabase.WritingSystem>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(*(QFontDatabase.WritingSystem*) __qlistData.At(i));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns a list of the point sizes available for the font that has
        /// family family and style styleName. The list may be empty.</para>
        /// <para>See also smoothSizes() and standardSizes().</para>
        /// </summary>
        public System.Collections.Generic.IList<int> PointSizes(string family, string style = "")
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.PointSizes_0(__Instance, arg0, arg1);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<int>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(*(int*) __qlistData.At(i));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns the point sizes of a font that has family family and
        /// style styleName that will look attractive. The list may be empty. For
        /// non-scalable fonts and bitmap scalable fonts, this function is equivalent
        /// to pointSizes().</para>
        /// <para>See also pointSizes() and standardSizes().</para>
        /// </summary>
        public System.Collections.Generic.IList<int> SmoothSizes(string family, string style)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.SmoothSizes_0(__Instance, arg0, arg1);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<int>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(*(int*) __qlistData.At(i));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns a string that describes the style of the font. For
        /// example, &quot;Bold Italic&quot;, &quot;Bold&quot;, &quot;Italic&quot; or
        /// &quot;Normal&quot;. An empty string may be returned.</para>
        /// </summary>
        public string StyleString(QFont font)
        {
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.StyleString_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns a string that describes the style of the fontInfo. For
        /// example, &quot;Bold Italic&quot;, &quot;Bold&quot;, &quot;Italic&quot; or
        /// &quot;Normal&quot;. An empty string may be returned.</para>
        /// </summary>
        public string StyleString(QFontInfo fontInfo)
        {
            var arg0 = ReferenceEquals(fontInfo, null) ? global::System.IntPtr.Zero : fontInfo.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.StyleString_1(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns a QFont object that has family family, style style and
        /// point size pointSize. If no matching font could be created, a QFont object
        /// that uses the application's default font is returned.</para>
        /// </summary>
        public QFont Font(string family, string style, int pointSize)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = new QtGui.QFont.Internal();
            Internal.Font_0(new IntPtr(&__ret), __Instance, arg0, arg1, pointSize);
            return QFont.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if the font that has family family and style style
        /// is a scalable bitmap font; otherwise returns false. Scaling a bitmap font
        /// usually produces an unattractive hardly readable result, because the pixels
        /// of the font are scaled. If you need to scale a bitmap font it is better to
        /// scale it to one of the fixed sizes returned by smoothSizes().</para>
        /// <para>See also isScalable() and isSmoothlyScalable().</para>
        /// </summary>
        public bool IsBitmapScalable(string family, string style = "")
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.IsBitmapScalable_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the font that has family family and style style
        /// is smoothly scalable; otherwise returns false. If this function returns
        /// true, it's safe to scale this font to any size, and the result will always
        /// look attractive.</para>
        /// <para>See also isScalable() and isBitmapScalable().</para>
        /// </summary>
        public bool IsSmoothlyScalable(string family, string style = "")
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.IsSmoothlyScalable_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the font that has family family and style style
        /// is scalable; otherwise returns false.</para>
        /// <para>See also isBitmapScalable() and isSmoothlyScalable().</para>
        /// </summary>
        public bool IsScalable(string family, string style = "")
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.IsScalable_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the font that has family family and style style
        /// is fixed pitch; otherwise returns false.</para>
        /// </summary>
        public bool IsFixedPitch(string family, string style = "")
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.IsFixedPitch_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the font that has family family and style style
        /// is italic; otherwise returns false.</para>
        /// <para>See also weight() and bold().</para>
        /// </summary>
        public bool Italic(string family, string style)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.Italic_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the font that has family family and style style
        /// is bold; otherwise returns false.</para>
        /// <para>See also italic() and weight().</para>
        /// </summary>
        public bool Bold(string family, string style)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.Bold_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the weight of the font that has family family and style
        /// style. If there is no such family and style combination, returns -1.</para>
        /// <para>See also italic() and bold().</para>
        /// </summary>
        public int Weight(string family, string style)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(style).ToPointer(), style.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            var __ret = Internal.Weight_0(__Instance, arg0, arg1);
            return __ret;
        }

        public bool HasFamily(string family)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(family).ToPointer(), family.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.HasFamily_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the names the writingSystem (e.g. for displaying to the
        /// user in a dialog).</para>
        /// </summary>
        public static string WritingSystemName(QFontDatabase.WritingSystem writingSystem)
        {
            var arg0 = writingSystem;
            var __ret = new QtCore.QString.Internal();
            Internal.WritingSystemName_0(new IntPtr(&__ret), arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns a string with sample characters from
        /// writingSystem.</para>
        /// </summary>
        public static string WritingSystemSample(QFontDatabase.WritingSystem writingSystem)
        {
            var arg0 = writingSystem;
            var __ret = new QtCore.QString.Internal();
            Internal.WritingSystemSample_0(new IntPtr(&__ret), arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Loads the font from the file specified by fileName and makes it
        /// available to the application. An ID is returned that can be used to remove
        /// the font again with removeApplicationFont() or to retrieve the list of
        /// family names contained in the font.</para>
        /// <para>The function returns -1 if the font could not be loaded.</para>
        /// <para>Currently only TrueType fonts, TrueType font collections, and
        /// OpenType fonts are supported.</para>
        /// <para>Note: Adding application fonts on Unix/X11 platforms without
        /// fontconfig is currently not supported.This function was introduced in  Qt
        /// 4.2.</para>
        /// <para>See also addApplicationFontFromData(), applicationFontFamilies(),
        /// and removeApplicationFont().</para>
        /// </summary>
        public static int AddApplicationFont(string fileName)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(fileName).ToPointer(), fileName.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = Internal.AddApplicationFont_0(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Removes the previously loaded application font identified by id.
        /// Returns true if unloading of the font succeeded; otherwise returns
        /// false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also removeAllApplicationFonts(), addApplicationFont(), and
        /// addApplicationFontFromData().</para>
        /// </summary>
        public static bool RemoveApplicationFont(int id)
        {
            var __ret = Internal.RemoveApplicationFont_0(id);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the most adequate font for a given type case for proper
        /// integration with the system's look and feel.</para>
        /// <para>This function was introduced in  Qt 5.2.</para>
        /// <para>See also QGuiApplication::font().</para>
        /// </summary>
        public static QFont systemFont(QFontDatabase.SystemFont type)
        {
            var arg0 = type;
            var __ret = new QtGui.QFont.Internal();
            Internal.systemFont_0(new IntPtr(&__ret), arg0);
            return QFont.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a list of standard font sizes.</para>
        /// <para>See also smoothSizes() and pointSizes().</para>
        /// </summary>
        public static System.Collections.Generic.IList<int> StandardSizes
        {
            get
            {
                var __ret = Internal.StandardSizes_0();
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<int>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(*(int*) __qlistData.At(i));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>Removes all application-local fonts previously added using
        /// addApplicationFont() and addApplicationFontFromData().</para>
        /// <para>Returns true if unloading of the fonts succeeded; otherwise
        /// returns false.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also removeApplicationFont(), addApplicationFont(), and
        /// addApplicationFontFromData().</para>
        /// </summary>
        public static bool RemoveAllApplicationFonts
        {
            get
            {
                var __ret = Internal.RemoveAllApplicationFonts_0();
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if font rendering is supported outside the GUI
        /// thread, false otherwise. In other words, a return value of false means that
        /// all QPainter::drawText() calls outside the GUI thread will not produce
        /// readable output.</para>
        /// <para>As of 5.0, always returns true.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also Painting In Threads.</para>
        /// </summary>
        public static bool SupportsThreadedFontRendering
        {
            get
            {
                var __ret = Internal.SupportsThreadedFontRendering_0();
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QRawFont class provides access to a single physical instance
    /// of a font.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Note: QRawFont is a low level class. For most purposes QFont is a
    /// more appropriate class.Most commonly, when presenting text in a user
    /// interface, the exact fonts used to render the characters is to some extent
    /// unknown. This can be the case for several reasons: For instance, the
    /// actual, physical fonts present on the target system could be unexpected to
    /// the developers, or the text could contain user selected styles, sizes or
    /// writing systems that are not supported by font chosen in the code.</para>
    /// <para>Therefore, Qt's QFont class really represents a query for fonts.
    /// When text is interpreted, Qt will do its best to match the text to the
    /// query, but depending on the support, different fonts can be used behind the
    /// scenes.</para>
    /// <para>For most use cases, this is both expected and necessary, as it
    /// minimizes the possibility of text in the user interface being
    /// undisplayable. In some cases, however, more direct control over the process
    /// might be useful. It is for these use cases the QRawFont class
    /// exists.</para>
    /// <para>A QRawFont object represents a single, physical instance of a
    /// given font in a given pixel size. I.e. in the typical case it represents a
    /// set of TrueType or OpenType font tables and uses a user specified pixel
    /// size to convert metrics into logical pixel units. It can be used in
    /// combination with the QGlyphRun class to draw specific glyph indexes at
    /// specific positions, and also have accessors to some relevant data in the
    /// physical font.</para>
    /// <para>QRawFont only provides support for the main font technologies:
    /// GDI and DirectWrite on Windows platforms, FreeType on Linux platforms and
    /// CoreText on Mac OS X. For other font back-ends, the APIs will be
    /// disabled.</para>
    /// <para>QRawFont can be constructed in a number of ways:</para>
    /// <para></para>
    /// <para>It can be constructed by calling QTextLayout::glyphs() or
    /// QTextFragment::glyphs(). The returned QGlyphs objects will contain QRawFont
    /// objects which represent the actual fonts used to render each portion of the
    /// text.</para>
    /// <para>It can be constructed by passing a QFont object to
    /// QRawFont::fromFont(). The function will return a QRawFont object
    /// representing the font that will be selected as response to the QFont query
    /// and the selected writing system.</para>
    /// <para>It can be constructed by passing a file name or QByteArray
    /// directly to the QRawFont constructor, or by calling loadFromFile() or
    /// loadFromData(). In this case, the font will not be registered in
    /// QFontDatabase, and it will not be available as part of regular font
    /// selection.</para>
    /// <para></para>
    /// <para>QRawFont is considered local to the thread in which it is
    /// constructed (either using a constructor, or by calling loadFromData() or
    /// loadFromFile()). The QRawFont cannot be moved to a different thread, but
    /// will have to be recreated in the thread in question.</para>
    /// <para>Note: For the requirement of caching glyph indexes and font
    /// selections for static text to avoid reshaping and relayouting in the inner
    /// loop of an application, a better choice is the QStaticText class, since it
    /// optimizes the memory cost of the cache and also provides the possibility of
    /// paint engine specific caches for an additional speed-up.</para>
    /// </remarks>
    public unsafe partial class QRawFont : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QRawFontC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QRawFontC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN8QRawFontD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFonteqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8QRawFont8fromFontERK5QFontN13QFontDatabase13WritingSystemE")]
            internal static extern void FromFont_0(global::System.IntPtr @return, global::System.IntPtr font, QFontDatabase.WritingSystem writingSystem);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont10familyNameEv")]
            internal static extern void FamilyName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont9styleNameEv")]
            internal static extern void StyleName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont5styleEv")]
            internal static extern QFont.Style Style_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont6weightEv")]
            internal static extern int Weight_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont17hintingPreferenceEv")]
            internal static extern QFont.HintingPreference HintingPreference_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK8QRawFont23supportedWritingSystemsEv")]
            internal static extern QList.Internal SupportedWritingSystems_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum represents the different ways a glyph can be rasterized
        /// in the function alphaMapForGlyph().</para>
        /// </summary>
        public enum AntialiasingType : uint
        {
            /// <summary>Will rasterize by measuring the coverage of the shape on whole pixels. The returned image contains the alpha values of each pixel based on the coverage of the glyph shape.</summary>
            PixelAntialiasing = 0,
            /// <summary>Will rasterize by measuring the coverage of each subpixel, returning a separate alpha value for each of the red, green and blue components of each pixel.</summary>
            SubPixelAntialiasing = 1
        }

        /// <summary>
        /// <para>This enum tells the function advancesForGlyphIndexes() how to
        /// calculate the advances.</para>
        /// <para>This enum was introduced or modified in  Qt 5.1.</para>
        /// </summary>
        public enum LayoutFlag : uint
        {
            /// <summary>Will calculate the advance for each glyph separately.</summary>
            SeparateAdvances = 0,
            /// <summary>Will apply kerning between adjacent glyphs. Note that OpenType GPOS based kerning is currently not supported.</summary>
            KernedAdvances = 1,
            /// <summary>Use design metrics instead of hinted metrics adjusted to the resolution of the paint device. Can be OR-ed with any of the options above.</summary>
            UseDesignMetrics = 2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QRawFont __CreateInstance(global::System.IntPtr native)
        {
            return new QRawFont((QRawFont.Internal*) native);
        }

        public static QRawFont __CreateInstance(QRawFont.Internal native)
        {
            return new QRawFont(native);
        }

        private static QRawFont.Internal* __CopyValue(QRawFont.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QRawFont.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QRawFont.Internal*) ret;
        }

        private QRawFont(QRawFont.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QRawFont(QRawFont.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an invalid QRawFont.</para>
        /// </summary>
        public QRawFont()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Creates a QRawFont which is a copy of other.</para>
        /// </summary>
        public QRawFont(QRawFont other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_3(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public static bool operator !=(QRawFont __op, QRawFont other)
        {
            return !(__op == other);
        }

        /// <summary>
        /// <para>Returns true if this QRawFont is equal to other. Otherwise,
        /// returns false.</para>
        /// </summary>
        public static bool operator ==(QRawFont __op, QRawFont other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QRawFont;
        }

        /// <summary>
        /// <para>Fetches the physical representation based on a font query. The
        /// physical font returned is the font that will be preferred by Qt in order to
        /// display text in the selected writingSystem.</para>
        /// <para>Warning: This function is potentially expensive and should not be
        /// called in performance sensitive code.</para>
        /// </summary>
        public static QRawFont FromFont(QFont font, QFontDatabase.WritingSystem writingSystem = QFontDatabase.WritingSystem.Any)
        {
            var arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var arg1 = writingSystem;
            var __ret = new QtGui.QRawFont.Internal();
            Internal.FromFont_0(new IntPtr(&__ret), arg0, arg1);
            return QRawFont.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if the QRawFont is valid and false otherwise.</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the family name of this QRawFont.</para>
        /// </summary>
        public string FamilyName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FamilyName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the style name of this QRawFont.</para>
        /// <para>See also QFont::styleName().</para>
        /// </summary>
        public string StyleName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.StyleName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the style of this QRawFont.</para>
        /// <para>See also QFont::style().</para>
        /// </summary>
        public QFont.Style Style
        {
            get
            {
                var __ret = Internal.Style_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the weight of this QRawFont.</para>
        /// <para>See also QFont::weight().</para>
        /// </summary>
        public int Weight
        {
            get
            {
                var __ret = Internal.Weight_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the hinting preference used to construct this
        /// QRawFont.</para>
        /// <para>See also QFont::hintingPreference().</para>
        /// </summary>
        public QFont.HintingPreference HintingPreference
        {
            get
            {
                var __ret = Internal.HintingPreference_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a list of writing systems supported by the font according
        /// to designer supplied information in the font file. Please note that this
        /// does not guarantee support for a specific unicode point in the font. You
        /// can use the supportsCharacter() to check support for a single, specific
        /// character.</para>
        /// <para>Note: The list is determined based on the unicode ranges and
        /// codepage ranges set in the font's OS/2 table and requires such a table to
        /// be present in the underlying font file.See also supportsCharacter().</para>
        /// </summary>
        public System.Collections.Generic.IList<QFontDatabase.WritingSystem> SupportedWritingSystems
        {
            get
            {
                var __ret = Internal.SupportedWritingSystems_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QFontDatabase.WritingSystem>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(*(QFontDatabase.WritingSystem*) __qlistData.At(i));
                }
                return __list;
            }
        }
    }

    /// <summary>
    /// <para>The QGlyphRun class provides direct access to the internal glyphs
    /// in a font.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>When Qt displays a string of text encoded in Unicode, it will
    /// first convert the Unicode points into a list of glyph indexes and a list of
    /// positions based on one or more fonts. The Unicode representation of the
    /// text and the QFont object will in this case serve as a convenient
    /// abstraction that hides the details of what actually takes place when
    /// displaying the text on-screen. For instance, by the time the text actually
    /// reaches the screen, it may be represented by a set of fonts in addition to
    /// the one specified by the user, e.g. in case the originally selected font
    /// did not support all the writing systems contained in the text.</para>
    /// <para>Under certain circumstances, it can be useful as an application
    /// developer to have more low-level control over which glyphs in a specific
    /// font are drawn to the screen. This could for instance be the case in
    /// applications that use an external font engine and text shaper together with
    /// Qt. QGlyphRun provides an interface to the raw data needed to get text on
    /// the screen. It contains a list of glyph indexes, a position for each glyph
    /// and a font.</para>
    /// <para>It is the user's responsibility to ensure that the selected font
    /// actually contains the provided glyph indexes.</para>
    /// <para>QTextLayout::glyphRuns() or QTextFragment::glyphRuns() can be
    /// used to convert unicode encoded text into a list of QGlyphRun objects, and
    /// QPainter::drawGlyphRun() can be used to draw the glyphs.</para>
    /// <para>Note: Please note that QRawFont is considered local to the thread
    /// in which it is constructed. This in turn means that a new QRawFont will
    /// have to be created and set on the QGlyphRun if it is moved to a different
    /// thread. If the QGlyphRun contains a reference to a QRawFont from a
    /// different thread than the current, it will not be possible to draw the
    /// glyphs using a QPainter, as the QRawFont is considered invalid and
    /// inaccessible in this case.</para>
    /// </remarks>
    public unsafe partial class QGlyphRun : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRunC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRunC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRunD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun5clearEv")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRuneqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun7setFlagENS_12GlyphRunFlagEb")]
            internal static extern void SetFlag_0(global::System.IntPtr instance, QGlyphRun.GlyphRunFlag flag, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun7rawFontEv")]
            internal static extern void RawFont_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun10setRawFontERK8QRawFont")]
            internal static extern void SetRawFont_0(global::System.IntPtr instance, global::System.IntPtr rawFont);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun8overlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Overline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun11setOverlineEb")]
            internal static extern void SetOverline_0(global::System.IntPtr instance, bool overline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun9underlineEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Underline_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun12setUnderlineEb")]
            internal static extern void SetUnderline_0(global::System.IntPtr instance, bool underline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun9strikeOutEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool StrikeOut_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun12setStrikeOutEb")]
            internal static extern void SetStrikeOut_0(global::System.IntPtr instance, bool strikeOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun13isRightToLeftEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RightToLeft_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun14setRightToLeftEb")]
            internal static extern void SetRightToLeft_0(global::System.IntPtr instance, bool on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun5flagsEv")]
            internal static extern QGlyphRun.GlyphRunFlag Flags_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QGlyphRun8setFlagsE6QFlagsINS_12GlyphRunFlagEE")]
            internal static extern void SetFlags_0(global::System.IntPtr instance, QGlyphRun.GlyphRunFlag flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QGlyphRun7isEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes flags that alter the way the run of glyphs
        /// might be presented or behave in a visual layout. The layout which generates
        /// the glyph runs can set these flags based on relevant internal data, to
        /// retain information needed to present the text as intended by the user of
        /// the layout.</para>
        /// <para>This enum was introduced or modified in  Qt 5.0.</para>
        /// </summary>
        [Flags]
        public enum GlyphRunFlag : uint
        {
            /// <summary>Indicates that the glyphs should be visualized together with an overline.</summary>
            Overline = 0x1,
            /// <summary>Indicates that the glyphs should be visualized together with an underline.</summary>
            Underline = 0x2,
            /// <summary>Indicates that the glyphs should be struck out visually.</summary>
            StrikeOut = 0x4,
            /// <summary>Indicates that the glyphs are ordered right to left. This can affect the positioning of other screen elements that are relative to the glyph run, such as an inline text object.</summary>
            RightToLeft = 0x8,
            /// <summary>Indicates that the glyph run splits a ligature glyph. This means that a ligature glyph is included in the run, but the characters represented by it corresponds only to part of that ligature. The glyph run's boundingRect() function can in this case be used to retrieve the area covered by glyphs that correspond to the characters represented by the glyph run. When visualizing the glyphs, care needs to be taken to clip to this bounding rect to ensure that only the corresponding part of the ligature is painted. In particular, this can be the case when retrieving a glyph run from a QTextLayout for a specific character range, e.g. when retrieving the selected area of a QTextLayout.</summary>
            SplitLigature = 0x10
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QGlyphRun __CreateInstance(global::System.IntPtr native)
        {
            return new QGlyphRun((QGlyphRun.Internal*) native);
        }

        public static QGlyphRun __CreateInstance(QGlyphRun.Internal native)
        {
            return new QGlyphRun(native);
        }

        private static QGlyphRun.Internal* __CopyValue(QGlyphRun.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QGlyphRun.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QGlyphRun.Internal*) ret;
        }

        private QGlyphRun(QGlyphRun.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QGlyphRun(QGlyphRun.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QGlyphRun object.</para>
        /// </summary>
        public QGlyphRun()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QGlyphRun object which is a copy of other.</para>
        /// </summary>
        public QGlyphRun(QGlyphRun other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_1(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Clears all data in the QGlyphRun object.</para>
        /// </summary>
        public void Clear()
        {
            Internal.Clear_0(__Instance);
        }

        public static bool operator !=(QGlyphRun __op, QGlyphRun other)
        {
            return !(__op == other);
        }

        /// <summary>
        /// <para>Compares other to this QGlyphRun object. Returns true if the list
        /// of glyph indexes, the list of positions and the font are all equal,
        /// otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QGlyphRun __op, QGlyphRun other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QGlyphRun;
        }

        /// <summary>
        /// <para>If enabled is true, then flag is enabled; otherwise, it is
        /// disabled.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also flags() and setFlags().</para>
        /// </summary>
        public void SetFlag(QGlyphRun.GlyphRunFlag flag, bool enabled = true)
        {
            var arg0 = flag;
            Internal.SetFlag_0(__Instance, arg0, enabled);
        }

        /// <summary>
        /// <para>Returns the font selected for this QGlyphRun object.</para>
        /// <para>See also setRawFont().</para>
        /// <para></para>
        /// <para>Sets the font in which to look up the glyph indexes to the
        /// rawFont specified.</para>
        /// <para>See also rawFont() and setGlyphIndexes().</para>
        /// </summary>
        public QRawFont RawFont
        {
            get
            {
                var __ret = new QtGui.QRawFont.Internal();
                Internal.RawFont_0(new IntPtr(&__ret), __Instance);
                return QRawFont.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetRawFont_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if this QGlyphRun should be painted with an overline
        /// decoration.</para>
        /// <para>See also setOverline() and flags().</para>
        /// <para></para>
        /// <para>Indicates that this QGlyphRun should be painted with an overline
        /// decoration if overline is true. Otherwise the QGlyphRun should be painted
        /// with no overline decoration.</para>
        /// <para>See also overline(), setFlag(), and setFlags().</para>
        /// </summary>
        public bool Overline
        {
            get
            {
                var __ret = Internal.Overline_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetOverline_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if this QGlyphRun should be painted with an
        /// underline decoration.</para>
        /// <para>See also setUnderline() and flags().</para>
        /// <para></para>
        /// <para>Indicates that this QGlyphRun should be painted with an underline
        /// decoration if underline is true. Otherwise the QGlyphRun should be painted
        /// with no underline decoration.</para>
        /// <para>See also underline(), setFlag(), and setFlags().</para>
        /// </summary>
        public bool Underline
        {
            get
            {
                var __ret = Internal.Underline_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetUnderline_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if this QGlyphRun should be painted with a strike
        /// out decoration.</para>
        /// <para>See also setStrikeOut() and flags().</para>
        /// <para></para>
        /// <para>Indicates that this QGlyphRun should be painted with an strike
        /// out decoration if strikeOut is true. Otherwise the QGlyphRun should be
        /// painted with no strike out decoration.</para>
        /// <para>See also strikeOut(), setFlag(), and setFlags().</para>
        /// </summary>
        public bool StrikeOut
        {
            get
            {
                var __ret = Internal.StrikeOut_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetStrikeOut_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if this QGlyphRun contains glyphs that are painted
        /// from the right to the left.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also setRightToLeft() and flags().</para>
        /// <para></para>
        /// <para>Indicates that this QGlyphRun contains glyphs that should be
        /// ordered from the right to left if rightToLeft is true. Otherwise the order
        /// of the glyphs is assumed to be left to right.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also isRightToLeft(), setFlag(), and setFlags().</para>
        /// </summary>
        public bool RightToLeft
        {
            get
            {
                var __ret = Internal.RightToLeft_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRightToLeft_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the flags set for this QGlyphRun.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also setFlags(), setFlag(), and setFlag().</para>
        /// <para></para>
        /// <para>Sets the flags of this QGlyphRun to flags.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also setFlag() and flags().</para>
        /// </summary>
        public QGlyphRun.GlyphRunFlag Flags
        {
            get
            {
                var __ret = Internal.Flags_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetFlags_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if the QGlyphRun does not contain any glyphs.</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                var __ret = Internal.IsEmpty_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QTextCursor class offers an API to access and modify
    /// QTextDocuments.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Text cursors are objects that are used to access and modify the
    /// contents and underlying structure of text documents via a programming
    /// interface that mimics the behavior of a cursor in a text editor.
    /// QTextCursor contains information about both the cursor's position within a
    /// QTextDocument and any selection that it has made.</para>
    /// <para>QTextCursor is modeled on the way a text cursor behaves in a text
    /// editor, providing a programmatic means of performing standard actions
    /// through the user interface. A document can be thought of as a single string
    /// of characters. The cursor's current position() then is always either
    /// between two consecutive characters in the string, or else before the very
    /// first character or after the very last character in the string. Documents
    /// can also contain tables, lists, images, and other objects in addition to
    /// text but, from the developer's point of view, the document can be treated
    /// as one long string. Some portions of that string can be considered to lie
    /// within particular blocks (e.g. paragraphs), or within a table's cell, or a
    /// list's item, or other structural elements. When we refer to &quot;current
    /// character&quot; we mean the character immediately before the cursor
    /// position() in the document. Similarly, the &quot;current block&quot; is the
    /// block that contains the cursor position().</para>
    /// <para>A QTextCursor also has an anchor() position. The text that is
    /// between the anchor() and the position() is the selection. If anchor() ==
    /// position() there is no selection.</para>
    /// <para>The cursor position can be changed programmatically using
    /// setPosition() and movePosition(); the latter can also be used to select
    /// text. For selections see selectionStart(), selectionEnd(), hasSelection(),
    /// clearSelection(), and removeSelectedText().</para>
    /// <para>If the position() is at the start of a block atBlockStart()
    /// returns true; and if it is at the end of a block atBlockEnd() returns true.
    /// The format of the current character is returned by charFormat(), and the
    /// format of the current block is returned by blockFormat().</para>
    /// <para>Formatting can be applied to the current text document using the
    /// setCharFormat(), mergeCharFormat(), setBlockFormat() and mergeBlockFormat()
    /// functions. The 'set' functions will replace the cursor's current character
    /// or block format, while the 'merge' functions add the given format
    /// properties to the cursor's current format. If the cursor has a selection
    /// the given format is applied to the current selection. Note that when only
    /// parts of a block is selected the block format is applied to the entire
    /// block. The text at the current character position can be turned into a list
    /// using createList().</para>
    /// <para>Deletions can be achieved using deleteChar(),
    /// deletePreviousChar(), and removeSelectedText().</para>
    /// <para>Text strings can be inserted into the document with the
    /// insertText() function, blocks (representing new paragraphs) can be inserted
    /// with insertBlock().</para>
    /// <para>Existing fragments of text can be inserted with insertFragment()
    /// but, if you want to insert pieces of text in various formats, it is usually
    /// still easier to use insertText() and supply a character format.</para>
    /// <para>Various types of higher-level structure can also be inserted into
    /// the document with the cursor:</para>
    /// <para></para>
    /// <para>Lists are ordered sequences of block elements that are decorated
    /// with bullet points or symbols. These are inserted in a specified format
    /// with insertList().</para>
    /// <para>Tables are inserted with the insertTable() function, and can be
    /// given an optional format. These contain an array of cells that can be
    /// traversed using the cursor.</para>
    /// <para>Inline images are inserted with insertImage(). The image to be
    /// used can be specified in an image format, or by name.</para>
    /// <para>Frames are inserted by calling insertFrame() with a specified
    /// format.</para>
    /// <para></para>
    /// <para>Actions can be grouped (i.e. treated as a single action for
    /// undo/redo) using beginEditBlock() and endEditBlock().</para>
    /// <para>Cursor movements are limited to valid cursor positions. In Latin
    /// writing this is between any two consecutive characters in the text, before
    /// the first character, or after the last character. In some other writing
    /// systems cursor movements are limited to &quot;clusters&quot; (e.g. a
    /// syllable in Devanagari, or a base letter plus diacritics). Functions such
    /// as movePosition() and deleteChar() limit cursor movement to these valid
    /// positions.</para>
    /// <para></para>
    /// <para>See also Rich Text Processing.</para>
    /// </remarks>
    public unsafe partial class QTextCursor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QSharedDataPointer.Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursorC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursorC2EP13QTextDocument")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursorC2EP10QTextFrame")]
            internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr frame);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursorC2ERK10QTextBlock")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursorC2ERKS_")]
            internal static extern void cctor_6(global::System.IntPtr instance, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11setPositionEiNS_8MoveModeE")]
            internal static extern void SetPosition_0(global::System.IntPtr instance, int pos, QTextCursor.MoveMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10insertTextERK7QString")]
            internal static extern void InsertText_0(global::System.IntPtr instance, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10insertTextERK7QStringRK15QTextCharFormat")]
            internal static extern void InsertText_1(global::System.IntPtr instance, global::System.IntPtr text, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor12movePositionENS_13MoveOperationENS_8MoveModeEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool MovePosition_0(global::System.IntPtr instance, QTextCursor.MoveOperation op, QTextCursor.MoveMode mode, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10deleteCharEv")]
            internal static extern void DeleteChar_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor18deletePreviousCharEv")]
            internal static extern void DeletePreviousChar_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor6selectENS_13SelectionTypeE")]
            internal static extern void Select_0(global::System.IntPtr instance, QTextCursor.SelectionType selection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor18removeSelectedTextEv")]
            internal static extern void RemoveSelectedText_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor14clearSelectionEv")]
            internal static extern void ClearSelection_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor18selectedTableCellsEPiS0_S0_S0_")]
            internal static extern void SelectedTableCells_0(global::System.IntPtr instance, int* firstRow, int* numRows, int* firstColumn, int* numColumns);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor15mergeCharFormatERK15QTextCharFormat")]
            internal static extern void MergeCharFormat_0(global::System.IntPtr instance, global::System.IntPtr modifier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor16mergeBlockFormatERK16QTextBlockFormat")]
            internal static extern void MergeBlockFormat_0(global::System.IntPtr instance, global::System.IntPtr modifier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor20mergeBlockCharFormatERK15QTextCharFormat")]
            internal static extern void MergeBlockCharFormat_0(global::System.IntPtr instance, global::System.IntPtr modifier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertBlockEv")]
            internal static extern void InsertBlock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertBlockERK16QTextBlockFormat")]
            internal static extern void InsertBlock_1(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertBlockERK16QTextBlockFormatRK15QTextCharFormat")]
            internal static extern void InsertBlock_2(global::System.IntPtr instance, global::System.IntPtr format, global::System.IntPtr charFormat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10insertListERK15QTextListFormat")]
            internal static extern global::System.IntPtr InsertList_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10insertListEN15QTextListFormat5StyleE")]
            internal static extern global::System.IntPtr InsertList_1(global::System.IntPtr instance, QTextListFormat.Style style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10createListERK15QTextListFormat")]
            internal static extern global::System.IntPtr CreateList_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10createListEN15QTextListFormat5StyleE")]
            internal static extern global::System.IntPtr CreateList_1(global::System.IntPtr instance, QTextListFormat.Style style);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertTableEiiRK16QTextTableFormat")]
            internal static extern global::System.IntPtr InsertTable_0(global::System.IntPtr instance, int rows, int cols, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertTableEii")]
            internal static extern global::System.IntPtr InsertTable_1(global::System.IntPtr instance, int rows, int cols);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertFrameERK16QTextFrameFormat")]
            internal static extern global::System.IntPtr InsertFrame_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor14insertFragmentERK21QTextDocumentFragment")]
            internal static extern void InsertFragment_0(global::System.IntPtr instance, global::System.IntPtr fragment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor10insertHtmlERK7QString")]
            internal static extern void InsertHtml_0(global::System.IntPtr instance, global::System.IntPtr html);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertImageERK16QTextImageFormatN16QTextFrameFormat8PositionE")]
            internal static extern void InsertImage_0(global::System.IntPtr instance, global::System.IntPtr format, QTextFrameFormat.Position alignment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertImageERK16QTextImageFormat")]
            internal static extern void InsertImage_1(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertImageERK7QString")]
            internal static extern void InsertImage_2(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor11insertImageERK6QImageRK7QString")]
            internal static extern void InsertImage_3(global::System.IntPtr instance, global::System.IntPtr image, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor14beginEditBlockEv")]
            internal static extern void BeginEditBlock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor21joinPreviousEditBlockEv")]
            internal static extern void JoinPreviousEditBlock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor12endEditBlockEv")]
            internal static extern void EndEditBlock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursorneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursorltERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursorleERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursoreqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursorgeERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursorgtERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorGreater_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor8isCopyOfERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsCopyOf_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor16visualNavigationEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool VisualNavigation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor19setVisualNavigationEb")]
            internal static extern void SetVisualNavigation_0(global::System.IntPtr instance, bool b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor17verticalMovementXEv")]
            internal static extern int VerticalMovementX_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor20setVerticalMovementXEi")]
            internal static extern void SetVerticalMovementX_0(global::System.IntPtr instance, int x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor20keepPositionOnInsertEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool KeepPositionOnInsert_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor23setKeepPositionOnInsertEb")]
            internal static extern void SetKeepPositionOnInsert_0(global::System.IntPtr instance, bool b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor10charFormatEv")]
            internal static extern void CharFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor13setCharFormatERK15QTextCharFormat")]
            internal static extern void SetCharFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor11blockFormatEv")]
            internal static extern void BlockFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor14setBlockFormatERK16QTextBlockFormat")]
            internal static extern void SetBlockFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor15blockCharFormatEv")]
            internal static extern void BlockCharFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextCursor18setBlockCharFormatERK15QTextCharFormat")]
            internal static extern void SetBlockCharFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor8positionEv")]
            internal static extern int Position_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor6isNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor15positionInBlockEv")]
            internal static extern int PositionInBlock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor6anchorEv")]
            internal static extern int Anchor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12hasSelectionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasSelection_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor19hasComplexSelectionEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasComplexSelection_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor14selectionStartEv")]
            internal static extern int SelectionStart_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12selectionEndEv")]
            internal static extern int SelectionEnd_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12selectedTextEv")]
            internal static extern void SelectedText_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor9selectionEv")]
            internal static extern void Selection_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor5blockEv")]
            internal static extern void Block_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12atBlockStartEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AtBlockStart_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor10atBlockEndEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AtBlockEnd_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor7atStartEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AtStart_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor5atEndEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AtEnd_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor11currentListEv")]
            internal static extern global::System.IntPtr CurrentList_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12currentTableEv")]
            internal static extern global::System.IntPtr CurrentTable_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12currentFrameEv")]
            internal static extern global::System.IntPtr CurrentFrame_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor11blockNumberEv")]
            internal static extern int BlockNumber_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor12columnNumberEv")]
            internal static extern int ColumnNumber_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextCursor8documentEv")]
            internal static extern global::System.IntPtr Document_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>If the anchor() is kept where it is and the position() is moved,
        /// the text in between will be selected.</para>
        /// </summary>
        public enum MoveMode : uint
        {
            /// <summary>Moves the anchor to the same position as the cursor itself.</summary>
            MoveAnchor = 0,
            /// <summary>Keeps the anchor where it is.</summary>
            KeepAnchor = 1
        }

        /// <summary>
        /// <para>See also movePosition().</para>
        /// </summary>
        public enum MoveOperation : uint
        {
            /// <summary>Keep the cursor where it is</summary>
            NoMove = 0,
            /// <summary>Move to the start of the document.</summary>
            Start = 1,
            /// <summary>Move up one line.</summary>
            Up = 2,
            /// <summary>Move to the start of the current line.</summary>
            StartOfLine = 3,
            /// <summary>Move to the start of the current block.</summary>
            StartOfBlock = 4,
            /// <summary>Move to the start of the current word.</summary>
            StartOfWord = 5,
            /// <summary>Move to the start of the previous block.</summary>
            PreviousBlock = 6,
            /// <summary>Move to the previous character.</summary>
            PreviousCharacter = 7,
            /// <summary>Move to the beginning of the previous word.</summary>
            PreviousWord = 8,
            /// <summary>Move left one character.</summary>
            Left = 9,
            /// <summary>Move left one word.</summary>
            WordLeft = 10,
            /// <summary>Move to the end of the document.</summary>
            End = 11,
            /// <summary>Move down one line.</summary>
            Down = 12,
            /// <summary>Move to the end of the current line.</summary>
            EndOfLine = 13,
            /// <summary>Move to the end of the current word.</summary>
            EndOfWord = 14,
            /// <summary>Move to the end of the current block.</summary>
            EndOfBlock = 15,
            /// <summary>Move to the beginning of the next block.</summary>
            NextBlock = 16,
            /// <summary>Move to the next character.</summary>
            NextCharacter = 17,
            /// <summary>Move to the next word.</summary>
            NextWord = 18,
            /// <summary>Move right one character.</summary>
            Right = 19,
            /// <summary>Move right one word.</summary>
            WordRight = 20,
            /// <summary>Move to the beginning of the next table cell inside the current table. If the current cell is the last cell in the row, the cursor will move to the first cell in the next row.</summary>
            NextCell = 21,
            /// <summary>Move to the beginning of the previous table cell inside the current table. If the current cell is the first cell in the row, the cursor will move to the last cell in the previous row.</summary>
            PreviousCell = 22,
            /// <summary>Move to the first new cell of the next row in the current table.</summary>
            NextRow = 23,
            /// <summary>Move to the last cell of the previous row in the current table.</summary>
            PreviousRow = 24
        }

        /// <summary>
        /// <para>This enum describes the types of selection that can be applied
        /// with the select() function.</para>
        /// </summary>
        public enum SelectionType : uint
        {
            /// <summary>Selects the word under the cursor. If the cursor is not positioned within a string of selectable characters, no text is selected.</summary>
            WordUnderCursor = 0,
            /// <summary>Selects the line of text under the cursor.</summary>
            LineUnderCursor = 1,
            /// <summary>Selects the block of text under the cursor.</summary>
            BlockUnderCursor = 2,
            /// <summary>Selects the entire document.</summary>
            Document = 3
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextCursor __CreateInstance(global::System.IntPtr native)
        {
            return new QTextCursor((QTextCursor.Internal*) native);
        }

        public static QTextCursor __CreateInstance(QTextCursor.Internal native)
        {
            return new QTextCursor(native);
        }

        private static QTextCursor.Internal* __CopyValue(QTextCursor.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QTextCursor.Internal.cctor_6(ret, new global::System.IntPtr(&native));
            return (QTextCursor.Internal*) ret;
        }

        private QTextCursor(QTextCursor.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextCursor(QTextCursor.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs a null cursor.</para>
        /// </summary>
        public QTextCursor()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a cursor pointing to the beginning of the
        /// document.</para>
        /// </summary>
        public QTextCursor(QTextDocument document)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a cursor pointing to the beginning of the
        /// frame.</para>
        /// </summary>
        public QTextCursor(QTextFrame frame)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(frame, null) ? global::System.IntPtr.Zero : frame.__Instance;
            Internal.ctor_3(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a cursor pointing to the beginning of the
        /// block.</para>
        /// </summary>
        public QTextCursor(QTextBlock block)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.ctor_4(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a new cursor that is a copy of cursor.</para>
        /// </summary>
        public QTextCursor(QTextCursor cursor)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            Internal.cctor_6(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Moves the cursor to the absolute position in the document
        /// specified by pos using a MoveMode specified by m. The cursor is positioned
        /// between characters.</para>
        /// <para>See also position(), movePosition(), and anchor().</para>
        /// </summary>
        public void SetPosition(int pos, QTextCursor.MoveMode mode = QTextCursor.MoveMode.MoveAnchor)
        {
            var arg1 = mode;
            Internal.SetPosition_0(__Instance, pos, arg1);
        }

        /// <summary>
        /// <para>Inserts text at the current position, using the current character
        /// format.</para>
        /// <para>If there is a selection, the selection is deleted and replaced by
        /// text, for example:</para>
        /// <para>cursor.clearSelection();</para>
        /// <para>cursor.movePosition(QTextCursor::NextWord,
        /// QTextCursor::KeepAnchor);</para>
        /// <para>cursor.insertText(&quot;Hello World&quot;);</para>
        /// <para>This clears any existing selection, selects the word at the
        /// cursor (i.e. from position() forward), and replaces the selection with the
        /// phrase &quot;Hello World&quot;.</para>
        /// <para>Any ASCII linefeed characters (\n) in the inserted text are
        /// transformed into unicode block separators, corresponding to insertBlock()
        /// calls.</para>
        /// <para>See also charFormat() and hasSelection().</para>
        /// </summary>
        public void InsertText(string text)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.InsertText_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Inserts text at the current position with the given
        /// format.</para>
        /// </summary>
        public void InsertText(string text, QTextCharFormat format)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.InsertText_1(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Moves the cursor by performing the given operation n times, using
        /// the specified mode, and returns true if all operations were completed
        /// successfully; otherwise returns false.</para>
        /// <para>For example, if this function is repeatedly used to seek to the
        /// end of the next word, it will eventually fail when the end of the document
        /// is reached.</para>
        /// <para>By default, the move operation is performed once (n = 1).</para>
        /// <para>If mode is KeepAnchor, the cursor selects the text it moves over.
        /// This is the same effect that the user achieves when they hold down the
        /// Shift key and move the cursor with the cursor keys.</para>
        /// <para>See also setVisualNavigation().</para>
        /// </summary>
        public bool MovePosition(QTextCursor.MoveOperation op, QTextCursor.MoveMode mode = QTextCursor.MoveMode.MoveAnchor, int n = 1)
        {
            var arg0 = op;
            var arg1 = mode;
            var __ret = Internal.MovePosition_0(__Instance, arg0, arg1, n);
            return __ret;
        }

        /// <summary>
        /// <para>If there is no selected text, deletes the character at the
        /// current cursor position; otherwise deletes the selected text.</para>
        /// <para>See also deletePreviousChar(), hasSelection(), and
        /// clearSelection().</para>
        /// </summary>
        public void DeleteChar()
        {
            Internal.DeleteChar_0(__Instance);
        }

        /// <summary>
        /// <para>If there is no selected text, deletes the character before the
        /// current cursor position; otherwise deletes the selected text.</para>
        /// <para>See also deleteChar(), hasSelection(), and
        /// clearSelection().</para>
        /// </summary>
        public void DeletePreviousChar()
        {
            Internal.DeletePreviousChar_0(__Instance);
        }

        /// <summary>
        /// <para>Selects text in the document according to the given
        /// selection.</para>
        /// </summary>
        public void Select(QTextCursor.SelectionType selection)
        {
            var arg0 = selection;
            Internal.Select_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>If there is a selection, its content is deleted; otherwise does
        /// nothing.</para>
        /// <para>See also hasSelection().</para>
        /// </summary>
        public void RemoveSelectedText()
        {
            Internal.RemoveSelectedText_0(__Instance);
        }

        /// <summary>
        /// <para>Clears the current selection by setting the anchor to the cursor
        /// position.</para>
        /// <para>Note that it does not delete the text of the selection.</para>
        /// <para>See also removeSelectedText() and hasSelection().</para>
        /// </summary>
        public void ClearSelection()
        {
            Internal.ClearSelection_0(__Instance);
        }

        /// <summary>
        /// <para>If the selection spans over table cells, firstRow is populated
        /// with the number of the first row in the selection, firstColumn with the
        /// number of the first column in the selection, and numRows and numColumns
        /// with the number of rows and columns in the selection. If the selection does
        /// not span any table cells the results are harmless but undefined.</para>
        /// </summary>
        public void SelectedTableCells(int* firstRow, int* numRows, int* firstColumn, int* numColumns)
        {
            var arg0 = firstRow;
            var arg1 = numRows;
            var arg2 = firstColumn;
            var arg3 = numColumns;
            Internal.SelectedTableCells_0(__Instance, arg0, arg1, arg2, arg3);
        }

        /// <summary>
        /// <para>Merges the cursor's current character format with the properties
        /// described by format modifier. If the cursor has a selection, this function
        /// applies all the properties set in modifier to all the character formats
        /// that are part of the selection.</para>
        /// <para>See also hasSelection() and setCharFormat().</para>
        /// </summary>
        public void MergeCharFormat(QTextCharFormat modifier)
        {
            var arg0 = ReferenceEquals(modifier, null) ? global::System.IntPtr.Zero : modifier.__Instance;
            Internal.MergeCharFormat_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Modifies the block format of the current block (or all blocks
        /// that are contained in the selection) with the block format specified by
        /// modifier.</para>
        /// <para>See also setBlockFormat() and blockFormat().</para>
        /// </summary>
        public void MergeBlockFormat(QTextBlockFormat modifier)
        {
            var arg0 = ReferenceEquals(modifier, null) ? global::System.IntPtr.Zero : modifier.__Instance;
            Internal.MergeBlockFormat_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Modifies the block char format of the current block (or all
        /// blocks that are contained in the selection) with the block format specified
        /// by modifier.</para>
        /// <para>See also setBlockCharFormat().</para>
        /// </summary>
        public void MergeBlockCharFormat(QTextCharFormat modifier)
        {
            var arg0 = ReferenceEquals(modifier, null) ? global::System.IntPtr.Zero : modifier.__Instance;
            Internal.MergeBlockCharFormat_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Inserts a new empty block at the cursor position() with the
        /// current blockFormat() and charFormat().</para>
        /// <para>See also setBlockFormat().</para>
        /// </summary>
        public void InsertBlock()
        {
            Internal.InsertBlock_0(__Instance);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Inserts a new empty block at the cursor position() with block
        /// format format and the current charFormat() as block char format.</para>
        /// <para>See also setBlockFormat().</para>
        /// </summary>
        public void InsertBlock(QTextBlockFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.InsertBlock_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Inserts a new empty block at the cursor position() with block
        /// format format and charFormat as block char format.</para>
        /// <para>See also setBlockFormat().</para>
        /// </summary>
        public void InsertBlock(QTextBlockFormat format, QTextCharFormat charFormat)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            var arg1 = ReferenceEquals(charFormat, null) ? global::System.IntPtr.Zero : charFormat.__Instance;
            Internal.InsertBlock_2(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Inserts a new block at the current position and makes it the
        /// first list item of a newly created list with the given format. Returns the
        /// created list.</para>
        /// <para>See also currentList(), createList(), and insertBlock().</para>
        /// </summary>
        public QTextList InsertList(QTextListFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            var __ret = Internal.InsertList_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Inserts a new block at the current position and makes it the
        /// first list item of a newly created list with the given style. Returns the
        /// created list.</para>
        /// <para>See also currentList(), createList(), and insertBlock().</para>
        /// </summary>
        public QTextList InsertList(QTextListFormat.Style style)
        {
            var arg0 = style;
            var __ret = Internal.InsertList_1(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates and returns a new list with the given format, and makes
        /// the current paragraph the cursor is in the first list item.</para>
        /// <para>See also insertList() and currentList().</para>
        /// </summary>
        public QTextList CreateList(QTextListFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            var __ret = Internal.CreateList_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates and returns a new list with the given style, making the
        /// cursor's current paragraph the first list item.</para>
        /// <para>The style to be used is defined by the QTextListFormat::Style
        /// enum.</para>
        /// <para>See also insertList() and currentList().</para>
        /// </summary>
        public QTextList CreateList(QTextListFormat.Style style)
        {
            var arg0 = style;
            var __ret = Internal.CreateList_1(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Creates a new table with the given number of rows and columns in
        /// the specified format, inserts it at the current cursor position() in the
        /// document, and returns the table object. The cursor is moved to the
        /// beginning of the first cell.</para>
        /// <para>There must be at least one row and one column in the
        /// table.</para>
        /// <para>See also currentTable().</para>
        /// </summary>
        public QTextTable InsertTable(int rows, int cols, QTextTableFormat format)
        {
            var arg2 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            var __ret = Internal.InsertTable_0(__Instance, rows, cols, arg2);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextTable.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Creates a new table with the given number of rows and columns,
        /// inserts it at the current cursor position() in the document, and returns
        /// the table object. The cursor is moved to the beginning of the first
        /// cell.</para>
        /// <para>There must be at least one row and one column in the
        /// table.</para>
        /// <para>See also currentTable().</para>
        /// </summary>
        public QTextTable InsertTable(int rows, int cols)
        {
            var __ret = Internal.InsertTable_1(__Instance, rows, cols);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextTable.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Inserts a frame with the given format at the current cursor
        /// position(), moves the cursor position() inside the frame, and returns the
        /// frame.</para>
        /// <para>If the cursor holds a selection, the whole selection is moved
        /// inside the frame.</para>
        /// <para>See also hasSelection().</para>
        /// </summary>
        public QTextFrame InsertFrame(QTextFrameFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            var __ret = Internal.InsertFrame_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextFrame.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Inserts the text fragment at the current position().</para>
        /// </summary>
        public void InsertFragment(QTextDocumentFragment fragment)
        {
            var arg0 = ReferenceEquals(fragment, null) ? global::System.IntPtr.Zero : fragment.__Instance;
            Internal.InsertFragment_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Inserts the text html at the current position(). The text is
        /// interpreted as HTML.</para>
        /// <para>Note: When using this function with a style sheet, the style
        /// sheet will only apply to the current block in the document. In order to
        /// apply a style sheet throughout a document, use
        /// QTextDocument::setDefaultStyleSheet() instead.This function was introduced
        /// in  Qt 4.2.</para>
        /// </summary>
        public void InsertHtml(string html)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(html).ToPointer(), html.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.InsertHtml_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Inserts the image defined by the given format at the cursor's
        /// current position with the specified alignment.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also position().</para>
        /// </summary>
        public void InsertImage(QTextImageFormat format, QTextFrameFormat.Position alignment)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            var arg1 = alignment;
            Internal.InsertImage_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Inserts the image defined by format at the current
        /// position().</para>
        /// </summary>
        public void InsertImage(QTextImageFormat format)
        {
            var arg0 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.InsertImage_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Convenience method for inserting the image with the given name at
        /// the current position().</para>
        /// <para>QImage img = ...</para>
        /// <para>textDocument-&gt;addResource(QTextDocument::ImageResource,
        /// QUrl(&quot;myimage&quot;), img);</para>
        /// <para>cursor.insertImage(&quot;myimage&quot;);</para>
        /// </summary>
        public void InsertImage(string name)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.InsertImage_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Convenience function for inserting the given image with an
        /// optional name at the current position().</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// </summary>
        public void InsertImage(QImage image, string name = "")
        {
            var arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(name).ToPointer(), name.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.InsertImage_3(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Indicates the start of a block of editing operations on the
        /// document that should appear as a single operation from an undo/redo point
        /// of view.</para>
        /// <para>For example:</para>
        /// <para>QTextCursor cursor(textDocument);</para>
        /// <para>cursor.beginEditBlock();</para>
        /// <para>cursor.insertText(&quot;Hello&quot;);</para>
        /// <para>cursor.insertText(&quot;World&quot;);</para>
        /// <para>cursor.endEditBlock();</para>
        /// <para></para>
        /// <para>textDocument-&gt;undo();</para>
        /// <para>The call to undo() will cause both insertions to be undone,
        /// causing both &quot;World&quot; and &quot;Hello&quot; to be removed.</para>
        /// <para>It is possible to nest calls to beginEditBlock and endEditBlock.
        /// The top-most pair will determine the scope of the undo/redo
        /// operation.</para>
        /// <para>See also endEditBlock().</para>
        /// </summary>
        public void BeginEditBlock()
        {
            Internal.BeginEditBlock_0(__Instance);
        }

        /// <summary>
        /// <para>Like beginEditBlock() indicates the start of a block of editing
        /// operations that should appear as a single operation for undo/redo. However
        /// unlike beginEditBlock() it does not start a new block but reverses the
        /// previous call to endEditBlock() and therefore makes following operations
        /// part of the previous edit block created.</para>
        /// <para>For example:</para>
        /// <para>QTextCursor cursor(textDocument);</para>
        /// <para>cursor.beginEditBlock();</para>
        /// <para>cursor.insertText(&quot;Hello&quot;);</para>
        /// <para>cursor.insertText(&quot;World&quot;);</para>
        /// <para>cursor.endEditBlock();</para>
        /// <para></para>
        /// <para>...</para>
        /// <para></para>
        /// <para>cursor.joinPreviousEditBlock();</para>
        /// <para>cursor.insertText(&quot;Hey&quot;);</para>
        /// <para>cursor.endEditBlock();</para>
        /// <para></para>
        /// <para>textDocument-&gt;undo();</para>
        /// <para>The call to undo() will cause all three insertions to be
        /// undone.</para>
        /// <para>See also beginEditBlock() and endEditBlock().</para>
        /// </summary>
        public void JoinPreviousEditBlock()
        {
            Internal.JoinPreviousEditBlock_0(__Instance);
        }

        /// <summary>
        /// <para>Indicates the end of a block of editing operations on the
        /// document that should appear as a single operation from an undo/redo point
        /// of view.</para>
        /// <para>See also beginEditBlock().</para>
        /// </summary>
        public void EndEditBlock()
        {
            Internal.EndEditBlock_0(__Instance);
        }

        /// <summary>
        /// <para>Returns true if the other cursor is at a different position in
        /// the document as this cursor; otherwise returns false.</para>
        /// </summary>
        public static bool operator !=(QTextCursor __op, QTextCursor rhs)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the other cursor is positioned later in the
        /// document than this cursor; otherwise returns false.</para>
        /// </summary>
        public static bool operator <(QTextCursor __op, QTextCursor rhs)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            var __ret = Internal.OperatorLess_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the other cursor is positioned later or at the
        /// same position in the document as this cursor; otherwise returns
        /// false.</para>
        /// </summary>
        public static bool operator <=(QTextCursor __op, QTextCursor rhs)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            var __ret = Internal.OperatorLessEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the other cursor is at the same position in the
        /// document as this cursor; otherwise returns false.</para>
        /// </summary>
        public static bool operator ==(QTextCursor __op, QTextCursor rhs)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (__opNull || rhsNull)
                return __opNull && rhsNull;
            var arg0 = __op.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QTextCursor;
        }

        /// <summary>
        /// <para>Returns true if the other cursor is positioned earlier or at the
        /// same position in the document as this cursor; otherwise returns
        /// false.</para>
        /// </summary>
        public static bool operator >=(QTextCursor __op, QTextCursor rhs)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the other cursor is positioned earlier in the
        /// document than this cursor; otherwise returns false.</para>
        /// </summary>
        public static bool operator >(QTextCursor __op, QTextCursor rhs)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            var __ret = Internal.OperatorGreater_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if this cursor and other are copies of each other,
        /// i.e. one of them was created as a copy of the other and neither has moved
        /// since. This is much stricter than equality.</para>
        /// <para>See also operator=() and operator==().</para>
        /// </summary>
        public bool IsCopyOf(QTextCursor other)
        {
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.IsCopyOf_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns true if the cursor does visual navigation; otherwise
        /// returns false.</para>
        /// <para>Visual navigation means skipping over hidden text paragraphs. The
        /// default is false.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setVisualNavigation() and movePosition().</para>
        /// <para></para>
        /// <para>Sets visual navigation to b.</para>
        /// <para>Visual navigation means skipping over hidden text paragraphs. The
        /// default is false.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also visualNavigation() and movePosition().</para>
        /// </summary>
        public bool VisualNavigation
        {
            get
            {
                var __ret = Internal.VisualNavigation_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetVisualNavigation_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the visual x position for vertical cursor
        /// movements.</para>
        /// <para>A value of -1 indicates no predefined x position. It will then be
        /// set automatically the next time the cursor moves up or down.</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also setVerticalMovementX().</para>
        /// <para></para>
        /// <para>Sets the visual x position for vertical cursor movements to
        /// x.</para>
        /// <para>The vertical movement x position is cleared automatically when
        /// the cursor moves horizontally, and kept unchanged when the cursor moves
        /// vertically. The mechanism allows the cursor to move up and down on a
        /// visually straight line with proportional fonts, and to gently
        /// &quot;jump&quot; over short lines.</para>
        /// <para>A value of -1 indicates no predefined x position. It will then be
        /// set automatically the next time the cursor moves up or down.</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also verticalMovementX().</para>
        /// </summary>
        public int VerticalMovementX
        {
            get
            {
                var __ret = Internal.VerticalMovementX_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetVerticalMovementX_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns whether the cursor should keep its current position when
        /// text gets inserted at the position of the cursor.</para>
        /// <para>The default is false;</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also setKeepPositionOnInsert().</para>
        /// <para></para>
        /// <para>Defines whether the cursor should keep its current position when
        /// text gets inserted at the current position of the cursor.</para>
        /// <para>If b is true, the cursor keeps its current position when text
        /// gets inserted at the positing of the cursor. If b is false, the cursor
        /// moves along with the inserted text.</para>
        /// <para>The default is false.</para>
        /// <para>Note that a cursor always moves when text is inserted before the
        /// current position of the cursor, and it always keeps its position when text
        /// is inserted after the current position of the cursor.</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also keepPositionOnInsert().</para>
        /// </summary>
        public bool KeepPositionOnInsert
        {
            get
            {
                var __ret = Internal.KeepPositionOnInsert_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetKeepPositionOnInsert_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the format of the character immediately before the cursor
        /// position(). If the cursor is positioned at the beginning of a text block
        /// that is not empty then the format of the character immediately after the
        /// cursor is returned.</para>
        /// <para>See also setCharFormat(), insertText(), and blockFormat().</para>
        /// <para></para>
        /// <para>Sets the cursor's current character format to the given format.
        /// If the cursor has a selection, the given format is applied to the current
        /// selection.</para>
        /// <para>See also charFormat(), hasSelection(), and
        /// mergeCharFormat().</para>
        /// </summary>
        public QTextCharFormat CharFormat
        {
            get
            {
                var __ret = new QtGui.QTextCharFormat.Internal();
                Internal.CharFormat_0(new IntPtr(&__ret), __Instance);
                return QTextCharFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetCharFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the block format of the block the cursor is in.</para>
        /// <para>See also setBlockFormat() and charFormat().</para>
        /// <para></para>
        /// <para>Sets the block format of the current block (or all blocks that
        /// are contained in the selection) to format.</para>
        /// <para>See also blockFormat() and mergeBlockFormat().</para>
        /// </summary>
        public QTextBlockFormat BlockFormat
        {
            get
            {
                var __ret = new QtGui.QTextBlockFormat.Internal();
                Internal.BlockFormat_0(new IntPtr(&__ret), __Instance);
                return QTextBlockFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBlockFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the block character format of the block the cursor is
        /// in.</para>
        /// <para>The block char format is the format used when inserting text at
        /// the beginning of an empty block.</para>
        /// <para>See also setBlockCharFormat().</para>
        /// <para></para>
        /// <para>Sets the block char format of the current block (or all blocks
        /// that are contained in the selection) to format.</para>
        /// <para>See also blockCharFormat().</para>
        /// </summary>
        public QTextCharFormat BlockCharFormat
        {
            get
            {
                var __ret = new QtGui.QTextCharFormat.Internal();
                Internal.BlockCharFormat_0(new IntPtr(&__ret), __Instance);
                return QTextCharFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetBlockCharFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the absolute position of the cursor within the document.
        /// The cursor is positioned between characters.</para>
        /// <para>See also setPosition(), movePosition(), anchor(), and
        /// positionInBlock().</para>
        /// </summary>
        public int Position
        {
            get
            {
                var __ret = Internal.Position_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor is null; otherwise returns false. A
        /// null cursor is created by the default constructor.</para>
        /// </summary>
        public bool IsNull
        {
            get
            {
                var __ret = Internal.IsNull_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the relative position of the cursor within the block. The
        /// cursor is positioned between characters.</para>
        /// <para>This is equivalent to position() - block().position().</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also position().</para>
        /// </summary>
        public int PositionInBlock
        {
            get
            {
                var __ret = Internal.PositionInBlock_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the anchor position; this is the same as position()
        /// unless there is a selection in which case position() marks one end of the
        /// selection and anchor() marks the other end. Just like the cursor position,
        /// the anchor position is between characters.</para>
        /// <para>See also position(), setPosition(), movePosition(),
        /// selectionStart(), and selectionEnd().</para>
        /// </summary>
        public int Anchor
        {
            get
            {
                var __ret = Internal.Anchor_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor contains a selection; otherwise
        /// returns false.</para>
        /// </summary>
        public bool HasSelection
        {
            get
            {
                var __ret = Internal.HasSelection_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor contains a selection that is not
        /// simply a range from selectionStart() to selectionEnd(); otherwise returns
        /// false.</para>
        /// <para>Complex selections are ones that span at least two cells in a
        /// table; their extent is specified by selectedTableCells().</para>
        /// </summary>
        public bool HasComplexSelection
        {
            get
            {
                var __ret = Internal.HasComplexSelection_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the start of the selection or position() if the cursor
        /// doesn't have a selection.</para>
        /// <para>See also selectionEnd(), position(), and anchor().</para>
        /// </summary>
        public int SelectionStart
        {
            get
            {
                var __ret = Internal.SelectionStart_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the end of the selection or position() if the cursor
        /// doesn't have a selection.</para>
        /// <para>See also selectionStart(), position(), and anchor().</para>
        /// </summary>
        public int SelectionEnd
        {
            get
            {
                var __ret = Internal.SelectionEnd_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the current selection's text (which may be empty). This
        /// only returns the text, with no rich text formatting information. If you
        /// want a document fragment (i.e. formatted rich text) use selection()
        /// instead.</para>
        /// <para>Note: If the selection obtained from an editor spans a line
        /// break, the text will contain a Unicode U+2029 paragraph separator character
        /// instead of a newline \n character. Use QString::replace() to replace these
        /// characters with newlines.</para>
        /// <para></para>
        /// <para>QTextDocumentFragment QTextCursor::selection() const</para>
        /// <para>Returns the current selection (which may be empty) with all its
        /// formatting information. If you just want the selected text (i.e. plain
        /// text) use selectedText() instead.</para>
        /// <para>Note: Unlike QTextDocumentFragment::toPlainText(), selectedText()
        /// may include special unicode characters such as
        /// QChar::ParagraphSeparator.See also
        /// QTextDocumentFragment::toPlainText().</para>
        /// </summary>
        public string SelectedText
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.SelectedText_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the current selection (which may be empty) with all its
        /// formatting information. If you just want the selected text (i.e. plain
        /// text) use selectedText() instead.</para>
        /// <para>Note: Unlike QTextDocumentFragment::toPlainText(), selectedText()
        /// may include special unicode characters such as
        /// QChar::ParagraphSeparator.See also
        /// QTextDocumentFragment::toPlainText().</para>
        /// </summary>
        public QTextDocumentFragment Selection
        {
            get
            {
                var __ret = new QtGui.QTextDocumentFragment.Internal();
                Internal.Selection_0(new IntPtr(&__ret), __Instance);
                return QTextDocumentFragment.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the block that contains the cursor.</para>
        /// </summary>
        public QTextBlock Block
        {
            get
            {
                var __ret = new QtGui.QTextBlock.Internal();
                Internal.Block_0(new IntPtr(&__ret), __Instance);
                return QTextBlock.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor is at the start of a block; otherwise
        /// returns false.</para>
        /// <para>See also atBlockEnd() and atStart().</para>
        /// </summary>
        public bool AtBlockStart
        {
            get
            {
                var __ret = Internal.AtBlockStart_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor is at the end of a block; otherwise
        /// returns false.</para>
        /// <para>See also atBlockStart() and atEnd().</para>
        /// </summary>
        public bool AtBlockEnd
        {
            get
            {
                var __ret = Internal.AtBlockEnd_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor is at the start of the document;
        /// otherwise returns false.</para>
        /// <para>See also atBlockStart() and atEnd().</para>
        /// </summary>
        public bool AtStart
        {
            get
            {
                var __ret = Internal.AtStart_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if the cursor is at the end of the document;
        /// otherwise returns false.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also atStart() and atBlockEnd().</para>
        /// </summary>
        public bool AtEnd
        {
            get
            {
                var __ret = Internal.AtEnd_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the current list if the cursor position() is inside a
        /// block that is part of a list; otherwise returns 0.</para>
        /// <para>See also insertList() and createList().</para>
        /// </summary>
        public QTextList CurrentList
        {
            get
            {
                var __ret = Internal.CurrentList_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextList.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the current table if the cursor position()
        /// is inside a block that is part of a table; otherwise returns 0.</para>
        /// <para>See also insertTable().</para>
        /// </summary>
        public QTextTable CurrentTable
        {
            get
            {
                var __ret = Internal.CurrentTable_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextTable.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the current frame. Returns 0 if the cursor
        /// is invalid.</para>
        /// <para>See also insertFrame().</para>
        /// </summary>
        public QTextFrame CurrentFrame
        {
            get
            {
                var __ret = Internal.CurrentFrame_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextFrame.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the number of the block the cursor is in, or 0 if the
        /// cursor is invalid.</para>
        /// <para>Note that this function only makes sense in documents without
        /// complex objects such as tables or frames.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public int BlockNumber
        {
            get
            {
                var __ret = Internal.BlockNumber_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the position of the cursor within its containing
        /// line.</para>
        /// <para>Note that this is the column number relative to a wrapped line,
        /// not relative to the block (i.e. the paragraph).</para>
        /// <para>You probably want to call positionInBlock() instead.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also positionInBlock().</para>
        /// </summary>
        public int ColumnNumber
        {
            get
            {
                var __ret = Internal.ColumnNumber_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the document this cursor is associated with.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// </summary>
        public QTextDocument Document
        {
            get
            {
                var __ret = Internal.Document_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextDocument.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QTextInlineObject class represents an inline object in a
    /// QAbstractTextDocumentLayout and its implementations.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Normally, you do not need to create a QTextInlineObject. It is
    /// used by QAbstractTextDocumentLayout to handle inline objects when
    /// implementing a custom layout.</para>
    /// <para>The inline object has various attributes that can be set, for
    /// example using, setWidth(), setAscent(), and setDescent(). The rectangle it
    /// occupies is given by rect(), and its direction by textDirection(). Its
    /// position in the text layout is given by textPosition(), and its format is
    /// given by format().</para>
    /// </remarks>
    public unsafe partial class QTextInlineObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public int itm;

            [FieldOffset(4)]
            public global::System.IntPtr eng;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QTextInlineObjectC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QTextInlineObject12textPositionEv")]
            internal static extern int TextPosition_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QTextInlineObject11formatIndexEv")]
            internal static extern int FormatIndex_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK17QTextInlineObject6formatEv")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextInlineObject __CreateInstance(global::System.IntPtr native)
        {
            return new QTextInlineObject((QTextInlineObject.Internal*) native);
        }

        public static QTextInlineObject __CreateInstance(QTextInlineObject.Internal native)
        {
            return new QTextInlineObject(native);
        }

        private static QTextInlineObject.Internal* __CopyValue(QTextInlineObject.Internal native)
        {
            var ret = (QTextInlineObject.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QTextInlineObject(QTextInlineObject.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextInlineObject(QTextInlineObject.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>The position of the inline object within the text layout.</para>
        /// </summary>
        public int TextPosition
        {
            get
            {
                var __ret = Internal.TextPosition_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns an integer describing the format of the inline object
        /// within the text layout.</para>
        /// </summary>
        public int FormatIndex
        {
            get
            {
                var __ret = Internal.FormatIndex_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns format of the inline object within the text
        /// layout.</para>
        /// </summary>
        public QTextFormat Format
        {
            get
            {
                var __ret = new QtGui.QTextFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QTextFormat.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QTextLayout class is used to lay out and render text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>It offers many features expected from a modern text layout
    /// engine, including Unicode compliant rendering, line breaking and handling
    /// of cursor positioning. It can also produce and render device independent
    /// layout, something that is important for WYSIWYG applications.</para>
    /// <para>The class has a rather low level API and unless you intend to
    /// implement your own text rendering for some specialized widget, you probably
    /// won't need to use it directly.</para>
    /// <para>QTextLayout can be used with both plain and rich text.</para>
    /// <para>QTextLayout can be used to create a sequence of QTextLine
    /// instances with given widths and can position them independently on the
    /// screen. Once the layout is done, these lines can be drawn on a paint
    /// device.</para>
    /// <para>The text to be laid out can be provided in the constructor or set
    /// with setText().</para>
    /// <para>The layout can be seen as a sequence of QTextLine objects; use
    /// createLine() to create a QTextLine instance, and lineAt() or
    /// lineForTextPosition() to retrieve created lines.</para>
    /// <para>Here is a code snippet that demonstrates the layout phase:</para>
    /// <para>int leading = fontMetrics.leading();</para>
    /// <para>qreal height = 0;</para>
    /// <para>textLayout.setCacheEnabled(true);</para>
    /// <para>textLayout.beginLayout();</para>
    /// <para>while (1) {</para>
    /// <para>    QTextLine line = textLayout.createLine();</para>
    /// <para>    if (!line.isValid())</para>
    /// <para>        break;</para>
    /// <para></para>
    /// <para>    line.setLineWidth(lineWidth);</para>
    /// <para>    height += leading;</para>
    /// <para>    line.setPosition(QPointF(0, height));</para>
    /// <para>    height += line.height();</para>
    /// <para>}</para>
    /// <para>textLayout.endLayout();</para>
    /// <para>The text can then be rendered by calling the layout's draw()
    /// function:</para>
    /// <para>QPainter painter(this);</para>
    /// <para>textLayout.draw(&amp;painter, QPoint(0, 0));</para>
    /// <para>For a given position in the text you can find a valid cursor
    /// position with isValidCursorPosition(), nextCursorPosition(), and
    /// previousCursorPosition().</para>
    /// <para>The QTextLayout itself can be positioned with setPosition(); it
    /// has a boundingRect(), and a minimumWidth() and a maximumWidth().</para>
    /// <para></para>
    /// <para>See also QStaticText.</para>
    /// </remarks>
    public unsafe partial class QTextLayout : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayoutC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayoutC2ERK7QString")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayoutC2ERK7QStringRK5QFontP12QPaintDevice")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr text, global::System.IntPtr font, global::System.IntPtr paintdevice);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayoutC2ERK10QTextBlock")]
            internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayoutC2ERKS_")]
            internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayoutD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout10setRawFontERK8QRawFont")]
            internal static extern void SetRawFont_0(global::System.IntPtr instance, global::System.IntPtr rawFont);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout14setPreeditAreaEiRK7QString")]
            internal static extern void SetPreeditArea_0(global::System.IntPtr instance, int position, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout19preeditAreaPositionEv")]
            internal static extern int PreeditAreaPosition_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout15preeditAreaTextEv")]
            internal static extern void PreeditAreaText_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout22clearAdditionalFormatsEv")]
            internal static extern void ClearAdditionalFormats_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout11beginLayoutEv")]
            internal static extern void BeginLayout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout9endLayoutEv")]
            internal static extern void EndLayout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout11clearLayoutEv")]
            internal static extern void ClearLayout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout10createLineEv")]
            internal static extern QTextLine.Internal CreateLine_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout6lineAtEi")]
            internal static extern QTextLine.Internal LineAt_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout19lineForTextPositionEi")]
            internal static extern QTextLine.Internal LineForTextPosition_0(global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout21isValidCursorPositionEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValidCursorPosition_0(global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout18nextCursorPositionEiNS_10CursorModeE")]
            internal static extern int NextCursorPosition_0(global::System.IntPtr instance, int oldPos, QTextLayout.CursorMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout22previousCursorPositionEiNS_10CursorModeE")]
            internal static extern int PreviousCursorPosition_0(global::System.IntPtr instance, int oldPos, QTextLayout.CursorMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout18leftCursorPositionEi")]
            internal static extern int LeftCursorPosition_0(global::System.IntPtr instance, int oldPos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout19rightCursorPositionEi")]
            internal static extern int RightCursorPosition_0(global::System.IntPtr instance, int oldPos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout9glyphRunsEii")]
            internal static extern QList.Internal GlyphRuns_0(global::System.IntPtr instance, int from, int length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout8setFlagsEi")]
            internal static extern void SetFlags_0(global::System.IntPtr instance, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout4fontEv")]
            internal static extern void Font_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout7setFontERK5QFont")]
            internal static extern void SetFont_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout4textEv")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout7setTextERK7QString")]
            internal static extern void SetText_0(global::System.IntPtr instance, global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout10textOptionEv")]
            internal static extern global::System.IntPtr TextOption_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout13setTextOptionERK11QTextOption")]
            internal static extern void SetTextOption_0(global::System.IntPtr instance, global::System.IntPtr option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout17additionalFormatsEv")]
            internal static extern QList.Internal AdditionalFormats_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout20setAdditionalFormatsERK5QListINS_11FormatRangeEE")]
            internal static extern void SetAdditionalFormats_0(global::System.IntPtr instance, global::System.IntPtr overrides);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout12cacheEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CacheEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextLayout15setCacheEnabledEb")]
            internal static extern void SetCacheEnabled_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextLayout9lineCountEv")]
            internal static extern int LineCount_0(global::System.IntPtr instance);
        }

        public enum CursorMode : uint
        {
            SkipCharacters = 0,
            SkipWords = 1
        }

        public unsafe partial class FormatRange : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public int start;

                [FieldOffset(4)]
                public int length;

                [FieldOffset(8)]
                public QTextCharFormat.Internal format;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTextLayout11FormatRangeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN11QTextLayout11FormatRangeD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static FormatRange __CreateInstance(global::System.IntPtr native)
            {
                return new FormatRange((FormatRange.Internal*) native);
            }

            public static FormatRange __CreateInstance(FormatRange.Internal native)
            {
                return new FormatRange(native);
            }

            private static FormatRange.Internal* __CopyValue(FormatRange.Internal native)
            {
                var ret = Marshal.AllocHGlobal(16);
                QtGui.QTextLayout.FormatRange.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                return (FormatRange.Internal*) ret;
            }

            private FormatRange(FormatRange.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected FormatRange(FormatRange.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public int Start
            {
                get
                {
                    return ((Internal*) __Instance)->start;
                }

                set
                {
                    ((Internal*) __Instance)->start = value;
                }
            }

            public int Length
            {
                get
                {
                    return ((Internal*) __Instance)->length;
                }

                set
                {
                    ((Internal*) __Instance)->length = value;
                }
            }

            public QTextCharFormat Format
            {
                get
                {
                    return QTextCharFormat.__CreateInstance(((Internal*) __Instance)->format);
                }

                set
                {
                    ((Internal*) __Instance)->format = ReferenceEquals(value, null) ? new QTextCharFormat.Internal() : *(QTextCharFormat.Internal*) (value.__Instance);
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextLayout __CreateInstance(global::System.IntPtr native)
        {
            return new QTextLayout((QTextLayout.Internal*) native);
        }

        public static QTextLayout __CreateInstance(QTextLayout.Internal native)
        {
            return new QTextLayout(native);
        }

        private static QTextLayout.Internal* __CopyValue(QTextLayout.Internal native)
        {
            var ret = (QTextLayout.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QTextLayout(QTextLayout.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextLayout(QTextLayout.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty text layout.</para>
        /// <para>See also setText().</para>
        /// </summary>
        public QTextLayout()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a text layout to lay out the given text.</para>
        /// </summary>
        public QTextLayout(string text)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a text layout to lay out the given text with the
        /// specified font.</para>
        /// <para>All the metric and layout calculations will be done in terms of
        /// the paint device, paintdevice. If paintdevice is 0 the calculations will be
        /// done in screen metrics.</para>
        /// </summary>
        public QTextLayout(string text, QFont font, QPaintDevice paintdevice = null)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var arg2 = ReferenceEquals(paintdevice, null) ? global::System.IntPtr.Zero : paintdevice.__Instance;
            Internal.ctor_2(__Instance, arg0, arg1, arg2);
        }

        public QTextLayout(QTextBlock b)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(b, null) ? global::System.IntPtr.Zero : b.__Instance;
            Internal.ctor_3(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public void SetRawFont(QRawFont rawFont)
        {
            var arg0 = ReferenceEquals(rawFont, null) ? global::System.IntPtr.Zero : rawFont.__Instance;
            Internal.SetRawFont_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Sets the position and text of the area in the layout that is
        /// processed before editing occurs. The layout is invalidated and must be laid
        /// out again.</para>
        /// <para>See also preeditAreaPosition() and preeditAreaText().</para>
        /// </summary>
        public void SetPreeditArea(int position, string text)
        {
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.SetPreeditArea_0(__Instance, position, arg1);
        }

        /// <summary>
        /// <para>Returns the position of the area in the text layout that will be
        /// processed before editing occurs.</para>
        /// <para>See also preeditAreaText().</para>
        /// </summary>
        public int PreeditAreaPosition()
        {
            var __ret = Internal.PreeditAreaPosition_0(__Instance);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the text that is inserted in the layout before editing
        /// occurs.</para>
        /// <para>See also preeditAreaPosition().</para>
        /// </summary>
        public string PreeditAreaText()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.PreeditAreaText_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Clears the list of additional formats supported by the text
        /// layout.</para>
        /// <para>See also additionalFormats() and setAdditionalFormats().</para>
        /// </summary>
        public void ClearAdditionalFormats()
        {
            Internal.ClearAdditionalFormats_0(__Instance);
        }

        /// <summary>
        /// <para>Begins the layout process.</para>
        /// <para>See also endLayout().</para>
        /// </summary>
        public void BeginLayout()
        {
            Internal.BeginLayout_0(__Instance);
        }

        /// <summary>
        /// <para>Ends the layout process.</para>
        /// <para>See also beginLayout().</para>
        /// </summary>
        public void EndLayout()
        {
            Internal.EndLayout_0(__Instance);
        }

        /// <summary>
        /// <para>Clears the line information in the layout. After having called
        /// this function, lineCount() returns 0.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public void ClearLayout()
        {
            Internal.ClearLayout_0(__Instance);
        }

        /// <summary>
        /// <para>Returns a new text line to be laid out if there is text to be
        /// inserted into the layout; otherwise returns an invalid text line.</para>
        /// <para>The text layout creates a new line object that starts after the
        /// last line in the layout, or at the beginning if the layout is empty. The
        /// layout maintains an internal cursor, and each line is filled with text from
        /// the cursor position onwards when the QTextLine::setLineWidth() function is
        /// called.</para>
        /// <para>Once QTextLine::setLineWidth() is called, a new line can be
        /// created and filled with text. Repeating this process will lay out the whole
        /// block of text contained in the QTextLayout. If there is no text left to be
        /// inserted into the layout, the QTextLine returned will not be valid
        /// (isValid() will return false).</para>
        /// </summary>
        public QTextLine CreateLine()
        {
            var __ret = Internal.CreateLine_0(__Instance);
            return QTextLine.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the i-th line of text in this text layout.</para>
        /// <para>See also lineCount() and lineForTextPosition().</para>
        /// </summary>
        public QTextLine LineAt(int i)
        {
            var __ret = Internal.LineAt_0(__Instance, i);
            return QTextLine.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the line that contains the cursor position specified by
        /// pos.</para>
        /// <para>See also isValidCursorPosition() and lineAt().</para>
        /// </summary>
        public QTextLine LineForTextPosition(int pos)
        {
            var __ret = Internal.LineForTextPosition_0(__Instance, pos);
            return QTextLine.__CreateInstance(__ret);
        }

        public bool IsValidCursorPosition(int pos)
        {
            var __ret = Internal.IsValidCursorPosition_0(__Instance, pos);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the next valid cursor position after oldPos that respects
        /// the given cursor mode. Returns value of oldPos, if oldPos is not a valid
        /// cursor position.</para>
        /// <para>See also isValidCursorPosition() and
        /// previousCursorPosition().</para>
        /// </summary>
        public int NextCursorPosition(int oldPos, QTextLayout.CursorMode mode = QTextLayout.CursorMode.SkipCharacters)
        {
            var arg1 = mode;
            var __ret = Internal.NextCursorPosition_0(__Instance, oldPos, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the first valid cursor position before oldPos that
        /// respects the given cursor mode. Returns value of oldPos, if oldPos is not a
        /// valid cursor position.</para>
        /// <para>See also isValidCursorPosition() and nextCursorPosition().</para>
        /// </summary>
        public int PreviousCursorPosition(int oldPos, QTextLayout.CursorMode mode = QTextLayout.CursorMode.SkipCharacters)
        {
            var arg1 = mode;
            var __ret = Internal.PreviousCursorPosition_0(__Instance, oldPos, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the cursor position to the left of oldPos, next to it.
        /// It's dependent on the visual position of characters, after bi-directional
        /// reordering.</para>
        /// <para>See also rightCursorPosition() and
        /// previousCursorPosition().</para>
        /// </summary>
        public int LeftCursorPosition(int oldPos)
        {
            var __ret = Internal.LeftCursorPosition_0(__Instance, oldPos);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the cursor position to the right of oldPos, next to it.
        /// It's dependent on the visual position of characters, after bi-directional
        /// reordering.</para>
        /// <para>See also leftCursorPosition() and nextCursorPosition().</para>
        /// </summary>
        public int RightCursorPosition(int oldPos)
        {
            var __ret = Internal.RightCursorPosition_0(__Instance, oldPos);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the glyph indexes and positions for all glyphs
        /// corresponding to the length characters starting at the position from in
        /// this QTextLayout. This is an expensive function, and should not be called
        /// in a time sensitive context.</para>
        /// <para>If from is less than zero, then the glyph run will begin at the
        /// first character in the layout. If length is less than zero, it will span
        /// the entire string from the start position.</para>
        /// <para>This function was introduced in  Qt 4.8.</para>
        /// <para>See also draw() and QPainter::drawGlyphRun().</para>
        /// </summary>
        public System.Collections.Generic.IList<QGlyphRun> GlyphRuns(int from = -1, int length = -1)
        {
            var __ret = Internal.GlyphRuns_0(__Instance, from, length);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QGlyphRun>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QGlyphRun.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        public void SetFlags(int flags)
        {
            Internal.SetFlags_0(__Instance, flags);
        }

        /// <summary>
        /// <para>Returns the current font that is used for the layout, or a
        /// default font if none is set.</para>
        /// <para>See also setFont().</para>
        /// <para></para>
        /// <para>Sets the layout's font to the given font. The layout is
        /// invalidated and must be laid out again.</para>
        /// <para>See also font().</para>
        /// </summary>
        public QFont Font
        {
            get
            {
                var __ret = new QtGui.QFont.Internal();
                Internal.Font_0(new IntPtr(&__ret), __Instance);
                return QFont.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFont_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the layout's text.</para>
        /// <para>See also setText().</para>
        /// <para></para>
        /// <para>Sets the layout's text to the given string. The layout is
        /// invalidated and must be laid out again.</para>
        /// <para>Notice that when using this QTextLayout as part of a
        /// QTextDocument this method will have no effect.</para>
        /// <para>See also text().</para>
        /// </summary>
        public string Text
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Text_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetText_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the current text option used to control the layout
        /// process.</para>
        /// <para>See also setTextOption().</para>
        /// <para></para>
        /// <para>Sets the text option structure that controls the layout process
        /// to the given option.</para>
        /// <para>See also textOption().</para>
        /// </summary>
        public QTextOption TextOption
        {
            get
            {
                var __ret = Internal.TextOption_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextOption.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetTextOption_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the list of additional formats supported by the text
        /// layout.</para>
        /// <para>See also setAdditionalFormats() and
        /// clearAdditionalFormats().</para>
        /// <para></para>
        /// <para>Sets the additional formats supported by the text layout to
        /// formatList. The formats are applied with preedit area text in place.</para>
        /// <para>See also additionalFormats() and clearAdditionalFormats().</para>
        /// </summary>
        public System.Collections.Generic.IList<QTextLayout.FormatRange> AdditionalFormats
        {
            get
            {
                var __ret = Internal.AdditionalFormats_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTextLayout.FormatRange>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTextLayout.FormatRange.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }

            set
            {
                var __qList = new QtCore.QList.Internal();
                var __qlistDataData = (QListData.Data.Internal*) __qList._0.d;
                __qlistDataData->alloc = value.Count;
                __qlistDataData->begin = 0;
                __qlistDataData->end = value.Count;
                fixed (void** __v = new void*[value.Count])
                {
                    __qlistDataData->array = __v;
                }

                for (int i = 0; i < value.Count; i++)
                {
                    __qlistDataData->array[i] = (void*) value[i].__Instance;
                }
                var arg0 = new global::System.IntPtr(&__qList);
                Internal.SetAdditionalFormats_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns true if the complete layout information is cached;
        /// otherwise returns false.</para>
        /// <para>See also setCacheEnabled().</para>
        /// <para></para>
        /// <para>Enables caching of the complete layout information if enable is
        /// true; otherwise disables layout caching. Usually QTextLayout throws most of
        /// the layouting information away after a call to endLayout() to reduce memory
        /// consumption. If you however want to draw the laid out text directly
        /// afterwards enabling caching might speed up drawing significantly.</para>
        /// <para>See also cacheEnabled().</para>
        /// </summary>
        public bool CacheEnabled
        {
            get
            {
                var __ret = Internal.CacheEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetCacheEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the number of lines in this text layout.</para>
        /// <para>See also lineAt().</para>
        /// </summary>
        public int LineCount
        {
            get
            {
                var __ret = Internal.LineCount_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QTextLine class represents a line of text inside a
    /// QTextLayout.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A text line is usually created by
    /// QTextLayout::createLine().</para>
    /// <para>After being created, the line can be filled using the
    /// setLineWidth() or setNumColumns() functions. A line has a number of
    /// attributes including the rectangle it occupies, rect(), its coordinates,
    /// x() and y(), its textLength(), width() and naturalTextWidth(), and its
    /// ascent() and descent() relative to the text. The position of the cursor in
    /// terms of the line is available from cursorToX() and its inverse from
    /// xToCursor(). A line can be moved with setPosition().</para>
    /// </remarks>
    public unsafe partial class QTextLine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public int index;

            [FieldOffset(4)]
            public global::System.IntPtr eng;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextLineC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextLine13setNumColumnsEi")]
            internal static extern void SetNumColumns_0(global::System.IntPtr instance, int columns);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextLine9glyphRunsEii")]
            internal static extern QList.Internal GlyphRuns_0(global::System.IntPtr instance, int from, int length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextLine15leadingIncludedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool LeadingIncluded_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextLine18setLeadingIncludedEb")]
            internal static extern void SetLeadingIncluded_0(global::System.IntPtr instance, bool included);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextLine9textStartEv")]
            internal static extern int TextStart_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextLine10textLengthEv")]
            internal static extern int TextLength_0(global::System.IntPtr instance);
        }

        public enum Edge : uint
        {
            Leading = 0,
            Trailing = 1
        }

        public enum CursorPosition : uint
        {
            CursorBetweenCharacters = 0,
            CursorOnCharacter = 1
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextLine __CreateInstance(global::System.IntPtr native)
        {
            return new QTextLine((QTextLine.Internal*) native);
        }

        public static QTextLine __CreateInstance(QTextLine.Internal native)
        {
            return new QTextLine(native);
        }

        private static QTextLine.Internal* __CopyValue(QTextLine.Internal native)
        {
            var ret = (QTextLine.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QTextLine(QTextLine.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextLine(QTextLine.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Lays out the line. The line is filled from its starting position
        /// with as many characters as are specified by numColumns. In case the text
        /// cannot be split until numColumns characters, the line will be filled with
        /// as many characters to the next whitespace or end of the text.</para>
        /// </summary>
        public void SetNumColumns(int columns)
        {
            Internal.SetNumColumns_0(__Instance, columns);
        }

        /// <summary>
        /// <para>Returns the glyph indexes and positions for all glyphs in this
        /// QTextLine for characters in the range defined by from and length. The from
        /// index is relative to the beginning of the text in the containing
        /// QTextLayout, and the range must be within the range of QTextLine as given
        /// by functions textStart() and textLength().</para>
        /// <para>If from is negative, it will default to textStart(), and if
        /// length is negative it will default to the return value of
        /// textLength().</para>
        /// <para>This function was introduced in  Qt 5.0.</para>
        /// <para>See also QTextLayout::glyphRuns().</para>
        /// </summary>
        public System.Collections.Generic.IList<QGlyphRun> GlyphRuns(int from = -1, int length = -1)
        {
            var __ret = Internal.GlyphRuns_0(__Instance, from, length);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QGlyphRun>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QGlyphRun.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns true if positive leading is included into the line's
        /// height; otherwise returns false.</para>
        /// <para>By default, leading is not included.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also setLeadingIncluded().</para>
        /// <para></para>
        /// <para>Includes positive leading into the line's height if included is
        /// true; otherwise does not include leading.</para>
        /// <para>By default, leading is not included.</para>
        /// <para>Note that negative leading is ignored, it must be handled in the
        /// code using the text lines by letting the lines overlap.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also leadingIncluded().</para>
        /// </summary>
        public bool LeadingIncluded
        {
            get
            {
                var __ret = Internal.LeadingIncluded_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetLeadingIncluded_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the start of the line from the beginning of the string
        /// passed to the QTextLayout.</para>
        /// </summary>
        public int TextStart
        {
            get
            {
                var __ret = Internal.TextStart_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the length of the text in the line.</para>
        /// <para>See also naturalTextWidth().</para>
        /// </summary>
        public int TextLength
        {
            get
            {
                var __ret = Internal.TextLength_0(__Instance);
                return __ret;
            }
        }
    }

    public unsafe abstract partial class QAbstractUndoItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN17QAbstractUndoItemC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAbstractUndoItem(QAbstractUndoItem.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        public abstract void Undo();

        public abstract void Redo();

        #region Virtual table interop

        // virtual ~QAbstractUndoItem()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractUndoItem) _References[instance].Target;
            target.Dispose();
        }

        // void undo()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Undo_0Delegate(global::System.IntPtr instance);
        private static _Undo_0Delegate _Undo_0DelegateInstance;

        private static void _Undo_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractUndoItem) _References[instance].Target;
            target.Undo();
        }

        // void redo()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Redo_0Delegate(global::System.IntPtr instance);
        private static _Redo_0Delegate _Redo_0DelegateInstance;

        private static void _Redo_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractUndoItem) _References[instance].Target;
            target.Redo();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Undo_0DelegateInstance += _Undo_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Undo_0DelegateInstance).ToPointer();
                _Redo_0DelegateInstance += _Redo_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Redo_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
                *(void**)(vfptr0 + 8) = _Thunks[1];
                *(void**)(vfptr0 + 12) = _Thunks[2];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextDocument class holds formatted text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QTextDocument is a container for structured rich text documents,
    /// providing support for styled text and various types of document elements,
    /// such as lists, tables, frames, and images. They can be created for use in a
    /// QTextEdit, or used independently.</para>
    /// <para>Each document element is described by an associated format
    /// object. Each format object is treated as a unique object by QTextDocuments,
    /// and can be passed to objectForFormat() to obtain the document element that
    /// it is applied to.</para>
    /// <para>A QTextDocument can be edited programmatically using a
    /// QTextCursor, and its contents can be examined by traversing the document
    /// structure. The entire document structure is stored as a hierarchy of
    /// document elements beneath the root frame, found with the rootFrame()
    /// function. Alternatively, if you just want to iterate over the textual
    /// contents of the document you can use begin(), end(), and findBlock() to
    /// retrieve text blocks that you can examine and iterate over.</para>
    /// <para>The layout of a document is determined by the documentLayout();
    /// you can create your own QAbstractTextDocumentLayout subclass and set it
    /// using setDocumentLayout() if you want to use your own layout logic. The
    /// document's title and other meta-information can be obtained by calling the
    /// metaInformation() function. For documents that are exposed to users through
    /// the QTextEdit class, the document title is also available via the
    /// QTextEdit::documentTitle() function.</para>
    /// <para>The toPlainText() and toHtml() convenience functions allow you to
    /// retrieve the contents of the document as plain text and HTML. The
    /// document's text can be searched using the find() functions.</para>
    /// <para>Undo/redo of operations performed on the document can be
    /// controlled using the setUndoRedoEnabled() function. The undo/redo system
    /// can be controlled by an editor widget through the undo() and redo() slots;
    /// the document also provides contentsChanged(), undoAvailable(), and
    /// redoAvailable() signals that inform connected editor widgets about the
    /// state of the undo/redo system. The following are the undo/redo operations
    /// of a QTextDocument:</para>
    /// <para></para>
    /// <para>Insertion or removal of characters. A sequence of insertions or
    /// removals within the same text block are regarded as a single undo/redo
    /// operation.</para>
    /// <para>Insertion or removal of text blocks. Sequences of insertion or
    /// removals in a single operation (e.g., by selecting and then deleting text)
    /// are regarded as a single undo/redo operation.</para>
    /// <para>Text character format changes.</para>
    /// <para>Text block format changes.</para>
    /// <para>Text block group format changes.</para>
    /// </remarks>
    public unsafe partial class QTextDocument : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocumentC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocumentD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument5clearEv")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument18setMetaInformationENS_15MetaInformationERK7QString")]
            internal static extern void SetMetaInformation_0(global::System.IntPtr instance, QTextDocument.MetaInformation info, global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument15metaInformationENS_15MetaInformationE")]
            internal static extern void metaInformation_0(global::System.IntPtr @return, global::System.IntPtr instance, QTextDocument.MetaInformation info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument7setHtmlERK7QString")]
            internal static extern void SetHtml_0(global::System.IntPtr instance, global::System.IntPtr html);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument11toPlainTextEv")]
            internal static extern void ToPlainText_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument12setPlainTextERK7QString")]
            internal static extern void SetPlainText_0(global::System.IntPtr instance, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument4findERK7QStringi6QFlagsINS_8FindFlagEE")]
            internal static extern void Find_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr subString, int from, QTextDocument.FindFlag options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument4findERK7QStringRK11QTextCursor6QFlagsINS_8FindFlagEE")]
            internal static extern void Find_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr subString, global::System.IntPtr from, QTextDocument.FindFlag options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument7frameAtEi")]
            internal static extern global::System.IntPtr FrameAt_0(global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument6objectEi")]
            internal static extern global::System.IntPtr Object_0(global::System.IntPtr instance, int objectIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument15objectForFormatERK11QTextFormat")]
            internal static extern global::System.IntPtr ObjectForFormat_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument9findBlockEi")]
            internal static extern void FindBlock_0(global::System.IntPtr @return, global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument17findBlockByNumberEi")]
            internal static extern void FindBlockByNumber_0(global::System.IntPtr @return, global::System.IntPtr instance, int blockNumber);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument21findBlockByLineNumberEi")]
            internal static extern void FindBlockByLineNumber_0(global::System.IntPtr @return, global::System.IntPtr instance, int blockNumber);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument5beginEv")]
            internal static extern void Begin_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument3endEv")]
            internal static extern void End_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument5printEP17QPagedPaintDevice")]
            internal static extern void Print_0(global::System.IntPtr instance, global::System.IntPtr printer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument17markContentsDirtyEii")]
            internal static extern void MarkContentsDirty_0(global::System.IntPtr instance, int from, int length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument10adjustSizeEv")]
            internal static extern void AdjustSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument4undoEP11QTextCursor")]
            internal static extern void Undo_0(global::System.IntPtr instance, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument4redoEP11QTextCursor")]
            internal static extern void Redo_0(global::System.IntPtr instance, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument19clearUndoRedoStacksENS_6StacksE")]
            internal static extern void ClearUndoRedoStacks_0(global::System.IntPtr instance, QTextDocument.Stacks historyToClear);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument4undoEv")]
            internal static extern void Undo_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument4redoEv")]
            internal static extern void Redo_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument14appendUndoItemEP17QAbstractUndoItem")]
            internal static extern void AppendUndoItem_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument12createObjectERK11QTextFormat")]
            internal static extern global::System.IntPtr CreateObject_0(global::System.IntPtr instance, global::System.IntPtr f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument17isUndoRedoEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool UndoRedoEnabled_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument18setUndoRedoEnabledEb")]
            internal static extern void SetUndoRedoEnabled_0(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument14documentLayoutEv")]
            internal static extern global::System.IntPtr DocumentLayout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument17setDocumentLayoutEP27QAbstractTextDocumentLayout")]
            internal static extern void SetDocumentLayout_0(global::System.IntPtr instance, global::System.IntPtr layout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument11defaultFontEv")]
            internal static extern void DefaultFont_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument14setDefaultFontERK5QFont")]
            internal static extern void SetDefaultFont_0(global::System.IntPtr instance, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument16useDesignMetricsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool UseDesignMetrics_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument19setUseDesignMetricsEb")]
            internal static extern void SetUseDesignMetrics_0(global::System.IntPtr instance, bool b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument17defaultStyleSheetEv")]
            internal static extern void DefaultStyleSheet_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument20setDefaultStyleSheetERK7QString")]
            internal static extern void SetDefaultStyleSheet_0(global::System.IntPtr instance, global::System.IntPtr sheet);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument17maximumBlockCountEv")]
            internal static extern int MaximumBlockCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument20setMaximumBlockCountEi")]
            internal static extern void SetMaximumBlockCount_0(global::System.IntPtr instance, int maximum);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument17defaultTextOptionEv")]
            internal static extern void DefaultTextOption_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument20setDefaultTextOptionERK11QTextOption")]
            internal static extern void SetDefaultTextOption_0(global::System.IntPtr instance, global::System.IntPtr option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument10isModifiedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Modified_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextDocument11setModifiedEb")]
            internal static extern void SetModified_0(global::System.IntPtr instance, bool m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument7isEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument15isUndoAvailableEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsUndoAvailable_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument15isRedoAvailableEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsRedoAvailable_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument18availableUndoStepsEv")]
            internal static extern int AvailableUndoSteps_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument18availableRedoStepsEv")]
            internal static extern int AvailableRedoSteps_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument8revisionEv")]
            internal static extern int Revision_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument9rootFrameEv")]
            internal static extern global::System.IntPtr RootFrame_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument10firstBlockEv")]
            internal static extern void FirstBlock_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument9lastBlockEv")]
            internal static extern void LastBlock_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument9pageCountEv")]
            internal static extern int PageCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument10blockCountEv")]
            internal static extern int BlockCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument9lineCountEv")]
            internal static extern int LineCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextDocument14characterCountEv")]
            internal static extern int CharacterCount_0(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>This enum describes the different types of meta information that
        /// can be added to a document.</para>
        /// <para>See also metaInformation() and setMetaInformation().</para>
        /// </summary>
        public enum MetaInformation : uint
        {
            /// <summary>The title of the document.</summary>
            DocumentTitle = 0,
            /// <summary>The url of the document. The loadResource() function uses this url as the base when loading relative resources.</summary>
            DocumentUrl = 1
        }

        /// <summary>
        /// <para>This enum describes the options available to QTextDocument's find
        /// function. The options can be OR-ed together from the following list:</para>
        /// </summary>
        [Flags]
        public enum FindFlag : uint
        {
            /// <summary>Search backwards instead of forwards.</summary>
            FindBackward = 0x1,
            /// <summary>By default find works case insensitive. Specifying this option changes the behaviour to a case sensitive find operation.</summary>
            FindCaseSensitively = 0x2,
            /// <summary>Makes find match only complete words.</summary>
            FindWholeWords = 0x4
        }

        /// <summary>
        /// <para>This enum describes the types of resources that can be loaded by
        /// QTextDocument's loadResource() function.</para>
        /// <para>See also loadResource().</para>
        /// </summary>
        public enum ResourceType : uint
        {
            /// <summary>The resource contains HTML.</summary>
            HtmlResource = 1,
            /// <summary>The resource contains image data. Currently supported data types are QVariant::Pixmap and QVariant::Image. If the corresponding variant is of type QVariant::ByteArray then Qt attempts to load the image using QImage::loadFromData. QVariant::Icon is currently not supported. The icon needs to be converted to one of the supported types first, for example using QIcon::pixmap.</summary>
            ImageResource = 2,
            /// <summary>The resource contains CSS.</summary>
            StyleSheetResource = 3,
            /// <summary>The first available value for user defined resource types.</summary>
            UserResource = 100
        }

        public enum Stacks : uint
        {
            /// <summary>The undo stack.</summary>
            UndoStack = 0x1,
            /// <summary>The redo stack.</summary>
            RedoStack = 0x2,
            /// <summary>Both the undo and redo stacks.</summary>
            UndoAndRedoStacks = 3
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted whenever the document's content changes; for example, when text is inserted or deleted, or when formatting is applied.</para>
        /// <para>Information is provided about the position of the character in the document where the change occurred, the number of characters removed (charsRemoved), and the number of characters added (charsAdded).</para>
        /// <para>The signal is emitted before the document's layout manager is notified about the change. This hook allows you to implement syntax highlighting for the document.</para>
        /// <para>See also QAbstractTextDocumentLayout::documentChanged() and contentsChanged().</para>
        /// </summary>
        public event Action<int,int,int> ContentsChange
        {
        	add
        	{
                ConnectDynamicSlot(this, "contentsChange(int, int, int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "contentsChange(int, int, int)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever the document's content changes; for example, when text is inserted or deleted, or when formatting is applied.</para>
        /// <para>See also contentsChange().</para>
        /// </summary>
        public event Action ContentsChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "contentsChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "contentsChanged()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever undo operations become available (available is true) or unavailable (available is false).</para>
        /// <para>See the Qt Undo Framework documentation for details.</para>
        /// <para>See also undo() and isUndoRedoEnabled().</para>
        /// </summary>
        public event Action<bool> UndoAvailable
        {
        	add
        	{
                ConnectDynamicSlot(this, "undoAvailable(bool)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "undoAvailable(bool)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever redo operations become available (available is true) or unavailable (available is false).</para>
        /// </summary>
        public event Action<bool> RedoAvailable
        {
        	add
        	{
                ConnectDynamicSlot(this, "redoAvailable(bool)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "redoAvailable(bool)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted every time a new level of undo is added to the QTextDocument.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public event Action UndoCommandAdded
        {
        	add
        	{
                ConnectDynamicSlot(this, "undoCommandAdded()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "undoCommandAdded()", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever the content of the document changes in a way that affects the modification state. If changed is true, the document has been modified; otherwise it is false.</para>
        /// <para>For example, calling setModified(false) on a document and then inserting text causes the signal to get emitted. If you undo that operation, causing the document to return to its original unmodified state, the signal will get emitted again.</para>
        /// </summary>
        public event Action<bool> ModificationChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "modificationChanged(bool)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "modificationChanged(bool)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted whenever the position of a cursor changed due to an editing operation. The cursor that changed is passed in cursor. If the document is used with the QTextEdit class and you need a signal when the cursor is moved with the arrow keys you can use the cursorPositionChanged() signal in QTextEdit.</para>
        /// </summary>
        public event Action<QTextCursor> CursorPositionChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "cursorPositionChanged(QTextCursor)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "cursorPositionChanged(QTextCursor)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the total number of text blocks in the document changes. The value passed in newBlockCount is the new total.</para>
        /// <para>This function was introduced in  Qt 4.3.</para>
        /// </summary>
        public event Action<int> BlockCountChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "blockCountChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "blockCountChanged(int)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when a new document layout is set.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setDocumentLayout().</para>
        /// </summary>
        public event Action DocumentLayoutChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "documentLayoutChanged()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "documentLayoutChanged()", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextDocument __CreateInstance(global::System.IntPtr native)
        {
            return new QTextDocument((QTextDocument.Internal*) native);
        }

        public static QTextDocument __CreateInstance(QTextDocument.Internal native)
        {
            return new QTextDocument(native);
        }

        private static QTextDocument.Internal* __CopyValue(QTextDocument.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextDocument.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QTextDocument.Internal*) ret;
        }

        private QTextDocument(QTextDocument.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextDocument(QTextDocument.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Clears the document.</para>
        /// </summary>
        public virtual void Clear()
        {
            Internal.Clear_0(__Instance);
        }

        /// <summary>
        /// <para>Sets the document's meta information of the type specified by
        /// info to the given string.</para>
        /// <para>See also metaInformation().</para>
        /// </summary>
        public void SetMetaInformation(QTextDocument.MetaInformation info, string @string)
        {
            var arg0 = info;
            var __qstring1 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(@string).ToPointer(), @string.Length);
            var arg1 = ReferenceEquals(__qstring1, null) ? global::System.IntPtr.Zero : __qstring1.__Instance;
            Internal.SetMetaInformation_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Returns meta information about the document of the type specified
        /// by info.</para>
        /// <para>See also setMetaInformation().</para>
        /// </summary>
        public string metaInformation(QTextDocument.MetaInformation info)
        {
            var arg0 = info;
            var __ret = new QtCore.QString.Internal();
            Internal.metaInformation_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Replaces the entire contents of the document with the given
        /// HTML-formatted text in the html string.</para>
        /// <para>The HTML formatting is respected as much as possible; for
        /// example, &quot;&lt;b&gt;bold&lt;/b&gt; text&quot; will produce text where
        /// the first word has a font weight that gives it a bold appearance:
        /// &quot;bold text&quot;.</para>
        /// <para>Note: It is the responsibility of the caller to make sure that
        /// the text is correctly decoded when a QString containing HTML is created and
        /// passed to setHtml().See also setPlainText() and Supported HTML
        /// Subset.</para>
        /// </summary>
        public void SetHtml(string html)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(html).ToPointer(), html.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.SetHtml_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns the plain text contained in the document. If you want
        /// formatting information use a QTextCursor instead.</para>
        /// <para>See also toHtml().</para>
        /// </summary>
        public string ToPlainText()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.ToPlainText_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Replaces the entire contents of the document with the given plain
        /// text.</para>
        /// <para>See also setHtml().</para>
        /// </summary>
        public void SetPlainText(string text)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.SetPlainText_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Finds the next occurrence of the string, subString, in the
        /// document. The search starts at the given position, and proceeds forwards
        /// through the document unless specified otherwise in the search options. The
        /// options control the type of search performed.</para>
        /// <para>Returns a cursor with the match selected if subString was found;
        /// otherwise returns a null cursor.</para>
        /// <para>If the position is 0 (the default) the search begins from the
        /// beginning of the document; otherwise it begins at the specified
        /// position.</para>
        /// </summary>
        public QTextCursor Find(string subString, int from = 0, QTextDocument.FindFlag options = 0)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(subString).ToPointer(), subString.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg2 = options;
            var __ret = new QtGui.QTextCursor.Internal();
            Internal.Find_0(new IntPtr(&__ret), __Instance, arg0, from, arg2);
            return QTextCursor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Finds the next occurrence of the string, subString, in the
        /// document. The search starts at the position of the given cursor, and
        /// proceeds forwards through the document unless specified otherwise in the
        /// search options. The options control the type of search performed.</para>
        /// <para>Returns a cursor with the match selected if subString was found;
        /// otherwise returns a null cursor.</para>
        /// <para>If the given cursor has a selection, the search begins after the
        /// selection; otherwise it begins at the cursor's position.</para>
        /// <para>By default the search is case-sensitive, and can match text
        /// anywhere in the document.</para>
        /// </summary>
        public QTextCursor Find(string subString, QTextCursor from, QTextDocument.FindFlag options = 0)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(subString).ToPointer(), subString.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(from, null) ? global::System.IntPtr.Zero : from.__Instance;
            var arg2 = options;
            var __ret = new QtGui.QTextCursor.Internal();
            Internal.Find_1(new IntPtr(&__ret), __Instance, arg0, arg1, arg2);
            return QTextCursor.__CreateInstance(__ret);
        }

        public QTextFrame FrameAt(int pos)
        {
            var __ret = Internal.FrameAt_0(__Instance, pos);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextFrame.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the text object associated with the given
        /// objectIndex.</para>
        /// </summary>
        public QTextObject Object(int objectIndex)
        {
            var __ret = Internal.Object_0(__Instance, objectIndex);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextObject.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the text object associated with the format f.</para>
        /// </summary>
        public QTextObject ObjectForFormat(QTextFormat f)
        {
            var arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
            var __ret = Internal.ObjectForFormat_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextObject.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the text block that contains the pos-th character.</para>
        /// </summary>
        public QTextBlock FindBlock(int pos)
        {
            var __ret = new QtGui.QTextBlock.Internal();
            Internal.FindBlock_0(new IntPtr(&__ret), __Instance, pos);
            return QTextBlock.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the text block with the specified blockNumber.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also QTextBlock::blockNumber().</para>
        /// </summary>
        public QTextBlock FindBlockByNumber(int blockNumber)
        {
            var __ret = new QtGui.QTextBlock.Internal();
            Internal.FindBlockByNumber_0(new IntPtr(&__ret), __Instance, blockNumber);
            return QTextBlock.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the text block that contains the specified
        /// lineNumber.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also QTextBlock::firstLineNumber().</para>
        /// </summary>
        public QTextBlock FindBlockByLineNumber(int blockNumber)
        {
            var __ret = new QtGui.QTextBlock.Internal();
            Internal.FindBlockByLineNumber_0(new IntPtr(&__ret), __Instance, blockNumber);
            return QTextBlock.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the document's first text block.</para>
        /// <para>See also firstBlock().</para>
        /// </summary>
        public QTextBlock Begin()
        {
            var __ret = new QtGui.QTextBlock.Internal();
            Internal.Begin_0(new IntPtr(&__ret), __Instance);
            return QTextBlock.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This function returns a block to test for the end of the document
        /// while iterating over it.</para>
        /// <para>    for (QTextBlock it = doc-&gt;begin(); it != doc-&gt;end(); it
        /// = it.next())</para>
        /// <para>        cout &lt;&lt; it.text().toStdString() &lt;&lt;
        /// endl;</para>
        /// <para>The block returned is invalid and represents the block after the
        /// last block in the document. You can use lastBlock() to retrieve the last
        /// valid block of the document.</para>
        /// <para>See also lastBlock().</para>
        /// </summary>
        public QTextBlock End()
        {
            var __ret = new QtGui.QTextBlock.Internal();
            Internal.End_0(new IntPtr(&__ret), __Instance);
            return QTextBlock.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Prints the document to the given printer. The
        /// QPageablePaintDevice must be set up before being used with this
        /// function.</para>
        /// <para>This is only a convenience method to print the whole document to
        /// the printer.</para>
        /// <para>If the document is already paginated through a specified height
        /// in the pageSize() property it is printed as-is.</para>
        /// <para>If the document is not paginated, like for example a document
        /// used in a QTextEdit, then a temporary copy of the document is created and
        /// the copy is broken into multiple pages according to the size of the paint
        /// device's paperRect(). By default a 2 cm margin is set around the document
        /// contents. In addition the current page number is printed at the bottom of
        /// each page.</para>
        /// <para>See also QTextEdit::print().</para>
        /// </summary>
        public void Print(QPagedPaintDevice printer)
        {
            var arg0 = ReferenceEquals(printer, null) ? global::System.IntPtr.Zero : printer.__Instance;
            Internal.Print_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Marks the contents specified by the given position and length as
        /// &quot;dirty&quot;, informing the document that it needs to be laid out
        /// again.</para>
        /// </summary>
        public void MarkContentsDirty(int from, int length)
        {
            Internal.MarkContentsDirty_0(__Instance, from, length);
        }

        /// <summary>
        /// <para>Adjusts the document to a reasonable size.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also idealWidth(), textWidth, and size.</para>
        /// </summary>
        public void AdjustSize()
        {
            Internal.AdjustSize_0(__Instance);
        }

        /// <summary>
        /// <para>Undoes the last editing operation on the document if undo is
        /// available. The provided cursor is positioned at the end of the location
        /// where the edition operation was undone.</para>
        /// <para>See the Qt Undo Framework documentation for details.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also undoAvailable() and isUndoRedoEnabled().</para>
        /// </summary>
        public void Undo(QTextCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            Internal.Undo_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Redoes the last editing operation on the document if redo is
        /// available.</para>
        /// <para>The provided cursor is positioned at the end of the location
        /// where the edition operation was redone.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public void Redo(QTextCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            Internal.Redo_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Clears the stacks specified by stacksToClear.</para>
        /// <para>This method clears any commands on the undo stack, the redo
        /// stack, or both (the default). If commands are cleared, the appropriate
        /// signals are emitted, QTextDocument::undoAvailable() or
        /// QTextDocument::redoAvailable().</para>
        /// <para>This function was introduced in  Qt 4.7.</para>
        /// <para>See also QTextDocument::undoAvailable() and
        /// QTextDocument::redoAvailable().</para>
        /// </summary>
        public void ClearUndoRedoStacks(QTextDocument.Stacks historyToClear = QTextDocument.Stacks.UndoAndRedoStacks)
        {
            var arg0 = historyToClear;
            Internal.ClearUndoRedoStacks_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// </summary>
        public void Undo()
        {
            Internal.Undo_1(__Instance);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Redoes the last editing operation on the document if redo is
        /// available.</para>
        /// </summary>
        public void Redo()
        {
            Internal.Redo_1(__Instance);
        }

        public void AppendUndoItem(QAbstractUndoItem _0)
        {
            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            Internal.AppendUndoItem_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Creates and returns a new document object (a QTextObject), based
        /// on the given format.</para>
        /// <para>QTextObjects will always get created through this method, so you
        /// must reimplement it if you use custom text objects inside your
        /// document.</para>
        /// </summary>
        protected virtual QTextObject CreateObject(QTextFormat f)
        {
            var arg0 = ReferenceEquals(f, null) ? global::System.IntPtr.Zero : f.__Instance;
            var __ret = Internal.CreateObject_0(__Instance, arg0);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextObject.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This property holds whether undo/redo are enabled for this
        /// document.</para>
        /// <para>This defaults to true. If disabled, the undo stack is cleared and
        /// no items will be added to it.</para>
        /// </summary>
        public bool UndoRedoEnabled
        {
            get
            {
                var __ret = Internal.UndoRedoEnabled_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetUndoRedoEnabled_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the document layout for this document.</para>
        /// <para>See also setDocumentLayout().</para>
        /// <para></para>
        /// <para>Sets the document to use the given layout. The previous layout is
        /// deleted.</para>
        /// <para>See also documentLayoutChanged().</para>
        /// </summary>
        public QAbstractTextDocumentLayout DocumentLayout
        {
            get
            {
                var __ret = Internal.DocumentLayout_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QAbstractTextDocumentLayoutInternal.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetDocumentLayout_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds the default font used to display the
        /// document's text.</para>
        /// </summary>
        public QFont DefaultFont
        {
            get
            {
                var __ret = new QtGui.QFont.Internal();
                Internal.DefaultFont_0(new IntPtr(&__ret), __Instance);
                return QFont.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetDefaultFont_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds whether the document uses design metrics of
        /// fonts to improve the accuracy of text layout.</para>
        /// <para>If this property is set to true, the layout will use design
        /// metrics. Otherwise, the metrics of the paint device as set on
        /// QAbstractTextDocumentLayout::setPaintDevice() will be used.</para>
        /// <para>Using design metrics makes a layout have a width that is no
        /// longer dependent on hinting and pixel-rounding. This means that WYSIWYG
        /// text layout becomes possible because the width scales much more linearly
        /// based on paintdevice metrics than it would otherwise.</para>
        /// <para>By default, this property is false.</para>
        /// <para>This property was introduced in  Qt 4.1.</para>
        /// </summary>
        public bool UseDesignMetrics
        {
            get
            {
                var __ret = Internal.UseDesignMetrics_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetUseDesignMetrics_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>The default style sheet is applied to all newly HTML formatted
        /// text that is inserted into the document, for example using setHtml() or
        /// QTextCursor::insertHtml().</para>
        /// <para>The style sheet needs to be compliant to CSS 2.1 syntax.</para>
        /// <para>Note: Changing the default style sheet does not have any effect
        /// to the existing content of the document.</para>
        /// <para>This property was introduced in  Qt 4.2.</para>
        /// </summary>
        public string DefaultStyleSheet
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.DefaultStyleSheet_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetDefaultStyleSheet_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property specifies the limit for blocks in the
        /// document.</para>
        /// <para>Specifies the maximum number of blocks the document may have. If
        /// there are more blocks in the document that specified with this property
        /// blocks are removed from the beginning of the document.</para>
        /// <para>A negative or zero value specifies that the document may contain
        /// an unlimited amount of blocks.</para>
        /// <para>The default value is 0.</para>
        /// <para>Note that setting this property will apply the limit immediately
        /// to the document contents.</para>
        /// <para>Setting this property also disables the undo redo history.</para>
        /// <para>This property is undefined in documents with tables or
        /// frames.</para>
        /// <para>This property was introduced in  Qt 4.2.</para>
        /// </summary>
        public int MaximumBlockCount
        {
            get
            {
                var __ret = Internal.MaximumBlockCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetMaximumBlockCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>This property holds the default text option will be set on all
        /// QTextLayouts in the document.</para>
        /// <para>When QTextBlocks are created, the defaultTextOption is set on
        /// their QTextLayout. This allows setting global properties for the document
        /// such as the default word wrap mode.</para>
        /// </summary>
        public QTextOption DefaultTextOption
        {
            get
            {
                var __ret = new QtGui.QTextOption.Internal();
                Internal.DefaultTextOption_0(new IntPtr(&__ret), __Instance);
                return QTextOption.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetDefaultTextOption_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>This property holds whether the document has been modified by the
        /// user.</para>
        /// <para>By default, this property is false.</para>
        /// </summary>
        public bool Modified
        {
            get
            {
                var __ret = Internal.Modified_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetModified_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if the document is empty; otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                var __ret = Internal.IsEmpty_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if undo is available; otherwise returns
        /// false.</para>
        /// <para>See also isRedoAvailable() and availableUndoSteps().</para>
        /// </summary>
        public bool IsUndoAvailable
        {
            get
            {
                var __ret = Internal.IsUndoAvailable_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns true if redo is available; otherwise returns
        /// false.</para>
        /// <para>See also isUndoAvailable() and availableRedoSteps().</para>
        /// </summary>
        public bool IsRedoAvailable
        {
            get
            {
                var __ret = Internal.IsRedoAvailable_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of available undo steps.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also isUndoAvailable().</para>
        /// </summary>
        public int AvailableUndoSteps
        {
            get
            {
                var __ret = Internal.AvailableUndoSteps_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of available redo steps.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also isRedoAvailable().</para>
        /// </summary>
        public int AvailableRedoSteps
        {
            get
            {
                var __ret = Internal.AvailableRedoSteps_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the document's revision (if undo is enabled).</para>
        /// <para>The revision is guaranteed to increase when a document that is
        /// not modified is edited.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also QTextBlock::revision() and isModified().</para>
        /// </summary>
        public int Revision
        {
            get
            {
                var __ret = Internal.Revision_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the document's root frame.</para>
        /// </summary>
        public QTextFrame RootFrame
        {
            get
            {
                var __ret = Internal.RootFrame_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextFrame.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the document's first text block.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public QTextBlock FirstBlock
        {
            get
            {
                var __ret = new QtGui.QTextBlock.Internal();
                Internal.FirstBlock_0(new IntPtr(&__ret), __Instance);
                return QTextBlock.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the document's last (valid) text block.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public QTextBlock LastBlock
        {
            get
            {
                var __ret = new QtGui.QTextBlock.Internal();
                Internal.LastBlock_0(new IntPtr(&__ret), __Instance);
                return QTextBlock.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>returns the number of pages in this document.</para>
        /// </summary>
        public int PageCount
        {
            get
            {
                var __ret = Internal.PageCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of text blocks in the document.</para>
        /// <para>The value of this property is undefined in documents with tables
        /// or frames.</para>
        /// <para>By default, if defined, this property contains a value of
        /// 1.</para>
        /// <para>This property was introduced in  Qt 4.2.</para>
        /// </summary>
        public int BlockCount
        {
            get
            {
                var __ret = Internal.BlockCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of lines of this document (if the layout
        /// supports this). Otherwise, this is identical to the number of
        /// blocks.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also blockCount() and characterCount().</para>
        /// </summary>
        public int LineCount
        {
            get
            {
                var __ret = Internal.LineCount_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of characters of this document.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also blockCount() and characterAt().</para>
        /// </summary>
        public int CharacterCount
        {
            get
            {
                var __ret = Internal.CharacterCount_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QTextDocument()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextDocument) _References[instance].Target;
            target.Dispose();
        }

        // void clear()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Clear_0Delegate(global::System.IntPtr instance);
        private static _Clear_0Delegate _Clear_0DelegateInstance;

        private static void _Clear_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextDocument) _References[instance].Target;
            target.Clear();
        }

        // QTextObject *createObject(const QTextFormat &f)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate global::System.IntPtr _CreateObject_0Delegate(global::System.IntPtr instance, global::System.IntPtr f);
        private static _CreateObject_0Delegate _CreateObject_0DelegateInstance;

        private static global::System.IntPtr _CreateObject_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr f)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextDocument) _References[instance].Target;
            var _ret = target.CreateObject((f == IntPtr.Zero) ? null : QTextFormat.__CreateInstance(f));
            return ReferenceEquals(_ret, null) ? global::System.IntPtr.Zero : _ret.__Instance;
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Clear_0DelegateInstance += _Clear_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Clear_0DelegateInstance).ToPointer();
                _CreateObject_0DelegateInstance += _CreateObject_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CreateObject_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(14 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QAbstractUndoItemInternal : QtGui.QAbstractUndoItem, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAbstractUndoItemInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAbstractUndoItemInternal((QAbstractUndoItem.Internal*) native);
        }

        public static QAbstractUndoItem __CreateInstance(QAbstractUndoItem.Internal native)
        {
            return new QAbstractUndoItemInternal(native);
        }

        private static QAbstractUndoItem.Internal* __CopyValue(QAbstractUndoItem.Internal native)
        {
            var ret = (QAbstractUndoItem.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QAbstractUndoItemInternal(QAbstractUndoItem.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAbstractUndoItemInternal(QAbstractUndoItem.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAbstractUndoItem.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override void Undo()
        {
            void* slot = *(void**) (((QAbstractUndoItem.Internal*) __Instance)->vfptr0 + 2 * 4);
            var ___Undo_0Delegate = (_Undo_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Undo_0Delegate));
            ___Undo_0Delegate(__Instance);
        }

        public override void Redo()
        {
            void* slot = *(void**) (((QAbstractUndoItem.Internal*) __Instance)->vfptr0 + 3 * 4);
            var ___Redo_0Delegate = (_Redo_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Redo_0Delegate));
            ___Redo_0Delegate(__Instance);
        }
    }

    public unsafe partial class qtextdocument
    {
        public partial struct Internal
        {
        }
    }

    namespace Qt
    {
        public unsafe partial class qtextdocument
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN2Qt15mightBeRichTextERK7QString")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool MightBeRichText_0(global::System.IntPtr _0);
            }

            public static bool MightBeRichText(string _0)
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_0).ToPointer(), _0.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                var __ret = Internal.MightBeRichText_0(arg0);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QAbstractTextDocumentLayout class is an abstract base class
    /// used to implement custom layouts for QTextDocuments.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The standard layout provided by Qt can handle simple word
    /// processing including inline images, lists and tables.</para>
    /// <para>Some applications, e.g., a word processor or a DTP application
    /// might need more features than the ones provided by Qt's layout engine, in
    /// which case you can subclass QAbstractTextDocumentLayout to provide custom
    /// layout behavior for your text documents.</para>
    /// <para>An instance of the QAbstractTextDocumentLayout subclass can be
    /// installed on a QTextDocument object with the setDocumentLayout()
    /// function.</para>
    /// <para>You can insert custom objects into a QTextDocument; see the
    /// QTextObjectInterface class description for details.</para>
    /// <para></para>
    /// <para>See also QTextObjectInterface.</para>
    /// </remarks>
    public unsafe abstract partial class QAbstractTextDocumentLayout : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayoutC2EP13QTextDocument")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayoutC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayoutD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QAbstractTextDocumentLayout16handlerForObjectEi")]
            internal static extern global::System.IntPtr HandlerForObject_0(global::System.IntPtr instance, int objectType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayout18resizeInlineObjectE17QTextInlineObjectiRK11QTextFormat")]
            internal static extern void ResizeInlineObject_0(global::System.IntPtr instance, QTextInlineObject.Internal item, int posInDocument, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayout20positionInlineObjectE17QTextInlineObjectiRK11QTextFormat")]
            internal static extern void PositionInlineObject_0(global::System.IntPtr instance, QTextInlineObject.Internal item, int posInDocument, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayout11formatIndexEi")]
            internal static extern int FormatIndex_0(global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayout6formatEi")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QAbstractTextDocumentLayout11paintDeviceEv")]
            internal static extern global::System.IntPtr PaintDevice_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QAbstractTextDocumentLayout14setPaintDeviceEP12QPaintDevice")]
            internal static extern void SetPaintDevice_0(global::System.IntPtr instance, global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QAbstractTextDocumentLayout8documentEv")]
            internal static extern global::System.IntPtr Document_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public unsafe partial class Selection : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public QTextCursor.Internal cursor;

                [FieldOffset(4)]
                public QTextCharFormat.Internal format;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN27QAbstractTextDocumentLayout9SelectionC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN27QAbstractTextDocumentLayout9SelectionD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Selection __CreateInstance(global::System.IntPtr native)
            {
                return new Selection((Selection.Internal*) native);
            }

            public static Selection __CreateInstance(Selection.Internal native)
            {
                return new Selection(native);
            }

            private static Selection.Internal* __CopyValue(Selection.Internal native)
            {
                var ret = Marshal.AllocHGlobal(12);
                QtGui.QAbstractTextDocumentLayout.Selection.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                return (Selection.Internal*) ret;
            }

            private Selection(Selection.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Selection(Selection.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public QTextCursor Cursor
            {
                get
                {
                    return QTextCursor.__CreateInstance(((Internal*) __Instance)->cursor);
                }

                set
                {
                    ((Internal*) __Instance)->cursor = ReferenceEquals(value, null) ? new QTextCursor.Internal() : *(QTextCursor.Internal*) (value.__Instance);
                }
            }

            public QTextCharFormat Format
            {
                get
                {
                    return QTextCharFormat.__CreateInstance(((Internal*) __Instance)->format);
                }

                set
                {
                    ((Internal*) __Instance)->format = ReferenceEquals(value, null) ? new QTextCharFormat.Internal() : *(QTextCharFormat.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class PaintContext : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public int cursorPosition;

                [FieldOffset(4)]
                public QPalette.Internal palette;

                [FieldOffset(16)]
                internal QtCore.QRectF.Internal clip;

                [FieldOffset(48)]
                internal QVector.Internal selections;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN27QAbstractTextDocumentLayout12PaintContextC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN27QAbstractTextDocumentLayout12PaintContextD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static PaintContext __CreateInstance(global::System.IntPtr native)
            {
                return new PaintContext((PaintContext.Internal*) native);
            }

            public static PaintContext __CreateInstance(PaintContext.Internal native)
            {
                return new PaintContext(native);
            }

            private static PaintContext.Internal* __CopyValue(PaintContext.Internal native)
            {
                var ret = Marshal.AllocHGlobal(56);
                QtGui.QAbstractTextDocumentLayout.PaintContext.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                return (PaintContext.Internal*) ret;
            }

            private PaintContext(PaintContext.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected PaintContext(PaintContext.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            public int CursorPosition
            {
                get
                {
                    return ((Internal*) __Instance)->cursorPosition;
                }

                set
                {
                    ((Internal*) __Instance)->cursorPosition = value;
                }
            }

            public QPalette Palette
            {
                get
                {
                    return QPalette.__CreateInstance(((Internal*) __Instance)->palette);
                }

                set
                {
                    ((Internal*) __Instance)->palette = ReferenceEquals(value, null) ? new QPalette.Internal() : *(QPalette.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>This signal is emitted when the specified block has been updated.</para>
        /// <para>Subclasses of QAbstractTextDocumentLayout should emit this signal when the layout of block has changed in order to repaint.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public event Action<QTextBlock> UpdateBlock
        {
        	add
        	{
                ConnectDynamicSlot(this, "updateBlock(QTextBlock)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "updateBlock(QTextBlock)", value);
        	}
        }

        /// <summary>
        /// <para>This signal is emitted when the number of pages in the layout changes; newPages is the updated page count.</para>
        /// <para>Subclasses of QAbstractTextDocumentLayout should emit this signal when the number of pages in the layout has changed. Changes to the page count are caused by changes to the layout or the document content itself.</para>
        /// <para>See also pageCount().</para>
        /// </summary>
        public event Action<int> PageCountChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "pageCountChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "pageCountChanged(int)", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QAbstractTextDocumentLayout(QAbstractTextDocumentLayout.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates a new text document layout for the given document.</para>
        /// </summary>
        protected QAbstractTextDocumentLayout(QTextDocument doc)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Draws the layout with the given painter using the given
        /// context.</para>
        /// </summary>
        public abstract void Draw(QPainter painter, QAbstractTextDocumentLayout.PaintContext context);

        /// <summary>
        /// <para>Returns a handler for objects of the given objectType.</para>
        /// </summary>
        public QTextObjectInterface HandlerForObject(int objectType)
        {
            var __ret = Internal.HandlerForObject_0(__Instance, objectType);
            if (__ret == global::System.IntPtr.Zero) return null;
            return (__ret == IntPtr.Zero) ? null : QTextObjectInterfaceInternal.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This function is called whenever the contents of the document
        /// change. A change occurs when text is inserted, removed, or a combination of
        /// these two. The change is specified by position, charsRemoved, and
        /// charsAdded corresponding to the starting character position of the change,
        /// the number of characters removed from the document, and the number of
        /// characters added.</para>
        /// <para>For example, when inserting the text &quot;Hello&quot; into an
        /// empty document, charsRemoved would be 0 and charsAdded would be 5 (the
        /// length of the string).</para>
        /// <para>Replacing text is a combination of removing and inserting. For
        /// example, if the text &quot;Hello&quot; gets replaced by &quot;Hi&quot;,
        /// charsRemoved would be 5 and charsAdded would be 2.</para>
        /// <para>For subclasses of QAbstractTextDocumentLayout, this is the
        /// central function where a large portion of the work to lay out and position
        /// document contents is done.</para>
        /// <para>For example, in a subclass that only arranges blocks of text, an
        /// implementation of this function would have to do the following:</para>
        /// <para></para>
        /// <para>Determine the list of changed QTextBlock(s) using the parameters
        /// provided.</para>
        /// <para>Each QTextBlock object's corresponding QTextLayout object needs
        /// to be processed. You can access the QTextBlock's layout using the
        /// QTextBlock::layout() function. This processing should take the document's
        /// page size into consideration.</para>
        /// <para>If the total number of pages changed, the pageCountChanged()
        /// signal should be emitted.</para>
        /// <para>If the total size changed, the documentSizeChanged() signal
        /// should be emitted.</para>
        /// <para>The update() signal should be emitted to schedule a repaint of
        /// areas in the layout that require repainting.</para>
        /// <para></para>
        /// <para>See also QTextLayout.</para>
        /// </summary>
        protected abstract void DocumentChanged(int from, int charsRemoved, int charsAdded);

        /// <summary>
        /// <para>Sets the size of the inline object item corresponding to the text
        /// format.</para>
        /// <para>posInDocument specifies the position of the object within the
        /// document.</para>
        /// <para>The default implementation resizes the item to the size returned
        /// by the object handler's intrinsicSize() function. This function is called
        /// only within Qt. Subclasses can reimplement this function to customize the
        /// resizing of inline objects.</para>
        /// </summary>
        protected virtual void ResizeInlineObject(QTextInlineObject item, int posInDocument, QTextFormat format)
        {
            var arg0 = ReferenceEquals(item, null) ? new QTextInlineObject.Internal() : *(QTextInlineObject.Internal*) (item.__Instance);
            var arg2 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.ResizeInlineObject_0(__Instance, arg0, posInDocument, arg2);
        }

        /// <summary>
        /// <para>Lays out the inline object item using the given text
        /// format.</para>
        /// <para>posInDocument specifies the position of the object within the
        /// document.</para>
        /// <para>The default implementation does nothing. This function is called
        /// only within Qt. Subclasses can reimplement this function to customize the
        /// position of inline objects.</para>
        /// <para>See also drawInlineObject().</para>
        /// </summary>
        protected virtual void PositionInlineObject(QTextInlineObject item, int posInDocument, QTextFormat format)
        {
            var arg0 = ReferenceEquals(item, null) ? new QTextInlineObject.Internal() : *(QTextInlineObject.Internal*) (item.__Instance);
            var arg2 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.PositionInlineObject_0(__Instance, arg0, posInDocument, arg2);
        }

        protected int FormatIndex(int pos)
        {
            var __ret = Internal.FormatIndex_0(__Instance, pos);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the character format that is applicable at the given
        /// position.</para>
        /// </summary>
        protected QTextCharFormat Format(int pos)
        {
            var __ret = new QtGui.QTextCharFormat.Internal();
            Internal.Format_0(new IntPtr(&__ret), __Instance, pos);
            return QTextCharFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the paint device used to render the document's
        /// layout.</para>
        /// <para>See also setPaintDevice().</para>
        /// <para></para>
        /// <para>Sets the paint device used for rendering the document's layout to
        /// the given device.</para>
        /// <para>See also paintDevice().</para>
        /// </summary>
        public QPaintDevice PaintDevice
        {
            get
            {
                var __ret = Internal.PaintDevice_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QPaintDeviceInternal.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetPaintDevice_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the number of pages contained in the layout.</para>
        /// <para>See also pageCountChanged().</para>
        /// </summary>
        public abstract int PageCount
        {
            get;
        }

        /// <summary>
        /// <para>Returns the text document that this layout is operating
        /// on.</para>
        /// </summary>
        public QTextDocument Document
        {
            get
            {
                var __ret = Internal.Document_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextDocument.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QAbstractTextDocumentLayout()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractTextDocumentLayout) _References[instance].Target;
            target.Dispose();
        }

        // void draw(QPainter *painter, const PaintContext &context)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Draw_0Delegate(global::System.IntPtr instance, global::System.IntPtr painter, global::System.IntPtr context);
        private static _Draw_0Delegate _Draw_0DelegateInstance;

        private static void _Draw_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr painter, global::System.IntPtr context)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractTextDocumentLayout) _References[instance].Target;
            target.Draw((painter == IntPtr.Zero) ? null : QPainter.__CreateInstance(painter), (context == IntPtr.Zero) ? null : QAbstractTextDocumentLayout.PaintContext.__CreateInstance(context));
        }

        // int pageCount()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate int _PageCount_0Delegate(global::System.IntPtr instance);
        private static _PageCount_0Delegate _PageCount_0DelegateInstance;

        private static int _PageCount_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractTextDocumentLayout) _References[instance].Target;
            var _ret = target.PageCount;
            return _ret;
        }

        // void documentChanged(int from, int charsRemoved, int charsAdded)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _DocumentChanged_0Delegate(global::System.IntPtr instance, int from, int charsRemoved, int charsAdded);
        private static _DocumentChanged_0Delegate _DocumentChanged_0DelegateInstance;

        private static void _DocumentChanged_0DelegateHook(global::System.IntPtr instance, int from, int charsRemoved, int charsAdded)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractTextDocumentLayout) _References[instance].Target;
            target.DocumentChanged(from, charsRemoved, charsAdded);
        }

        // void resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _ResizeInlineObject_0Delegate(global::System.IntPtr instance, QTextInlineObject.Internal item, int posInDocument, global::System.IntPtr format);
        private static _ResizeInlineObject_0Delegate _ResizeInlineObject_0DelegateInstance;

        private static void _ResizeInlineObject_0DelegateHook(global::System.IntPtr instance, QTextInlineObject.Internal item, int posInDocument, global::System.IntPtr format)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractTextDocumentLayout) _References[instance].Target;
            target.ResizeInlineObject(QTextInlineObject.__CreateInstance(item), posInDocument, (format == IntPtr.Zero) ? null : QTextFormat.__CreateInstance(format));
        }

        // void positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _PositionInlineObject_0Delegate(global::System.IntPtr instance, QTextInlineObject.Internal item, int posInDocument, global::System.IntPtr format);
        private static _PositionInlineObject_0Delegate _PositionInlineObject_0DelegateInstance;

        private static void _PositionInlineObject_0DelegateHook(global::System.IntPtr instance, QTextInlineObject.Internal item, int posInDocument, global::System.IntPtr format)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QAbstractTextDocumentLayout) _References[instance].Target;
            target.PositionInlineObject(QTextInlineObject.__CreateInstance(item), posInDocument, (format == IntPtr.Zero) ? null : QTextFormat.__CreateInstance(format));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Draw_0DelegateInstance += _Draw_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Draw_0DelegateInstance).ToPointer();
                _PageCount_0DelegateInstance += _PageCount_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_PageCount_0DelegateInstance).ToPointer();
                _DocumentChanged_0DelegateInstance += _DocumentChanged_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DocumentChanged_0DelegateInstance).ToPointer();
                _ResizeInlineObject_0DelegateInstance += _ResizeInlineObject_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ResizeInlineObject_0DelegateInstance).ToPointer();
                _PositionInlineObject_0DelegateInstance += _PositionInlineObject_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PositionInlineObject_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(21 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = *(void**)(native->vfptr0 + 52);
                *(void**)(vfptr0 + 56) = _Thunks[2];
                *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                *(void**)(vfptr0 + 68) = *(void**)(native->vfptr0 + 68);
                *(void**)(vfptr0 + 72) = _Thunks[3];
                *(void**)(vfptr0 + 76) = _Thunks[4];
                *(void**)(vfptr0 + 80) = _Thunks[5];
                *(void**)(vfptr0 + 84) = *(void**)(native->vfptr0 + 84);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextObjectInterface class allows drawing of custom text
    /// objects in QTextDocuments.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A text object describes the structure of one or more elements in
    /// a text document; for instance, images imported from HTML are implemented
    /// using text objects. A text object knows how to lay out and draw its
    /// elements when a document is being rendered.</para>
    /// <para>Qt allows custom text objects to be inserted into a document by
    /// registering a custom object type with QTextCharFormat. A
    /// QTextObjectInterface must also be implemented for this type and be
    /// registered with the QAbstractTextDocumentLayout of the document. When the
    /// object type is encountered while rendering a QTextDocument, the
    /// intrinsicSize() and drawObject() functions of the interface are
    /// called.</para>
    /// <para>The following list explains the required steps of inserting a
    /// custom text object into a document:</para>
    /// <para></para>
    /// <para>Choose an objectType. The objectType is an integer with a value
    /// greater or equal to QTextFormat::UserObject.</para>
    /// <para>Create a QTextCharFormat object and set the object type to the
    /// chosen type using the setObjectType() function.</para>
    /// <para>Implement the QTextObjectInterface class.</para>
    /// <para>Call QAbstractTextDocumentLayout::registerHandler() with an
    /// instance of your QTextObjectInterface subclass to register your object
    /// type.</para>
    /// <para>Insert QChar::ObjectReplacementCharacter with the aforementioned
    /// QTextCharFormat of the chosen object type into the document. As mentioned,
    /// the functions of QTextObjectInterface intrinsicSize() and drawObject() will
    /// then be called with the QTextFormat as parameter whenever the replacement
    /// character is encountered.</para>
    /// <para></para>
    /// <para>A class implementing a text object needs to inherit both QObject
    /// and QTextObjectInterface. QObject must be the first class inherited. For
    /// instance:</para>
    /// <para>class SvgTextObject : public QObject, public
    /// QTextObjectInterface</para>
    /// <para>{</para>
    /// <para>    Q_OBJECT</para>
    /// <para>    Q_INTERFACES(QTextObjectInterface)</para>
    /// <para>The data of a text object is usually stored in the
    /// QTextCharFormat using QTextCharFormat::setProperty(), and then retrieved
    /// with QTextCharFormat::property().</para>
    /// <para>Warning: Copy and Paste operations ignore custom text
    /// objects.</para>
    /// <para></para>
    /// <para>See also Text Object Example, QTextCharFormat, and
    /// QTextLayout.</para>
    /// </remarks>
    public unsafe abstract partial class QTextObjectInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextObjectInterfaceC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextObjectInterfaceD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QTextObjectInterface(QTextObjectInterface.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    internal unsafe partial class QAbstractTextDocumentLayoutInternal : QtGui.QAbstractTextDocumentLayout, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QAbstractTextDocumentLayoutInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QAbstractTextDocumentLayoutInternal((QAbstractTextDocumentLayout.Internal*) native);
        }

        public static QAbstractTextDocumentLayout __CreateInstance(QAbstractTextDocumentLayout.Internal native)
        {
            return new QAbstractTextDocumentLayoutInternal(native);
        }

        private static QAbstractTextDocumentLayout.Internal* __CopyValue(QAbstractTextDocumentLayout.Internal native)
        {
            var ret = (QAbstractTextDocumentLayout.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QAbstractTextDocumentLayoutInternal(QAbstractTextDocumentLayout.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QAbstractTextDocumentLayoutInternal(QAbstractTextDocumentLayout.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QAbstractTextDocumentLayout.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override void Draw(QPainter painter, QAbstractTextDocumentLayout.PaintContext context)
        {
            void* slot = *(void**) (((QAbstractTextDocumentLayout.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___Draw_0Delegate = (_Draw_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Draw_0Delegate));
            var arg0 = ReferenceEquals(painter, null) ? global::System.IntPtr.Zero : painter.__Instance;
            var arg1 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            ___Draw_0Delegate(__Instance, arg0, arg1);
        }

        protected override void DocumentChanged(int from, int charsRemoved, int charsAdded)
        {
            void* slot = *(void**) (((QAbstractTextDocumentLayout.Internal*) __Instance)->vfptr0 + 18 * 4);
            var ___DocumentChanged_0Delegate = (_DocumentChanged_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_DocumentChanged_0Delegate));
            ___DocumentChanged_0Delegate(__Instance, from, charsRemoved, charsAdded);
        }

        public override int PageCount
        {
            get
            {
                void* slot = *(void**) (((QAbstractTextDocumentLayout.Internal*) __Instance)->vfptr0 + 14 * 4);
                var ___PageCount_0Delegate = (_PageCount_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_PageCount_0Delegate));
                var __ret = ___PageCount_0Delegate(__Instance);
                return __ret;
            }
        }
    }

    internal unsafe partial class QTextObjectInterfaceInternal : QtGui.QTextObjectInterface, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QTextObjectInterfaceInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QTextObjectInterfaceInternal((QTextObjectInterface.Internal*) native);
        }

        public static QTextObjectInterface __CreateInstance(QTextObjectInterface.Internal native)
        {
            return new QTextObjectInterfaceInternal(native);
        }

        private static QTextObjectInterface.Internal* __CopyValue(QTextObjectInterface.Internal native)
        {
            var ret = (QTextObjectInterface.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QTextObjectInterfaceInternal(QTextObjectInterface.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextObjectInterfaceInternal(QTextObjectInterface.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextObjectInterface.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// <para>The QStaticText class enables optimized drawing of text when the
    /// text and its layout is updated rarely.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QStaticText provides a way to cache layout data for a block of
    /// text so that it can be drawn more efficiently than by using
    /// QPainter::drawText() in which the layout information is recalculated with
    /// every call.</para>
    /// <para>The class primarily provides an optimization for cases where the
    /// text, its font and the transformations on the painter are static over
    /// several paint events. If the text or its layout is changed for every
    /// iteration, QPainter::drawText() is the more efficient alternative, since
    /// the static text's layout would have to be recalculated to take the new
    /// state into consideration.</para>
    /// <para>Translating the painter will not cause the layout of the text to
    /// be recalculated, but will cause a very small performance impact on
    /// drawStaticText(). Altering any other parts of the painter's transformation
    /// or the painter's font will cause the layout of the static text to be
    /// recalculated. This should be avoided as often as possible to maximize the
    /// performance benefit of using QStaticText.</para>
    /// <para>In addition, only affine transformations are supported by
    /// drawStaticText(). Calling drawStaticText() on a projected painter will
    /// perform slightly worse than using the regular drawText() call, so this
    /// should be avoided.</para>
    /// <para>class MyWidget: public QWidget</para>
    /// <para>{</para>
    /// <para>public:</para>
    /// <para>    MyWidget(QWidget *parent = 0) : QWidget(parent),
    /// m_staticText(&quot;This is static text&quot;)</para>
    /// <para></para>
    /// <para>protected:</para>
    /// <para>    void paintEvent(QPaintEvent *)</para>
    /// <para>    {</para>
    /// <para>        QPainter painter(this);</para>
    /// <para>        painter.drawStaticText(0, 0, m_staticText);</para>
    /// <para>    }</para>
    /// <para></para>
    /// <para>private:</para>
    /// <para>    QStaticText m_staticText;</para>
    /// <para>};</para>
    /// <para>The QStaticText class can be used to mimic the behavior of
    /// QPainter::drawText() to a specific point with no boundaries, and also when
    /// QPainter::drawText() is called with a bounding rectangle.</para>
    /// <para>If a bounding rectangle is not required, create a QStaticText
    /// object without setting a preferred text width. The text will then occupy a
    /// single line.</para>
    /// <para>If you set a text width on the QStaticText object, this will
    /// bound the text. The text will be formatted so that no line exceeds the
    /// given width. The text width set for QStaticText will not automatically be
    /// used for clipping. To achieve clipping in addition to line breaks, use
    /// QPainter::setClipRect(). The position of the text is decided by the
    /// argument passed to QPainter::drawStaticText() and can change from call to
    /// call with a minimal impact on performance.</para>
    /// <para>For extra convenience, it is possible to apply formatting to the
    /// text using the HTML subset supported by QTextDocument. QStaticText will
    /// attempt to guess the format of the input text using Qt::mightBeRichText(),
    /// and interpret it as rich text if this function returns true. To force
    /// QStaticText to display its contents as either plain text or rich text, use
    /// the function QStaticText::setTextFormat() and pass in, respectively,
    /// Qt::PlainText and Qt::RichText.</para>
    /// <para>QStaticText can only represent text, so only HTML tags which
    /// alter the layout or appearance of the text will be respected. Adding an
    /// image to the input HTML, for instance, will cause the image to be included
    /// as part of the layout, affecting the positions of the text glyphs, but it
    /// will not be displayed. The result will be an empty area the size of the
    /// image in the output. Similarly, using tables will cause the text to be laid
    /// out in table format, but the borders will not be drawn.</para>
    /// <para>If it's the first time the static text is drawn, or if the static
    /// text, or the painter's font has been altered since the last time it was
    /// drawn, the text's layout has to be recalculated. On some paint engines,
    /// changing the matrix of the painter will also cause the layout to be
    /// recalculated. In particular, this will happen for any engine except for the
    /// OpenGL2 paint engine. Recalculating the layout will impose an overhead on
    /// the QPainter::drawStaticText() call where it occurs. To avoid this overhead
    /// in the paint event, you can call prepare() ahead of time to ensure that the
    /// layout is calculated.</para>
    /// <para></para>
    /// <para>See also QPainter::drawText(), QPainter::drawStaticText(),
    /// QTextLayout, and QTextDocument.</para>
    /// </remarks>
    public unsafe partial class QStaticText : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal QExplicitlySharedDataPointer.Internal data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticTextC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticTextC2ERK7QString")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticTextC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticTextD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticText7prepareERK10QTransformRK5QFont")]
            internal static extern void Prepare_0(global::System.IntPtr instance, global::System.IntPtr matrix, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStaticTexteqERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStaticTextneERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStaticText4textEv")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticText7setTextERK7QString")]
            internal static extern void SetText_0(global::System.IntPtr instance, global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStaticText10textOptionEv")]
            internal static extern void TextOption_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticText13setTextOptionERK11QTextOption")]
            internal static extern void SetTextOption_0(global::System.IntPtr instance, global::System.IntPtr textOption);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QStaticText15performanceHintEv")]
            internal static extern QStaticText.PerformanceHint performanceHint_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QStaticText18setPerformanceHintENS_15PerformanceHintE")]
            internal static extern void SetPerformanceHint_0(global::System.IntPtr instance, QStaticText.PerformanceHint performanceHint);
        }

        /// <summary>
        /// <para>This enum the different performance hints that can be set on the
        /// QStaticText. These hints can be used to indicate that the QStaticText
        /// should use additional caches, if possible, to improve performance at the
        /// expense of memory. In particular, setting the performance hint
        /// AggressiveCaching on the QStaticText will improve performance when using
        /// the OpenGL graphics system or when drawing to a QOpenGLWidget.</para>
        /// </summary>
        public enum PerformanceHint : uint
        {
            /// <summary>Do basic caching for high performance at a low memory cost.</summary>
            ModerateCaching = 0,
            /// <summary>Use additional caching when available. This may improve performance at a higher memory cost.</summary>
            AggressiveCaching = 1
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QStaticText __CreateInstance(global::System.IntPtr native)
        {
            return new QStaticText((QStaticText.Internal*) native);
        }

        public static QStaticText __CreateInstance(QStaticText.Internal native)
        {
            return new QStaticText(native);
        }

        private static QStaticText.Internal* __CopyValue(QStaticText.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QStaticText.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QStaticText.Internal*) ret;
        }

        private QStaticText(QStaticText.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QStaticText(QStaticText.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QStaticText</para>
        /// </summary>
        public QStaticText()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QStaticText object with the given text.</para>
        /// </summary>
        public QStaticText(string text)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Constructs a QStaticText object which is a copy of other.</para>
        /// </summary>
        public QStaticText(QStaticText other)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            Internal.cctor_2(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Prepares the QStaticText object for being painted with the given
        /// matrix and the given font to avoid overhead when the actual
        /// drawStaticText() call is made.</para>
        /// <para>When drawStaticText() is called, the layout of the QStaticText
        /// will be recalculated if any part of the QStaticText object has changed
        /// since the last time it was drawn. It will also be recalculated if the
        /// painter's font is not the same as when the QStaticText was last drawn, or,
        /// on any other paint engine than the OpenGL2 engine, if the painter's matrix
        /// has been altered since the static text was last drawn.</para>
        /// <para>To avoid the overhead of creating the layout the first time you
        /// draw the QStaticText after making changes, you can use the prepare()
        /// function and pass in the matrix and font you expect to use when drawing the
        /// text.</para>
        /// <para>See also QPainter::setFont() and QPainter::setMatrix().</para>
        /// </summary>
        public void Prepare(QTransform matrix, QFont font)
        {
            var arg0 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var arg1 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            Internal.Prepare_0(__Instance, arg0, arg1);
        }

        /// <summary>
        /// <para>Compares other to this QStaticText. Returns true if the texts,
        /// fonts and text widths are equal.</para>
        /// </summary>
        public static bool operator ==(QStaticText __op, QStaticText other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var arg0 = __op.__Instance;
            var arg1 = other.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as QStaticText;
        }

        /// <summary>
        /// <para>Compares other to this QStaticText. Returns true if the texts,
        /// fonts or maximum sizes are different.</para>
        /// </summary>
        public static bool operator !=(QStaticText __op, QStaticText other)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Prepares the QStaticText object for being painted with the given
        /// matrix and the given font to avoid overhead when the actual
        /// drawStaticText() call is made.</para>
        /// <para>When drawStaticText() is called, the layout of the QStaticText
        /// will be recalculated if any part of the QStaticText object has changed
        /// since the last time it was drawn. It will also be recalculated if the
        /// painter's font is not the same as when the QStaticText was last drawn, or,
        /// on any other paint engine than the OpenGL2 engine, if the painter's matrix
        /// has been altered since the static text was last drawn.</para>
        /// <para>To avoid the overhead of creating the layout the first time you
        /// draw the QStaticText after making changes, you can use the prepare()
        /// function and pass in the matrix and font you expect to use when drawing the
        /// text.</para>
        /// <para>See also QPainter::setFont() and QPainter::setMatrix().</para>
        /// </summary>
        public void Prepare(QFont font)
        {
            Prepare(new QTransform(), font);
        }

        /// <summary>
        /// <para>Prepares the QStaticText object for being painted with the given
        /// matrix and the given font to avoid overhead when the actual
        /// drawStaticText() call is made.</para>
        /// <para>When drawStaticText() is called, the layout of the QStaticText
        /// will be recalculated if any part of the QStaticText object has changed
        /// since the last time it was drawn. It will also be recalculated if the
        /// painter's font is not the same as when the QStaticText was last drawn, or,
        /// on any other paint engine than the OpenGL2 engine, if the painter's matrix
        /// has been altered since the static text was last drawn.</para>
        /// <para>To avoid the overhead of creating the layout the first time you
        /// draw the QStaticText after making changes, you can use the prepare()
        /// function and pass in the matrix and font you expect to use when drawing the
        /// text.</para>
        /// <para>See also QPainter::setFont() and QPainter::setMatrix().</para>
        /// </summary>
        public void Prepare(QTransform matrix)
        {
            Prepare(matrix, new QFont());
        }

        /// <summary>
        /// <para>Returns the text of the QStaticText.</para>
        /// <para>See also setText().</para>
        /// <para></para>
        /// <para>Sets the text of the QStaticText to text.</para>
        /// <para>Note: This function will cause the layout of the text to require
        /// recalculation.See also text().</para>
        /// </summary>
        public string Text
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Text_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetText_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the current text option used to control the layout
        /// process.</para>
        /// <para>See also setTextOption().</para>
        /// <para></para>
        /// <para>Sets the text option structure that controls the layout process
        /// to the given textOption.</para>
        /// <para>See also textOption().</para>
        /// </summary>
        public QTextOption TextOption
        {
            get
            {
                var __ret = new QtGui.QTextOption.Internal();
                Internal.TextOption_0(new IntPtr(&__ret), __Instance);
                return QTextOption.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetTextOption_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns which performance hint is set for the QStaticText.</para>
        /// <para>See also setPerformanceHint().</para>
        /// <para></para>
        /// <para>Sets the performance hint of the QStaticText according to the
        /// performanceHint provided. The performanceHint is used to customize how much
        /// caching is done internally to improve performance.</para>
        /// <para>The default is QStaticText::ModerateCaching.</para>
        /// <para>Note: This function will cause the layout of the text to require
        /// recalculation.See also performanceHint().</para>
        /// </summary>
        public QStaticText.PerformanceHint performanceHint
        {
            get
            {
                var __ret = Internal.performanceHint_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetPerformanceHint_0(__Instance, arg0);
            }
        }
    }

    /// <summary>
    /// <para>The QTextObject class is a base class for different kinds of
    /// objects that can group parts of a QTextDocument together.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The common grouping text objects are lists (QTextList), frames
    /// (QTextFrame), and tables (QTextTable). A text object has an associated
    /// format() and document().</para>
    /// <para>There are essentially two kinds of text objects: those that are
    /// used with blocks (block formats), and those that are used with characters
    /// (character formats). The first kind are derived from QTextBlockGroup, and
    /// the second kind from QTextFrame.</para>
    /// <para>You rarely need to use this class directly. When creating custom
    /// text objects, you will also need to reimplement
    /// QTextDocument::createObject() which acts as a factory method for creating
    /// text objects.</para>
    /// <para></para>
    /// <para>See also QTextDocument and Text Object Example.</para>
    /// </remarks>
    public unsafe partial class QTextObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextObjectC2EP13QTextDocument")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextObjectC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextObjectD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextObject6formatEv")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN11QTextObject9setFormatERK11QTextFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextObject11formatIndexEv")]
            internal static extern int FormatIndex_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextObject8documentEv")]
            internal static extern global::System.IntPtr Document_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextObject11objectIndexEv")]
            internal static extern int ObjectIndex_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextObject __CreateInstance(global::System.IntPtr native)
        {
            return new QTextObject((QTextObject.Internal*) native);
        }

        public static QTextObject __CreateInstance(QTextObject.Internal native)
        {
            return new QTextObject(native);
        }

        private static QTextObject.Internal* __CopyValue(QTextObject.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextObject.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextObject.Internal*) ret;
        }

        private QTextObject(QTextObject.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextObject(QTextObject.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Creates a new QTextObject for the given document.</para>
        /// <para>Warning: This function should never be called directly, but only
        /// from QTextDocument::createObject().</para>
        /// </summary>
        protected QTextObject(QTextDocument doc)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the text object's format.</para>
        /// <para>See also setFormat() and document().</para>
        /// <para></para>
        /// <para>Sets the text object's format.</para>
        /// <para>See also format().</para>
        /// </summary>
        public QTextFormat Format
        {
            get
            {
                var __ret = new QtGui.QTextFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QTextFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the index of the object's format in the document's
        /// internal list of formats.</para>
        /// <para>See also QTextDocument::allFormats().</para>
        /// </summary>
        public int FormatIndex
        {
            get
            {
                var __ret = Internal.FormatIndex_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the document this object belongs to.</para>
        /// <para>See also format().</para>
        /// </summary>
        public QTextDocument Document
        {
            get
            {
                var __ret = Internal.Document_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextDocument.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the object index of this object. This can be used
        /// together with QTextFormat::setObjectIndex().</para>
        /// </summary>
        public int ObjectIndex
        {
            get
            {
                var __ret = Internal.ObjectIndex_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QTextObject()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextObject) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextBlockGroup class provides a container for text blocks
    /// within a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Block groups can be used to organize blocks of text within a
    /// document. They maintain an up-to-date list of the text blocks that belong
    /// to them, even when text blocks are being edited.</para>
    /// <para>Each group has a parent document which is specified when the
    /// group is constructed.</para>
    /// <para>Text blocks can be inserted into a group with blockInserted(),
    /// and removed with blockRemoved(). If a block's format is changed,
    /// blockFormatChanged() is called.</para>
    /// <para>The list of blocks in the group is returned by blockList(). Note
    /// that the blocks in the list are not necessarily adjacent elements in the
    /// document; for example, the top-level items in a multi-level list will be
    /// separated by the items in lower levels of the list.</para>
    /// <para></para>
    /// <para>See also QTextBlock and QTextDocument.</para>
    /// </remarks>
    public unsafe partial class QTextBlockGroup : QtGui.QTextObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextBlockGroupC2EP13QTextDocument")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextBlockGroupC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextBlockGroupD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextBlockGroup13blockInsertedERK10QTextBlock")]
            internal static extern void BlockInserted_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextBlockGroup12blockRemovedERK10QTextBlock")]
            internal static extern void BlockRemoved_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN15QTextBlockGroup18blockFormatChangedERK10QTextBlock")]
            internal static extern void BlockFormatChanged_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK15QTextBlockGroup9blockListEv")]
            internal static extern QList.Internal BlockList_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextBlockGroup __CreateInstance(global::System.IntPtr native)
        {
            return new QTextBlockGroup((QTextBlockGroup.Internal*) native);
        }

        public static QTextBlockGroup __CreateInstance(QTextBlockGroup.Internal native)
        {
            return new QTextBlockGroup(native);
        }

        private static QTextBlockGroup.Internal* __CopyValue(QTextBlockGroup.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextBlockGroup.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextBlockGroup.Internal*) ret;
        }

        private QTextBlockGroup(QTextBlockGroup.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextBlockGroup(QTextBlockGroup.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextObject.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Creates a new new block group for the given document.</para>
        /// <para>Warning: This function should only be called from
        /// QTextDocument::createObject().</para>
        /// </summary>
        protected QTextBlockGroup(QTextDocument doc)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Appends the given block to the end of the group.</para>
        /// <para>Warning: If you reimplement this function you must call the base
        /// class implementation.</para>
        /// </summary>
        protected virtual void BlockInserted(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.BlockInserted_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Removes the given block from the group; the block itself is not
        /// deleted, it simply isn't a member of this group anymore.</para>
        /// </summary>
        protected virtual void BlockRemoved(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.BlockRemoved_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>This function is called whenever the specified block of text is
        /// changed. The text block is a member of this group.</para>
        /// <para>The base class implementation does nothing.</para>
        /// </summary>
        protected virtual void BlockFormatChanged(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.BlockFormatChanged_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns a (possibly empty) list of all the blocks that are part
        /// of the block group.</para>
        /// </summary>
        public System.Collections.Generic.IList<QTextBlock> BlockList
        {
            get
            {
                var __ret = Internal.BlockList_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTextBlock>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTextBlock.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        #region Virtual table interop

        // ~QTextBlockGroup()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextBlockGroup) _References[instance].Target;
            target.Dispose();
        }

        // void blockInserted(const QTextBlock &block)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _BlockInserted_0Delegate(global::System.IntPtr instance, global::System.IntPtr block);
        private static _BlockInserted_0Delegate _BlockInserted_0DelegateInstance;

        private static void _BlockInserted_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr block)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextBlockGroup) _References[instance].Target;
            target.BlockInserted((block == IntPtr.Zero) ? null : QTextBlock.__CreateInstance(block));
        }

        // void blockRemoved(const QTextBlock &block)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _BlockRemoved_0Delegate(global::System.IntPtr instance, global::System.IntPtr block);
        private static _BlockRemoved_0Delegate _BlockRemoved_0DelegateInstance;

        private static void _BlockRemoved_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr block)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextBlockGroup) _References[instance].Target;
            target.BlockRemoved((block == IntPtr.Zero) ? null : QTextBlock.__CreateInstance(block));
        }

        // void blockFormatChanged(const QTextBlock &block)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _BlockFormatChanged_0Delegate(global::System.IntPtr instance, global::System.IntPtr block);
        private static _BlockFormatChanged_0Delegate _BlockFormatChanged_0DelegateInstance;

        private static void _BlockFormatChanged_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr block)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextBlockGroup) _References[instance].Target;
            target.BlockFormatChanged((block == IntPtr.Zero) ? null : QTextBlock.__CreateInstance(block));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _BlockInserted_0DelegateInstance += _BlockInserted_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BlockInserted_0DelegateInstance).ToPointer();
                _BlockRemoved_0DelegateInstance += _BlockRemoved_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_BlockRemoved_0DelegateInstance).ToPointer();
                _BlockFormatChanged_0DelegateInstance += _BlockFormatChanged_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_BlockFormatChanged_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(14 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = _Thunks[3];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    public unsafe partial class QTextFrameLayoutData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextFrameLayoutDataC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN20QTextFrameLayoutDataD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextFrameLayoutData __CreateInstance(global::System.IntPtr native)
        {
            return new QTextFrameLayoutData((QTextFrameLayoutData.Internal*) native);
        }

        public static QTextFrameLayoutData __CreateInstance(QTextFrameLayoutData.Internal native)
        {
            return new QTextFrameLayoutData(native);
        }

        private static QTextFrameLayoutData.Internal* __CopyValue(QTextFrameLayoutData.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QTextFrameLayoutData.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QTextFrameLayoutData.Internal*) ret;
        }

        private QTextFrameLayoutData(QTextFrameLayoutData.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextFrameLayoutData(QTextFrameLayoutData.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // virtual ~QTextFrameLayoutData()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextFrameLayoutData) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextFrame class represents a frame in a
    /// QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Text frames provide structure for the text in a document. They
    /// are used as generic containers for other document elements. Frames are
    /// usually created by using QTextCursor::insertFrame().</para>
    /// <para>Frames can be used to create hierarchical structures in rich text
    /// documents. Each document has a root frame (QTextDocument::rootFrame()), and
    /// each frame beneath the root frame has a parent frame and a (possibly empty)
    /// list of child frames. The parent frame can be found with parentFrame(), and
    /// the childFrames() function provides a list of child frames.</para>
    /// <para>Each frame contains at least one text block to enable text
    /// cursors to insert new document elements within. As a result, the
    /// QTextFrame::iterator class is used to traverse both the blocks and child
    /// frames within a given frame. The first and last child elements in the frame
    /// can be found with begin() and end().</para>
    /// <para>A frame also has a format (specified using QTextFrameFormat)
    /// which can be set with setFormat() and read with format().</para>
    /// <para>Text cursors can be obtained that point to the first and last
    /// valid cursor positions within a frame; use the firstCursorPosition() and
    /// lastCursorPosition() functions for this. The frame's extent in the document
    /// can be found with firstPosition() and lastPosition().</para>
    /// <para>You can iterate over a frame's contents using the
    /// QTextFrame::iterator class: this provides read-only access to its internal
    /// list of text blocks and child frames.</para>
    /// <para></para>
    /// <para>See also QTextCursor and QTextDocument.</para>
    /// </remarks>
    public unsafe partial class QTextFrame : QtGui.QTextObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextFrameC2EP13QTextDocument")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextFrameC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextFrameD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame5beginEv")]
            internal static extern void Begin_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame3endEv")]
            internal static extern void End_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame10layoutDataEv")]
            internal static extern global::System.IntPtr LayoutData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextFrame13setLayoutDataEP20QTextFrameLayoutData")]
            internal static extern void SetLayoutData_0(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame19firstCursorPositionEv")]
            internal static extern void FirstCursorPosition_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame18lastCursorPositionEv")]
            internal static extern void LastCursorPosition_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame13firstPositionEv")]
            internal static extern int FirstPosition_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame12lastPositionEv")]
            internal static extern int LastPosition_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame11childFramesEv")]
            internal static extern QList.Internal ChildFrames_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextFrame11parentFrameEv")]
            internal static extern global::System.IntPtr ParentFrame_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>The iterator class provides an iterator for reading the contents
        /// of a QTextFrame.</para>
        /// </summary>
        /// <remarks>
        /// <para></para>
        /// <para>A frame consists of an arbitrary sequence of QTextBlocks and
        /// child QTextFrames. This class provides a way to iterate over the child
        /// objects of a frame, and read their contents. It does not provide a way to
        /// modify the contents of the frame.</para>
        /// </remarks>
        public unsafe partial class Iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 20)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr f;

                [FieldOffset(4)]
                public int b;

                [FieldOffset(8)]
                public int e;

                [FieldOffset(12)]
                public global::System.IntPtr cf;

                [FieldOffset(16)]
                public int cb;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextFrame8iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextFrame8iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr o);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextFrame8iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextFrame8iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK10QTextFrame8iterator12currentFrameEv")]
                internal static extern global::System.IntPtr CurrentFrame_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK10QTextFrame8iterator12currentBlockEv")]
                internal static extern void CurrentBlock_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Iterator __CreateInstance(global::System.IntPtr native)
            {
                return new Iterator((Iterator.Internal*) native);
            }

            public static Iterator __CreateInstance(Iterator.Internal native)
            {
                return new Iterator(native);
            }

            private static Iterator.Internal* __CopyValue(Iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(20);
                QtGui.QTextFrame.Iterator.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                return (Iterator.Internal*) ret;
            }

            private Iterator(Iterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Iterator(Iterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Constructs an invalid iterator.</para>
            /// </summary>
            public Iterator()
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                Internal.ctor_1(__Instance);
            }

            /// <summary>
            /// <para>Copy constructor. Constructs a copy of the other iterator.</para>
            /// </summary>
            public Iterator(QTextFrame.Iterator o)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                var arg0 = ReferenceEquals(o, null) ? global::System.IntPtr.Zero : o.__Instance;
                Internal.cctor_2(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            /// <summary>
            /// <para>Moves the iterator to the next frame or block.</para>
            /// <para>See also currentBlock() and currentFrame().</para>
            /// </summary>
            public static QTextFrame.Iterator operator ++(QTextFrame.Iterator __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextFrame.Iterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Moves the iterator to the previous frame or block.</para>
            /// <para>See also currentBlock() and currentFrame().</para>
            /// </summary>
            public static QTextFrame.Iterator operator --(QTextFrame.Iterator __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextFrame.Iterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the current frame pointed to by the iterator, or 0 if the
            /// iterator currently points to a block.</para>
            /// <para>See also currentBlock().</para>
            /// </summary>
            public QTextFrame CurrentFrame
            {
                get
                {
                    var __ret = Internal.CurrentFrame_0(__Instance);
                    if (__ret == global::System.IntPtr.Zero) return null;
                    return (__ret == IntPtr.Zero) ? null : QTextFrame.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>Returns the current block the iterator points to. If the iterator
            /// points to a child frame, the returned block is invalid.</para>
            /// <para>See also currentFrame().</para>
            /// </summary>
            public QTextBlock CurrentBlock
            {
                get
                {
                    var __ret = new QtGui.QTextBlock.Internal();
                    Internal.CurrentBlock_0(new IntPtr(&__ret), __Instance);
                    return QTextBlock.__CreateInstance(__ret);
                }
            }
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextFrame __CreateInstance(global::System.IntPtr native)
        {
            return new QTextFrame((QTextFrame.Internal*) native);
        }

        public static QTextFrame __CreateInstance(QTextFrame.Internal native)
        {
            return new QTextFrame(native);
        }

        private static QTextFrame.Internal* __CopyValue(QTextFrame.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextFrame.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextFrame.Internal*) ret;
        }

        private QTextFrame(QTextFrame.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextFrame(QTextFrame.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextObject.Internal*) native)
        {
        }

        /// <summary>
        /// <para>Creates a new empty frame for the text document.</para>
        /// </summary>
        public QTextFrame(QTextDocument doc)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Returns an iterator pointing to the first document element inside
        /// the frame. Please see the document STL-style-Iterators for more
        /// information.</para>
        /// <para>See also end().</para>
        /// </summary>
        public QTextFrame.Iterator Begin()
        {
            var __ret = new QtGui.QTextFrame.Iterator.Internal();
            Internal.Begin_0(new IntPtr(&__ret), __Instance);
            return QTextFrame.Iterator.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns an iterator pointing to the position past the last
        /// document element inside the frame. Please see the document STL-Style
        /// Iterators for more information.</para>
        /// <para>See also begin().</para>
        /// </summary>
        public QTextFrame.Iterator End()
        {
            var __ret = new QtGui.QTextFrame.Iterator.Internal();
            Internal.End_0(new IntPtr(&__ret), __Instance);
            return QTextFrame.Iterator.__CreateInstance(__ret);
        }

        public QTextFrameLayoutData LayoutData
        {
            get
            {
                var __ret = Internal.LayoutData_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextFrameLayoutData.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetLayoutData_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the first cursor position inside the frame.</para>
        /// <para>See also lastCursorPosition(), firstPosition(), and
        /// lastPosition().</para>
        /// </summary>
        public QTextCursor FirstCursorPosition
        {
            get
            {
                var __ret = new QtGui.QTextCursor.Internal();
                Internal.FirstCursorPosition_0(new IntPtr(&__ret), __Instance);
                return QTextCursor.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the last cursor position inside the frame.</para>
        /// <para>See also firstCursorPosition(), firstPosition(), and
        /// lastPosition().</para>
        /// </summary>
        public QTextCursor LastCursorPosition
        {
            get
            {
                var __ret = new QtGui.QTextCursor.Internal();
                Internal.LastCursorPosition_0(new IntPtr(&__ret), __Instance);
                return QTextCursor.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the first document position inside the frame.</para>
        /// <para>See also lastPosition(), firstCursorPosition(), and
        /// lastCursorPosition().</para>
        /// </summary>
        public int FirstPosition
        {
            get
            {
                var __ret = Internal.FirstPosition_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the last document position inside the frame.</para>
        /// <para>See also firstPosition(), firstCursorPosition(), and
        /// lastCursorPosition().</para>
        /// </summary>
        public int LastPosition
        {
            get
            {
                var __ret = Internal.LastPosition_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a (possibly empty) list of the frame's child
        /// frames.</para>
        /// <para>See also parentFrame().</para>
        /// </summary>
        public System.Collections.Generic.IList<QTextFrame> ChildFrames
        {
            get
            {
                var __ret = Internal.ChildFrames_0(__Instance);
                var __qlistData = QListData.__CreateInstance(__ret._0.p);
                var __size = __qlistData.Size;
                var __list = new System.Collections.Generic.List<QTextFrame>(__size);
                for (int i = 0; i < __size; i++)
                {
                    __list.Add(QTextFrame.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
                }
                return __list;
            }
        }

        /// <summary>
        /// <para>Returns the frame's parent frame. If the frame is the root frame
        /// of a document, this will return 0.</para>
        /// <para>See also childFrames() and QTextDocument::rootFrame().</para>
        /// </summary>
        public QTextFrame ParentFrame
        {
            get
            {
                var __ret = Internal.ParentFrame_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextFrame.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~QTextFrame()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextFrame) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextBlockUserData class is used to associate custom data
    /// with blocks of text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QTextBlockUserData provides an abstract interface for container
    /// classes that are used to associate application-specific user data with text
    /// blocks in a QTextDocument.</para>
    /// <para>Generally, subclasses of this class provide functions to allow
    /// data to be stored and retrieved, and instances are attached to blocks of
    /// text using QTextBlock::setUserData(). This makes it possible to store
    /// additional data per text block in a way that can be retrieved safely by the
    /// application.</para>
    /// <para>Each subclass should provide a reimplementation of the destructor
    /// to ensure that any private data is automatically cleaned up when user data
    /// objects are deleted.</para>
    /// <para></para>
    /// <para>See also QTextBlock.</para>
    /// </remarks>
    public unsafe partial class QTextBlockUserData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QTextBlockUserDataC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QTextBlockUserDataD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextBlockUserData __CreateInstance(global::System.IntPtr native)
        {
            return new QTextBlockUserData((QTextBlockUserData.Internal*) native);
        }

        public static QTextBlockUserData __CreateInstance(QTextBlockUserData.Internal native)
        {
            return new QTextBlockUserData(native);
        }

        private static QTextBlockUserData.Internal* __CopyValue(QTextBlockUserData.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QTextBlockUserData.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QTextBlockUserData.Internal*) ret;
        }

        private QTextBlockUserData(QTextBlockUserData.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextBlockUserData(QTextBlockUserData.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        #region Virtual table interop

        // virtual ~QTextBlockUserData()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextBlockUserData) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 4) = _Thunks[0];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextBlock class provides a container for text fragments in a
    /// QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A text block encapsulates a block or paragraph of text in a
    /// QTextDocument. QTextBlock provides read-only access to the block/paragraph
    /// structure of QTextDocuments. It is mainly of use if you want to implement
    /// your own layouts for the visual representation of a QTextDocument, or if
    /// you want to iterate over a document and write out the contents in your own
    /// custom format.</para>
    /// <para>Text blocks are created by their parent documents. If you need to
    /// create a new text block, or modify the contents of a document while
    /// examining its contents, use the cursor-based interface provided by
    /// QTextCursor instead.</para>
    /// <para>Each text block is located at a specific position() in a
    /// document(). The contents of the block can be obtained by using the text()
    /// function. The length() function determines the block's size within the
    /// document (including formatting characters). The visual properties of the
    /// block are determined by its text layout(), its charFormat(), and its
    /// blockFormat().</para>
    /// <para>The next() and previous() functions enable iteration over
    /// consecutive valid blocks in a document under the condition that the
    /// document is not modified by other means during the iteration process. Note
    /// that, although blocks are returned in sequence, adjacent blocks may come
    /// from different places in the document structure. The validity of a block
    /// can be determined by calling isValid().</para>
    /// <para>QTextBlock provides comparison operators to make it easier to
    /// work with blocks: operator==() compares two block for equality,
    /// operator!=() compares two blocks for inequality, and operator&lt;()
    /// determines whether a block precedes another in the same document.</para>
    /// <para></para>
    /// <para>See also QTextBlockFormat, QTextCharFormat, and
    /// QTextFragment.</para>
    /// </remarks>
    public unsafe partial class QTextBlock : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr p;

            [FieldOffset(4)]
            public int n;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlockC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr o);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8containsEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Contains_0(global::System.IntPtr instance, int position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlock11clearLayoutEv")]
            internal static extern void ClearLayout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock5beginEv")]
            internal static extern void Begin_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock3endEv")]
            internal static extern void End_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8userDataEv")]
            internal static extern global::System.IntPtr UserData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlock11setUserDataEP18QTextBlockUserData")]
            internal static extern void SetUserData_0(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock9userStateEv")]
            internal static extern int UserState_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlock12setUserStateEi")]
            internal static extern void SetUserState_0(global::System.IntPtr instance, int state);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8revisionEv")]
            internal static extern int Revision_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlock11setRevisionEi")]
            internal static extern void SetRevision_0(global::System.IntPtr instance, int rev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock9isVisibleEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Visible_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlock10setVisibleEb")]
            internal static extern void SetVisible_0(global::System.IntPtr instance, bool visible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock9lineCountEv")]
            internal static extern int LineCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextBlock12setLineCountEi")]
            internal static extern void SetLineCount_0(global::System.IntPtr instance, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock7isValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8positionEv")]
            internal static extern int Position_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock6lengthEv")]
            internal static extern int Length_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock6layoutEv")]
            internal static extern global::System.IntPtr Layout_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock11blockFormatEv")]
            internal static extern void BlockFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock16blockFormatIndexEv")]
            internal static extern int BlockFormatIndex_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock10charFormatEv")]
            internal static extern void CharFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock15charFormatIndexEv")]
            internal static extern int CharFormatIndex_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock4textEv")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8documentEv")]
            internal static extern global::System.IntPtr Document_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8textListEv")]
            internal static extern global::System.IntPtr TextList_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock11blockNumberEv")]
            internal static extern int BlockNumber_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock15firstLineNumberEv")]
            internal static extern int FirstLineNumber_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock4nextEv")]
            internal static extern void Next_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextBlock8previousEv")]
            internal static extern void Previous_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public unsafe partial class Iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr p;

                [FieldOffset(4)]
                public int b;

                [FieldOffset(8)]
                public int e;

                [FieldOffset(12)]
                public int n;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextBlock8iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr o);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextBlock8iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZN10QTextBlock8iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="_ZNK10QTextBlock8iterator8fragmentEv")]
                internal static extern void Fragment_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            private readonly bool __ownsNativeInstance;

            public static Iterator __CreateInstance(global::System.IntPtr native)
            {
                return new Iterator((Iterator.Internal*) native);
            }

            public static Iterator __CreateInstance(Iterator.Internal native)
            {
                return new Iterator(native);
            }

            private static Iterator.Internal* __CopyValue(Iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(16);
                QtGui.QTextBlock.Iterator.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                return (Iterator.Internal*) ret;
            }

            private Iterator(Iterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
            }

            protected Iterator(Iterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (__ownsNativeInstance)
                {
                    Marshal.FreeHGlobal(__Instance);
                }
            }

            /// <summary>
            /// <para>The prefix ++ operator (++i) advances the iterator to the next
            /// item in the hash and returns an iterator to the new current item.</para>
            /// </summary>
            public static QTextBlock.Iterator operator ++(QTextBlock.Iterator __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextBlock.Iterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>The prefix -- operator (--i) makes the preceding item current and
            /// returns an iterator pointing to the new current item.</para>
            /// </summary>
            public static QTextBlock.Iterator operator --(QTextBlock.Iterator __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextBlock.Iterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the text fragment the iterator currently points
            /// to.</para>
            /// </summary>
            public QTextFragment Fragment
            {
                get
                {
                    var __ret = new QtGui.QTextFragment.Internal();
                    Internal.Fragment_0(new IntPtr(&__ret), __Instance);
                    return QTextFragment.__CreateInstance(__ret);
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextBlock __CreateInstance(global::System.IntPtr native)
        {
            return new QTextBlock((QTextBlock.Internal*) native);
        }

        public static QTextBlock __CreateInstance(QTextBlock.Internal native)
        {
            return new QTextBlock(native);
        }

        private static QTextBlock.Internal* __CopyValue(QTextBlock.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextBlock.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextBlock.Internal*) ret;
        }

        private QTextBlock(QTextBlock.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextBlock(QTextBlock.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if the given position is located within the text
        /// block; otherwise returns false.</para>
        /// </summary>
        public bool Contains(int position)
        {
            var __ret = Internal.Contains_0(__Instance, position);
            return __ret;
        }

        /// <summary>
        /// <para>Clears the QTextLayout that is used to lay out and display the
        /// block's contents.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also layout().</para>
        /// </summary>
        public void ClearLayout()
        {
            Internal.ClearLayout_0(__Instance);
        }

        /// <summary>
        /// <para>Returns a text block iterator pointing to the beginning of the
        /// text block.</para>
        /// <para>See also end().</para>
        /// </summary>
        public QTextBlock.Iterator Begin()
        {
            var __ret = new QtGui.QTextBlock.Iterator.Internal();
            Internal.Begin_0(new IntPtr(&__ret), __Instance);
            return QTextBlock.Iterator.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a text block iterator pointing to the end of the text
        /// block.</para>
        /// <para>See also begin(), next(), and previous().</para>
        /// </summary>
        public QTextBlock.Iterator End()
        {
            var __ret = new QtGui.QTextBlock.Iterator.Internal();
            Internal.End_0(new IntPtr(&__ret), __Instance);
            return QTextBlock.Iterator.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a pointer to a QTextBlockUserData object if previously
        /// set with setUserData() or a null pointer.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also setUserData().</para>
        /// <para></para>
        /// <para>Attaches the given data object to the text block.</para>
        /// <para>QTextBlockUserData can be used to store custom settings. The
        /// ownership is passed to the underlying text document, i.e. the provided
        /// QTextBlockUserData object will be deleted if the corresponding text block
        /// gets deleted. The user data object is not stored in the undo history, so it
        /// will not be available after undoing the deletion of a text block.</para>
        /// <para>For example, if you write a programming editor in an IDE, you may
        /// want to let your user set breakpoints visually in your code for an
        /// integrated debugger. In a programming editor a line of text usually
        /// corresponds to one QTextBlock. The QTextBlockUserData interface allows the
        /// developer to store data for each QTextBlock, like for example in which
        /// lines of the source code the user has a breakpoint set. Of course this
        /// could also be stored externally, but by storing it inside the
        /// QTextDocument, it will for example be automatically deleted when the user
        /// deletes the associated line. It's really just a way to store custom
        /// information in the QTextDocument without using custom properties in
        /// QTextFormat which would affect the undo/redo stack.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also userData().</para>
        /// </summary>
        public QTextBlockUserData UserData
        {
            get
            {
                var __ret = Internal.UserData_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextBlockUserData.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetUserData_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the integer value previously set with setUserState() or
        /// -1.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also setUserState().</para>
        /// <para></para>
        /// <para>Stores the specified state integer value in the text block. This
        /// may be useful for example in a syntax highlighter to store a text parsing
        /// state.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also userState().</para>
        /// </summary>
        public int UserState
        {
            get
            {
                var __ret = Internal.UserState_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetUserState_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the blocks revision.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setRevision() and QTextDocument::revision().</para>
        /// <para></para>
        /// <para>Sets a blocks revision to rev.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also revision() and QTextDocument::revision().</para>
        /// </summary>
        public int Revision
        {
            get
            {
                var __ret = Internal.Revision_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetRevision_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if the block is visible; otherwise returns
        /// false.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also setVisible().</para>
        /// <para></para>
        /// <para>Sets the block's visibility to visible.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also isVisible().</para>
        /// </summary>
        public bool Visible
        {
            get
            {
                var __ret = Internal.Visible_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetVisible_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the line count. Not all document layouts support this
        /// feature.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also setLineCount().</para>
        /// <para></para>
        /// <para>Sets the line count to count.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also lineCount().</para>
        /// </summary>
        public int LineCount
        {
            get
            {
                var __ret = Internal.LineCount_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetLineCount_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns true if this text block is valid; otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsValid
        {
            get
            {
                var __ret = Internal.IsValid_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the index of the block's first character within the
        /// document.</para>
        /// </summary>
        public int Position
        {
            get
            {
                var __ret = Internal.Position_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the length of the block in characters.</para>
        /// <para>Note: The length returned includes all formatting characters, for
        /// example, newline.See also text(), charFormat(), and blockFormat().</para>
        /// </summary>
        public int Length
        {
            get
            {
                var __ret = Internal.Length_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the QTextLayout that is used to lay out and display the
        /// block's contents.</para>
        /// <para>Note that the returned QTextLayout object can only be modified
        /// from the documentChanged implementation of a QAbstractTextDocumentLayout
        /// subclass. Any changes applied from the outside cause undefined
        /// behavior.</para>
        /// <para>See also clearLayout().</para>
        /// </summary>
        public QTextLayout Layout
        {
            get
            {
                var __ret = Internal.Layout_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextLayout.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the QTextBlockFormat that describes block-specific
        /// properties.</para>
        /// <para>See also charFormat().</para>
        /// </summary>
        public QTextBlockFormat BlockFormat
        {
            get
            {
                var __ret = new QtGui.QTextBlockFormat.Internal();
                Internal.BlockFormat_0(new IntPtr(&__ret), __Instance);
                return QTextBlockFormat.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns an index into the document's internal list of block
        /// formats for the text block's format.</para>
        /// <para>See also QTextDocument::allFormats().</para>
        /// </summary>
        public int BlockFormatIndex
        {
            get
            {
                var __ret = Internal.BlockFormatIndex_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the QTextCharFormat that describes the block's character
        /// format. The block's character format is used when inserting text into an
        /// empty block.</para>
        /// <para>See also blockFormat().</para>
        /// </summary>
        public QTextCharFormat CharFormat
        {
            get
            {
                var __ret = new QtGui.QTextCharFormat.Internal();
                Internal.CharFormat_0(new IntPtr(&__ret), __Instance);
                return QTextCharFormat.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns an index into the document's internal list of character
        /// formats for the text block's character format.</para>
        /// <para>See also QTextDocument::allFormats().</para>
        /// </summary>
        public int CharFormatIndex
        {
            get
            {
                var __ret = Internal.CharFormatIndex_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the block's contents as plain text.</para>
        /// <para>See also length(), charFormat(), and blockFormat().</para>
        /// </summary>
        public string Text
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Text_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }

        /// <summary>
        /// <para>Returns the text document this text block belongs to, or 0 if the
        /// text block does not belong to any document.</para>
        /// </summary>
        public QTextDocument Document
        {
            get
            {
                var __ret = Internal.Document_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextDocument.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>If the block represents a list item, returns the list that the
        /// item belongs to; otherwise returns 0.</para>
        /// </summary>
        public QTextList TextList
        {
            get
            {
                var __ret = Internal.TextList_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextList.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the number of this block, or -1 if the block is
        /// invalid.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// <para>See also QTextCursor::blockNumber().</para>
        /// </summary>
        public int BlockNumber
        {
            get
            {
                var __ret = Internal.BlockNumber_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the first line number of this block, or -1 if the block
        /// is invalid. Unless the layout supports it, the line number is identical to
        /// the block number.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also QTextBlock::blockNumber().</para>
        /// </summary>
        public int FirstLineNumber
        {
            get
            {
                var __ret = Internal.FirstLineNumber_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the text block in the document after this block, or an
        /// empty text block if this is the last one.</para>
        /// <para>Note that the next block may be in a different frame or table to
        /// this block.</para>
        /// <para>See also previous(), begin(), and end().</para>
        /// </summary>
        public QTextBlock Next
        {
            get
            {
                var __ret = new QtGui.QTextBlock.Internal();
                Internal.Next_0(new IntPtr(&__ret), __Instance);
                return QTextBlock.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the text block in the document before this block, or an
        /// empty text block if this is the first one.</para>
        /// <para>Note that the next block may be in a different frame or table to
        /// this block.</para>
        /// <para>See also next(), begin(), and end().</para>
        /// </summary>
        public QTextBlock Previous
        {
            get
            {
                var __ret = new QtGui.QTextBlock.Internal();
                Internal.Previous_0(new IntPtr(&__ret), __Instance);
                return QTextBlock.__CreateInstance(__ret);
            }
        }
    }

    /// <summary>
    /// <para>The QTextFragment class holds a piece of text in a QTextDocument
    /// with a single QTextCharFormat.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A text fragment describes a piece of text that is stored with a
    /// single character format. Text in which the character format changes can be
    /// represented by sequences of text fragments with different formats.</para>
    /// <para>If the user edits the text in a fragment and introduces a
    /// different character format, the fragment's text will be split at each point
    /// where the format changes, and new fragments will be created. For example,
    /// changing the style of some text in the middle of a sentence will cause the
    /// fragment to be broken into three separate fragments: the first and third
    /// with the same format as before, and the second with the new style. The
    /// first fragment will contain the text from the beginning of the sentence,
    /// the second will contain the text from the middle, and the third takes the
    /// text from the end of the sentence.</para>
    /// <para>A fragment's text and character format can be obtained with the
    /// text() and charFormat() functions. The length() function gives the length
    /// of the text in the fragment. position() gives the position in the document
    /// of the start of the fragment. To determine whether the fragment contains a
    /// particular position within the document, use the contains()
    /// function.</para>
    /// <para></para>
    /// <para>See also QTextDocument and Rich Text Document Structure.</para>
    /// </remarks>
    public unsafe partial class QTextFragment : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr p;

            [FieldOffset(4)]
            public int n;

            [FieldOffset(8)]
            public int ne;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QTextFragmentC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr o);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment8containsEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Contains_0(global::System.IntPtr instance, int position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment9glyphRunsEii")]
            internal static extern QList.Internal GlyphRuns_0(global::System.IntPtr instance, int from, int length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment8positionEv")]
            internal static extern int Position_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment6lengthEv")]
            internal static extern int Length_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment10charFormatEv")]
            internal static extern void CharFormat_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment15charFormatIndexEv")]
            internal static extern int CharFormatIndex_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QTextFragment4textEv")]
            internal static extern void Text_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextFragment __CreateInstance(global::System.IntPtr native)
        {
            return new QTextFragment((QTextFragment.Internal*) native);
        }

        public static QTextFragment __CreateInstance(QTextFragment.Internal native)
        {
            return new QTextFragment(native);
        }

        private static QTextFragment.Internal* __CopyValue(QTextFragment.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QTextFragment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QTextFragment.Internal*) ret;
        }

        private QTextFragment(QTextFragment.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextFragment(QTextFragment.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns true if the text fragment contains the text at the given
        /// position in the document; otherwise returns false.</para>
        /// </summary>
        public bool Contains(int position)
        {
            var __ret = Internal.Contains_0(__Instance, position);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the glyphs corresponding to len characters of this text
        /// fragment starting at position pos. The positions of the glyphs are relative
        /// to the position of the QTextBlock's layout.</para>
        /// <para>If pos is less than zero, it will default to the start of the
        /// QTextFragment. If len is less than zero, it will default to the length of
        /// the fragment.</para>
        /// <para>See also QGlyphRun, QTextBlock::layout(),
        /// QTextLayout::position(), and QPainter::drawGlyphRun().</para>
        /// </summary>
        public System.Collections.Generic.IList<QGlyphRun> GlyphRuns(int from = -1, int length = -1)
        {
            var __ret = Internal.GlyphRuns_0(__Instance, from, length);
            var __qlistData = QListData.__CreateInstance(__ret._0.p);
            var __size = __qlistData.Size;
            var __list = new System.Collections.Generic.List<QGlyphRun>(__size);
            for (int i = 0; i < __size; i++)
            {
                __list.Add(QGlyphRun.__CreateInstance(new global::System.IntPtr(__qlistData.At(i))));
            }
            return __list;
        }

        /// <summary>
        /// <para>Returns the position of this text fragment in the
        /// document.</para>
        /// </summary>
        public int Position
        {
            get
            {
                var __ret = Internal.Position_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of characters in the text fragment.</para>
        /// <para>See also text().</para>
        /// </summary>
        public int Length
        {
            get
            {
                var __ret = Internal.Length_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the text fragment's character format.</para>
        /// <para>See also text().</para>
        /// </summary>
        public QTextCharFormat CharFormat
        {
            get
            {
                var __ret = new QtGui.QTextCharFormat.Internal();
                Internal.CharFormat_0(new IntPtr(&__ret), __Instance);
                return QTextCharFormat.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns an index into the document's internal list of character
        /// formats for the text fragment's character format.</para>
        /// <para>See also QTextDocument::allFormats().</para>
        /// </summary>
        public int CharFormatIndex
        {
            get
            {
                var __ret = Internal.CharFormatIndex_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the text fragment's as plain text.</para>
        /// <para>See also length() and charFormat().</para>
        /// </summary>
        public string Text
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.Text_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }
        }
    }

    /// <summary>
    /// <para>The QSyntaxHighlighter class allows you to define syntax
    /// highlighting rules, and in addition you can use the class to query a
    /// document's current formatting or user data.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The QSyntaxHighlighter class is a base class for implementing
    /// QTextDocument syntax highlighters. A syntax highligher automatically
    /// highlights parts of the text in a QTextDocument. Syntax highlighters are
    /// often used when the user is entering text in a specific format (for example
    /// source code) and help the user to read the text and identify syntax
    /// errors.</para>
    /// <para>To provide your own syntax highlighting, you must subclass
    /// QSyntaxHighlighter and reimplement highlightBlock().</para>
    /// <para>When you create an instance of your QSyntaxHighlighter subclass,
    /// pass it the QTextDocument that you want the syntax highlighting to be
    /// applied to. For example:</para>
    /// <para>QTextEdit *editor = new QTextEdit;</para>
    /// <para>MyHighlighter *highlighter = new
    /// MyHighlighter(editor-&gt;document());</para>
    /// <para>After this your highlightBlock() function will be called
    /// automatically whenever necessary. Use your highlightBlock() function to
    /// apply formatting (e.g. setting the font and color) to the text that is
    /// passed to it. QSyntaxHighlighter provides the setFormat() function which
    /// applies a given QTextCharFormat on the current text block. For
    /// example:</para>
    /// <para>void MyHighlighter::highlightBlock(const QString
    /// &amp;text)</para>
    /// <para>{</para>
    /// <para>    QTextCharFormat myClassFormat;</para>
    /// <para>    myClassFormat.setFontWeight(QFont::Bold);</para>
    /// <para>    myClassFormat.setForeground(Qt::darkMagenta);</para>
    /// <para>    QString pattern = &quot;\\bMy[A-Za-z]+\\b&quot;;</para>
    /// <para></para>
    /// <para>    QRegExp expression(pattern);</para>
    /// <para>    int index = text.indexOf(expression);</para>
    /// <para>    while (index &gt;= 0) {</para>
    /// <para>        int length = expression.matchedLength();</para>
    /// <para>        setFormat(index, length, myClassFormat);</para>
    /// <para>        index = text.indexOf(expression, index + length);</para>
    /// <para>    }</para>
    /// <para>}</para>
    /// <para>Some syntaxes can have constructs that span several text blocks.
    /// For example, a C++ syntax highlighter should be able to cope with /*...*/
    /// multiline comments. To deal with these cases it is necessary to know the
    /// end state of the previous text block (e.g. &quot;in comment&quot;).</para>
    /// <para>Inside your highlightBlock() implementation you can query the end
    /// state of the previous text block using the previousBlockState() function.
    /// After parsing the block you can save the last state using
    /// setCurrentBlockState().</para>
    /// <para>The currentBlockState() and previousBlockState() functions return
    /// an int value. If no state is set, the returned value is -1. You can
    /// designate any other value to identify any given state using the
    /// setCurrentBlockState() function. Once the state is set the QTextBlock keeps
    /// that value until it is set set again or until the corresponding paragraph
    /// of text is deleted.</para>
    /// <para>For example, if you're writing a simple C++ syntax highlighter,
    /// you might designate 1 to signify &quot;in comment&quot;:</para>
    /// <para>QTextCharFormat multiLineCommentFormat;</para>
    /// <para>multiLineCommentFormat.setForeground(Qt::red);</para>
    /// <para></para>
    /// <para>QRegExp startExpression(&quot;/\\*&quot;);</para>
    /// <para>QRegExp endExpression(&quot;\\*/&quot;);</para>
    /// <para></para>
    /// <para>setCurrentBlockState(0);</para>
    /// <para></para>
    /// <para>int startIndex = 0;</para>
    /// <para>if (previousBlockState() != 1)</para>
    /// <para>    startIndex = text.indexOf(startExpression);</para>
    /// <para></para>
    /// <para>while (startIndex &gt;= 0) {</para>
    /// <para>   int endIndex = text.indexOf(endExpression, startIndex);</para>
    /// <para>   int commentLength;</para>
    /// <para>   if (endIndex == -1) {</para>
    /// <para>       setCurrentBlockState(1);</para>
    /// <para>       commentLength = text.length() - startIndex;</para>
    /// <para>   } else {</para>
    /// <para>       commentLength = endIndex - startIndex</para>
    /// <para>                       + endExpression.matchedLength();</para>
    /// <para>   }</para>
    /// <para>   setFormat(startIndex, commentLength,
    /// multiLineCommentFormat);</para>
    /// <para>   startIndex = text.indexOf(startExpression,</para>
    /// <para>                             startIndex + commentLength);</para>
    /// <para>}</para>
    /// <para>In the example above, we first set the current block state to 0.
    /// Then, if the previous block ended within a comment, we higlight from the
    /// beginning of the current block (startIndex = 0). Otherwise, we search for
    /// the given start expression. If the specified end expression cannot be found
    /// in the text block, we change the current block state by calling
    /// setCurrentBlockState(), and make sure that the rest of the block is
    /// higlighted.</para>
    /// <para>In addition you can query the current formatting and user data
    /// using the format() and currentBlockUserData() functions respectively. You
    /// can also attach user data to the current text block using the
    /// setCurrentBlockUserData() function. QTextBlockUserData can be used to store
    /// custom settings. In the case of syntax highlighting, it is in particular
    /// interesting as cache storage for information that you may figure out while
    /// parsing the paragraph's text. For an example, see the
    /// setCurrentBlockUserData() documentation.</para>
    /// <para></para>
    /// <para>See also QTextDocument and Syntax Highlighter Example.</para>
    /// </remarks>
    public unsafe abstract partial class QSyntaxHighlighter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighterC2EP13QTextDocument")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighterC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighterD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter11rehighlightEv")]
            internal static extern void Rehighlight_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter16rehighlightBlockERK10QTextBlock")]
            internal static extern void RehighlightBlock_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter9setFormatEiiRK15QTextCharFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, int start, int count, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter9setFormatEiiRK6QColor")]
            internal static extern void SetFormat_1(global::System.IntPtr instance, int start, int count, global::System.IntPtr color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter9setFormatEiiRK5QFont")]
            internal static extern void SetFormat_2(global::System.IntPtr instance, int start, int count, global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QSyntaxHighlighter6formatEi")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance, int pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QSyntaxHighlighter8documentEv")]
            internal static extern global::System.IntPtr Document_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter11setDocumentEP13QTextDocument")]
            internal static extern void SetDocument_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QSyntaxHighlighter17currentBlockStateEv")]
            internal static extern int CurrentBlockState_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter20setCurrentBlockStateEi")]
            internal static extern void SetCurrentBlockState_0(global::System.IntPtr instance, int newState);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QSyntaxHighlighter20currentBlockUserDataEv")]
            internal static extern global::System.IntPtr CurrentBlockUserData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN18QSyntaxHighlighter23setCurrentBlockUserDataEP18QTextBlockUserData")]
            internal static extern void SetCurrentBlockUserData_0(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QSyntaxHighlighter18previousBlockStateEv")]
            internal static extern int PreviousBlockState_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK18QSyntaxHighlighter12currentBlockEv")]
            internal static extern void CurrentBlock_0(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QSyntaxHighlighter(QSyntaxHighlighter.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        /// <summary>
        /// <para>Constructs a QSyntaxHighlighter and installs it on parent. The
        /// specified QTextDocument also becomes the owner of the
        /// QSyntaxHighlighter.</para>
        /// </summary>
        protected QSyntaxHighlighter(QTextDocument parent)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            Internal.ctor_1(__Instance, arg0);
            SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Reapplies the highlighting to the whole document.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also rehighlightBlock().</para>
        /// </summary>
        public void Rehighlight()
        {
            Internal.Rehighlight_0(__Instance);
        }

        /// <summary>
        /// <para>Reapplies the highlighting to the given QTextBlock block.</para>
        /// <para>This function was introduced in  Qt 4.6.</para>
        /// <para>See also rehighlight().</para>
        /// </summary>
        public void RehighlightBlock(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.RehighlightBlock_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Highlights the given text block. This function is called when
        /// necessary by the rich text engine, i.e. on text blocks which have
        /// changed.</para>
        /// <para>To provide your own syntax highlighting, you must subclass
        /// QSyntaxHighlighter and reimplement highlightBlock(). In your
        /// reimplementation you should parse the block's text and call setFormat() as
        /// often as necessary to apply any font and color changes that you require.
        /// For example:</para>
        /// <para>void MyHighlighter::highlightBlock(const QString
        /// &amp;text)</para>
        /// <para>{</para>
        /// <para>    QTextCharFormat myClassFormat;</para>
        /// <para>    myClassFormat.setFontWeight(QFont::Bold);</para>
        /// <para>    myClassFormat.setForeground(Qt::darkMagenta);</para>
        /// <para>    QString pattern = &quot;\\bMy[A-Za-z]+\\b&quot;;</para>
        /// <para></para>
        /// <para>    QRegExp expression(pattern);</para>
        /// <para>    int index = text.indexOf(expression);</para>
        /// <para>    while (index &gt;= 0) {</para>
        /// <para>        int length = expression.matchedLength();</para>
        /// <para>        setFormat(index, length, myClassFormat);</para>
        /// <para>        index = text.indexOf(expression, index + length);</para>
        /// <para>     }</para>
        /// <para> }</para>
        /// <para>Some syntaxes can have constructs that span several text blocks.
        /// For example, a C++ syntax highlighter should be able to cope with /*...*/
        /// multiline comments. To deal with these cases it is necessary to know the
        /// end state of the previous text block (e.g. &quot;in comment&quot;).</para>
        /// <para>Inside your highlightBlock() implementation you can query the end
        /// state of the previous text block using the previousBlockState() function.
        /// After parsing the block you can save the last state using
        /// setCurrentBlockState().</para>
        /// <para>The currentBlockState() and previousBlockState() functions return
        /// an int value. If no state is set, the returned value is -1. You can
        /// designate any other value to identify any given state using the
        /// setCurrentBlockState() function. Once the state is set the QTextBlock keeps
        /// that value until it is set set again or until the corresponding paragraph
        /// of text gets deleted.</para>
        /// <para>For example, if you're writing a simple C++ syntax highlighter,
        /// you might designate 1 to signify &quot;in comment&quot;. For a text block
        /// that ended in the middle of a comment you'd set 1 using
        /// setCurrentBlockState, and for other paragraphs you'd set 0. In your parsing
        /// code if the return value of previousBlockState() is 1, you would highlight
        /// the text as a C++ comment until you reached the closing */.</para>
        /// <para>See also previousBlockState(), setFormat(), and
        /// setCurrentBlockState().</para>
        /// </summary>
        protected abstract void HighlightBlock(string text);

        /// <summary>
        /// <para>This function is applied to the syntax highlighter's current text
        /// block (i.e. the text that is passed to the highlightBlock()
        /// function).</para>
        /// <para>The specified format is applied to the text from the start
        /// position for a length of count characters (if count is 0, nothing is done).
        /// The formatting properties set in format are merged at display time with the
        /// formatting information stored directly in the document, for example as
        /// previously set with QTextCursor's functions. Note that the document itself
        /// remains unmodified by the format set through this function.</para>
        /// <para>See also format() and highlightBlock().</para>
        /// </summary>
        protected void SetFormat(int start, int count, QTextCharFormat format)
        {
            var arg2 = ReferenceEquals(format, null) ? global::System.IntPtr.Zero : format.__Instance;
            Internal.SetFormat_0(__Instance, start, count, arg2);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>The specified color is applied to the current text block from the
        /// start position for a length of count characters.</para>
        /// <para>The other attributes of the current text block, e.g. the font and
        /// background color, are reset to default values.</para>
        /// <para>See also format() and highlightBlock().</para>
        /// </summary>
        protected void SetFormat(int start, int count, QColor color)
        {
            var arg2 = ReferenceEquals(color, null) ? global::System.IntPtr.Zero : color.__Instance;
            Internal.SetFormat_1(__Instance, start, count, arg2);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>The specified font is applied to the current text block from the
        /// start position for a length of count characters.</para>
        /// <para>The other attributes of the current text block, e.g. the font and
        /// background color, are reset to default values.</para>
        /// <para>See also format() and highlightBlock().</para>
        /// </summary>
        protected void SetFormat(int start, int count, QFont font)
        {
            var arg2 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            Internal.SetFormat_2(__Instance, start, count, arg2);
        }

        /// <summary>
        /// <para>Returns the format at position inside the syntax highlighter's
        /// current text block.</para>
        /// <para>See also setFormat().</para>
        /// </summary>
        protected QTextCharFormat Format(int pos)
        {
            var __ret = new QtGui.QTextCharFormat.Internal();
            Internal.Format_0(new IntPtr(&__ret), __Instance, pos);
            return QTextCharFormat.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the QTextDocument on which this syntax highlighter is
        /// installed.</para>
        /// <para>See also setDocument().</para>
        /// <para></para>
        /// <para>Installs the syntax highlighter on the given QTextDocument doc. A
        /// QSyntaxHighlighter can only be used with one document at a time.</para>
        /// <para>See also document().</para>
        /// </summary>
        public QTextDocument Document
        {
            get
            {
                var __ret = Internal.Document_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextDocument.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetDocument_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the state of the current text block. If no value is set,
        /// the returned value is -1.</para>
        /// <para>See also setCurrentBlockState().</para>
        /// <para></para>
        /// <para>Sets the state of the current text block to newState.</para>
        /// <para>See also currentBlockState() and highlightBlock().</para>
        /// </summary>
        public int CurrentBlockState
        {
            get
            {
                var __ret = Internal.CurrentBlockState_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetCurrentBlockState_0(__Instance, value);
            }
        }

        /// <summary>
        /// <para>Returns the QTextBlockUserData object previously attached to the
        /// current text block.</para>
        /// <para>See also QTextBlock::userData() and
        /// setCurrentBlockUserData().</para>
        /// <para></para>
        /// <para>Attaches the given data to the current text block. The ownership
        /// is passed to the underlying text document, i.e. the provided
        /// QTextBlockUserData object will be deleted if the corresponding text block
        /// gets deleted.</para>
        /// <para>QTextBlockUserData can be used to store custom settings. In the
        /// case of syntax highlighting, it is in particular interesting as cache
        /// storage for information that you may figure out while parsing the
        /// paragraph's text.</para>
        /// <para>For example while parsing the text, you can keep track of
        /// parenthesis characters that you encounter ('{[(' and the like), and store
        /// their relative position and the actual QChar in a simple class derived from
        /// QTextBlockUserData:</para>
        /// <para>struct ParenthesisInfo</para>
        /// <para>{</para>
        /// <para>    QChar char;</para>
        /// <para>    int position;</para>
        /// <para>};</para>
        /// <para></para>
        /// <para>struct BlockData : public QTextBlockUserData</para>
        /// <para>{</para>
        /// <para>    QVector&lt;ParenthesisInfo&gt; parentheses;</para>
        /// <para>};</para>
        /// <para>During cursor navigation in the associated editor, you can ask
        /// the current QTextBlock (retrieved using the QTextCursor::block() function)
        /// if it has a user data object set and cast it to your BlockData object. Then
        /// you can check if the current cursor position matches with a previously
        /// recorded parenthesis position, and, depending on the type of parenthesis
        /// (opening or closing), find the next opening or closing parenthesis on the
        /// same level.</para>
        /// <para>In this way you can do a visual parenthesis matching and
        /// highlight from the current cursor position to the matching parenthesis.
        /// That makes it easier to spot a missing parenthesis in your code and to find
        /// where a corresponding opening/closing parenthesis is when editing
        /// parenthesis intensive code.</para>
        /// <para>See also currentBlockUserData() and
        /// QTextBlock::setUserData().</para>
        /// </summary>
        public QTextBlockUserData CurrentBlockUserData
        {
            get
            {
                var __ret = Internal.CurrentBlockUserData_0(__Instance);
                if (__ret == global::System.IntPtr.Zero) return null;
                return (__ret == IntPtr.Zero) ? null : QTextBlockUserData.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetCurrentBlockUserData_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the end state of the text block previous to the syntax
        /// highlighter's current block. If no value was previously set, the returned
        /// value is -1.</para>
        /// <para>See also highlightBlock() and setCurrentBlockState().</para>
        /// </summary>
        public int PreviousBlockState
        {
            get
            {
                var __ret = Internal.PreviousBlockState_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the current text block.</para>
        /// <para>This function was introduced in  Qt 4.4.</para>
        /// </summary>
        public QTextBlock CurrentBlock
        {
            get
            {
                var __ret = new QtGui.QTextBlock.Internal();
                Internal.CurrentBlock_0(new IntPtr(&__ret), __Instance);
                return QTextBlock.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // virtual ~QSyntaxHighlighter()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QSyntaxHighlighter) _References[instance].Target;
            target.Dispose();
        }

        // void highlightBlock(const QString &text)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _HighlightBlock_0Delegate(global::System.IntPtr instance, global::System.IntPtr text);
        private static _HighlightBlock_0Delegate _HighlightBlock_0DelegateInstance;

        private static void _HighlightBlock_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr text)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QSyntaxHighlighter) _References[instance].Target;
            target.HighlightBlock(Marshal.PtrToStringUni(new IntPtr(new QString(text).Utf16)));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _HighlightBlock_0DelegateInstance += _HighlightBlock_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_HighlightBlock_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(12 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QSyntaxHighlighterInternal : QtGui.QSyntaxHighlighter, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QSyntaxHighlighterInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QSyntaxHighlighterInternal((QSyntaxHighlighter.Internal*) native);
        }

        public static QSyntaxHighlighter __CreateInstance(QSyntaxHighlighter.Internal native)
        {
            return new QSyntaxHighlighterInternal(native);
        }

        private static QSyntaxHighlighter.Internal* __CopyValue(QSyntaxHighlighter.Internal native)
        {
            var ret = (QSyntaxHighlighter.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QSyntaxHighlighterInternal(QSyntaxHighlighter.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QSyntaxHighlighterInternal(QSyntaxHighlighter.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QSyntaxHighlighter.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        protected override void HighlightBlock(string text)
        {
            void* slot = *(void**) (((QSyntaxHighlighter.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___HighlightBlock_0Delegate = (_HighlightBlock_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_HighlightBlock_0Delegate));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(text).ToPointer(), text.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            ___HighlightBlock_0Delegate(__Instance, arg0);
        }
    }

    /// <summary>
    /// <para>The QTextDocumentFragment class represents a piece of formatted
    /// text from a QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A QTextDocumentFragment is a fragment of rich text, that can be
    /// inserted into a QTextDocument. A document fragment can be created from a
    /// QTextDocument, from a QTextCursor's selection, or from another document
    /// fragment. Document fragments can also be created by the static functions,
    /// fromPlainText() and fromHtml().</para>
    /// <para>The contents of a document fragment can be obtained as plain text
    /// by using the toPlainText() function, or it can be obtained as HTML with
    /// toHtml().</para>
    /// </remarks>
    public unsafe partial class QTextDocumentFragment : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QTextDocumentFragmentC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QTextDocumentFragmentC2EPK13QTextDocument")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QTextDocumentFragmentC2ERK11QTextCursor")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr range);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QTextDocumentFragmentC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN21QTextDocumentFragmentD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK21QTextDocumentFragment11toPlainTextEv")]
            internal static extern void ToPlainText_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21QTextDocumentFragment13fromPlainTextERK7QString")]
            internal static extern void FromPlainText_0(global::System.IntPtr @return, global::System.IntPtr plainText);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21QTextDocumentFragment8fromHtmlERK7QString")]
            internal static extern void FromHtml_0(global::System.IntPtr @return, global::System.IntPtr html);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21QTextDocumentFragment8fromHtmlERK7QStringPK13QTextDocument")]
            internal static extern void FromHtml_1(global::System.IntPtr @return, global::System.IntPtr html, global::System.IntPtr resourceProvider);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK21QTextDocumentFragment7isEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextDocumentFragment __CreateInstance(global::System.IntPtr native)
        {
            return new QTextDocumentFragment((QTextDocumentFragment.Internal*) native);
        }

        public static QTextDocumentFragment __CreateInstance(QTextDocumentFragment.Internal native)
        {
            return new QTextDocumentFragment(native);
        }

        private static QTextDocumentFragment.Internal* __CopyValue(QTextDocumentFragment.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            QtGui.QTextDocumentFragment.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return (QTextDocumentFragment.Internal*) ret;
        }

        private QTextDocumentFragment(QTextDocumentFragment.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextDocumentFragment(QTextDocumentFragment.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QTextDocumentFragment.</para>
        /// <para>See also isEmpty().</para>
        /// </summary>
        public QTextDocumentFragment()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        /// <summary>
        /// <para>Converts the given document into a QTextDocumentFragment. Note
        /// that the QTextDocumentFragment only stores the document contents, not meta
        /// information like the document's title.</para>
        /// </summary>
        public QTextDocumentFragment(QTextDocument document)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            Internal.ctor_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Creates a QTextDocumentFragment from the cursor's selection. If
        /// the cursor doesn't have a selection, the created fragment is empty.</para>
        /// <para>See also isEmpty() and QTextCursor::selection().</para>
        /// </summary>
        public QTextDocumentFragment(QTextCursor range)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(range, null) ? global::System.IntPtr.Zero : range.__Instance;
            Internal.ctor_2(__Instance, arg0);
        }

        /// <summary>
        /// <para>Copy constructor. Creates a copy of the other fragment.</para>
        /// </summary>
        public QTextDocumentFragment(QTextDocumentFragment rhs)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            Internal.cctor_3(__Instance, arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns the document fragment's text as plain text (i.e. with no
        /// formatting information).</para>
        /// <para>See also toHtml().</para>
        /// </summary>
        public string ToPlainText()
        {
            var __ret = new QtCore.QString.Internal();
            Internal.ToPlainText_0(new IntPtr(&__ret), __Instance);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Returns a document fragment that contains the given
        /// plainText.</para>
        /// <para>When inserting such a fragment into a QTextDocument the current
        /// char format of the QTextCursor used for insertion is used as format for the
        /// text.</para>
        /// </summary>
        public static QTextDocumentFragment FromPlainText(string plainText)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(plainText).ToPointer(), plainText.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtGui.QTextDocumentFragment.Internal();
            Internal.FromPlainText_0(new IntPtr(&__ret), arg0);
            return QTextDocumentFragment.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a QTextDocumentFragment based on the arbitrary piece of
        /// HTML in the given text. The formatting is preserved as much as possible;
        /// for example, &quot;&lt;b&gt;bold&lt;/b&gt;&quot; will become a document
        /// fragment with the text &quot;bold&quot; with a bold character
        /// format.</para>
        /// </summary>
        public static QTextDocumentFragment FromHtml(string html)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(html).ToPointer(), html.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var __ret = new QtGui.QTextDocumentFragment.Internal();
            Internal.FromHtml_0(new IntPtr(&__ret), arg0);
            return QTextDocumentFragment.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a QTextDocumentFragment based on the arbitrary piece of
        /// HTML in the given text. The formatting is preserved as much as possible;
        /// for example, &quot;&lt;b&gt;bold&lt;/b&gt;&quot; will become a document
        /// fragment with the text &quot;bold&quot; with a bold character
        /// format.</para>
        /// <para>If the provided HTML contains references to external resources
        /// such as imported style sheets, then they will be loaded through the
        /// resourceProvider.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// </summary>
        public static QTextDocumentFragment FromHtml(string html, QTextDocument resourceProvider)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(html).ToPointer(), html.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = ReferenceEquals(resourceProvider, null) ? global::System.IntPtr.Zero : resourceProvider.__Instance;
            var __ret = new QtGui.QTextDocumentFragment.Internal();
            Internal.FromHtml_1(new IntPtr(&__ret), arg0, arg1);
            return QTextDocumentFragment.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns true if the fragment is empty; otherwise returns
        /// false.</para>
        /// </summary>
        public bool IsEmpty
        {
            get
            {
                var __ret = Internal.IsEmpty_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QTextDocumentWriter class provides a format-independent
    /// interface for writing a QTextDocument to files or other devices.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>To write a document, construct a QTextDocumentWriter object with
    /// either a file name or a device object, and specify the document format to
    /// be written. You can construct a writer and set the format using setFormat()
    /// later.</para>
    /// <para>Call write() to write the document to the device. If the document
    /// is successfully written, this function returns true. However, if an error
    /// occurs when writing the document, it will return false.</para>
    /// <para>Call supportedDocumentFormats() for a list of formats that
    /// QTextDocumentWriter can write.</para>
    /// <para>Since the capabilities of the supported output formats vary
    /// considerably, the writer simply outputs the appropriate subset of objects
    /// for each format. This typically includes the formatted text and images
    /// contained in a document.</para>
    /// </remarks>
    public unsafe partial class QTextDocumentWriter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QTextDocumentWriterC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QTextDocumentWriterC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QTextDocumentWriterD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QTextDocumentWriter5writeEPK13QTextDocument")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Write_0(global::System.IntPtr instance, global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QTextDocumentWriter5writeERK21QTextDocumentFragment")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Write_1(global::System.IntPtr instance, global::System.IntPtr fragment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK19QTextDocumentWriter8fileNameEv")]
            internal static extern void FileName_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN19QTextDocumentWriter11setFileNameERK7QString")]
            internal static extern void SetFileName_0(global::System.IntPtr instance, global::System.IntPtr fileName);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextDocumentWriter __CreateInstance(global::System.IntPtr native)
        {
            return new QTextDocumentWriter((QTextDocumentWriter.Internal*) native);
        }

        public static QTextDocumentWriter __CreateInstance(QTextDocumentWriter.Internal native)
        {
            return new QTextDocumentWriter(native);
        }

        private static QTextDocumentWriter.Internal* __CopyValue(QTextDocumentWriter.Internal native)
        {
            var ret = (QTextDocumentWriter.Internal*) Marshal.AllocHGlobal(4);
            *ret = native;
            return ret;
        }

        private QTextDocumentWriter(QTextDocumentWriter.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextDocumentWriter(QTextDocumentWriter.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructs an empty QTextDocumentWriter object. Before writing,
        /// you must call setFormat() to set a document format, then setDevice() or
        /// setFileName().</para>
        /// </summary>
        public QTextDocumentWriter()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Writes the given document to the assigned device or file and
        /// returns true if successful; otherwise returns false.</para>
        /// </summary>
        public bool Write(QTextDocument document)
        {
            var arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = Internal.Write_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Writes the document fragment specified by fragment to the
        /// assigned device or file and returns true if successful; otherwise returns
        /// false.</para>
        /// </summary>
        public bool Write(QTextDocumentFragment fragment)
        {
            var arg0 = ReferenceEquals(fragment, null) ? global::System.IntPtr.Zero : fragment.__Instance;
            var __ret = Internal.Write_1(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>If the currently assigned device is a QFile, or if setFileName()
        /// has been called, this function returns the name of the file to be written
        /// to. In all other cases, it returns an empty string.</para>
        /// <para>See also setFileName() and setDevice().</para>
        /// <para></para>
        /// <para>Sets the name of the file to be written to fileName. Internally,
        /// QTextDocumentWriter will create a QFile and open it in QIODevice::WriteOnly
        /// mode, and use this file when writing the document.</para>
        /// <para>See also fileName() and setDevice().</para>
        /// </summary>
        public string FileName
        {
            get
            {
                var __ret = new QtCore.QString.Internal();
                Internal.FileName_0(new IntPtr(&__ret), __Instance);
                return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
            }

            set
            {
                var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(value).ToPointer(), value.Length);
                var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
                Internal.SetFileName_0(__Instance, arg0);
            }
        }
    }

    /// <summary>
    /// <para>The QTextList class provides a decorated list of items in a
    /// QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A list contains a sequence of text blocks, each of which is
    /// marked with a bullet point or other symbol. Multiple levels of lists can be
    /// used, and the automatic numbering feature provides support for ordered
    /// numeric and alphabetical lists.</para>
    /// <para>Lists are created by using a text cursor to insert an empty list
    /// at the current position or by moving existing text into a new list. The
    /// QTextCursor::insertList() function inserts an empty block into the document
    /// at the cursor position, and makes it the first item in a list.</para>
    /// <para>    QTextListFormat listFormat;</para>
    /// <para>    if (list) {</para>
    /// <para>        listFormat = list-&gt;format();</para>
    /// <para>        listFormat.setIndent(listFormat.indent() + 1);</para>
    /// <para>    }</para>
    /// <para></para>
    /// <para>    listFormat.setStyle(QTextListFormat::ListDisc);</para>
    /// <para>    cursor.insertList(listFormat);</para>
    /// <para>The QTextCursor::createList() function takes the contents of the
    /// cursor's current block and turns it into the first item of a new
    /// list.</para>
    /// <para>The cursor's current list is found with
    /// QTextCursor::currentList().</para>
    /// <para>The number of items in a list is given by count(). Each item can
    /// be obtained by its index in the list with the item() function. Similarly,
    /// the index of a given item can be found with itemNumber(). The text of each
    /// item can be found with the itemText() function.</para>
    /// <para>Note that the items in the list may not be adjacent elements in
    /// the document. For example, the top-level items in a multi-level list will
    /// be separated by the items in lower levels of the list.</para>
    /// <para>List items can be deleted by index with the removeItem()
    /// function. remove() deletes the specified item in the list.</para>
    /// <para>The list's format is set with setFormat() and read with format().
    /// The format describes the decoration of the list itself, and not the
    /// individual items.</para>
    /// <para></para>
    /// <para>See also QTextBlock, QTextListFormat, and QTextCursor.</para>
    /// </remarks>
    public unsafe partial class QTextList : QtGui.QTextBlockGroup, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextListC2EP13QTextDocument")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextListC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextListD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextList4itemEi")]
            internal static extern void Item_0(global::System.IntPtr @return, global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextList10itemNumberERK10QTextBlock")]
            internal static extern int ItemNumber_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextList8itemTextERK10QTextBlock")]
            internal static extern void ItemText_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextList10removeItemEi")]
            internal static extern void RemoveItem_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextList6removeERK10QTextBlock")]
            internal static extern void Remove_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN9QTextList3addERK10QTextBlock")]
            internal static extern void Add_0(global::System.IntPtr instance, global::System.IntPtr block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK9QTextList5countEv")]
            internal static extern int Count_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextList __CreateInstance(global::System.IntPtr native)
        {
            return new QTextList((QTextList.Internal*) native);
        }

        public static QTextList __CreateInstance(QTextList.Internal native)
        {
            return new QTextList(native);
        }

        private static QTextList.Internal* __CopyValue(QTextList.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextList.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QTextList.Internal*) ret;
        }

        private QTextList(QTextList.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextList(QTextList.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextBlockGroup.Internal*) native)
        {
        }

        public QTextList(QTextDocument doc)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Returns the i-th text block in the list.</para>
        /// <para>See also count() and itemText().</para>
        /// </summary>
        public QTextBlock Item(int i)
        {
            var __ret = new QtGui.QTextBlock.Internal();
            Internal.Item_0(new IntPtr(&__ret), __Instance, i);
            return QTextBlock.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the index of the list item that corresponds to the given
        /// block. Returns -1 if the block was not present in the list.</para>
        /// </summary>
        public int ItemNumber(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            var __ret = Internal.ItemNumber_0(__Instance, arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the text of the list item that corresponds to the given
        /// block.</para>
        /// </summary>
        public string ItemText(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            var __ret = new QtCore.QString.Internal();
            Internal.ItemText_0(new IntPtr(&__ret), __Instance, arg0);
            return Marshal.PtrToStringUni(new IntPtr(new QString(__ret).Utf16));
        }

        /// <summary>
        /// <para>Removes the item at item position i from the list. When the last
        /// item in the list is removed, the list is automatically deleted by the
        /// QTextDocument that owns it.</para>
        /// <para>See also add() and remove().</para>
        /// </summary>
        public void RemoveItem(int i)
        {
            Internal.RemoveItem_0(__Instance, i);
        }

        /// <summary>
        /// <para>Removes the given block from the list.</para>
        /// <para>See also add() and removeItem().</para>
        /// </summary>
        public void Remove(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.Remove_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Makes the given block part of the list.</para>
        /// <para>See also remove() and removeItem().</para>
        /// </summary>
        public void Add(QTextBlock block)
        {
            var arg0 = ReferenceEquals(block, null) ? global::System.IntPtr.Zero : block.__Instance;
            Internal.Add_0(__Instance, arg0);
        }

        /// <summary>
        /// <para>Returns the number of items in the list.</para>
        /// </summary>
        public int Count
        {
            get
            {
                var __ret = Internal.Count_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QTextList()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextList) _References[instance].Target;
            target.Dispose();
        }

        // void blockInserted(const QTextBlock &block)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _BlockInserted_0Delegate(global::System.IntPtr instance, global::System.IntPtr block);
        private static _BlockInserted_0Delegate _BlockInserted_0DelegateInstance;

        private static void _BlockInserted_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr block)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextList) _References[instance].Target;
            target.BlockInserted((block == IntPtr.Zero) ? null : QTextBlock.__CreateInstance(block));
        }

        // void blockRemoved(const QTextBlock &block)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _BlockRemoved_0Delegate(global::System.IntPtr instance, global::System.IntPtr block);
        private static _BlockRemoved_0Delegate _BlockRemoved_0DelegateInstance;

        private static void _BlockRemoved_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr block)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextList) _References[instance].Target;
            target.BlockRemoved((block == IntPtr.Zero) ? null : QTextBlock.__CreateInstance(block));
        }

        // void blockFormatChanged(const QTextBlock &block)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _BlockFormatChanged_0Delegate(global::System.IntPtr instance, global::System.IntPtr block);
        private static _BlockFormatChanged_0Delegate _BlockFormatChanged_0DelegateInstance;

        private static void _BlockFormatChanged_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr block)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextList) _References[instance].Target;
            target.BlockFormatChanged((block == IntPtr.Zero) ? null : QTextBlock.__CreateInstance(block));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _BlockInserted_0DelegateInstance += _BlockInserted_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BlockInserted_0DelegateInstance).ToPointer();
                _BlockRemoved_0DelegateInstance += _BlockRemoved_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_BlockRemoved_0DelegateInstance).ToPointer();
                _BlockFormatChanged_0DelegateInstance += _BlockFormatChanged_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_BlockFormatChanged_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(14 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = _Thunks[3];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QTextTableCell class represents the properties of a cell in a
    /// QTextTable.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Table cells are pieces of document structure that belong to a
    /// table. The table orders cells into particular rows and columns; cells can
    /// also span multiple columns and rows.</para>
    /// <para>Cells are usually created when a table is inserted into a
    /// document with QTextCursor::insertTable(), but they are also created and
    /// destroyed when a table is resized.</para>
    /// <para>Cells contain information about their location in a table; you
    /// can obtain the row() and column() numbers of a cell, and its rowSpan() and
    /// columnSpan().</para>
    /// <para>The format() of a cell describes the default character format of
    /// its contents. The firstCursorPosition() and lastCursorPosition() functions
    /// are used to obtain the extent of the cell in the document.</para>
    /// <para></para>
    /// <para>See also QTextTable and QTextTableFormat.</para>
    /// </remarks>
    public unsafe partial class QTextTableCell : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr table;

            [FieldOffset(4)]
            public int fragment;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QTextTableCellC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr o);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QTextTableCellD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell5beginEv")]
            internal static extern void Begin_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell3endEv")]
            internal static extern void End_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell6formatEv")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN14QTextTableCell9setFormatERK15QTextCharFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell3rowEv")]
            internal static extern int Row_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell6columnEv")]
            internal static extern int Column_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell7rowSpanEv")]
            internal static extern int RowSpan_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell10columnSpanEv")]
            internal static extern int ColumnSpan_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell19firstCursorPositionEv")]
            internal static extern void FirstCursorPosition_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell18lastCursorPositionEv")]
            internal static extern void LastCursorPosition_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell13firstPositionEv")]
            internal static extern int FirstPosition_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell12lastPositionEv")]
            internal static extern int LastPosition_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK14QTextTableCell20tableCellFormatIndexEv")]
            internal static extern int TableCellFormatIndex_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QTextTableCell __CreateInstance(global::System.IntPtr native)
        {
            return new QTextTableCell((QTextTableCell.Internal*) native);
        }

        public static QTextTableCell __CreateInstance(QTextTableCell.Internal native)
        {
            return new QTextTableCell(native);
        }

        private static QTextTableCell.Internal* __CopyValue(QTextTableCell.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextTableCell.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QTextTableCell.Internal*) ret;
        }

        private QTextTableCell(QTextTableCell.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextTableCell(QTextTableCell.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Returns a frame iterator pointing to the beginning of the table's
        /// cell.</para>
        /// <para>See also end().</para>
        /// </summary>
        public QTextFrame.Iterator Begin()
        {
            var __ret = new QtGui.QTextFrame.Iterator.Internal();
            Internal.Begin_0(new IntPtr(&__ret), __Instance);
            return QTextFrame.Iterator.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a frame iterator pointing to the end of the table's
        /// cell.</para>
        /// <para>See also begin().</para>
        /// </summary>
        public QTextFrame.Iterator End()
        {
            var __ret = new QtGui.QTextFrame.Iterator.Internal();
            Internal.End_0(new IntPtr(&__ret), __Instance);
            return QTextFrame.Iterator.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the cell's character format.</para>
        /// <para>See also setFormat().</para>
        /// <para></para>
        /// <para>Sets the cell's character format to format. This can for example
        /// be used to change the background color of the entire cell:</para>
        /// <para>QTextTableCell cell = table-&gt;cellAt(2, 3); QTextCharFormat
        /// format = cell.format(); format.setBackground(Qt::blue);
        /// cell.setFormat(format);</para>
        /// <para>Note that the cell's row or column span cannot be changed through
        /// this function. You have to use QTextTable::mergeCells and
        /// QTextTable::splitCell instead.</para>
        /// <para>This function was introduced in  Qt 4.2.</para>
        /// <para>See also format().</para>
        /// </summary>
        public QTextCharFormat Format
        {
            get
            {
                var __ret = new QtGui.QTextCharFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QTextCharFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the number of the row in the table that contains this
        /// cell.</para>
        /// <para>See also column().</para>
        /// </summary>
        public int Row
        {
            get
            {
                var __ret = Internal.Row_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of the column in the table that contains this
        /// cell.</para>
        /// <para>See also row().</para>
        /// </summary>
        public int Column
        {
            get
            {
                var __ret = Internal.Column_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of rows this cell spans. The default is
        /// 1.</para>
        /// <para>See also columnSpan().</para>
        /// </summary>
        public int RowSpan
        {
            get
            {
                var __ret = Internal.RowSpan_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of columns this cell spans. The default is
        /// 1.</para>
        /// <para>See also rowSpan().</para>
        /// </summary>
        public int ColumnSpan
        {
            get
            {
                var __ret = Internal.ColumnSpan_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the first valid cursor position in this cell.</para>
        /// <para>See also lastCursorPosition().</para>
        /// </summary>
        public QTextCursor FirstCursorPosition
        {
            get
            {
                var __ret = new QtGui.QTextCursor.Internal();
                Internal.FirstCursorPosition_0(new IntPtr(&__ret), __Instance);
                return QTextCursor.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Returns the last valid cursor position in this cell.</para>
        /// <para>See also firstCursorPosition().</para>
        /// </summary>
        public QTextCursor LastCursorPosition
        {
            get
            {
                var __ret = new QtGui.QTextCursor.Internal();
                Internal.LastCursorPosition_0(new IntPtr(&__ret), __Instance);
                return QTextCursor.__CreateInstance(__ret);
            }
        }

        public int FirstPosition
        {
            get
            {
                var __ret = Internal.FirstPosition_0(__Instance);
                return __ret;
            }
        }

        public int LastPosition
        {
            get
            {
                var __ret = Internal.LastPosition_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the index of the tableCell's format in the document's
        /// internal list of formats.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also QTextDocument::allFormats().</para>
        /// </summary>
        public int TableCellFormatIndex
        {
            get
            {
                var __ret = Internal.TableCellFormatIndex_0(__Instance);
                return __ret;
            }
        }
    }

    /// <summary>
    /// <para>The QTextTable class represents a table in a
    /// QTextDocument.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>A table is a group of cells ordered into rows and columns. Each
    /// table contains at least one row and one column. Each cell contains a block,
    /// and is surrounded by a frame.</para>
    /// <para>Tables are usually created and inserted into a document with the
    /// QTextCursor::insertTable() function. For example, we can insert a table
    /// with three rows and two columns at the current cursor position in an editor
    /// using the following lines of code:</para>
    /// <para>    QTextCursor cursor(editor-&gt;textCursor());</para>
    /// <para>    cursor.movePosition(QTextCursor::Start);</para>
    /// <para></para>
    /// <para>    QTextTable *table = cursor.insertTable(rows, columns,
    /// tableFormat);</para>
    /// <para>The table format is either defined when the table is created or
    /// changed later with setFormat().</para>
    /// <para>The table currently being edited by the cursor is found with
    /// QTextCursor::currentTable(). This allows its format or dimensions to be
    /// changed after it has been inserted into a document.</para>
    /// <para>A table's size can be changed with resize(), or by using
    /// insertRows(), insertColumns(), removeRows(), or removeColumns(). Use
    /// cellAt() to retrieve table cells.</para>
    /// <para>The starting and ending positions of table rows can be found by
    /// moving a cursor within a table, and using the rowStart() and rowEnd()
    /// functions to obtain cursors at the start and end of each row.</para>
    /// <para>Rows and columns within a QTextTable can be merged and split
    /// using the mergeCells() and splitCell() functions. However, only cells that
    /// span multiple rows or columns can be split. (Merging or splitting does not
    /// increase or decrease the number of rows and columns.)</para>
    /// <para>Note that if you have merged multiple columns and rows into one
    /// cell, you will not be able to split the merged cell into new cells spanning
    /// over more than one row or column. To be able to split cells spanning over
    /// several rows and columns you need to do this over several
    /// iterations.</para>
    /// <para></para>
    /// <para> 	Suppose we have a 2x3 table of names and addresses. To merge
    /// both columns in the first row we invoke mergeCells() with row = 0, column =
    /// 0, numRows = 1 and numColumns = 2.    table-&gt;mergeCells(0, 0, 1,
    /// 2);</para>
    /// <para></para>
    /// <para>	This gives us the following table. To split the first row of the
    /// table back into two cells, we invoke the splitCell() function with numRows
    /// and numCols = 1.    table-&gt;splitCell(0, 0, 1, 1);</para>
    /// <para></para>
    /// <para>	This results in the original table.</para>
    /// </remarks>
    public unsafe partial class QTextTable : QtGui.QTextFrame, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTableC2EP13QTextDocument")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTableC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTableD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable6resizeEii")]
            internal static extern void Resize_0(global::System.IntPtr instance, int rows, int cols);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable10insertRowsEii")]
            internal static extern void InsertRows_0(global::System.IntPtr instance, int pos, int num);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable13insertColumnsEii")]
            internal static extern void InsertColumns_0(global::System.IntPtr instance, int pos, int num);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable10appendRowsEi")]
            internal static extern void AppendRows_0(global::System.IntPtr instance, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable13appendColumnsEi")]
            internal static extern void AppendColumns_0(global::System.IntPtr instance, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable10removeRowsEii")]
            internal static extern void RemoveRows_0(global::System.IntPtr instance, int pos, int num);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable13removeColumnsEii")]
            internal static extern void RemoveColumns_0(global::System.IntPtr instance, int pos, int num);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable10mergeCellsEiiii")]
            internal static extern void MergeCells_0(global::System.IntPtr instance, int row, int col, int numRows, int numCols);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable10mergeCellsERK11QTextCursor")]
            internal static extern void MergeCells_1(global::System.IntPtr instance, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable9splitCellEiiii")]
            internal static extern void SplitCell_0(global::System.IntPtr instance, int row, int col, int numRows, int numCols);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable6cellAtEii")]
            internal static extern void CellAt_0(global::System.IntPtr @return, global::System.IntPtr instance, int row, int col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable6cellAtEi")]
            internal static extern void CellAt_1(global::System.IntPtr @return, global::System.IntPtr instance, int position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable6cellAtERK11QTextCursor")]
            internal static extern void CellAt_2(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable8rowStartERK11QTextCursor")]
            internal static extern void RowStart_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable6rowEndERK11QTextCursor")]
            internal static extern void RowEnd_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK11QTextObject6formatEv")]
            internal static extern void Format_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QTextTable9setFormatERK16QTextTableFormat")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, global::System.IntPtr format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable4rowsEv")]
            internal static extern int Rows_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QTextTable7columnsEv")]
            internal static extern int Columns_0(global::System.IntPtr instance);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        private readonly bool __ownsNativeInstance;

        public static new QTextTable __CreateInstance(global::System.IntPtr native)
        {
            return new QTextTable((QTextTable.Internal*) native);
        }

        public static QTextTable __CreateInstance(QTextTable.Internal native)
        {
            return new QTextTable(native);
        }

        private static QTextTable.Internal* __CopyValue(QTextTable.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QTextTable.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return (QTextTable.Internal*) ret;
        }

        private QTextTable(QTextTable.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QTextTable(QTextTable.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QTextFrame.Internal*) native)
        {
        }

        public QTextTable(QTextDocument doc)
            : this((Internal*) null)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            var arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            Internal.ctor_0(__Instance, arg0);
            SetupVTables(__Instance);
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Resizes the table to contain the required number of rows and
        /// columns.</para>
        /// <para>See also insertRows(), insertColumns(), removeRows(), and
        /// removeColumns().</para>
        /// </summary>
        public void Resize(int rows, int cols)
        {
            Internal.Resize_0(__Instance, rows, cols);
        }

        /// <summary>
        /// <para>Inserts a number of rows before the row with the specified
        /// index.</para>
        /// <para>See also resize(), insertColumns(), removeRows(),
        /// removeColumns(), appendRows(), and appendColumns().</para>
        /// </summary>
        public void InsertRows(int pos, int num)
        {
            Internal.InsertRows_0(__Instance, pos, num);
        }

        /// <summary>
        /// <para>Inserts a number of columns before the column with the specified
        /// index.</para>
        /// <para>See also insertRows(), resize(), removeRows(), removeColumns(),
        /// appendRows(), and appendColumns().</para>
        /// </summary>
        public void InsertColumns(int pos, int num)
        {
            Internal.InsertColumns_0(__Instance, pos, num);
        }

        /// <summary>
        /// <para>Appends count rows at the bottom of the table.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also insertColumns(), insertRows(), resize(), removeRows(),
        /// removeColumns(), and appendColumns().</para>
        /// </summary>
        public void AppendRows(int count)
        {
            Internal.AppendRows_0(__Instance, count);
        }

        /// <summary>
        /// <para>Appends count columns at the right side of the table.</para>
        /// <para>This function was introduced in  Qt 4.5.</para>
        /// <para>See also insertColumns(), insertRows(), resize(), removeRows(),
        /// removeColumns(), and appendRows().</para>
        /// </summary>
        public void AppendColumns(int count)
        {
            Internal.AppendColumns_0(__Instance, count);
        }

        /// <summary>
        /// <para>Removes a number of rows starting with the row at the specified
        /// index.</para>
        /// <para>See also insertRows(), insertColumns(), resize(),
        /// removeColumns(), appendRows(), and appendColumns().</para>
        /// </summary>
        public void RemoveRows(int pos, int num)
        {
            Internal.RemoveRows_0(__Instance, pos, num);
        }

        /// <summary>
        /// <para>Removes a number of columns starting with the column at the
        /// specified index.</para>
        /// <para>See also insertRows(), insertColumns(), removeRows(), resize(),
        /// appendRows(), and appendColumns().</para>
        /// </summary>
        public void RemoveColumns(int pos, int num)
        {
            Internal.RemoveColumns_0(__Instance, pos, num);
        }

        /// <summary>
        /// <para>Merges the cell at the specified row and column with the adjacent
        /// cells into one cell. The new cell will span numRows rows and numCols
        /// columns. If numRows or numCols is less than the current number of rows or
        /// columns the cell spans then this method does nothing.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also splitCell().</para>
        /// </summary>
        public void MergeCells(int row, int col, int numRows, int numCols)
        {
            Internal.MergeCells_0(__Instance, row, col, numRows, numCols);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Merges the cells selected by the provided cursor.</para>
        /// <para>This function was introduced in  Qt 4.1.</para>
        /// <para>See also splitCell().</para>
        /// </summary>
        public void MergeCells(QTextCursor cursor)
        {
            var arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            Internal.MergeCells_1(__Instance, arg0);
        }

        /// <summary>
        /// <para>Splits the specified cell at row and column into an array of
        /// multiple cells with dimensions specified by numRows and numCols.</para>
        /// <para>Note: It is only possible to split cells that span multiple rows
        /// or columns, such as rows that have been merged using mergeCells().This
        /// function was introduced in  Qt 4.1.</para>
        /// <para>See also mergeCells().</para>
        /// </summary>
        public void SplitCell(int row, int col, int numRows, int numCols)
        {
            Internal.SplitCell_0(__Instance, row, col, numRows, numCols);
        }

        /// <summary>
        /// <para>Returns the table cell at the given row and column in the
        /// table.</para>
        /// <para>See also columns() and rows().</para>
        /// </summary>
        public QTextTableCell CellAt(int row, int col)
        {
            var __ret = new QtGui.QTextTableCell.Internal();
            Internal.CellAt_0(new IntPtr(&__ret), __Instance, row, col);
            return QTextTableCell.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the table cell that contains the character at the given
        /// position in the document.</para>
        /// </summary>
        public QTextTableCell CellAt(int position)
        {
            var __ret = new QtGui.QTextTableCell.Internal();
            Internal.CellAt_1(new IntPtr(&__ret), __Instance, position);
            return QTextTableCell.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>This is an overloaded function.</para>
        /// <para>Returns the table cell containing the given cursor.</para>
        /// </summary>
        public QTextTableCell CellAt(QTextCursor c)
        {
            var arg0 = ReferenceEquals(c, null) ? global::System.IntPtr.Zero : c.__Instance;
            var __ret = new QtGui.QTextTableCell.Internal();
            Internal.CellAt_2(new IntPtr(&__ret), __Instance, arg0);
            return QTextTableCell.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a cursor pointing to the start of the row that contains
        /// the given cursor.</para>
        /// <para>See also rowEnd().</para>
        /// </summary>
        public QTextCursor RowStart(QTextCursor c)
        {
            var arg0 = ReferenceEquals(c, null) ? global::System.IntPtr.Zero : c.__Instance;
            var __ret = new QtGui.QTextCursor.Internal();
            Internal.RowStart_0(new IntPtr(&__ret), __Instance, arg0);
            return QTextCursor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns a cursor pointing to the end of the row that contains the
        /// given cursor.</para>
        /// <para>See also rowStart().</para>
        /// </summary>
        public QTextCursor RowEnd(QTextCursor c)
        {
            var arg0 = ReferenceEquals(c, null) ? global::System.IntPtr.Zero : c.__Instance;
            var __ret = new QtGui.QTextCursor.Internal();
            Internal.RowEnd_0(new IntPtr(&__ret), __Instance, arg0);
            return QTextCursor.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Returns the text object's format.</para>
        /// <para>See also setFormat() and document().</para>
        /// <para></para>
        /// <para>Sets the table's format.</para>
        /// <para>See also format().</para>
        /// </summary>
        public QTextFormat Format
        {
            get
            {
                var __ret = new QtGui.QTextFormat.Internal();
                Internal.Format_0(new IntPtr(&__ret), __Instance);
                return QTextFormat.__CreateInstance(__ret);
            }

            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetFormat_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Returns the number of rows in the table.</para>
        /// <para>See also columns().</para>
        /// </summary>
        public int Rows
        {
            get
            {
                var __ret = Internal.Rows_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the number of columns in the table.</para>
        /// <para>See also rows().</para>
        /// </summary>
        public int Columns
        {
            get
            {
                var __ret = Internal.Columns_0(__Instance);
                return __ret;
            }
        }

        #region Virtual table interop

        // ~QTextTable()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QTextTable) _References[instance].Target;
            target.Dispose();
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QDesktopServices class provides methods for accessing common
    /// desktop services.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Many desktop environments provide services that can be used by
    /// applications to perform common tasks, such as opening a web page, in a way
    /// that is both consistent and takes into account the user's application
    /// preferences.</para>
    /// <para>This class contains functions that provide simple interfaces to
    /// these services that indicate whether they succeeded or failed.</para>
    /// <para>The openUrl() function is used to open files located at arbitrary
    /// URLs in external applications. For URLs that correspond to resources on the
    /// local filing system (where the URL scheme is &quot;file&quot;), a suitable
    /// application will be used to open the file; otherwise, a web browser will be
    /// used to fetch and display the file.</para>
    /// <para>The user's desktop settings control whether certain executable
    /// file types are opened for browsing, or if they are executed instead. Some
    /// desktop environments are configured to prevent users from executing files
    /// obtained from non-local URLs, or to ask the user's permission before doing
    /// so.</para>
    /// <para></para>
    /// <para>URL Handlers</para>
    /// <para>The behavior of the openUrl() function can be customized for
    /// individual URL schemes to allow applications to override the default
    /// handling behavior for certain types of URLs.</para>
    /// <para>The dispatch mechanism allows only one custom handler to be used
    /// for each URL scheme; this is set using the setUrlHandler() function. Each
    /// handler is implemented as a slot which accepts only a single QUrl
    /// argument.</para>
    /// <para>The existing handlers for each scheme can be removed with the
    /// unsetUrlHandler() function. This returns the handling behavior for the
    /// given scheme to the default behavior.</para>
    /// <para>This system makes it easy to implement a help system, for
    /// example. Help could be provided in labels and text browsers using
    /// help://myapplication/mytopic URLs, and by registering a handler it becomes
    /// possible to display the help text inside the application:</para>
    /// <para>class MyHelpHandler : public QObject</para>
    /// <para>{</para>
    /// <para>    Q_OBJECT</para>
    /// <para>public:</para>
    /// <para>    ...</para>
    /// <para>public slots:</para>
    /// <para>    void showHelp(const QUrl &amp;url);</para>
    /// <para>};</para>
    /// <para></para>
    /// <para>QDesktopServices::setUrlHandler(&quot;help&quot;, helpInstance,
    /// &quot;showHelp&quot;);</para>
    /// <para>If inside the handler you decide that you can't open the
    /// requested URL, you can just call QDesktopServices::openUrl() again with the
    /// same argument, and it will try to open the URL using the appropriate
    /// mechanism for the user's desktop environment.</para>
    /// <para>Note: Since Qt 5, storageLocation() and displayName() are
    /// replaced by functionality provided by the QStandardPaths class.</para>
    /// <para>See also QSystemTrayIcon, QProcess, and QStandardPaths.</para>
    /// </remarks>
    public unsafe partial class QDesktopServices : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDesktopServicesC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16QDesktopServices15unsetUrlHandlerERK7QString")]
            internal static extern void UnsetUrlHandler_0(global::System.IntPtr scheme);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        public static QDesktopServices __CreateInstance(global::System.IntPtr native)
        {
            return new QDesktopServices((QDesktopServices.Internal*) native);
        }

        public static QDesktopServices __CreateInstance(QDesktopServices.Internal native)
        {
            return new QDesktopServices(native);
        }

        private static QDesktopServices.Internal* __CopyValue(QDesktopServices.Internal native)
        {
            var ret = (QDesktopServices.Internal*) Marshal.AllocHGlobal(1);
            *ret = native;
            return ret;
        }

        private QDesktopServices(QDesktopServices.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDesktopServices(QDesktopServices.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Removes a previously set URL handler for the specified
        /// scheme.</para>
        /// <para>See also setUrlHandler().</para>
        /// </summary>
        public static void UnsetUrlHandler(string scheme)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(scheme).ToPointer(), scheme.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.UnsetUrlHandler_0(arg0);
        }
    }

    /// <summary>
    /// <para>The QValidator class provides validation of input text.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>The class itself is abstract. Two subclasses, QIntValidator and
    /// QDoubleValidator, provide basic numeric-range checking, and
    /// QRegExpValidator provides general checking using a custom regular
    /// expression.</para>
    /// <para>If the built-in validators aren't sufficient, you can subclass
    /// QValidator. The class has two virtual functions: validate() and
    /// fixup().</para>
    /// <para>validate() must be implemented by every subclass. It returns
    /// Invalid, Intermediate or Acceptable depending on whether its argument is
    /// valid (for the subclass's definition of valid).</para>
    /// <para>These three states require some explanation. An Invalid string is
    /// clearly invalid. Intermediate is less obvious: the concept of validity is
    /// difficult to apply when the string is incomplete (still being edited).
    /// QValidator defines Intermediate as the property of a string that is neither
    /// clearly invalid nor acceptable as a final result. Acceptable means that the
    /// string is acceptable as a final result. One might say that any string that
    /// is a plausible intermediate state during entry of an Acceptable string is
    /// Intermediate.</para>
    /// <para>Here are some examples:</para>
    /// <para></para>
    /// <para>For a line edit that accepts integers from 10 to 1000 inclusive,
    /// 42 and 123 are Acceptable, the empty string and 5 are Intermediate, and
    /// &quot;asdf&quot; and 1114 is Invalid.</para>
    /// <para>For an editable combobox that accepts URLs, any well-formed URL
    /// is Acceptable, &quot;http://example.com/,&quot; is Intermediate (it might
    /// be a cut and paste action that accidentally took in a comma at the end),
    /// the empty string is Intermediate (the user might select and delete all of
    /// the text in preparation for entering a new URL) and &quot;http:///./&quot;
    /// is Invalid.</para>
    /// <para>For a spin box that accepts lengths, &quot;11cm&quot; and
    /// &quot;1in&quot; are Acceptable, &quot;11&quot; and the empty string are
    /// Intermediate, and &quot;http://example.com&quot; and &quot;hour&quot; are
    /// Invalid.</para>
    /// <para></para>
    /// <para>fixup() is provided for validators that can repair some user
    /// errors. The default implementation does nothing. QLineEdit, for example,
    /// will call fixup() if the user presses Enter (or Return) and the content is
    /// not currently valid. This allows the fixup() function the opportunity of
    /// performing some magic to make an Invalid string Acceptable.</para>
    /// <para>A validator has a locale, set with setLocale(). It is typically
    /// used to parse localized data. For example, QIntValidator and
    /// QDoubleValidator use it to parse localized representations of integers and
    /// doubles.</para>
    /// <para>QValidator is typically used with QLineEdit, QSpinBox and
    /// QComboBox.</para>
    /// <para></para>
    /// <para>See also QIntValidator, QDoubleValidator, QRegExpValidator, and
    /// Line Edits Example.</para>
    /// </remarks>
    public unsafe abstract partial class QValidator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QValidatorC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN10QValidatorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK10QValidator5fixupER7QString")]
            internal static extern void Fixup_0(global::System.IntPtr instance, global::System.IntPtr input);
        }

        /// <summary>
        /// <para>This enum type defines the states in which a validated string can
        /// exist.</para>
        /// </summary>
        public enum State : uint
        {
            /// <summary>The string is clearly invalid.</summary>
            Invalid = 0,
            /// <summary>The string is a plausible intermediate value.</summary>
            Intermediate = 1,
            /// <summary>The string is acceptable as a final result; i.e. it is valid.</summary>
            Acceptable = 2
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This signal is emitted when any property that may affect the validity of a string has changed.</para>
        /// </summary>
        public event Action Changed
        {
        	add
        	{
                ConnectDynamicSlot(this, "changed()", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "changed()", value);
        	}
        }

        public global::System.IntPtr __Instance { get; protected set; }

        private readonly bool __ownsNativeInstance;

        protected QValidator(QValidator.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
            if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                SetupVTables(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>This virtual function returns Invalid if input is invalid
        /// according to this validator's rules, Intermediate if it is likely that a
        /// little more editing will make the input acceptable (e.g. the user types
        /// &quot;4&quot; into a widget which accepts integers between 10 and 99), and
        /// Acceptable if the input is valid.</para>
        /// <para>The function can change both input and pos (the cursor position)
        /// if required.</para>
        /// </summary>
        public abstract QValidator.State Validate(string input, int* pos);

        /// <summary>
        /// <para>This function attempts to change input to be valid according to
        /// this validator's rules. It need not result in a valid string: callers of
        /// this function must re-test afterwards; the default does nothing.</para>
        /// <para>Reimplementations of this function can change input even if they
        /// do not produce a valid string. For example, an ISBN validator might want to
        /// delete every character except digits and &quot;-&quot;, even if the result
        /// is still not a valid ISBN; a surname validator might want to remove
        /// whitespace from the start and end of the string, even if the resulting
        /// string is not in the list of accepted surnames.</para>
        /// </summary>
        public virtual void Fixup(string input)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(input).ToPointer(), input.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.Fixup_0(__Instance, arg0);
        }

        #region Virtual table interop

        // ~QValidator()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QValidator) _References[instance].Target;
            target.Dispose();
        }

        // State validate(QString &, int &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QValidator.State _Validate_0Delegate(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        private static _Validate_0Delegate _Validate_0DelegateInstance;

        private static QValidator.State _Validate_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input, int* pos)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QValidator) _References[instance].Target;
            var _ret = target.Validate(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)), pos);
            return _ret;
        }

        // void fixup(QString &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Fixup_0Delegate(global::System.IntPtr instance, global::System.IntPtr input);
        private static _Fixup_0Delegate _Fixup_0DelegateInstance;

        private static void _Fixup_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QValidator) _References[instance].Target;
            target.Fixup(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Validate_0DelegateInstance += _Validate_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Validate_0DelegateInstance).ToPointer();
                _Fixup_0DelegateInstance += _Fixup_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Fixup_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QIntValidator class provides a validator that ensures a
    /// string contains a valid integer within a specified range.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>Example of use:</para>
    /// <para>QValidator *validator = new QIntValidator(100, 999, this);</para>
    /// <para>QLineEdit *edit = new QLineEdit(this);</para>
    /// <para></para>
    /// <para>// the edit lineedit will only accept integers between 100 and
    /// 999</para>
    /// <para>edit-&gt;setValidator(validator);</para>
    /// <para>Below we present some examples of validators. In practice they
    /// would normally be associated with a widget as in the example above.</para>
    /// <para>QString str;</para>
    /// <para>int pos = 0;</para>
    /// <para>QIntValidator v(100, 900, this);</para>
    /// <para></para>
    /// <para>str = &quot;1&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Intermediate</para>
    /// <para>str = &quot;012&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Intermediate</para>
    /// <para></para>
    /// <para>str = &quot;123&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Acceptable</para>
    /// <para>str = &quot;678&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Acceptable</para>
    /// <para></para>
    /// <para>str = &quot;999&quot;;</para>
    /// <para>v.validate(str, pos);    // returns Intermediate</para>
    /// <para></para>
    /// <para>str = &quot;1234&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Invalid</para>
    /// <para>str = &quot;-123&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Invalid</para>
    /// <para>str = &quot;abc&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Invalid</para>
    /// <para>str = &quot;12cm&quot;;</para>
    /// <para>v.validate(str, pos);     // returns Invalid</para>
    /// <para>Notice that the value 999 returns Intermediate. Values consisting
    /// of a number of digits equal to or less than the max value are considered
    /// intermediate. This is intended because the digit that prevents a number
    /// from being in range is not necessarily the last digit typed. This also
    /// means that an intermediate number can have leading zeros.</para>
    /// <para>The minimum and maximum values are set in one call with
    /// setRange(), or individually with setBottom() and setTop().</para>
    /// <para>QIntValidator uses its locale() to interpret the number. For
    /// example, in Arabic locales, QIntValidator will accept Arabic digits.</para>
    /// <para>Note: The QLocale::NumberOptions set on the locale() also affect
    /// the way the number is interpreted. For example, since
    /// QLocale::RejectGroupSeparator is not set by default, the validator will
    /// accept group separators. It is thus recommended to use QLocale::toInt() to
    /// obtain the numeric value.</para>
    /// <para>See also QDoubleValidator, QRegExpValidator, QLocale::toInt(),
    /// and Line Edits Example.</para>
    /// </remarks>
    public unsafe partial class QIntValidator : QtGui.QValidator, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct Internal
        {
            [FieldOffset(8)]
            public int b;

            [FieldOffset(12)]
            public int t;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QIntValidatorC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QIntValidatorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QIntValidator8validateER7QStringRi")]
            internal static extern QValidator.State Validate_0(global::System.IntPtr instance, global::System.IntPtr input, int* pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK13QIntValidator5fixupER7QString")]
            internal static extern void Fixup_0(global::System.IntPtr instance, global::System.IntPtr input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QIntValidator9setBottomEi")]
            internal static extern void SetBottom_0(global::System.IntPtr instance, int _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QIntValidator6setTopEi")]
            internal static extern void SetTop_0(global::System.IntPtr instance, int _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN13QIntValidator8setRangeEii")]
            internal static extern void SetRange_0(global::System.IntPtr instance, int bottom, int top);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public event Action<int> BottomChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "bottomChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "bottomChanged(int)", value);
        	}
        }

        public event Action<int> TopChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "topChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "topChanged(int)", value);
        	}
        }

        private readonly bool __ownsNativeInstance;

        public static QIntValidator __CreateInstance(global::System.IntPtr native)
        {
            return new QIntValidator((QIntValidator.Internal*) native);
        }

        public static QIntValidator __CreateInstance(QIntValidator.Internal native)
        {
            return new QIntValidator(native);
        }

        private static QIntValidator.Internal* __CopyValue(QIntValidator.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            QtGui.QIntValidator.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QIntValidator.Internal*) ret;
        }

        private QIntValidator(QIntValidator.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QIntValidator(QIntValidator.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QValidator.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Reimplemented from QValidator::validate().</para>
        /// <para>Returns Acceptable if the input is an integer within the valid
        /// range, Intermediate if the input is a prefix of an integer in the valid
        /// range, and Invalid otherwise.</para>
        /// <para>If the valid range consists of just positive integers (e.g., 32
        /// to 100) and input is a negative integer, then Invalid is returned. (On the
        /// other hand, if the range consists of negative integers (e.g., -100 to -32)
        /// and input is a positive integer, then Intermediate is returned, because the
        /// user might be just about to type the minus (especially for right-to-left
        /// languages).</para>
        /// <para>int pos = 0;</para>
        /// <para></para>
        /// <para>s = &quot;abc&quot;;</para>
        /// <para>v.validate(s, pos);    // returns Invalid</para>
        /// <para></para>
        /// <para>s = &quot;5&quot;;</para>
        /// <para>v.validate(s, pos);    // returns Intermediate</para>
        /// <para></para>
        /// <para>s = &quot;50&quot;;</para>
        /// <para>v.validate(s, pos);    // returns Acceptable</para>
        /// <para>By default, the pos parameter is not used by this
        /// validator.</para>
        /// </summary>
        public override QValidator.State Validate(string input, int* pos)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(input).ToPointer(), input.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = pos;
            var __ret = Internal.Validate_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Reimplemented from QValidator::fixup().</para>
        /// </summary>
        public override void Fixup(string input)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(input).ToPointer(), input.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            Internal.Fixup_0(__Instance, arg0);
        }

        public void SetBottom(int _0)
        {
            Internal.SetBottom_0(__Instance, _0);
        }

        public void SetTop(int _0)
        {
            Internal.SetTop_0(__Instance, _0);
        }

        /// <summary>
        /// <para>Sets the range of the validator to only accept integers between
        /// bottom and top inclusive.</para>
        /// </summary>
        public virtual void SetRange(int bottom, int top)
        {
            Internal.SetRange_0(__Instance, bottom, top);
        }

        #region Virtual table interop

        // ~QIntValidator()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIntValidator) _References[instance].Target;
            target.Dispose();
        }

        // QValidator::State validate(QString &, int &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QValidator.State _Validate_0Delegate(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        private static _Validate_0Delegate _Validate_0DelegateInstance;

        private static QValidator.State _Validate_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input, int* pos)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIntValidator) _References[instance].Target;
            var _ret = target.Validate(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)), pos);
            return _ret;
        }

        // void fixup(QString &input)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Fixup_0Delegate(global::System.IntPtr instance, global::System.IntPtr input);
        private static _Fixup_0Delegate _Fixup_0DelegateInstance;

        private static void _Fixup_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIntValidator) _References[instance].Target;
            target.Fixup(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)));
        }

        // void setRange(int bottom, int top)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetRange_0Delegate(global::System.IntPtr instance, int bottom, int top);
        private static _SetRange_0Delegate _SetRange_0DelegateInstance;

        private static void _SetRange_0DelegateHook(global::System.IntPtr instance, int bottom, int top)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QIntValidator) _References[instance].Target;
            target.SetRange(bottom, top);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Validate_0DelegateInstance += _Validate_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Validate_0DelegateInstance).ToPointer();
                _Fixup_0DelegateInstance += _Fixup_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Fixup_0DelegateInstance).ToPointer();
                _SetRange_0DelegateInstance += _SetRange_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetRange_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(14 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = _Thunks[3];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QDoubleValidator class provides range checking of
    /// floating-point numbers.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QDoubleValidator provides an upper bound, a lower bound, and a
    /// limit on the number of digits after the decimal point. It does not provide
    /// a fixup() function.</para>
    /// <para>You can set the acceptable range in one call with setRange(), or
    /// with setBottom() and setTop(). Set the number of decimal places with
    /// setDecimals(). The validate() function returns the validation state.</para>
    /// <para>QDoubleValidator uses its locale() to interpret the number. For
    /// example, in the German locale, &quot;1,234&quot; will be accepted as the
    /// fractional number 1.234. In Arabic locales, QDoubleValidator will accept
    /// Arabic digits.</para>
    /// <para>Note: The QLocale::NumberOptions set on the locale() also affect
    /// the way the number is interpreted. For example, since
    /// QLocale::RejectGroupSeparator is not set by default, the validator will
    /// accept group separators. It is thus recommended to use QLocale::toDouble()
    /// to obtain the numeric value.</para>
    /// <para>See also QIntValidator, QRegExpValidator, QLocale::toDouble(),
    /// and Line Edits Example.</para>
    /// </remarks>
    public unsafe partial class QDoubleValidator : QtGui.QValidator, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct Internal
        {
            [FieldOffset(8)]
            public double b;

            [FieldOffset(16)]
            public double t;

            [FieldOffset(24)]
            public int dec;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidatorC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidatorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QDoubleValidator8validateER7QStringRi")]
            internal static extern QValidator.State Validate_0(global::System.IntPtr instance, global::System.IntPtr input, int* pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidator8setRangeEddi")]
            internal static extern void SetRange_0(global::System.IntPtr instance, double bottom, double top, int decimals);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidator9setBottomEd")]
            internal static extern void SetBottom_0(global::System.IntPtr instance, double _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidator6setTopEd")]
            internal static extern void SetTop_0(global::System.IntPtr instance, double _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidator11setDecimalsEi")]
            internal static extern void SetDecimals_0(global::System.IntPtr instance, int _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QDoubleValidator8notationEv")]
            internal static extern QDoubleValidator.Notation notation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QDoubleValidator11setNotationENS_8NotationE")]
            internal static extern void SetNotation_0(global::System.IntPtr instance, QDoubleValidator.Notation _0);
        }

        /// <summary>
        /// <para>This enum defines the allowed notations for entering a
        /// double.</para>
        /// <para>This enum was introduced or modified in  Qt 4.3.</para>
        /// </summary>
        public enum Notation : uint
        {
            /// <summary>The string is written as a standard number (i.e. 0.015).</summary>
            StandardNotation = 0,
            /// <summary>The string is written in scientific form. It may have an exponent part(i.e. 1.5E-2).</summary>
            ScientificNotation = 1
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        public event Action<double> BottomChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "bottomChanged(double)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "bottomChanged(double)", value);
        	}
        }

        public event Action<double> TopChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "topChanged(double)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "topChanged(double)", value);
        	}
        }

        public event Action<int> DecimalsChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "decimalsChanged(int)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "decimalsChanged(int)", value);
        	}
        }

        public event Action<QDoubleValidator.Notation> NotationChanged
        {
        	add
        	{
                ConnectDynamicSlot(this, "notationChanged(QDoubleValidator.Notation)", value);
        	}
        	remove
        	{
                DisconnectDynamicSlot(this, "notationChanged(QDoubleValidator.Notation)", value);
        	}
        }

        private readonly bool __ownsNativeInstance;

        public static QDoubleValidator __CreateInstance(global::System.IntPtr native)
        {
            return new QDoubleValidator((QDoubleValidator.Internal*) native);
        }

        public static QDoubleValidator __CreateInstance(QDoubleValidator.Internal native)
        {
            return new QDoubleValidator(native);
        }

        private static QDoubleValidator.Internal* __CopyValue(QDoubleValidator.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            QtGui.QDoubleValidator.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QDoubleValidator.Internal*) ret;
        }

        private QDoubleValidator(QDoubleValidator.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QDoubleValidator(QDoubleValidator.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QValidator.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Reimplemented from QValidator::validate().</para>
        /// <para>Returns Acceptable if the string input contains a double that is
        /// within the valid range and is in the correct format.</para>
        /// <para>Returns Intermediate if input contains a double that is outside
        /// the range or is in the wrong format; e.g. with too many digits after the
        /// decimal point or is empty.</para>
        /// <para>Returns Invalid if the input is not a double.</para>
        /// <para>Note: If the valid range consists of just positive doubles (e.g.
        /// 0.0 to 100.0) and input is a negative double then Invalid is returned. If
        /// notation() is set to StandardNotation, and the input contains more digits
        /// before the decimal point than a double in the valid range may have, Invalid
        /// is returned. If notation() is ScientificNotation, and the input is not in
        /// the valid range, Intermediate is returned. The value may yet become valid
        /// by changing the exponent.</para>
        /// <para>By default, the pos parameter is not used by this
        /// validator.</para>
        /// </summary>
        public override QValidator.State Validate(string input, int* pos)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(input).ToPointer(), input.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = pos;
            var __ret = Internal.Validate_0(__Instance, arg0, arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the validator to accept doubles from minimum to maximum
        /// inclusive, with at most decimals digits after the decimal point.</para>
        /// </summary>
        public virtual void SetRange(double bottom, double top, int decimals = 0)
        {
            Internal.SetRange_0(__Instance, bottom, top, decimals);
        }

        public void SetBottom(double _0)
        {
            Internal.SetBottom_0(__Instance, _0);
        }

        public void SetTop(double _0)
        {
            Internal.SetTop_0(__Instance, _0);
        }

        public void SetDecimals(int _0)
        {
            Internal.SetDecimals_0(__Instance, _0);
        }

        /// <summary>
        /// <para>This property holds the notation of how a string can describe a
        /// number.</para>
        /// <para>By default, this property is set to ScientificNotation.</para>
        /// <para>This property was introduced in  Qt 4.3.</para>
        /// </summary>
        public QDoubleValidator.Notation notation
        {
            get
            {
                var __ret = Internal.notation_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetNotation_0(__Instance, arg0);
            }
        }

        #region Virtual table interop

        // ~QDoubleValidator()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDoubleValidator) _References[instance].Target;
            target.Dispose();
        }

        // QValidator::State validate(QString &, int &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QValidator.State _Validate_0Delegate(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        private static _Validate_0Delegate _Validate_0DelegateInstance;

        private static QValidator.State _Validate_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input, int* pos)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDoubleValidator) _References[instance].Target;
            var _ret = target.Validate(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)), pos);
            return _ret;
        }

        // void fixup(QString &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Fixup_0Delegate(global::System.IntPtr instance, global::System.IntPtr input);
        private static _Fixup_0Delegate _Fixup_0DelegateInstance;

        private static void _Fixup_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDoubleValidator) _References[instance].Target;
            target.Fixup(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)));
        }

        // void setRange(double bottom, double top, int decimals = 0)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _SetRange_0Delegate(global::System.IntPtr instance, double bottom, double top, int decimals);
        private static _SetRange_0Delegate _SetRange_0DelegateInstance;

        private static void _SetRange_0DelegateHook(global::System.IntPtr instance, double bottom, double top, int decimals)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QDoubleValidator) _References[instance].Target;
            target.SetRange(bottom, top, decimals);
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Validate_0DelegateInstance += _Validate_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Validate_0DelegateInstance).ToPointer();
                _Fixup_0DelegateInstance += _Fixup_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Fixup_0DelegateInstance).ToPointer();
                _SetRange_0DelegateInstance += _SetRange_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetRange_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(14 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
                *(void**)(vfptr0 + 56) = _Thunks[3];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QRegExpValidator class is used to check a string against a
    /// regular expression.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QRegExpValidator uses a regular expression (regexp) to determine
    /// whether an input string is Acceptable, Intermediate, or Invalid. The regexp
    /// can either be supplied when the QRegExpValidator is constructed, or at a
    /// later time.</para>
    /// <para>When QRegExpValidator determines whether a string is Acceptable
    /// or not, the regexp is treated as if it begins with the start of string
    /// assertion (^) and ends with the end of string assertion ($); the match is
    /// against the entire input string, or from the given position if a start
    /// position greater than zero is given.</para>
    /// <para>If a string is a prefix of an Acceptable string, it is considered
    /// Intermediate. For example, &quot;&quot; and &quot;A&quot; are Intermediate
    /// for the regexp [A-Z][0-9] (whereas &quot;_&quot; would be Invalid).</para>
    /// <para>For a brief introduction to Qt's regexp engine, see
    /// QRegExp.</para>
    /// <para>Example of use:</para>
    /// <para>// regexp: optional '-' followed by between 1 and 3 digits</para>
    /// <para>QRegExp rx(&quot;-?\\d{1,3}&quot;);</para>
    /// <para>QValidator *validator = new QRegExpValidator(rx, this);</para>
    /// <para></para>
    /// <para>QLineEdit *edit = new QLineEdit(this);</para>
    /// <para>edit-&gt;setValidator(validator);</para>
    /// <para>Below we present some examples of validators. In practice they
    /// would normally be associated with a widget as in the example above.</para>
    /// <para>// integers 1 to 9999</para>
    /// <para>QRegExp rx(&quot;[1-9]\\d{0,3}&quot;);</para>
    /// <para>// the validator treats the regexp as
    /// &quot;^[1-9]\\d{0,3}$&quot;</para>
    /// <para>QRegExpValidator v(rx, 0);</para>
    /// <para>QString s;</para>
    /// <para>int pos = 0;</para>
    /// <para></para>
    /// <para>s = &quot;0&quot;;     v.validate(s, pos);    // returns
    /// Invalid</para>
    /// <para>s = &quot;12345&quot;; v.validate(s, pos);    // returns
    /// Invalid</para>
    /// <para>s = &quot;1&quot;;     v.validate(s, pos);    // returns
    /// Acceptable</para>
    /// <para></para>
    /// <para>rx.setPattern(&quot;\\S+&quot;);            // one or more
    /// non-whitespace characters</para>
    /// <para>v.setRegExp(rx);</para>
    /// <para>s = &quot;myfile.txt&quot;;  v.validate(s, pos); // Returns
    /// Acceptable</para>
    /// <para>s = &quot;my file.txt&quot;; v.validate(s, pos); // Returns
    /// Invalid</para>
    /// <para></para>
    /// <para>// A, B or C followed by exactly five digits followed by W, X, Y
    /// or Z</para>
    /// <para>rx.setPattern(&quot;[A-C]\\d{5}[W-Z]&quot;);</para>
    /// <para>v.setRegExp(rx);</para>
    /// <para>s = &quot;a12345Z&quot;; v.validate(s, pos);        // Returns
    /// Invalid</para>
    /// <para>s = &quot;A12345Z&quot;; v.validate(s, pos);        // Returns
    /// Acceptable</para>
    /// <para>s = &quot;B12&quot;;     v.validate(s, pos);        // Returns
    /// Intermediate</para>
    /// <para></para>
    /// <para>// match most 'readme' files</para>
    /// <para>rx.setPattern(&quot;read\\S?me(\.(txt|asc|1st))?&quot;);</para>
    /// <para>rx.setCaseSensitive(false);</para>
    /// <para>v.setRegExp(rx);</para>
    /// <para>s = &quot;readme&quot;;      v.validate(s, pos); // Returns
    /// Acceptable</para>
    /// <para>s = &quot;README.1ST&quot;;  v.validate(s, pos); // Returns
    /// Acceptable</para>
    /// <para>s = &quot;read me.txt&quot;; v.validate(s, pos); // Returns
    /// Invalid</para>
    /// <para>s = &quot;readm&quot;;       v.validate(s, pos); // Returns
    /// Intermediate</para>
    /// <para></para>
    /// <para>See also QRegExp, QIntValidator, QDoubleValidator, and Settings
    /// Editor Example.</para>
    /// </remarks>
    public unsafe partial class QRegExpValidator : QtGui.QValidator, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct Internal
        {
            [FieldOffset(8)]
            internal QtCore.QRegExp.Internal r;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QRegExpValidatorC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN16QRegExpValidatorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK16QRegExpValidator8validateER7QStringRi")]
            internal static extern QValidator.State Validate_0(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        private readonly bool __ownsNativeInstance;

        public static QRegExpValidator __CreateInstance(global::System.IntPtr native)
        {
            return new QRegExpValidator((QRegExpValidator.Internal*) native);
        }

        public static QRegExpValidator __CreateInstance(QRegExpValidator.Internal native)
        {
            return new QRegExpValidator(native);
        }

        private static QRegExpValidator.Internal* __CopyValue(QRegExpValidator.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            QtGui.QRegExpValidator.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QRegExpValidator.Internal*) ret;
        }

        private QRegExpValidator(QRegExpValidator.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QRegExpValidator(QRegExpValidator.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QValidator.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Reimplemented from QValidator::validate().</para>
        /// <para>Returns Acceptable if input is matched by the regular expression
        /// for this validator, Intermediate if it has matched partially (i.e. could be
        /// a valid match if additional valid characters are added), and Invalid if
        /// input is not matched.</para>
        /// <para>Additionally, if input is not matched, the pos parameter is set
        /// to the length of the input parameter.</para>
        /// <para>For example, if the regular expression is \w\d\d (word-character,
        /// digit, digit) then &quot;A57&quot; is Acceptable, &quot;E5&quot; is
        /// Intermediate, and &quot;+9&quot; is Invalid.</para>
        /// <para>See also QRegExp::exactMatch().</para>
        /// </summary>
        public override QValidator.State Validate(string input, int* pos)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(input).ToPointer(), input.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = pos;
            var __ret = Internal.Validate_0(__Instance, arg0, arg1);
            return __ret;
        }

        #region Virtual table interop

        // ~QRegExpValidator()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRegExpValidator) _References[instance].Target;
            target.Dispose();
        }

        // QValidator::State validate(QString& input, int& pos)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QValidator.State _Validate_0Delegate(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        private static _Validate_0Delegate _Validate_0DelegateInstance;

        private static QValidator.State _Validate_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input, int* pos)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRegExpValidator) _References[instance].Target;
            var _ret = target.Validate(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)), pos);
            return _ret;
        }

        // void fixup(QString &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Fixup_0Delegate(global::System.IntPtr instance, global::System.IntPtr input);
        private static _Fixup_0Delegate _Fixup_0DelegateInstance;

        private static void _Fixup_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRegExpValidator) _References[instance].Target;
            target.Fixup(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Validate_0DelegateInstance += _Validate_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Validate_0DelegateInstance).ToPointer();
                _Fixup_0DelegateInstance += _Fixup_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Fixup_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    /// <summary>
    /// <para>The QRegularExpressionValidator class is used to check a string
    /// against a regular expression.</para>
    /// </summary>
    /// <remarks>
    /// <para></para>
    /// <para>QRegularExpressionValidator uses a regular expression (regexp) to
    /// determine whether an input string is Acceptable, Intermediate, or Invalid.
    /// The regexp can either be supplied when the QRegularExpressionValidator is
    /// constructed, or at a later time.</para>
    /// <para>If the regexp partially matches against the string, the result is
    /// considered Intermediate. For example, &quot;&quot; and &quot;A&quot; are
    /// Intermediate for the regexp [A-Z][0-9] (whereas &quot;_&quot; would be
    /// Invalid).</para>
    /// <para>QRegularExpressionValidator automatically wraps the regular
    /// expression in the \\A and \\z anchors; in other words, it always attempts
    /// to do an exact match.</para>
    /// <para>Example of use:</para>
    /// <para>// regexp: optional '-' followed by between 1 and 3 digits</para>
    /// <para>QRegularExpression rx(&quot;-?\\d{1,3}&quot;);</para>
    /// <para>QValidator *validator = new QRegularExpressionValidator(rx,
    /// this);</para>
    /// <para></para>
    /// <para>QLineEdit *edit = new QLineEdit(this);</para>
    /// <para>edit-&gt;setValidator(validator);</para>
    /// <para>Below we present some examples of validators. In practice they
    /// would normally be associated with a widget as in the example above.</para>
    /// <para>// integers 1 to 9999</para>
    /// <para>QRegularExpression re(&quot;[1-9]\\d{0,3}&quot;);</para>
    /// <para>// the validator treats the regexp as
    /// &quot;^[1-9]\\d{0,3}$&quot;</para>
    /// <para>QRegularExpressionValidator v(re, 0);</para>
    /// <para>QString s;</para>
    /// <para>int pos = 0;</para>
    /// <para></para>
    /// <para>s = &quot;0&quot;;     v.validate(s, pos);    // returns
    /// Invalid</para>
    /// <para>s = &quot;12345&quot;; v.validate(s, pos);    // returns
    /// Invalid</para>
    /// <para>s = &quot;1&quot;;     v.validate(s, pos);    // returns
    /// Acceptable</para>
    /// <para></para>
    /// <para>re.setPattern(&quot;\\S+&quot;);            // one or more
    /// non-whitespace characters</para>
    /// <para>v.setRegularExpression(re);</para>
    /// <para>s = &quot;myfile.txt&quot;;  v.validate(s, pos); // Returns
    /// Acceptable</para>
    /// <para>s = &quot;my file.txt&quot;; v.validate(s, pos); // Returns
    /// Invalid</para>
    /// <para></para>
    /// <para>// A, B or C followed by exactly five digits followed by W, X, Y
    /// or Z</para>
    /// <para>re.setPattern(&quot;[A-C]\\d{5}[W-Z]&quot;);</para>
    /// <para>v.setRegularExpression(re);</para>
    /// <para>s = &quot;a12345Z&quot;; v.validate(s, pos);        // Returns
    /// Invalid</para>
    /// <para>s = &quot;A12345Z&quot;; v.validate(s, pos);        // Returns
    /// Acceptable</para>
    /// <para>s = &quot;B12&quot;;     v.validate(s, pos);        // Returns
    /// Intermediate</para>
    /// <para></para>
    /// <para>// match most 'readme' files</para>
    /// <para>re.setPattern(&quot;read\\S?me(\.(txt|asc|1st))?&quot;);</para>
    ///
    /// <para>re.setPatternOptions(QRegularExpression::CaseInsensitiveOption);</par
    /// a>
    /// <para>v.setRegularExpression(re);</para>
    /// <para>s = &quot;readme&quot;;      v.validate(s, pos); // Returns
    /// Acceptable</para>
    /// <para>s = &quot;README.1ST&quot;;  v.validate(s, pos); // Returns
    /// Acceptable</para>
    /// <para>s = &quot;read me.txt&quot;; v.validate(s, pos); // Returns
    /// Invalid</para>
    /// <para>s = &quot;readm&quot;;       v.validate(s, pos); // Returns
    /// Intermediate</para>
    /// <para></para>
    /// <para>See also QRegularExpression, QIntValidator, QDoubleValidator, and
    /// QRegExpValidator.</para>
    /// </remarks>
    public unsafe partial class QRegularExpressionValidator : QtGui.QValidator, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("QtGuiSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QRegularExpressionValidatorC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZN27QRegularExpressionValidatorD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Qt5Gui", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="_ZNK27QRegularExpressionValidator8validateER7QStringRi")]
            internal static extern QValidator.State Validate_0(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        }

        internal unsafe partial class QPrivateSignal
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct Internal
            {
            }
        }

        private readonly bool __ownsNativeInstance;

        public static QRegularExpressionValidator __CreateInstance(global::System.IntPtr native)
        {
            return new QRegularExpressionValidator((QRegularExpressionValidator.Internal*) native);
        }

        public static QRegularExpressionValidator __CreateInstance(QRegularExpressionValidator.Internal native)
        {
            return new QRegularExpressionValidator(native);
        }

        private static QRegularExpressionValidator.Internal* __CopyValue(QRegularExpressionValidator.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            QtGui.QRegularExpressionValidator.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return (QRegularExpressionValidator.Internal*) ret;
        }

        private QRegularExpressionValidator(QRegularExpressionValidator.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QRegularExpressionValidator(QRegularExpressionValidator.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QValidator.Internal*) native)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// <para>Reimplemented from QValidator::validate().</para>
        /// <para>Returns Acceptable if input is matched by the regular expression
        /// for this validator, Intermediate if it has matched partially (i.e. could be
        /// a valid match if additional valid characters are added), and Invalid if
        /// input is not matched.</para>
        /// <para>In case the input is not matched, the pos parameter is set to the
        /// length of the input parameter; otherwise, it is not modified.</para>
        /// <para>For example, if the regular expression is \w\d\d (word-character,
        /// digit, digit) then &quot;A57&quot; is Acceptable, &quot;E5&quot; is
        /// Intermediate, and &quot;+9&quot; is Invalid.</para>
        /// <para>See also QRegularExpression::match().</para>
        /// </summary>
        public override QValidator.State Validate(string input, int* pos)
        {
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(input).ToPointer(), input.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = pos;
            var __ret = Internal.Validate_0(__Instance, arg0, arg1);
            return __ret;
        }

        #region Virtual table interop

        // ~QRegularExpressionValidator()
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
        private static _dtor_0Delegate _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRegularExpressionValidator) _References[instance].Target;
            target.Dispose();
        }

        // QValidator::State validate(QString &input, int &pos)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate QValidator.State _Validate_0Delegate(global::System.IntPtr instance, global::System.IntPtr input, int* pos);
        private static _Validate_0Delegate _Validate_0DelegateInstance;

        private static QValidator.State _Validate_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input, int* pos)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRegularExpressionValidator) _References[instance].Target;
            var _ret = target.Validate(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)), pos);
            return _ret;
        }

        // void fixup(QString &)
        [SuppressUnmanagedCodeSecurity]
        [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal delegate void _Fixup_0Delegate(global::System.IntPtr instance, global::System.IntPtr input);
        private static _Fixup_0Delegate _Fixup_0DelegateInstance;

        private static void _Fixup_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr input)
        {
            if (!_References.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var target = (QRegularExpressionValidator) _References[instance].Target;
            target.Fixup(Marshal.PtrToStringUni(new IntPtr(new QString(input).Utf16)));
        }

        private static void*[] _OldVTables;
        private static void*[] _NewVTables;
        private static void*[] _Thunks;
        private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

        void SetupVTables(global::System.IntPtr instance)
        {
            var native = (Internal*)instance.ToPointer();

            if (_References == null)
                _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

            if (_References.ContainsKey(instance))
                return;

            _References[instance] = new WeakReference(this);

            if (_OldVTables == null)
            {
                _OldVTables = new void*[1];
                _OldVTables[0] = native->vfptr0.ToPointer();
            }

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Validate_0DelegateInstance += _Validate_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Validate_0DelegateInstance).ToPointer();
                _Fixup_0DelegateInstance += _Fixup_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Fixup_0DelegateInstance).ToPointer();
            }

            if (_NewVTables == null)
            {
                _NewVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 4);
                _NewVTables[0] = vfptr0.ToPointer();
                *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                *(void**)(vfptr0 + 16) = _Thunks[0];
                *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                *(void**)(vfptr0 + 28) = *(void**)(native->vfptr0 + 28);
                *(void**)(vfptr0 + 32) = *(void**)(native->vfptr0 + 32);
                *(void**)(vfptr0 + 36) = *(void**)(native->vfptr0 + 36);
                *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                *(void**)(vfptr0 + 48) = _Thunks[1];
                *(void**)(vfptr0 + 52) = _Thunks[2];
            }

            native->vfptr0 = new IntPtr(_NewVTables[0]);
        }

        #endregion
    }

    internal unsafe partial class QValidatorInternal : QtGui.QValidator, IDisposable
    {
        private readonly bool __ownsNativeInstance;

        public static QValidatorInternal __CreateInstance(global::System.IntPtr native)
        {
            return new QValidatorInternal((QValidator.Internal*) native);
        }

        public static QValidator __CreateInstance(QValidator.Internal native)
        {
            return new QValidatorInternal(native);
        }

        private static QValidator.Internal* __CopyValue(QValidator.Internal native)
        {
            var ret = (QValidator.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private QValidatorInternal(QValidator.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
        }

        protected QValidatorInternal(QValidator.Internal* native, bool isInternalImpl = false)
            : base((QtGui.QValidator.Internal*) native, true)
        {
        }

        protected override void Dispose(bool disposing)
        {
            if (__ownsNativeInstance)
            {
                Marshal.FreeHGlobal(__Instance);
            }
            base.Dispose(disposing);
        }

        public override QValidator.State Validate(string _305, int* _306)
        {
            void* slot = *(void**) (((QValidator.Internal*) __Instance)->vfptr0 + 12 * 4);
            var ___Validate_0Delegate = (_Validate_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Validate_0Delegate));
            var __qstring0 = QString.FromUtf16((ushort*) Marshal.StringToHGlobalUni(_305).ToPointer(), _305.Length);
            var arg0 = ReferenceEquals(__qstring0, null) ? global::System.IntPtr.Zero : __qstring0.__Instance;
            var arg1 = _306;
            var __ret = ___Validate_0Delegate(__Instance, arg0, arg1);
            return __ret;
        }
    }
}
